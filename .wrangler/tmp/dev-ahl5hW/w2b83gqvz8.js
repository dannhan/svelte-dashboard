// .wrangler/tmp/bundle-Nq6h8V/checked-fetch.js
var urls = /* @__PURE__ */ new Set();
function checkURL(request, init2) {
  const url = request instanceof URL ? request : new URL(
    (typeof request === "string" ? new Request(request, init2) : request).url
  );
  if (url.port && url.port !== "443" && url.protocol === "https:") {
    if (!urls.has(url.toString())) {
      urls.add(url.toString());
      console.warn(
        `WARNING: known issue with \`fetch()\` requests to custom HTTPS ports in published Workers:
 - ${url.toString()} - the custom port will be ignored when the Worker is published using the \`wrangler deploy\` command.
`
      );
    }
  }
}
globalThis.fetch = new Proxy(globalThis.fetch, {
  apply(target, thisArg, argArray) {
    const [request, init2] = argArray;
    checkURL(request, init2);
    return Reflect.apply(target, thisArg, argArray);
  }
});

// .wrangler/tmp/pages-Sik1DJ/bundledWorker-0.8320960345253436.mjs
var urls2 = /* @__PURE__ */ new Set();
function checkURL2(request, init2) {
  const url = request instanceof URL ? request : new URL(
    (typeof request === "string" ? new Request(request, init2) : request).url
  );
  if (url.port && url.port !== "443" && url.protocol === "https:") {
    if (!urls2.has(url.toString())) {
      urls2.add(url.toString());
      console.warn(
        `WARNING: known issue with \`fetch()\` requests to custom HTTPS ports in published Workers:
 - ${url.toString()} - the custom port will be ignored when the Worker is published using the \`wrangler deploy\` command.
`
      );
    }
  }
}
globalThis.fetch = new Proxy(globalThis.fetch, {
  apply(target, thisArg, argArray) {
    const [request, init2] = argArray;
    checkURL2(request, init2);
    return Reflect.apply(target, thisArg, argArray);
  }
});
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb2, mod) => function __require() {
  return mod || (0, cb2[__getOwnPropNames(cb2)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name5 in all)
    __defProp(target, name5, { get: all[name5], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key2 of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key2) && key2 !== except)
        __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var BROWSER;
var DEV;
var init_prod_ssr = __esm({
  ".svelte-kit/output/server/chunks/prod-ssr.js"() {
    BROWSER = false;
    DEV = false;
  }
});
function noop() {
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a2, b2) {
  return a2 != a2 ? b2 == b2 : a2 !== b2 || a2 && typeof a2 === "object" || typeof a2 === "function";
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    for (const callback of callbacks) {
      callback(void 0);
    }
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
  let value;
  subscribe(store, (_) => value = _)();
  return value;
}
function compute_rest_props(props, keys) {
  const rest = {};
  keys = new Set(keys);
  for (const k2 in props)
    if (!keys.has(k2) && k2[0] !== "$")
      rest[k2] = props[k2];
  return rest;
}
function compute_slots(slots) {
  const result = {};
  for (const key2 in slots) {
    result[key2] = true;
  }
  return result;
}
function null_to_empty(value) {
  return value == null ? "" : value;
}
function set_store_value(store, ret, value) {
  store.set(value);
  return ret;
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  return new CustomEvent(type, { detail, bubbles, cancelable });
}
function set_current_component(component15) {
  current_component = component15;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
function createEventDispatcher() {
  const component15 = get_current_component();
  return (type, detail, { cancelable = false } = {}) => {
    const callbacks = component15.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(
        /** @type {string} */
        type,
        detail,
        { cancelable }
      );
      callbacks.slice().forEach((fn) => {
        fn.call(component15, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}
function setContext(key2, context) {
  get_current_component().$$.context.set(key2, context);
  return context;
}
function getContext(key2) {
  return get_current_component().$$.context.get(key2);
}
function hasContext(key2) {
  return get_current_component().$$.context.has(key2);
}
var identity;
var current_component;
var init_lifecycle = __esm({
  ".svelte-kit/output/server/chunks/lifecycle.js"() {
    identity = (x4) => x4;
  }
});
function ensure_array_like(array_like_or_iterator) {
  return array_like_or_iterator?.length !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}
function spread(args, attrs_to_add) {
  const attributes = Object.assign({}, ...args);
  if (attrs_to_add) {
    const classes_to_add = attrs_to_add.classes;
    const styles_to_add = attrs_to_add.styles;
    if (classes_to_add) {
      if (attributes.class == null) {
        attributes.class = classes_to_add;
      } else {
        attributes.class += " " + classes_to_add;
      }
    }
    if (styles_to_add) {
      if (attributes.style == null) {
        attributes.style = style_object_to_string(styles_to_add);
      } else {
        attributes.style = style_object_to_string(
          merge_ssr_styles(attributes.style, styles_to_add)
        );
      }
    }
  }
  let str = "";
  Object.keys(attributes).forEach((name5) => {
    if (invalid_attribute_name_character.test(name5))
      return;
    const value = attributes[name5];
    if (value === true)
      str += " " + name5;
    else if (boolean_attributes.has(name5.toLowerCase())) {
      if (value)
        str += " " + name5;
    } else if (value != null) {
      str += ` ${name5}="${value}"`;
    }
  });
  return str;
}
function merge_ssr_styles(style_attribute, style_directive) {
  const style_object = {};
  for (const individual_style of style_attribute.split(";")) {
    const colon_index = individual_style.indexOf(":");
    const name5 = individual_style.slice(0, colon_index).trim();
    const value = individual_style.slice(colon_index + 1).trim();
    if (!name5)
      continue;
    style_object[name5] = value;
  }
  for (const name5 in style_directive) {
    const value = style_directive[name5];
    if (value) {
      style_object[name5] = value;
    } else {
      delete style_object[name5];
    }
  }
  return style_object;
}
function escape(value, is_attr = false) {
  const str = String(value);
  const pattern2 = is_attr ? ATTR_REGEX : CONTENT_REGEX;
  pattern2.lastIndex = 0;
  let escaped2 = "";
  let last2 = 0;
  while (pattern2.test(str)) {
    const i3 = pattern2.lastIndex - 1;
    const ch = str[i3];
    escaped2 += str.substring(last2, i3) + (ch === "&" ? "&amp;" : ch === '"' ? "&quot;" : "&lt;");
    last2 = i3 + 1;
  }
  return escaped2 + str.substring(last2);
}
function escape_attribute_value(value) {
  const should_escape = typeof value === "string" || value && typeof value === "object";
  return should_escape ? escape(value, true) : value;
}
function escape_object(obj) {
  const result = {};
  for (const key2 in obj) {
    result[key2] = escape_attribute_value(obj[key2]);
  }
  return result;
}
function each(items, fn) {
  items = ensure_array_like(items);
  let str = "";
  for (let i3 = 0; i3 < items.length; i3 += 1) {
    str += fn(items[i3], i3);
  }
  return str;
}
function validate_component(component15, name5) {
  if (!component15 || !component15.$$render) {
    if (name5 === "svelte:component")
      name5 += " this={...}";
    throw new Error(
      `<${name5}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules. Otherwise you may need to fix a <${name5}>.`
    );
  }
  return component15;
}
function create_ssr_component(fn) {
  function $$render(result, props, bindings, slots, context) {
    const parent_component = current_component;
    const $$ = {
      on_destroy,
      context: new Map(context || (parent_component ? parent_component.$$.context : [])),
      // these will be immediately discarded
      on_mount: [],
      before_update: [],
      after_update: [],
      callbacks: blank_object()
    };
    set_current_component({ $$ });
    const html = fn(result, props, bindings, slots);
    set_current_component(parent_component);
    return html;
  }
  return {
    render: (props = {}, { $$slots = {}, context = /* @__PURE__ */ new Map() } = {}) => {
      on_destroy = [];
      const result = { title: "", head: "", css: /* @__PURE__ */ new Set() };
      const html = $$render(result, props, {}, $$slots, context);
      run_all(on_destroy);
      return {
        html,
        css: {
          code: Array.from(result.css).map((css4) => css4.code).join("\n"),
          map: null
          // TODO
        },
        head: result.title + result.head
      };
    },
    $$render
  };
}
function add_attribute(name5, value, boolean) {
  if (value == null || boolean && !value)
    return "";
  const assignment = boolean && value === true ? "" : `="${escape(value, true)}"`;
  return ` ${name5}${assignment}`;
}
function style_object_to_string(style_object) {
  return Object.keys(style_object).filter((key2) => style_object[key2]).map((key2) => `${key2}: ${escape_attribute_value(style_object[key2])};`).join(" ");
}
var _boolean_attributes;
var boolean_attributes;
var invalid_attribute_name_character;
var ATTR_REGEX;
var CONTENT_REGEX;
var missing_component;
var on_destroy;
var init_ssr = __esm({
  ".svelte-kit/output/server/chunks/ssr.js"() {
    init_lifecycle();
    _boolean_attributes = /** @type {const} */
    [
      "allowfullscreen",
      "allowpaymentrequest",
      "async",
      "autofocus",
      "autoplay",
      "checked",
      "controls",
      "default",
      "defer",
      "disabled",
      "formnovalidate",
      "hidden",
      "inert",
      "ismap",
      "loop",
      "multiple",
      "muted",
      "nomodule",
      "novalidate",
      "open",
      "playsinline",
      "readonly",
      "required",
      "reversed",
      "selected"
    ];
    boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);
    invalid_attribute_name_character = /[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u;
    ATTR_REGEX = /[&"]/g;
    CONTENT_REGEX = /[&<]/g;
    missing_component = {
      $$render: () => ""
    };
  }
});
function onMount() {
}
function afterUpdate() {
}
var init_ssr2 = __esm({
  ".svelte-kit/output/server/chunks/ssr2.js"() {
  }
});
function getGlobal() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("Unable to locate global object.");
}
function createMockUserToken(token, projectId) {
  if (token.uid) {
    throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.');
  }
  const header = {
    alg: "none",
    type: "JWT"
  };
  const project = projectId || "demo-project";
  const iat = token.iat || 0;
  const sub = token.sub || token.user_id;
  if (!sub) {
    throw new Error("mockUserToken must contain 'sub' or 'user_id' field!");
  }
  const payload = Object.assign({
    // Set all required fields to decent defaults
    iss: `https://securetoken.google.com/${project}`,
    aud: project,
    iat,
    exp: iat + 3600,
    auth_time: iat,
    sub,
    user_id: sub,
    firebase: {
      sign_in_provider: "custom",
      identities: {}
    }
  }, token);
  const signature = "";
  return [
    base64urlEncodeWithoutPadding(JSON.stringify(header)),
    base64urlEncodeWithoutPadding(JSON.stringify(payload)),
    signature
  ].join(".");
}
function getUA() {
  if (typeof navigator !== "undefined" && true) {
    return "Cloudflare-Workers";
  } else {
    return "";
  }
}
function isNode() {
  var _a2;
  const forceEnvironment = (_a2 = getDefaults()) === null || _a2 === void 0 ? void 0 : _a2.forceEnvironment;
  if (forceEnvironment === "node") {
    return true;
  } else if (forceEnvironment === "browser") {
    return false;
  }
  try {
    return Object.prototype.toString.call(global.process) === "[object process]";
  } catch (e3) {
    return false;
  }
}
function isSafari() {
  return !isNode() && true && "Cloudflare-Workers".includes("Safari") && !"Cloudflare-Workers".includes("Chrome");
}
function isIndexedDBAvailable() {
  try {
    return typeof indexedDB === "object";
  } catch (e3) {
    return false;
  }
}
function validateIndexedDBOpenable() {
  return new Promise((resolve2, reject) => {
    try {
      let preExist = true;
      const DB_CHECK_NAME = "validate-browser-context-for-indexeddb-analytics-module";
      const request = self.indexedDB.open(DB_CHECK_NAME);
      request.onsuccess = () => {
        request.result.close();
        if (!preExist) {
          self.indexedDB.deleteDatabase(DB_CHECK_NAME);
        }
        resolve2(true);
      };
      request.onupgradeneeded = () => {
        preExist = false;
      };
      request.onerror = () => {
        var _a2;
        reject(((_a2 = request.error) === null || _a2 === void 0 ? void 0 : _a2.message) || "");
      };
    } catch (error) {
      reject(error);
    }
  });
}
function replaceTemplate(template, data2) {
  return template.replace(PATTERN, (_, key2) => {
    const value = data2[key2];
    return value != null ? String(value) : `<${key2}?>`;
  });
}
function deepEqual(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  const aKeys = Object.keys(a2);
  const bKeys = Object.keys(b2);
  for (const k2 of aKeys) {
    if (!bKeys.includes(k2)) {
      return false;
    }
    const aProp = a2[k2];
    const bProp = b2[k2];
    if (isObject(aProp) && isObject(bProp)) {
      if (!deepEqual(aProp, bProp)) {
        return false;
      }
    } else if (aProp !== bProp) {
      return false;
    }
  }
  for (const k2 of bKeys) {
    if (!aKeys.includes(k2)) {
      return false;
    }
  }
  return true;
}
function isObject(thing) {
  return thing !== null && typeof thing === "object";
}
function getModularInstance(service) {
  if (service && service._delegate) {
    return service._delegate;
  } else {
    return service;
  }
}
var stringToByteArray$1;
var byteArrayToString;
var base64;
var DecodeBase64StringError;
var base64Encode;
var base64urlEncodeWithoutPadding;
var base64Decode;
var getDefaultsFromGlobal;
var getDefaultsFromEnvVariable;
var getDefaultsFromCookie;
var getDefaults;
var getDefaultEmulatorHost;
var getDefaultEmulatorHostnameAndPort;
var getDefaultAppConfig;
var Deferred;
var ERROR_NAME;
var FirebaseError;
var ErrorFactory;
var PATTERN;
var MAX_VALUE_MILLIS;
var init_index_esm2017 = __esm({
  "node_modules/@firebase/util/dist/index.esm2017.js"() {
    stringToByteArray$1 = function(str) {
      const out = [];
      let p3 = 0;
      for (let i3 = 0; i3 < str.length; i3++) {
        let c2 = str.charCodeAt(i3);
        if (c2 < 128) {
          out[p3++] = c2;
        } else if (c2 < 2048) {
          out[p3++] = c2 >> 6 | 192;
          out[p3++] = c2 & 63 | 128;
        } else if ((c2 & 64512) === 55296 && i3 + 1 < str.length && (str.charCodeAt(i3 + 1) & 64512) === 56320) {
          c2 = 65536 + ((c2 & 1023) << 10) + (str.charCodeAt(++i3) & 1023);
          out[p3++] = c2 >> 18 | 240;
          out[p3++] = c2 >> 12 & 63 | 128;
          out[p3++] = c2 >> 6 & 63 | 128;
          out[p3++] = c2 & 63 | 128;
        } else {
          out[p3++] = c2 >> 12 | 224;
          out[p3++] = c2 >> 6 & 63 | 128;
          out[p3++] = c2 & 63 | 128;
        }
      }
      return out;
    };
    byteArrayToString = function(bytes) {
      const out = [];
      let pos = 0, c2 = 0;
      while (pos < bytes.length) {
        const c1 = bytes[pos++];
        if (c1 < 128) {
          out[c2++] = String.fromCharCode(c1);
        } else if (c1 > 191 && c1 < 224) {
          const c22 = bytes[pos++];
          out[c2++] = String.fromCharCode((c1 & 31) << 6 | c22 & 63);
        } else if (c1 > 239 && c1 < 365) {
          const c22 = bytes[pos++];
          const c3 = bytes[pos++];
          const c4 = bytes[pos++];
          const u2 = ((c1 & 7) << 18 | (c22 & 63) << 12 | (c3 & 63) << 6 | c4 & 63) - 65536;
          out[c2++] = String.fromCharCode(55296 + (u2 >> 10));
          out[c2++] = String.fromCharCode(56320 + (u2 & 1023));
        } else {
          const c22 = bytes[pos++];
          const c3 = bytes[pos++];
          out[c2++] = String.fromCharCode((c1 & 15) << 12 | (c22 & 63) << 6 | c3 & 63);
        }
      }
      return out.join("");
    };
    base64 = {
      /**
       * Maps bytes to characters.
       */
      byteToCharMap_: null,
      /**
       * Maps characters to bytes.
       */
      charToByteMap_: null,
      /**
       * Maps bytes to websafe characters.
       * @private
       */
      byteToCharMapWebSafe_: null,
      /**
       * Maps websafe characters to bytes.
       * @private
       */
      charToByteMapWebSafe_: null,
      /**
       * Our default alphabet, shared between
       * ENCODED_VALS and ENCODED_VALS_WEBSAFE
       */
      ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
      /**
       * Our default alphabet. Value 64 (=) is special; it means "nothing."
       */
      get ENCODED_VALS() {
        return this.ENCODED_VALS_BASE + "+/=";
      },
      /**
       * Our websafe alphabet.
       */
      get ENCODED_VALS_WEBSAFE() {
        return this.ENCODED_VALS_BASE + "-_.";
      },
      /**
       * Whether this browser supports the atob and btoa functions. This extension
       * started at Mozilla but is now implemented by many browsers. We use the
       * ASSUME_* variables to avoid pulling in the full useragent detection library
       * but still allowing the standard per-browser compilations.
       *
       */
      HAS_NATIVE_SUPPORT: typeof atob === "function",
      /**
       * Base64-encode an array of bytes.
       *
       * @param input An array of bytes (numbers with
       *     value in [0, 255]) to encode.
       * @param webSafe Boolean indicating we should use the
       *     alternative alphabet.
       * @return The base64 encoded string.
       */
      encodeByteArray(input, webSafe) {
        if (!Array.isArray(input)) {
          throw Error("encodeByteArray takes an array as a parameter");
        }
        this.init_();
        const byteToCharMap = webSafe ? this.byteToCharMapWebSafe_ : this.byteToCharMap_;
        const output = [];
        for (let i3 = 0; i3 < input.length; i3 += 3) {
          const byte1 = input[i3];
          const haveByte2 = i3 + 1 < input.length;
          const byte2 = haveByte2 ? input[i3 + 1] : 0;
          const haveByte3 = i3 + 2 < input.length;
          const byte3 = haveByte3 ? input[i3 + 2] : 0;
          const outByte1 = byte1 >> 2;
          const outByte2 = (byte1 & 3) << 4 | byte2 >> 4;
          let outByte3 = (byte2 & 15) << 2 | byte3 >> 6;
          let outByte4 = byte3 & 63;
          if (!haveByte3) {
            outByte4 = 64;
            if (!haveByte2) {
              outByte3 = 64;
            }
          }
          output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);
        }
        return output.join("");
      },
      /**
       * Base64-encode a string.
       *
       * @param input A string to encode.
       * @param webSafe If true, we should use the
       *     alternative alphabet.
       * @return The base64 encoded string.
       */
      encodeString(input, webSafe) {
        if (this.HAS_NATIVE_SUPPORT && !webSafe) {
          return btoa(input);
        }
        return this.encodeByteArray(stringToByteArray$1(input), webSafe);
      },
      /**
       * Base64-decode a string.
       *
       * @param input to decode.
       * @param webSafe True if we should use the
       *     alternative alphabet.
       * @return string representing the decoded value.
       */
      decodeString(input, webSafe) {
        if (this.HAS_NATIVE_SUPPORT && !webSafe) {
          return atob(input);
        }
        return byteArrayToString(this.decodeStringToByteArray(input, webSafe));
      },
      /**
       * Base64-decode a string.
       *
       * In base-64 decoding, groups of four characters are converted into three
       * bytes.  If the encoder did not apply padding, the input length may not
       * be a multiple of 4.
       *
       * In this case, the last group will have fewer than 4 characters, and
       * padding will be inferred.  If the group has one or two characters, it decodes
       * to one byte.  If the group has three characters, it decodes to two bytes.
       *
       * @param input Input to decode.
       * @param webSafe True if we should use the web-safe alphabet.
       * @return bytes representing the decoded value.
       */
      decodeStringToByteArray(input, webSafe) {
        this.init_();
        const charToByteMap = webSafe ? this.charToByteMapWebSafe_ : this.charToByteMap_;
        const output = [];
        for (let i3 = 0; i3 < input.length; ) {
          const byte1 = charToByteMap[input.charAt(i3++)];
          const haveByte2 = i3 < input.length;
          const byte2 = haveByte2 ? charToByteMap[input.charAt(i3)] : 0;
          ++i3;
          const haveByte3 = i3 < input.length;
          const byte3 = haveByte3 ? charToByteMap[input.charAt(i3)] : 64;
          ++i3;
          const haveByte4 = i3 < input.length;
          const byte4 = haveByte4 ? charToByteMap[input.charAt(i3)] : 64;
          ++i3;
          if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {
            throw new DecodeBase64StringError();
          }
          const outByte1 = byte1 << 2 | byte2 >> 4;
          output.push(outByte1);
          if (byte3 !== 64) {
            const outByte2 = byte2 << 4 & 240 | byte3 >> 2;
            output.push(outByte2);
            if (byte4 !== 64) {
              const outByte3 = byte3 << 6 & 192 | byte4;
              output.push(outByte3);
            }
          }
        }
        return output;
      },
      /**
       * Lazy static initialization function. Called before
       * accessing any of the static map variables.
       * @private
       */
      init_() {
        if (!this.byteToCharMap_) {
          this.byteToCharMap_ = {};
          this.charToByteMap_ = {};
          this.byteToCharMapWebSafe_ = {};
          this.charToByteMapWebSafe_ = {};
          for (let i3 = 0; i3 < this.ENCODED_VALS.length; i3++) {
            this.byteToCharMap_[i3] = this.ENCODED_VALS.charAt(i3);
            this.charToByteMap_[this.byteToCharMap_[i3]] = i3;
            this.byteToCharMapWebSafe_[i3] = this.ENCODED_VALS_WEBSAFE.charAt(i3);
            this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i3]] = i3;
            if (i3 >= this.ENCODED_VALS_BASE.length) {
              this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i3)] = i3;
              this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i3)] = i3;
            }
          }
        }
      }
    };
    DecodeBase64StringError = class extends Error {
      constructor() {
        super(...arguments);
        this.name = "DecodeBase64StringError";
      }
    };
    base64Encode = function(str) {
      const utf8Bytes = stringToByteArray$1(str);
      return base64.encodeByteArray(utf8Bytes, true);
    };
    base64urlEncodeWithoutPadding = function(str) {
      return base64Encode(str).replace(/\./g, "");
    };
    base64Decode = function(str) {
      try {
        return base64.decodeString(str, true);
      } catch (e3) {
        console.error("base64Decode failed: ", e3);
      }
      return null;
    };
    getDefaultsFromGlobal = () => getGlobal().__FIREBASE_DEFAULTS__;
    getDefaultsFromEnvVariable = () => {
      if (typeof process === "undefined" || typeof process.env === "undefined") {
        return;
      }
      const defaultsJsonString = process.env.__FIREBASE_DEFAULTS__;
      if (defaultsJsonString) {
        return JSON.parse(defaultsJsonString);
      }
    };
    getDefaultsFromCookie = () => {
      if (typeof document === "undefined") {
        return;
      }
      let match;
      try {
        match = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);
      } catch (e3) {
        return;
      }
      const decoded = match && base64Decode(match[1]);
      return decoded && JSON.parse(decoded);
    };
    getDefaults = () => {
      try {
        return getDefaultsFromGlobal() || getDefaultsFromEnvVariable() || getDefaultsFromCookie();
      } catch (e3) {
        console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${e3}`);
        return;
      }
    };
    getDefaultEmulatorHost = (productName) => {
      var _a2, _b2;
      return (_b2 = (_a2 = getDefaults()) === null || _a2 === void 0 ? void 0 : _a2.emulatorHosts) === null || _b2 === void 0 ? void 0 : _b2[productName];
    };
    getDefaultEmulatorHostnameAndPort = (productName) => {
      const host = getDefaultEmulatorHost(productName);
      if (!host) {
        return void 0;
      }
      const separatorIndex = host.lastIndexOf(":");
      if (separatorIndex <= 0 || separatorIndex + 1 === host.length) {
        throw new Error(`Invalid host ${host} with no separate hostname and port!`);
      }
      const port = parseInt(host.substring(separatorIndex + 1), 10);
      if (host[0] === "[") {
        return [host.substring(1, separatorIndex - 1), port];
      } else {
        return [host.substring(0, separatorIndex), port];
      }
    };
    getDefaultAppConfig = () => {
      var _a2;
      return (_a2 = getDefaults()) === null || _a2 === void 0 ? void 0 : _a2.config;
    };
    Deferred = class {
      constructor() {
        this.reject = () => {
        };
        this.resolve = () => {
        };
        this.promise = new Promise((resolve2, reject) => {
          this.resolve = resolve2;
          this.reject = reject;
        });
      }
      /**
       * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around
       * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback
       * and returns a node-style callback which will resolve or reject the Deferred's promise.
       */
      wrapCallback(callback) {
        return (error, value) => {
          if (error) {
            this.reject(error);
          } else {
            this.resolve(value);
          }
          if (typeof callback === "function") {
            this.promise.catch(() => {
            });
            if (callback.length === 1) {
              callback(error);
            } else {
              callback(error, value);
            }
          }
        };
      }
    };
    ERROR_NAME = "FirebaseError";
    FirebaseError = class _FirebaseError extends Error {
      constructor(code, message, customData) {
        super(message);
        this.code = code;
        this.customData = customData;
        this.name = ERROR_NAME;
        Object.setPrototypeOf(this, _FirebaseError.prototype);
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, ErrorFactory.prototype.create);
        }
      }
    };
    ErrorFactory = class {
      constructor(service, serviceName, errors) {
        this.service = service;
        this.serviceName = serviceName;
        this.errors = errors;
      }
      create(code, ...data2) {
        const customData = data2[0] || {};
        const fullCode = `${this.service}/${code}`;
        const template = this.errors[code];
        const message = template ? replaceTemplate(template, customData) : "Error";
        const fullMessage = `${this.serviceName}: ${message} (${fullCode}).`;
        const error = new FirebaseError(fullCode, fullMessage, customData);
        return error;
      }
    };
    PATTERN = /\{\$([^}]+)}/g;
    MAX_VALUE_MILLIS = 4 * 60 * 60 * 1e3;
  }
});
function normalizeIdentifierForFactory(identifier) {
  return identifier === DEFAULT_ENTRY_NAME ? void 0 : identifier;
}
function isComponentEager(component15) {
  return component15.instantiationMode === "EAGER";
}
var Component;
var DEFAULT_ENTRY_NAME;
var Provider;
var ComponentContainer;
var init_index_esm20172 = __esm({
  "node_modules/@firebase/component/dist/esm/index.esm2017.js"() {
    init_index_esm2017();
    Component = class {
      /**
       *
       * @param name The public service name, e.g. app, auth, firestore, database
       * @param instanceFactory Service factory responsible for creating the public interface
       * @param type whether the service provided by the component is public or private
       */
      constructor(name5, instanceFactory, type) {
        this.name = name5;
        this.instanceFactory = instanceFactory;
        this.type = type;
        this.multipleInstances = false;
        this.serviceProps = {};
        this.instantiationMode = "LAZY";
        this.onInstanceCreated = null;
      }
      setInstantiationMode(mode) {
        this.instantiationMode = mode;
        return this;
      }
      setMultipleInstances(multipleInstances) {
        this.multipleInstances = multipleInstances;
        return this;
      }
      setServiceProps(props) {
        this.serviceProps = props;
        return this;
      }
      setInstanceCreatedCallback(callback) {
        this.onInstanceCreated = callback;
        return this;
      }
    };
    DEFAULT_ENTRY_NAME = "[DEFAULT]";
    Provider = class {
      constructor(name5, container) {
        this.name = name5;
        this.container = container;
        this.component = null;
        this.instances = /* @__PURE__ */ new Map();
        this.instancesDeferred = /* @__PURE__ */ new Map();
        this.instancesOptions = /* @__PURE__ */ new Map();
        this.onInitCallbacks = /* @__PURE__ */ new Map();
      }
      /**
       * @param identifier A provider can provide mulitple instances of a service
       * if this.component.multipleInstances is true.
       */
      get(identifier) {
        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
        if (!this.instancesDeferred.has(normalizedIdentifier)) {
          const deferred = new Deferred();
          this.instancesDeferred.set(normalizedIdentifier, deferred);
          if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {
            try {
              const instance = this.getOrInitializeService({
                instanceIdentifier: normalizedIdentifier
              });
              if (instance) {
                deferred.resolve(instance);
              }
            } catch (e3) {
            }
          }
        }
        return this.instancesDeferred.get(normalizedIdentifier).promise;
      }
      getImmediate(options2) {
        var _a2;
        const normalizedIdentifier = this.normalizeInstanceIdentifier(options2 === null || options2 === void 0 ? void 0 : options2.identifier);
        const optional = (_a2 = options2 === null || options2 === void 0 ? void 0 : options2.optional) !== null && _a2 !== void 0 ? _a2 : false;
        if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {
          try {
            return this.getOrInitializeService({
              instanceIdentifier: normalizedIdentifier
            });
          } catch (e3) {
            if (optional) {
              return null;
            } else {
              throw e3;
            }
          }
        } else {
          if (optional) {
            return null;
          } else {
            throw Error(`Service ${this.name} is not available`);
          }
        }
      }
      getComponent() {
        return this.component;
      }
      setComponent(component15) {
        if (component15.name !== this.name) {
          throw Error(`Mismatching Component ${component15.name} for Provider ${this.name}.`);
        }
        if (this.component) {
          throw Error(`Component for ${this.name} has already been provided`);
        }
        this.component = component15;
        if (!this.shouldAutoInitialize()) {
          return;
        }
        if (isComponentEager(component15)) {
          try {
            this.getOrInitializeService({ instanceIdentifier: DEFAULT_ENTRY_NAME });
          } catch (e3) {
          }
        }
        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {
          const normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
          try {
            const instance = this.getOrInitializeService({
              instanceIdentifier: normalizedIdentifier
            });
            instanceDeferred.resolve(instance);
          } catch (e3) {
          }
        }
      }
      clearInstance(identifier = DEFAULT_ENTRY_NAME) {
        this.instancesDeferred.delete(identifier);
        this.instancesOptions.delete(identifier);
        this.instances.delete(identifier);
      }
      // app.delete() will call this method on every provider to delete the services
      // TODO: should we mark the provider as deleted?
      async delete() {
        const services = Array.from(this.instances.values());
        await Promise.all([
          ...services.filter((service) => "INTERNAL" in service).map((service) => service.INTERNAL.delete()),
          ...services.filter((service) => "_delete" in service).map((service) => service._delete())
        ]);
      }
      isComponentSet() {
        return this.component != null;
      }
      isInitialized(identifier = DEFAULT_ENTRY_NAME) {
        return this.instances.has(identifier);
      }
      getOptions(identifier = DEFAULT_ENTRY_NAME) {
        return this.instancesOptions.get(identifier) || {};
      }
      initialize(opts = {}) {
        const { options: options2 = {} } = opts;
        const normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);
        if (this.isInitialized(normalizedIdentifier)) {
          throw Error(`${this.name}(${normalizedIdentifier}) has already been initialized`);
        }
        if (!this.isComponentSet()) {
          throw Error(`Component ${this.name} has not been registered yet`);
        }
        const instance = this.getOrInitializeService({
          instanceIdentifier: normalizedIdentifier,
          options: options2
        });
        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {
          const normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
          if (normalizedIdentifier === normalizedDeferredIdentifier) {
            instanceDeferred.resolve(instance);
          }
        }
        return instance;
      }
      /**
       *
       * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().
       * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.
       *
       * @param identifier An optional instance identifier
       * @returns a function to unregister the callback
       */
      onInit(callback, identifier) {
        var _a2;
        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
        const existingCallbacks = (_a2 = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a2 !== void 0 ? _a2 : /* @__PURE__ */ new Set();
        existingCallbacks.add(callback);
        this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);
        const existingInstance = this.instances.get(normalizedIdentifier);
        if (existingInstance) {
          callback(existingInstance, normalizedIdentifier);
        }
        return () => {
          existingCallbacks.delete(callback);
        };
      }
      /**
       * Invoke onInit callbacks synchronously
       * @param instance the service instance`
       */
      invokeOnInitCallbacks(instance, identifier) {
        const callbacks = this.onInitCallbacks.get(identifier);
        if (!callbacks) {
          return;
        }
        for (const callback of callbacks) {
          try {
            callback(instance, identifier);
          } catch (_a2) {
          }
        }
      }
      getOrInitializeService({ instanceIdentifier, options: options2 = {} }) {
        let instance = this.instances.get(instanceIdentifier);
        if (!instance && this.component) {
          instance = this.component.instanceFactory(this.container, {
            instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),
            options: options2
          });
          this.instances.set(instanceIdentifier, instance);
          this.instancesOptions.set(instanceIdentifier, options2);
          this.invokeOnInitCallbacks(instance, instanceIdentifier);
          if (this.component.onInstanceCreated) {
            try {
              this.component.onInstanceCreated(this.container, instanceIdentifier, instance);
            } catch (_a2) {
            }
          }
        }
        return instance || null;
      }
      normalizeInstanceIdentifier(identifier = DEFAULT_ENTRY_NAME) {
        if (this.component) {
          return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;
        } else {
          return identifier;
        }
      }
      shouldAutoInitialize() {
        return !!this.component && this.component.instantiationMode !== "EXPLICIT";
      }
    };
    ComponentContainer = class {
      constructor(name5) {
        this.name = name5;
        this.providers = /* @__PURE__ */ new Map();
      }
      /**
       *
       * @param component Component being added
       * @param overwrite When a component with the same name has already been registered,
       * if overwrite is true: overwrite the existing component with the new component and create a new
       * provider with the new component. It can be useful in tests where you want to use different mocks
       * for different tests.
       * if overwrite is false: throw an exception
       */
      addComponent(component15) {
        const provider = this.getProvider(component15.name);
        if (provider.isComponentSet()) {
          throw new Error(`Component ${component15.name} has already been registered with ${this.name}`);
        }
        provider.setComponent(component15);
      }
      addOrOverwriteComponent(component15) {
        const provider = this.getProvider(component15.name);
        if (provider.isComponentSet()) {
          this.providers.delete(component15.name);
        }
        this.addComponent(component15);
      }
      /**
       * getProvider provides a type safe interface where it can only be called with a field name
       * present in NameServiceMapping interface.
       *
       * Firebase SDKs providing services should extend NameServiceMapping interface to register
       * themselves.
       */
      getProvider(name5) {
        if (this.providers.has(name5)) {
          return this.providers.get(name5);
        }
        const provider = new Provider(name5, this);
        this.providers.set(name5, provider);
        return provider;
      }
      getProviders() {
        return Array.from(this.providers.values());
      }
    };
  }
});
var instances;
var LogLevel;
var levelStringToEnum;
var defaultLogLevel;
var ConsoleMethod;
var defaultLogHandler;
var Logger;
var init_index_esm20173 = __esm({
  "node_modules/@firebase/logger/dist/esm/index.esm2017.js"() {
    instances = [];
    (function(LogLevel2) {
      LogLevel2[LogLevel2["DEBUG"] = 0] = "DEBUG";
      LogLevel2[LogLevel2["VERBOSE"] = 1] = "VERBOSE";
      LogLevel2[LogLevel2["INFO"] = 2] = "INFO";
      LogLevel2[LogLevel2["WARN"] = 3] = "WARN";
      LogLevel2[LogLevel2["ERROR"] = 4] = "ERROR";
      LogLevel2[LogLevel2["SILENT"] = 5] = "SILENT";
    })(LogLevel || (LogLevel = {}));
    levelStringToEnum = {
      "debug": LogLevel.DEBUG,
      "verbose": LogLevel.VERBOSE,
      "info": LogLevel.INFO,
      "warn": LogLevel.WARN,
      "error": LogLevel.ERROR,
      "silent": LogLevel.SILENT
    };
    defaultLogLevel = LogLevel.INFO;
    ConsoleMethod = {
      [LogLevel.DEBUG]: "log",
      [LogLevel.VERBOSE]: "log",
      [LogLevel.INFO]: "info",
      [LogLevel.WARN]: "warn",
      [LogLevel.ERROR]: "error"
    };
    defaultLogHandler = (instance, logType, ...args) => {
      if (logType < instance.logLevel) {
        return;
      }
      const now = (/* @__PURE__ */ new Date()).toISOString();
      const method = ConsoleMethod[logType];
      if (method) {
        console[method](`[${now}]  ${instance.name}:`, ...args);
      } else {
        throw new Error(`Attempted to log a message with an invalid logType (value: ${logType})`);
      }
    };
    Logger = class {
      /**
       * Gives you an instance of a Logger to capture messages according to
       * Firebase's logging scheme.
       *
       * @param name The name that the logs will be associated with
       */
      constructor(name5) {
        this.name = name5;
        this._logLevel = defaultLogLevel;
        this._logHandler = defaultLogHandler;
        this._userLogHandler = null;
        instances.push(this);
      }
      get logLevel() {
        return this._logLevel;
      }
      set logLevel(val) {
        if (!(val in LogLevel)) {
          throw new TypeError(`Invalid value "${val}" assigned to \`logLevel\``);
        }
        this._logLevel = val;
      }
      // Workaround for setter/getter having to be the same type.
      setLogLevel(val) {
        this._logLevel = typeof val === "string" ? levelStringToEnum[val] : val;
      }
      get logHandler() {
        return this._logHandler;
      }
      set logHandler(val) {
        if (typeof val !== "function") {
          throw new TypeError("Value assigned to `logHandler` must be a function");
        }
        this._logHandler = val;
      }
      get userLogHandler() {
        return this._userLogHandler;
      }
      set userLogHandler(val) {
        this._userLogHandler = val;
      }
      /**
       * The functions below are all based on the `console` interface
       */
      debug(...args) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.DEBUG, ...args);
        this._logHandler(this, LogLevel.DEBUG, ...args);
      }
      log(...args) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.VERBOSE, ...args);
        this._logHandler(this, LogLevel.VERBOSE, ...args);
      }
      info(...args) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.INFO, ...args);
        this._logHandler(this, LogLevel.INFO, ...args);
      }
      warn(...args) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.WARN, ...args);
        this._logHandler(this, LogLevel.WARN, ...args);
      }
      error(...args) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.ERROR, ...args);
        this._logHandler(this, LogLevel.ERROR, ...args);
      }
    };
  }
});
function getIdbProxyableTypes() {
  return idbProxyableTypes || (idbProxyableTypes = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function getCursorAdvanceMethods() {
  return cursorAdvanceMethods || (cursorAdvanceMethods = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
function promisifyRequest(request) {
  const promise = new Promise((resolve2, reject) => {
    const unlisten = () => {
      request.removeEventListener("success", success);
      request.removeEventListener("error", error);
    };
    const success = () => {
      resolve2(wrap(request.result));
      unlisten();
    };
    const error = () => {
      reject(request.error);
      unlisten();
    };
    request.addEventListener("success", success);
    request.addEventListener("error", error);
  });
  promise.then((value) => {
    if (value instanceof IDBCursor) {
      cursorRequestMap.set(value, request);
    }
  }).catch(() => {
  });
  reverseTransformCache.set(promise, request);
  return promise;
}
function cacheDonePromiseForTransaction(tx) {
  if (transactionDoneMap.has(tx))
    return;
  const done = new Promise((resolve2, reject) => {
    const unlisten = () => {
      tx.removeEventListener("complete", complete);
      tx.removeEventListener("error", error);
      tx.removeEventListener("abort", error);
    };
    const complete = () => {
      resolve2();
      unlisten();
    };
    const error = () => {
      reject(tx.error || new DOMException("AbortError", "AbortError"));
      unlisten();
    };
    tx.addEventListener("complete", complete);
    tx.addEventListener("error", error);
    tx.addEventListener("abort", error);
  });
  transactionDoneMap.set(tx, done);
}
function replaceTraps(callback) {
  idbProxyTraps = callback(idbProxyTraps);
}
function wrapFunction(func) {
  if (func === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype)) {
    return function(storeNames, ...args) {
      const tx = func.call(unwrap(this), storeNames, ...args);
      transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);
      return wrap(tx);
    };
  }
  if (getCursorAdvanceMethods().includes(func)) {
    return function(...args) {
      func.apply(unwrap(this), args);
      return wrap(cursorRequestMap.get(this));
    };
  }
  return function(...args) {
    return wrap(func.apply(unwrap(this), args));
  };
}
function transformCachableValue(value) {
  if (typeof value === "function")
    return wrapFunction(value);
  if (value instanceof IDBTransaction)
    cacheDonePromiseForTransaction(value);
  if (instanceOfAny(value, getIdbProxyableTypes()))
    return new Proxy(value, idbProxyTraps);
  return value;
}
function wrap(value) {
  if (value instanceof IDBRequest)
    return promisifyRequest(value);
  if (transformCache.has(value))
    return transformCache.get(value);
  const newValue = transformCachableValue(value);
  if (newValue !== value) {
    transformCache.set(value, newValue);
    reverseTransformCache.set(newValue, value);
  }
  return newValue;
}
var instanceOfAny;
var idbProxyableTypes;
var cursorAdvanceMethods;
var cursorRequestMap;
var transactionDoneMap;
var transactionStoreNamesMap;
var transformCache;
var reverseTransformCache;
var idbProxyTraps;
var unwrap;
var init_wrap_idb_value = __esm({
  "node_modules/idb/build/wrap-idb-value.js"() {
    instanceOfAny = (object, constructors) => constructors.some((c2) => object instanceof c2);
    cursorRequestMap = /* @__PURE__ */ new WeakMap();
    transactionDoneMap = /* @__PURE__ */ new WeakMap();
    transactionStoreNamesMap = /* @__PURE__ */ new WeakMap();
    transformCache = /* @__PURE__ */ new WeakMap();
    reverseTransformCache = /* @__PURE__ */ new WeakMap();
    idbProxyTraps = {
      get(target, prop, receiver) {
        if (target instanceof IDBTransaction) {
          if (prop === "done")
            return transactionDoneMap.get(target);
          if (prop === "objectStoreNames") {
            return target.objectStoreNames || transactionStoreNamesMap.get(target);
          }
          if (prop === "store") {
            return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);
          }
        }
        return wrap(target[prop]);
      },
      set(target, prop, value) {
        target[prop] = value;
        return true;
      },
      has(target, prop) {
        if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) {
          return true;
        }
        return prop in target;
      }
    };
    unwrap = (value) => reverseTransformCache.get(value);
  }
});
function openDB(name5, version3, { blocked, upgrade, blocking, terminated } = {}) {
  const request = indexedDB.open(name5, version3);
  const openPromise = wrap(request);
  if (upgrade) {
    request.addEventListener("upgradeneeded", (event) => {
      upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);
    });
  }
  if (blocked) {
    request.addEventListener("blocked", (event) => blocked(
      // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
      event.oldVersion,
      event.newVersion,
      event
    ));
  }
  openPromise.then((db3) => {
    if (terminated)
      db3.addEventListener("close", () => terminated());
    if (blocking) {
      db3.addEventListener("versionchange", (event) => blocking(event.oldVersion, event.newVersion, event));
    }
  }).catch(() => {
  });
  return openPromise;
}
function getMethod(target, prop) {
  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) {
    return;
  }
  if (cachedMethods.get(prop))
    return cachedMethods.get(prop);
  const targetFuncName = prop.replace(/FromIndex$/, "");
  const useIndex = prop !== targetFuncName;
  const isWrite = writeMethods.includes(targetFuncName);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))
  ) {
    return;
  }
  const method = async function(storeName, ...args) {
    const tx = this.transaction(storeName, isWrite ? "readwrite" : "readonly");
    let target2 = tx.store;
    if (useIndex)
      target2 = target2.index(args.shift());
    return (await Promise.all([
      target2[targetFuncName](...args),
      isWrite && tx.done
    ]))[0];
  };
  cachedMethods.set(prop, method);
  return method;
}
var readMethods;
var writeMethods;
var cachedMethods;
var init_build = __esm({
  "node_modules/idb/build/index.js"() {
    init_wrap_idb_value();
    init_wrap_idb_value();
    readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"];
    writeMethods = ["put", "add", "delete", "clear"];
    cachedMethods = /* @__PURE__ */ new Map();
    replaceTraps((oldTraps) => ({
      ...oldTraps,
      get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
      has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)
    }));
  }
});
function isVersionServiceProvider(provider) {
  const component15 = provider.getComponent();
  return (component15 === null || component15 === void 0 ? void 0 : component15.type) === "VERSION";
}
function _addComponent(app2, component15) {
  try {
    app2.container.addComponent(component15);
  } catch (e3) {
    logger.debug(`Component ${component15.name} failed to register with FirebaseApp ${app2.name}`, e3);
  }
}
function _registerComponent(component15) {
  const componentName = component15.name;
  if (_components.has(componentName)) {
    logger.debug(`There were multiple attempts to register component ${componentName}.`);
    return false;
  }
  _components.set(componentName, component15);
  for (const app2 of _apps.values()) {
    _addComponent(app2, component15);
  }
  return true;
}
function _getProvider(app2, name5) {
  const heartbeatController = app2.container.getProvider("heartbeat").getImmediate({ optional: true });
  if (heartbeatController) {
    void heartbeatController.triggerHeartbeat();
  }
  return app2.container.getProvider(name5);
}
function initializeApp(_options, rawConfig = {}) {
  let options2 = _options;
  if (typeof rawConfig !== "object") {
    const name6 = rawConfig;
    rawConfig = { name: name6 };
  }
  const config = Object.assign({ name: DEFAULT_ENTRY_NAME2, automaticDataCollectionEnabled: false }, rawConfig);
  const name5 = config.name;
  if (typeof name5 !== "string" || !name5) {
    throw ERROR_FACTORY.create("bad-app-name", {
      appName: String(name5)
    });
  }
  options2 || (options2 = getDefaultAppConfig());
  if (!options2) {
    throw ERROR_FACTORY.create(
      "no-options"
      /* AppError.NO_OPTIONS */
    );
  }
  const existingApp = _apps.get(name5);
  if (existingApp) {
    if (deepEqual(options2, existingApp.options) && deepEqual(config, existingApp.config)) {
      return existingApp;
    } else {
      throw ERROR_FACTORY.create("duplicate-app", { appName: name5 });
    }
  }
  const container = new ComponentContainer(name5);
  for (const component15 of _components.values()) {
    container.addComponent(component15);
  }
  const newApp = new FirebaseAppImpl(options2, config, container);
  _apps.set(name5, newApp);
  return newApp;
}
function getApp(name5 = DEFAULT_ENTRY_NAME2) {
  const app2 = _apps.get(name5);
  if (!app2 && name5 === DEFAULT_ENTRY_NAME2 && getDefaultAppConfig()) {
    return initializeApp();
  }
  if (!app2) {
    throw ERROR_FACTORY.create("no-app", { appName: name5 });
  }
  return app2;
}
function registerVersion(libraryKeyOrName, version3, variant) {
  var _a2;
  let library = (_a2 = PLATFORM_LOG_STRING[libraryKeyOrName]) !== null && _a2 !== void 0 ? _a2 : libraryKeyOrName;
  if (variant) {
    library += `-${variant}`;
  }
  const libraryMismatch = library.match(/\s|\//);
  const versionMismatch = version3.match(/\s|\//);
  if (libraryMismatch || versionMismatch) {
    const warning = [
      `Unable to register library "${library}" with version "${version3}":`
    ];
    if (libraryMismatch) {
      warning.push(`library name "${library}" contains illegal characters (whitespace or "/")`);
    }
    if (libraryMismatch && versionMismatch) {
      warning.push("and");
    }
    if (versionMismatch) {
      warning.push(`version name "${version3}" contains illegal characters (whitespace or "/")`);
    }
    logger.warn(warning.join(" "));
    return;
  }
  _registerComponent(new Component(
    `${library}-version`,
    () => ({ library, version: version3 }),
    "VERSION"
    /* ComponentType.VERSION */
  ));
}
function getDbPromise() {
  if (!dbPromise) {
    dbPromise = openDB(DB_NAME, DB_VERSION, {
      upgrade: (db3, oldVersion) => {
        switch (oldVersion) {
          case 0:
            try {
              db3.createObjectStore(STORE_NAME);
            } catch (e3) {
              console.warn(e3);
            }
        }
      }
    }).catch((e3) => {
      throw ERROR_FACTORY.create("idb-open", {
        originalErrorMessage: e3.message
      });
    });
  }
  return dbPromise;
}
async function readHeartbeatsFromIndexedDB(app2) {
  try {
    const db3 = await getDbPromise();
    const tx = db3.transaction(STORE_NAME);
    const result = await tx.objectStore(STORE_NAME).get(computeKey(app2));
    await tx.done;
    return result;
  } catch (e3) {
    if (e3 instanceof FirebaseError) {
      logger.warn(e3.message);
    } else {
      const idbGetError = ERROR_FACTORY.create("idb-get", {
        originalErrorMessage: e3 === null || e3 === void 0 ? void 0 : e3.message
      });
      logger.warn(idbGetError.message);
    }
  }
}
async function writeHeartbeatsToIndexedDB(app2, heartbeatObject) {
  try {
    const db3 = await getDbPromise();
    const tx = db3.transaction(STORE_NAME, "readwrite");
    const objectStore = tx.objectStore(STORE_NAME);
    await objectStore.put(heartbeatObject, computeKey(app2));
    await tx.done;
  } catch (e3) {
    if (e3 instanceof FirebaseError) {
      logger.warn(e3.message);
    } else {
      const idbGetError = ERROR_FACTORY.create("idb-set", {
        originalErrorMessage: e3 === null || e3 === void 0 ? void 0 : e3.message
      });
      logger.warn(idbGetError.message);
    }
  }
}
function computeKey(app2) {
  return `${app2.name}!${app2.options.appId}`;
}
function getUTCDateString() {
  const today = /* @__PURE__ */ new Date();
  return today.toISOString().substring(0, 10);
}
function extractHeartbeatsForHeader(heartbeatsCache, maxSize = MAX_HEADER_BYTES) {
  const heartbeatsToSend = [];
  let unsentEntries = heartbeatsCache.slice();
  for (const singleDateHeartbeat of heartbeatsCache) {
    const heartbeatEntry = heartbeatsToSend.find((hb2) => hb2.agent === singleDateHeartbeat.agent);
    if (!heartbeatEntry) {
      heartbeatsToSend.push({
        agent: singleDateHeartbeat.agent,
        dates: [singleDateHeartbeat.date]
      });
      if (countBytes(heartbeatsToSend) > maxSize) {
        heartbeatsToSend.pop();
        break;
      }
    } else {
      heartbeatEntry.dates.push(singleDateHeartbeat.date);
      if (countBytes(heartbeatsToSend) > maxSize) {
        heartbeatEntry.dates.pop();
        break;
      }
    }
    unsentEntries = unsentEntries.slice(1);
  }
  return {
    heartbeatsToSend,
    unsentEntries
  };
}
function countBytes(heartbeatsCache) {
  return base64urlEncodeWithoutPadding(
    // heartbeatsCache wrapper properties
    JSON.stringify({ version: 2, heartbeats: heartbeatsCache })
  ).length;
}
function registerCoreComponents(variant) {
  _registerComponent(new Component(
    "platform-logger",
    (container) => new PlatformLoggerServiceImpl(container),
    "PRIVATE"
    /* ComponentType.PRIVATE */
  ));
  _registerComponent(new Component(
    "heartbeat",
    (container) => new HeartbeatServiceImpl(container),
    "PRIVATE"
    /* ComponentType.PRIVATE */
  ));
  registerVersion(name$o, version$1, variant);
  registerVersion(name$o, version$1, "esm2017");
  registerVersion("fire-js", "");
}
var PlatformLoggerServiceImpl;
var name$o;
var version$1;
var logger;
var name$n;
var name$m;
var name$l;
var name$k;
var name$j;
var name$i;
var name$h;
var name$g;
var name$f;
var name$e;
var name$d;
var name$c;
var name$b;
var name$a;
var name$9;
var name$8;
var name$7;
var name$6;
var name$5;
var name$4;
var name$3;
var name$2;
var name$1;
var name;
var version;
var DEFAULT_ENTRY_NAME2;
var PLATFORM_LOG_STRING;
var _apps;
var _components;
var ERRORS;
var ERROR_FACTORY;
var FirebaseAppImpl;
var SDK_VERSION;
var DB_NAME;
var DB_VERSION;
var STORE_NAME;
var dbPromise;
var MAX_HEADER_BYTES;
var STORED_HEARTBEAT_RETENTION_MAX_MILLIS;
var HeartbeatServiceImpl;
var HeartbeatStorageImpl;
var init_index_esm20174 = __esm({
  "node_modules/@firebase/app/dist/esm/index.esm2017.js"() {
    init_index_esm20172();
    init_index_esm20173();
    init_index_esm2017();
    init_index_esm2017();
    init_build();
    PlatformLoggerServiceImpl = class {
      constructor(container) {
        this.container = container;
      }
      // In initial implementation, this will be called by installations on
      // auth token refresh, and installations will send this string.
      getPlatformInfoString() {
        const providers = this.container.getProviders();
        return providers.map((provider) => {
          if (isVersionServiceProvider(provider)) {
            const service = provider.getImmediate();
            return `${service.library}/${service.version}`;
          } else {
            return null;
          }
        }).filter((logString) => logString).join(" ");
      }
    };
    name$o = "@firebase/app";
    version$1 = "0.9.28";
    logger = new Logger("@firebase/app");
    name$n = "@firebase/app-compat";
    name$m = "@firebase/analytics-compat";
    name$l = "@firebase/analytics";
    name$k = "@firebase/app-check-compat";
    name$j = "@firebase/app-check";
    name$i = "@firebase/auth";
    name$h = "@firebase/auth-compat";
    name$g = "@firebase/database";
    name$f = "@firebase/database-compat";
    name$e = "@firebase/functions";
    name$d = "@firebase/functions-compat";
    name$c = "@firebase/installations";
    name$b = "@firebase/installations-compat";
    name$a = "@firebase/messaging";
    name$9 = "@firebase/messaging-compat";
    name$8 = "@firebase/performance";
    name$7 = "@firebase/performance-compat";
    name$6 = "@firebase/remote-config";
    name$5 = "@firebase/remote-config-compat";
    name$4 = "@firebase/storage";
    name$3 = "@firebase/storage-compat";
    name$2 = "@firebase/firestore";
    name$1 = "@firebase/firestore-compat";
    name = "firebase";
    version = "10.8.1";
    DEFAULT_ENTRY_NAME2 = "[DEFAULT]";
    PLATFORM_LOG_STRING = {
      [name$o]: "fire-core",
      [name$n]: "fire-core-compat",
      [name$l]: "fire-analytics",
      [name$m]: "fire-analytics-compat",
      [name$j]: "fire-app-check",
      [name$k]: "fire-app-check-compat",
      [name$i]: "fire-auth",
      [name$h]: "fire-auth-compat",
      [name$g]: "fire-rtdb",
      [name$f]: "fire-rtdb-compat",
      [name$e]: "fire-fn",
      [name$d]: "fire-fn-compat",
      [name$c]: "fire-iid",
      [name$b]: "fire-iid-compat",
      [name$a]: "fire-fcm",
      [name$9]: "fire-fcm-compat",
      [name$8]: "fire-perf",
      [name$7]: "fire-perf-compat",
      [name$6]: "fire-rc",
      [name$5]: "fire-rc-compat",
      [name$4]: "fire-gcs",
      [name$3]: "fire-gcs-compat",
      [name$2]: "fire-fst",
      [name$1]: "fire-fst-compat",
      "fire-js": "fire-js",
      [name]: "fire-js-all"
    };
    _apps = /* @__PURE__ */ new Map();
    _components = /* @__PURE__ */ new Map();
    ERRORS = {
      [
        "no-app"
        /* AppError.NO_APP */
      ]: "No Firebase App '{$appName}' has been created - call initializeApp() first",
      [
        "bad-app-name"
        /* AppError.BAD_APP_NAME */
      ]: "Illegal App name: '{$appName}",
      [
        "duplicate-app"
        /* AppError.DUPLICATE_APP */
      ]: "Firebase App named '{$appName}' already exists with different options or config",
      [
        "app-deleted"
        /* AppError.APP_DELETED */
      ]: "Firebase App named '{$appName}' already deleted",
      [
        "no-options"
        /* AppError.NO_OPTIONS */
      ]: "Need to provide options, when not being deployed to hosting via source.",
      [
        "invalid-app-argument"
        /* AppError.INVALID_APP_ARGUMENT */
      ]: "firebase.{$appName}() takes either no argument or a Firebase App instance.",
      [
        "invalid-log-argument"
        /* AppError.INVALID_LOG_ARGUMENT */
      ]: "First argument to `onLog` must be null or a function.",
      [
        "idb-open"
        /* AppError.IDB_OPEN */
      ]: "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.",
      [
        "idb-get"
        /* AppError.IDB_GET */
      ]: "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.",
      [
        "idb-set"
        /* AppError.IDB_WRITE */
      ]: "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.",
      [
        "idb-delete"
        /* AppError.IDB_DELETE */
      ]: "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}."
    };
    ERROR_FACTORY = new ErrorFactory("app", "Firebase", ERRORS);
    FirebaseAppImpl = class {
      constructor(options2, config, container) {
        this._isDeleted = false;
        this._options = Object.assign({}, options2);
        this._config = Object.assign({}, config);
        this._name = config.name;
        this._automaticDataCollectionEnabled = config.automaticDataCollectionEnabled;
        this._container = container;
        this.container.addComponent(new Component(
          "app",
          () => this,
          "PUBLIC"
          /* ComponentType.PUBLIC */
        ));
      }
      get automaticDataCollectionEnabled() {
        this.checkDestroyed();
        return this._automaticDataCollectionEnabled;
      }
      set automaticDataCollectionEnabled(val) {
        this.checkDestroyed();
        this._automaticDataCollectionEnabled = val;
      }
      get name() {
        this.checkDestroyed();
        return this._name;
      }
      get options() {
        this.checkDestroyed();
        return this._options;
      }
      get config() {
        this.checkDestroyed();
        return this._config;
      }
      get container() {
        return this._container;
      }
      get isDeleted() {
        return this._isDeleted;
      }
      set isDeleted(val) {
        this._isDeleted = val;
      }
      /**
       * This function will throw an Error if the App has already been deleted -
       * use before performing API actions on the App.
       */
      checkDestroyed() {
        if (this.isDeleted) {
          throw ERROR_FACTORY.create("app-deleted", { appName: this._name });
        }
      }
    };
    SDK_VERSION = version;
    DB_NAME = "firebase-heartbeat-database";
    DB_VERSION = 1;
    STORE_NAME = "firebase-heartbeat-store";
    dbPromise = null;
    MAX_HEADER_BYTES = 1024;
    STORED_HEARTBEAT_RETENTION_MAX_MILLIS = 30 * 24 * 60 * 60 * 1e3;
    HeartbeatServiceImpl = class {
      constructor(container) {
        this.container = container;
        this._heartbeatsCache = null;
        const app2 = this.container.getProvider("app").getImmediate();
        this._storage = new HeartbeatStorageImpl(app2);
        this._heartbeatsCachePromise = this._storage.read().then((result) => {
          this._heartbeatsCache = result;
          return result;
        });
      }
      /**
       * Called to report a heartbeat. The function will generate
       * a HeartbeatsByUserAgent object, update heartbeatsCache, and persist it
       * to IndexedDB.
       * Note that we only store one heartbeat per day. So if a heartbeat for today is
       * already logged, subsequent calls to this function in the same day will be ignored.
       */
      async triggerHeartbeat() {
        var _a2, _b2;
        const platformLogger = this.container.getProvider("platform-logger").getImmediate();
        const agent = platformLogger.getPlatformInfoString();
        const date = getUTCDateString();
        if (((_a2 = this._heartbeatsCache) === null || _a2 === void 0 ? void 0 : _a2.heartbeats) == null) {
          this._heartbeatsCache = await this._heartbeatsCachePromise;
          if (((_b2 = this._heartbeatsCache) === null || _b2 === void 0 ? void 0 : _b2.heartbeats) == null) {
            return;
          }
        }
        if (this._heartbeatsCache.lastSentHeartbeatDate === date || this._heartbeatsCache.heartbeats.some((singleDateHeartbeat) => singleDateHeartbeat.date === date)) {
          return;
        } else {
          this._heartbeatsCache.heartbeats.push({ date, agent });
        }
        this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter((singleDateHeartbeat) => {
          const hbTimestamp = new Date(singleDateHeartbeat.date).valueOf();
          const now = Date.now();
          return now - hbTimestamp <= STORED_HEARTBEAT_RETENTION_MAX_MILLIS;
        });
        return this._storage.overwrite(this._heartbeatsCache);
      }
      /**
       * Returns a base64 encoded string which can be attached to the heartbeat-specific header directly.
       * It also clears all heartbeats from memory as well as in IndexedDB.
       *
       * NOTE: Consuming product SDKs should not send the header if this method
       * returns an empty string.
       */
      async getHeartbeatsHeader() {
        var _a2;
        if (this._heartbeatsCache === null) {
          await this._heartbeatsCachePromise;
        }
        if (((_a2 = this._heartbeatsCache) === null || _a2 === void 0 ? void 0 : _a2.heartbeats) == null || this._heartbeatsCache.heartbeats.length === 0) {
          return "";
        }
        const date = getUTCDateString();
        const { heartbeatsToSend, unsentEntries } = extractHeartbeatsForHeader(this._heartbeatsCache.heartbeats);
        const headerString = base64urlEncodeWithoutPadding(JSON.stringify({ version: 2, heartbeats: heartbeatsToSend }));
        this._heartbeatsCache.lastSentHeartbeatDate = date;
        if (unsentEntries.length > 0) {
          this._heartbeatsCache.heartbeats = unsentEntries;
          await this._storage.overwrite(this._heartbeatsCache);
        } else {
          this._heartbeatsCache.heartbeats = [];
          void this._storage.overwrite(this._heartbeatsCache);
        }
        return headerString;
      }
    };
    HeartbeatStorageImpl = class {
      constructor(app2) {
        this.app = app2;
        this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();
      }
      async runIndexedDBEnvironmentCheck() {
        if (!isIndexedDBAvailable()) {
          return false;
        } else {
          return validateIndexedDBOpenable().then(() => true).catch(() => false);
        }
      }
      /**
       * Read all heartbeats.
       */
      async read() {
        const canUseIndexedDB = await this._canUseIndexedDBPromise;
        if (!canUseIndexedDB) {
          return { heartbeats: [] };
        } else {
          const idbHeartbeatObject = await readHeartbeatsFromIndexedDB(this.app);
          if (idbHeartbeatObject === null || idbHeartbeatObject === void 0 ? void 0 : idbHeartbeatObject.heartbeats) {
            return idbHeartbeatObject;
          } else {
            return { heartbeats: [] };
          }
        }
      }
      // overwrite the storage with the provided heartbeats
      async overwrite(heartbeatsObject) {
        var _a2;
        const canUseIndexedDB = await this._canUseIndexedDBPromise;
        if (!canUseIndexedDB) {
          return;
        } else {
          const existingHeartbeatsObject = await this.read();
          return writeHeartbeatsToIndexedDB(this.app, {
            lastSentHeartbeatDate: (_a2 = heartbeatsObject.lastSentHeartbeatDate) !== null && _a2 !== void 0 ? _a2 : existingHeartbeatsObject.lastSentHeartbeatDate,
            heartbeats: heartbeatsObject.heartbeats
          });
        }
      }
      // add heartbeats
      async add(heartbeatsObject) {
        var _a2;
        const canUseIndexedDB = await this._canUseIndexedDBPromise;
        if (!canUseIndexedDB) {
          return;
        } else {
          const existingHeartbeatsObject = await this.read();
          return writeHeartbeatsToIndexedDB(this.app, {
            lastSentHeartbeatDate: (_a2 = heartbeatsObject.lastSentHeartbeatDate) !== null && _a2 !== void 0 ? _a2 : existingHeartbeatsObject.lastSentHeartbeatDate,
            heartbeats: [
              ...existingHeartbeatsObject.heartbeats,
              ...heartbeatsObject.heartbeats
            ]
          });
        }
      }
    };
    registerCoreComponents("");
  }
});
var name2;
var version2;
var init_index_esm = __esm({
  "node_modules/firebase/app/dist/esm/index.esm.js"() {
    init_index_esm20174();
    init_index_esm20174();
    name2 = "firebase";
    version2 = "10.8.1";
    registerVersion(name2, version2, "app");
  }
});
function aa(a2) {
  var b2 = typeof a2;
  b2 = "object" != b2 ? b2 : a2 ? Array.isArray(a2) ? "array" : b2 : "null";
  return "array" == b2 || "object" == b2 && "number" == typeof a2.length;
}
function p(a2) {
  var b2 = typeof a2;
  return "object" == b2 && null != a2 || "function" == b2;
}
function ba(a2) {
  return Object.prototype.hasOwnProperty.call(a2, ca) && a2[ca] || (a2[ca] = ++da);
}
function ea(a2, b2, c2) {
  return a2.call.apply(a2.bind, arguments);
}
function fa(a2, b2, c2) {
  if (!a2)
    throw Error();
  if (2 < arguments.length) {
    var d = Array.prototype.slice.call(arguments, 2);
    return function() {
      var e3 = Array.prototype.slice.call(arguments);
      Array.prototype.unshift.apply(e3, d);
      return a2.apply(b2, e3);
    };
  }
  return function() {
    return a2.apply(b2, arguments);
  };
}
function q(a2, b2, c2) {
  Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? q = ea : q = fa;
  return q.apply(null, arguments);
}
function ha(a2, b2) {
  var c2 = Array.prototype.slice.call(arguments, 1);
  return function() {
    var d = c2.slice();
    d.push.apply(d, arguments);
    return a2.apply(this, d);
  };
}
function r(a2, b2) {
  function c2() {
  }
  c2.prototype = b2.prototype;
  a2.$ = b2.prototype;
  a2.prototype = new c2();
  a2.prototype.constructor = a2;
  a2.ac = function(d, e3, f) {
    for (var h = Array(arguments.length - 2), n2 = 2; n2 < arguments.length; n2++)
      h[n2 - 2] = arguments[n2];
    return b2.prototype[e3].apply(d, h);
  };
}
function v() {
  this.s = this.s;
  this.o = this.o;
}
function ma(a2) {
  const b2 = a2.length;
  if (0 < b2) {
    const c2 = Array(b2);
    for (let d = 0; d < b2; d++)
      c2[d] = a2[d];
    return c2;
  }
  return [];
}
function na(a2, b2) {
  for (let c2 = 1; c2 < arguments.length; c2++) {
    const d = arguments[c2];
    if (aa(d)) {
      const e3 = a2.length || 0, f = d.length || 0;
      a2.length = e3 + f;
      for (let h = 0; h < f; h++)
        a2[e3 + h] = d[h];
    } else
      a2.push(d);
  }
}
function w(a2, b2) {
  this.type = a2;
  this.g = this.target = b2;
  this.defaultPrevented = false;
}
function x(a2) {
  return /^[\s\xa0]*$/.test(a2);
}
function pa() {
  var a2 = l.navigator;
  return a2 && (a2 = a2.userAgent) ? a2 : "";
}
function y(a2) {
  return -1 != pa().indexOf(a2);
}
function qa(a2) {
  qa[" "](a2);
  return a2;
}
function ra(a2, b2) {
  var c2 = sa;
  return Object.prototype.hasOwnProperty.call(c2, a2) ? c2[a2] : c2[a2] = b2(a2);
}
function ya() {
  var a2 = l.document;
  return a2 ? a2.documentMode : void 0;
}
function A(a2, b2) {
  w.call(this, a2 ? a2.type : "");
  this.relatedTarget = this.g = this.target = null;
  this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0;
  this.key = "";
  this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = false;
  this.state = null;
  this.pointerId = 0;
  this.pointerType = "";
  this.i = null;
  if (a2) {
    var c2 = this.type = a2.type, d = a2.changedTouches && a2.changedTouches.length ? a2.changedTouches[0] : null;
    this.target = a2.target || a2.srcElement;
    this.g = b2;
    if (b2 = a2.relatedTarget) {
      if (wa) {
        a: {
          try {
            qa(b2.nodeName);
            var e3 = true;
            break a;
          } catch (f) {
          }
          e3 = false;
        }
        e3 || (b2 = null);
      }
    } else
      "mouseover" == c2 ? b2 = a2.fromElement : "mouseout" == c2 && (b2 = a2.toElement);
    this.relatedTarget = b2;
    d ? (this.clientX = void 0 !== d.clientX ? d.clientX : d.pageX, this.clientY = void 0 !== d.clientY ? d.clientY : d.pageY, this.screenX = d.screenX || 0, this.screenY = d.screenY || 0) : (this.clientX = void 0 !== a2.clientX ? a2.clientX : a2.pageX, this.clientY = void 0 !== a2.clientY ? a2.clientY : a2.pageY, this.screenX = a2.screenX || 0, this.screenY = a2.screenY || 0);
    this.button = a2.button;
    this.key = a2.key || "";
    this.ctrlKey = a2.ctrlKey;
    this.altKey = a2.altKey;
    this.shiftKey = a2.shiftKey;
    this.metaKey = a2.metaKey;
    this.pointerId = a2.pointerId || 0;
    this.pointerType = "string" === typeof a2.pointerType ? a2.pointerType : Ga[a2.pointerType] || "";
    this.state = a2.state;
    this.i = a2;
    a2.defaultPrevented && A.$.h.call(this);
  }
}
function Ja(a2, b2, c2, d, e3) {
  this.listener = a2;
  this.proxy = null;
  this.src = b2;
  this.type = c2;
  this.capture = !!d;
  this.la = e3;
  this.key = ++Ia;
  this.fa = this.ia = false;
}
function Ma(a2) {
  a2.fa = true;
  a2.listener = null;
  a2.proxy = null;
  a2.src = null;
  a2.la = null;
}
function Na(a2, b2, c2) {
  for (const d in a2)
    b2.call(c2, a2[d], d, a2);
}
function Oa(a2, b2) {
  for (const c2 in a2)
    b2.call(void 0, a2[c2], c2, a2);
}
function Pa(a2) {
  const b2 = {};
  for (const c2 in a2)
    b2[c2] = a2[c2];
  return b2;
}
function Ra(a2, b2) {
  let c2, d;
  for (let e3 = 1; e3 < arguments.length; e3++) {
    d = arguments[e3];
    for (c2 in d)
      a2[c2] = d[c2];
    for (let f = 0; f < Qa.length; f++)
      c2 = Qa[f], Object.prototype.hasOwnProperty.call(d, c2) && (a2[c2] = d[c2]);
  }
}
function Sa(a2) {
  this.src = a2;
  this.g = {};
  this.h = 0;
}
function Ua(a2, b2) {
  var c2 = b2.type;
  if (c2 in a2.g) {
    var d = a2.g[c2], e3 = ka(d, b2), f;
    (f = 0 <= e3) && Array.prototype.splice.call(d, e3, 1);
    f && (Ma(b2), 0 == a2.g[c2].length && (delete a2.g[c2], a2.h--));
  }
}
function Ta(a2, b2, c2, d) {
  for (var e3 = 0; e3 < a2.length; ++e3) {
    var f = a2[e3];
    if (!f.fa && f.listener == b2 && f.capture == !!c2 && f.la == d)
      return e3;
  }
  return -1;
}
function Ya(a2, b2, c2, d, e3) {
  if (d && d.once)
    return Za(a2, b2, c2, d, e3);
  if (Array.isArray(b2)) {
    for (var f = 0; f < b2.length; f++)
      Ya(a2, b2[f], c2, d, e3);
    return null;
  }
  c2 = $a(c2);
  return a2 && a2[Ha] ? a2.O(b2, c2, p(d) ? !!d.capture : !!d, e3) : ab(a2, b2, c2, false, d, e3);
}
function ab(a2, b2, c2, d, e3, f) {
  if (!b2)
    throw Error("Invalid event type");
  var h = p(e3) ? !!e3.capture : !!e3, n2 = bb(a2);
  n2 || (a2[Va] = n2 = new Sa(a2));
  c2 = n2.add(b2, c2, d, h, f);
  if (c2.proxy)
    return c2;
  d = cb();
  c2.proxy = d;
  d.src = a2;
  d.listener = c2;
  if (a2.addEventListener)
    oa || (e3 = h), void 0 === e3 && (e3 = false), a2.addEventListener(b2.toString(), d, e3);
  else if (a2.attachEvent)
    a2.attachEvent(db(b2.toString()), d);
  else if (a2.addListener && a2.removeListener)
    a2.addListener(d);
  else
    throw Error("addEventListener and attachEvent are unavailable.");
  return c2;
}
function cb() {
  function a2(c2) {
    return b2.call(a2.src, a2.listener, c2);
  }
  const b2 = eb;
  return a2;
}
function Za(a2, b2, c2, d, e3) {
  if (Array.isArray(b2)) {
    for (var f = 0; f < b2.length; f++)
      Za(a2, b2[f], c2, d, e3);
    return null;
  }
  c2 = $a(c2);
  return a2 && a2[Ha] ? a2.P(b2, c2, p(d) ? !!d.capture : !!d, e3) : ab(a2, b2, c2, true, d, e3);
}
function fb(a2, b2, c2, d, e3) {
  if (Array.isArray(b2))
    for (var f = 0; f < b2.length; f++)
      fb(a2, b2[f], c2, d, e3);
  else
    (d = p(d) ? !!d.capture : !!d, c2 = $a(c2), a2 && a2[Ha]) ? (a2 = a2.i, b2 = String(b2).toString(), b2 in a2.g && (f = a2.g[b2], c2 = Ta(f, c2, d, e3), -1 < c2 && (Ma(f[c2]), Array.prototype.splice.call(f, c2, 1), 0 == f.length && (delete a2.g[b2], a2.h--)))) : a2 && (a2 = bb(a2)) && (b2 = a2.g[b2.toString()], a2 = -1, b2 && (a2 = Ta(b2, c2, d, e3)), (c2 = -1 < a2 ? b2[a2] : null) && gb(c2));
}
function gb(a2) {
  if ("number" !== typeof a2 && a2 && !a2.fa) {
    var b2 = a2.src;
    if (b2 && b2[Ha])
      Ua(b2.i, a2);
    else {
      var c2 = a2.type, d = a2.proxy;
      b2.removeEventListener ? b2.removeEventListener(c2, d, a2.capture) : b2.detachEvent ? b2.detachEvent(db(c2), d) : b2.addListener && b2.removeListener && b2.removeListener(d);
      (c2 = bb(b2)) ? (Ua(c2, a2), 0 == c2.h && (c2.src = null, b2[Va] = null)) : Ma(a2);
    }
  }
}
function db(a2) {
  return a2 in Wa ? Wa[a2] : Wa[a2] = "on" + a2;
}
function eb(a2, b2) {
  if (a2.fa)
    a2 = true;
  else {
    b2 = new A(b2, this);
    var c2 = a2.listener, d = a2.la || a2.src;
    a2.ia && gb(a2);
    a2 = c2.call(d, b2);
  }
  return a2;
}
function bb(a2) {
  a2 = a2[Va];
  return a2 instanceof Sa ? a2 : null;
}
function $a(a2) {
  if ("function" === typeof a2)
    return a2;
  a2[hb] || (a2[hb] = function(b2) {
    return a2.handleEvent(b2);
  });
  return a2[hb];
}
function B() {
  v.call(this);
  this.i = new Sa(this);
  this.S = this;
  this.J = null;
}
function C(a2, b2) {
  var c2, d = a2.J;
  if (d)
    for (c2 = []; d; d = d.J)
      c2.push(d);
  a2 = a2.S;
  d = b2.type || b2;
  if ("string" === typeof b2)
    b2 = new w(b2, a2);
  else if (b2 instanceof w)
    b2.target = b2.target || a2;
  else {
    var e3 = b2;
    b2 = new w(d, a2);
    Ra(b2, e3);
  }
  e3 = true;
  if (c2)
    for (var f = c2.length - 1; 0 <= f; f--) {
      var h = b2.g = c2[f];
      e3 = ib(h, d, true, b2) && e3;
    }
  h = b2.g = a2;
  e3 = ib(h, d, true, b2) && e3;
  e3 = ib(h, d, false, b2) && e3;
  if (c2)
    for (f = 0; f < c2.length; f++)
      h = b2.g = c2[f], e3 = ib(h, d, false, b2) && e3;
}
function ib(a2, b2, c2, d) {
  b2 = a2.i.g[String(b2)];
  if (!b2)
    return true;
  b2 = b2.concat();
  for (var e3 = true, f = 0; f < b2.length; ++f) {
    var h = b2[f];
    if (h && !h.fa && h.capture == c2) {
      var n2 = h.listener, t2 = h.la || h.src;
      h.ia && Ua(a2.i, h);
      e3 = false !== n2.call(t2, d) && e3;
    }
  }
  return e3 && !d.defaultPrevented;
}
function lb() {
  var a2 = mb;
  let b2 = null;
  a2.g && (b2 = a2.g, a2.g = a2.g.next, a2.g || (a2.h = null), b2.next = null);
  return b2;
}
function qb(a2) {
  var b2 = 1;
  a2 = a2.split(":");
  const c2 = [];
  for (; 0 < b2 && a2.length; )
    c2.push(a2.shift()), b2--;
  a2.length && c2.push(a2.join(":"));
  return c2;
}
function rb(a2) {
  l.setTimeout(() => {
    throw a2;
  }, 0);
}
function wb(a2, b2) {
  B.call(this);
  this.h = a2 || 1;
  this.g = b2 || l;
  this.j = q(this.qb, this);
  this.l = Date.now();
}
function xb(a2) {
  a2.ga = false;
  a2.T && (a2.g.clearTimeout(a2.T), a2.T = null);
}
function yb(a2, b2, c2) {
  if ("function" === typeof a2)
    c2 && (a2 = q(a2, c2));
  else if (a2 && "function" == typeof a2.handleEvent)
    a2 = q(a2.handleEvent, a2);
  else
    throw Error("Invalid listener argument");
  return 2147483647 < Number(b2) ? -1 : l.setTimeout(a2, b2 || 0);
}
function zb(a2) {
  a2.g = yb(() => {
    a2.g = null;
    a2.i && (a2.i = false, zb(a2));
  }, a2.j);
  const b2 = a2.h;
  a2.h = null;
  a2.m.apply(null, b2);
}
function Bb(a2) {
  v.call(this);
  this.h = a2;
  this.g = {};
}
function Eb(a2, b2, c2, d) {
  Array.isArray(c2) || (c2 && (Cb[0] = c2.toString()), c2 = Cb);
  for (var e3 = 0; e3 < c2.length; e3++) {
    var f = Ya(b2, c2[e3], d || a2.handleEvent, false, a2.h || a2);
    if (!f)
      break;
    a2.g[f.key] = f;
  }
}
function Fb(a2) {
  Na(a2.g, function(b2, c2) {
    this.g.hasOwnProperty(c2) && gb(b2);
  }, a2);
  a2.g = {};
}
function Gb() {
  this.g = true;
}
function Hb(a2, b2, c2, d, e3, f) {
  a2.info(function() {
    if (a2.g)
      if (f) {
        var h = "";
        for (var n2 = f.split("&"), t2 = 0; t2 < n2.length; t2++) {
          var m = n2[t2].split("=");
          if (1 < m.length) {
            var u2 = m[0];
            m = m[1];
            var L2 = u2.split("_");
            h = 2 <= L2.length && "type" == L2[1] ? h + (u2 + "=" + m + "&") : h + (u2 + "=redacted&");
          }
        }
      } else
        h = null;
    else
      h = f;
    return "XMLHTTP REQ (" + d + ") [attempt " + e3 + "]: " + b2 + "\n" + c2 + "\n" + h;
  });
}
function Ib(a2, b2, c2, d, e3, f, h) {
  a2.info(function() {
    return "XMLHTTP RESP (" + d + ") [ attempt " + e3 + "]: " + b2 + "\n" + c2 + "\n" + f + " " + h;
  });
}
function D(a2, b2, c2, d) {
  a2.info(function() {
    return "XMLHTTP TEXT (" + b2 + "): " + Jb(a2, c2) + (d ? " " + d : "");
  });
}
function Kb(a2, b2) {
  a2.info(function() {
    return "TIMEOUT: " + b2;
  });
}
function Jb(a2, b2) {
  if (!a2.g)
    return b2;
  if (!b2)
    return null;
  try {
    var c2 = JSON.parse(b2);
    if (c2) {
      for (a2 = 0; a2 < c2.length; a2++)
        if (Array.isArray(c2[a2])) {
          var d = c2[a2];
          if (!(2 > d.length)) {
            var e3 = d[1];
            if (Array.isArray(e3) && !(1 > e3.length)) {
              var f = e3[0];
              if ("noop" != f && "stop" != f && "close" != f)
                for (var h = 1; h < e3.length; h++)
                  e3[h] = "";
            }
          }
        }
    }
    return jb(c2);
  } catch (n2) {
    return b2;
  }
}
function Mb() {
  return Lb = Lb || new B();
}
function Nb(a2) {
  w.call(this, E.Ta, a2);
}
function Ob(a2) {
  const b2 = Mb();
  C(b2, new Nb(b2));
}
function Pb(a2, b2) {
  w.call(this, E.STAT_EVENT, a2);
  this.stat = b2;
}
function F(a2) {
  const b2 = Mb();
  C(b2, new Pb(b2, a2));
}
function Qb(a2, b2) {
  w.call(this, E.Ua, a2);
  this.size = b2;
}
function Rb(a2, b2) {
  if ("function" !== typeof a2)
    throw Error("Fn must not be null and must be a function");
  return l.setTimeout(function() {
    a2();
  }, b2);
}
function Ub() {
}
function Vb(a2) {
  return a2.h || (a2.h = a2.i());
}
function Wb() {
}
function Yb() {
  w.call(this, "d");
}
function Zb() {
  w.call(this, "c");
}
function ac() {
}
function bc(a2, b2, c2, d) {
  this.l = a2;
  this.j = b2;
  this.m = c2;
  this.W = d || 1;
  this.U = new Bb(this);
  this.P = cc;
  a2 = va ? 125 : void 0;
  this.V = new wb(a2);
  this.I = null;
  this.i = false;
  this.u = this.B = this.A = this.L = this.G = this.Y = this.C = null;
  this.F = [];
  this.g = null;
  this.o = 0;
  this.s = this.v = null;
  this.ca = -1;
  this.J = false;
  this.O = 0;
  this.M = null;
  this.ba = this.K = this.aa = this.S = false;
  this.h = new dc();
}
function dc() {
  this.i = null;
  this.g = "";
  this.h = false;
}
function gc(a2, b2, c2) {
  a2.L = 1;
  a2.A = hc(G(b2));
  a2.u = c2;
  a2.S = true;
  ic(a2, null);
}
function ic(a2, b2) {
  a2.G = Date.now();
  jc(a2);
  a2.B = G(a2.A);
  var c2 = a2.B, d = a2.W;
  Array.isArray(d) || (d = [String(d)]);
  kc(c2.i, "t", d);
  a2.o = 0;
  c2 = a2.l.J;
  a2.h = new dc();
  a2.g = lc(a2.l, c2 ? b2 : null, !a2.u);
  0 < a2.O && (a2.M = new Ab(q(a2.Pa, a2, a2.g), a2.O));
  Eb(a2.U, a2.g, "readystatechange", a2.nb);
  b2 = a2.I ? Pa(a2.I) : {};
  a2.u ? (a2.v || (a2.v = "POST"), b2["Content-Type"] = "application/x-www-form-urlencoded", a2.g.ha(a2.B, a2.v, a2.u, b2)) : (a2.v = "GET", a2.g.ha(a2.B, a2.v, null, b2));
  Ob();
  Hb(a2.j, a2.v, a2.B, a2.m, a2.W, a2.u);
}
function oc(a2) {
  return a2.g ? "GET" == a2.v && 2 != a2.L && a2.l.Ha : false;
}
function rc(a2, b2, c2) {
  let d = true, e3;
  for (; !a2.J && a2.o < c2.length; )
    if (e3 = uc(a2, c2), e3 == fc) {
      4 == b2 && (a2.s = 4, F(14), d = false);
      D(a2.j, a2.m, null, "[Incomplete Response]");
      break;
    } else if (e3 == ec) {
      a2.s = 4;
      F(15);
      D(a2.j, a2.m, c2, "[Invalid Chunk]");
      d = false;
      break;
    } else
      D(a2.j, a2.m, e3, null), qc(a2, e3);
  oc(a2) && 0 != a2.o && (a2.h.g = a2.h.g.slice(a2.o), a2.o = 0);
  4 != b2 || 0 != c2.length || a2.h.h || (a2.s = 1, F(16), d = false);
  a2.i = a2.i && d;
  d ? 0 < c2.length && !a2.ba && (a2.ba = true, b2 = a2.l, b2.g == a2 && b2.ca && !b2.M && (b2.l.info("Great, no buffering proxy detected. Bytes received: " + c2.length), vc(b2), b2.M = true, F(11))) : (D(
    a2.j,
    a2.m,
    c2,
    "[Invalid Chunked Response]"
  ), I(a2), pc(a2));
}
function uc(a2, b2) {
  var c2 = a2.o, d = b2.indexOf("\n", c2);
  if (-1 == d)
    return fc;
  c2 = Number(b2.substring(c2, d));
  if (isNaN(c2))
    return ec;
  d += 1;
  if (d + c2 > b2.length)
    return fc;
  b2 = b2.slice(d, d + c2);
  a2.o = d + c2;
  return b2;
}
function jc(a2) {
  a2.Y = Date.now() + a2.P;
  wc(a2, a2.P);
}
function wc(a2, b2) {
  if (null != a2.C)
    throw Error("WatchDog timer not null");
  a2.C = Rb(q(a2.lb, a2), b2);
}
function nc(a2) {
  a2.C && (l.clearTimeout(a2.C), a2.C = null);
}
function pc(a2) {
  0 == a2.l.H || a2.J || sc(a2.l, a2);
}
function I(a2) {
  nc(a2);
  var b2 = a2.M;
  b2 && "function" == typeof b2.sa && b2.sa();
  a2.M = null;
  xb(a2.V);
  Fb(a2.U);
  a2.g && (b2 = a2.g, a2.g = null, b2.abort(), b2.sa());
}
function qc(a2, b2) {
  try {
    var c2 = a2.l;
    if (0 != c2.H && (c2.g == a2 || xc(c2.i, a2))) {
      if (!a2.K && xc(c2.i, a2) && 3 == c2.H) {
        try {
          var d = c2.Ja.g.parse(b2);
        } catch (m) {
          d = null;
        }
        if (Array.isArray(d) && 3 == d.length) {
          var e3 = d;
          if (0 == e3[0])
            a: {
              if (!c2.u) {
                if (c2.g)
                  if (c2.g.G + 3e3 < a2.G)
                    yc(c2), zc(c2);
                  else
                    break a;
                Ac(c2);
                F(18);
              }
            }
          else
            c2.Fa = e3[1], 0 < c2.Fa - c2.V && 37500 > e3[2] && c2.G && 0 == c2.A && !c2.v && (c2.v = Rb(q(c2.ib, c2), 6e3));
          if (1 >= Bc(c2.i) && c2.oa) {
            try {
              c2.oa();
            } catch (m) {
            }
            c2.oa = void 0;
          }
        } else
          J(c2, 11);
      } else if ((a2.K || c2.g == a2) && yc(c2), !x(b2))
        for (e3 = c2.Ja.g.parse(b2), b2 = 0; b2 < e3.length; b2++) {
          let m = e3[b2];
          c2.V = m[0];
          m = m[1];
          if (2 == c2.H)
            if ("c" == m[0]) {
              c2.K = m[1];
              c2.pa = m[2];
              const u2 = m[3];
              null != u2 && (c2.ra = u2, c2.l.info("VER=" + c2.ra));
              const L2 = m[4];
              null != L2 && (c2.Ga = L2, c2.l.info("SVER=" + c2.Ga));
              const Ka = m[5];
              null != Ka && "number" === typeof Ka && 0 < Ka && (d = 1.5 * Ka, c2.L = d, c2.l.info("backChannelRequestTimeoutMs_=" + d));
              d = c2;
              const la = a2.g;
              if (la) {
                const La = la.g ? la.g.getResponseHeader("X-Client-Wire-Protocol") : null;
                if (La) {
                  var f = d.i;
                  f.g || -1 == La.indexOf("spdy") && -1 == La.indexOf("quic") && -1 == La.indexOf("h2") || (f.j = f.l, f.g = /* @__PURE__ */ new Set(), f.h && (Cc(f, f.h), f.h = null));
                }
                if (d.F) {
                  const Db = la.g ? la.g.getResponseHeader("X-HTTP-Session-Id") : null;
                  Db && (d.Da = Db, K(d.I, d.F, Db));
                }
              }
              c2.H = 3;
              c2.h && c2.h.Ba();
              c2.ca && (c2.S = Date.now() - a2.G, c2.l.info("Handshake RTT: " + c2.S + "ms"));
              d = c2;
              var h = a2;
              d.wa = Dc(d, d.J ? d.pa : null, d.Y);
              if (h.K) {
                Ec(d.i, h);
                var n2 = h, t2 = d.L;
                t2 && n2.setTimeout(t2);
                n2.C && (nc(n2), jc(n2));
                d.g = h;
              } else
                Fc(d);
              0 < c2.j.length && Gc(c2);
            } else
              "stop" != m[0] && "close" != m[0] || J(c2, 7);
          else
            3 == c2.H && ("stop" == m[0] || "close" == m[0] ? "stop" == m[0] ? J(c2, 7) : Hc(c2) : "noop" != m[0] && c2.h && c2.h.Aa(m), c2.A = 0);
        }
    }
    Ob(4);
  } catch (m) {
  }
}
function Ic(a2) {
  if (a2.Z && "function" == typeof a2.Z)
    return a2.Z();
  if ("undefined" !== typeof Map && a2 instanceof Map || "undefined" !== typeof Set && a2 instanceof Set)
    return Array.from(a2.values());
  if ("string" === typeof a2)
    return a2.split("");
  if (aa(a2)) {
    for (var b2 = [], c2 = a2.length, d = 0; d < c2; d++)
      b2.push(a2[d]);
    return b2;
  }
  b2 = [];
  c2 = 0;
  for (d in a2)
    b2[c2++] = a2[d];
  return b2;
}
function Jc(a2) {
  if (a2.ta && "function" == typeof a2.ta)
    return a2.ta();
  if (!a2.Z || "function" != typeof a2.Z) {
    if ("undefined" !== typeof Map && a2 instanceof Map)
      return Array.from(a2.keys());
    if (!("undefined" !== typeof Set && a2 instanceof Set)) {
      if (aa(a2) || "string" === typeof a2) {
        var b2 = [];
        a2 = a2.length;
        for (var c2 = 0; c2 < a2; c2++)
          b2.push(c2);
        return b2;
      }
      b2 = [];
      c2 = 0;
      for (const d in a2)
        b2[c2++] = d;
      return b2;
    }
  }
}
function Kc(a2, b2) {
  if (a2.forEach && "function" == typeof a2.forEach)
    a2.forEach(b2, void 0);
  else if (aa(a2) || "string" === typeof a2)
    Array.prototype.forEach.call(a2, b2, void 0);
  else
    for (var c2 = Jc(a2), d = Ic(a2), e3 = d.length, f = 0; f < e3; f++)
      b2.call(void 0, d[f], c2 && c2[f], a2);
}
function Mc(a2, b2) {
  if (a2) {
    a2 = a2.split("&");
    for (var c2 = 0; c2 < a2.length; c2++) {
      var d = a2[c2].indexOf("="), e3 = null;
      if (0 <= d) {
        var f = a2[c2].substring(0, d);
        e3 = a2[c2].substring(d + 1);
      } else
        f = a2[c2];
      b2(f, e3 ? decodeURIComponent(e3.replace(/\+/g, " ")) : "");
    }
  }
}
function M(a2) {
  this.g = this.s = this.j = "";
  this.m = null;
  this.o = this.l = "";
  this.h = false;
  if (a2 instanceof M) {
    this.h = a2.h;
    Nc(this, a2.j);
    this.s = a2.s;
    this.g = a2.g;
    Oc(this, a2.m);
    this.l = a2.l;
    var b2 = a2.i;
    var c2 = new Pc();
    c2.i = b2.i;
    b2.g && (c2.g = new Map(b2.g), c2.h = b2.h);
    Qc(this, c2);
    this.o = a2.o;
  } else
    a2 && (b2 = String(a2).match(Lc)) ? (this.h = false, Nc(this, b2[1] || "", true), this.s = Rc(b2[2] || ""), this.g = Rc(b2[3] || "", true), Oc(this, b2[4]), this.l = Rc(b2[5] || "", true), Qc(this, b2[6] || "", true), this.o = Rc(b2[7] || "")) : (this.h = false, this.i = new Pc(null, this.h));
}
function G(a2) {
  return new M(a2);
}
function Nc(a2, b2, c2) {
  a2.j = c2 ? Rc(b2, true) : b2;
  a2.j && (a2.j = a2.j.replace(/:$/, ""));
}
function Oc(a2, b2) {
  if (b2) {
    b2 = Number(b2);
    if (isNaN(b2) || 0 > b2)
      throw Error("Bad port number " + b2);
    a2.m = b2;
  } else
    a2.m = null;
}
function Qc(a2, b2, c2) {
  b2 instanceof Pc ? (a2.i = b2, Xc(a2.i, a2.h)) : (c2 || (b2 = Sc(b2, Yc)), a2.i = new Pc(b2, a2.h));
}
function K(a2, b2, c2) {
  a2.i.set(b2, c2);
}
function hc(a2) {
  K(a2, "zx", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ Date.now()).toString(36));
  return a2;
}
function Rc(a2, b2) {
  return a2 ? b2 ? decodeURI(a2.replace(/%25/g, "%2525")) : decodeURIComponent(a2) : "";
}
function Sc(a2, b2, c2) {
  return "string" === typeof a2 ? (a2 = encodeURI(a2).replace(b2, Zc), c2 && (a2 = a2.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), a2) : null;
}
function Zc(a2) {
  a2 = a2.charCodeAt(0);
  return "%" + (a2 >> 4 & 15).toString(16) + (a2 & 15).toString(16);
}
function Pc(a2, b2) {
  this.h = this.g = null;
  this.i = a2 || null;
  this.j = !!b2;
}
function N(a2) {
  a2.g || (a2.g = /* @__PURE__ */ new Map(), a2.h = 0, a2.i && Mc(a2.i, function(b2, c2) {
    a2.add(decodeURIComponent(b2.replace(/\+/g, " ")), c2);
  }));
}
function $c(a2, b2) {
  N(a2);
  b2 = O(a2, b2);
  a2.g.has(b2) && (a2.i = null, a2.h -= a2.g.get(b2).length, a2.g.delete(b2));
}
function ad(a2, b2) {
  N(a2);
  b2 = O(a2, b2);
  return a2.g.has(b2);
}
function kc(a2, b2, c2) {
  $c(a2, b2);
  0 < c2.length && (a2.i = null, a2.g.set(O(a2, b2), ma(c2)), a2.h += c2.length);
}
function O(a2, b2) {
  b2 = String(b2);
  a2.j && (b2 = b2.toLowerCase());
  return b2;
}
function Xc(a2, b2) {
  b2 && !a2.j && (N(a2), a2.i = null, a2.g.forEach(function(c2, d) {
    var e3 = d.toLowerCase();
    d != e3 && ($c(this, d), kc(this, e3, c2));
  }, a2));
  a2.j = b2;
}
function cd(a2) {
  this.l = a2 || dd;
  l.PerformanceNavigationTiming ? (a2 = l.performance.getEntriesByType("navigation"), a2 = 0 < a2.length && ("hq" == a2[0].nextHopProtocol || "h2" == a2[0].nextHopProtocol)) : a2 = !!(l.g && l.g.Ka && l.g.Ka() && l.g.Ka().dc);
  this.j = a2 ? this.l : 1;
  this.g = null;
  1 < this.j && (this.g = /* @__PURE__ */ new Set());
  this.h = null;
  this.i = [];
}
function ed(a2) {
  return a2.h ? true : a2.g ? a2.g.size >= a2.j : false;
}
function Bc(a2) {
  return a2.h ? 1 : a2.g ? a2.g.size : 0;
}
function xc(a2, b2) {
  return a2.h ? a2.h == b2 : a2.g ? a2.g.has(b2) : false;
}
function Cc(a2, b2) {
  a2.g ? a2.g.add(b2) : a2.h = b2;
}
function Ec(a2, b2) {
  a2.h && a2.h == b2 ? a2.h = null : a2.g && a2.g.has(b2) && a2.g.delete(b2);
}
function fd(a2) {
  if (null != a2.h)
    return a2.i.concat(a2.h.F);
  if (null != a2.g && 0 !== a2.g.size) {
    let b2 = a2.i;
    for (const c2 of a2.g.values())
      b2 = b2.concat(c2.F);
    return b2;
  }
  return ma(a2.i);
}
function hd() {
  this.g = new gd();
}
function id(a2, b2, c2) {
  const d = c2 || "";
  try {
    Kc(a2, function(e3, f) {
      let h = e3;
      p(e3) && (h = jb(e3));
      b2.push(d + f + "=" + encodeURIComponent(h));
    });
  } catch (e3) {
    throw b2.push(d + "type=" + encodeURIComponent("_badmap")), e3;
  }
}
function jd(a2, b2) {
  const c2 = new Gb();
  if (l.Image) {
    const d = new Image();
    d.onload = ha(kd, c2, d, "TestLoadImage: loaded", true, b2);
    d.onerror = ha(kd, c2, d, "TestLoadImage: error", false, b2);
    d.onabort = ha(kd, c2, d, "TestLoadImage: abort", false, b2);
    d.ontimeout = ha(kd, c2, d, "TestLoadImage: timeout", false, b2);
    l.setTimeout(function() {
      if (d.ontimeout)
        d.ontimeout();
    }, 1e4);
    d.src = a2;
  } else
    b2(false);
}
function kd(a2, b2, c2, d, e3) {
  try {
    b2.onload = null, b2.onerror = null, b2.onabort = null, b2.ontimeout = null, e3(d);
  } catch (f) {
  }
}
function ld(a2) {
  this.l = a2.ec || null;
  this.j = a2.ob || false;
}
function md(a2, b2) {
  B.call(this);
  this.F = a2;
  this.u = b2;
  this.m = void 0;
  this.readyState = nd;
  this.status = 0;
  this.responseType = this.responseText = this.response = this.statusText = "";
  this.onreadystatechange = null;
  this.v = new Headers();
  this.h = null;
  this.C = "GET";
  this.B = "";
  this.g = false;
  this.A = this.j = this.l = null;
}
function qd(a2) {
  a2.j.read().then(a2.Xa.bind(a2)).catch(a2.ka.bind(a2));
}
function pd(a2) {
  a2.readyState = 4;
  a2.l = null;
  a2.j = null;
  a2.A = null;
  od(a2);
}
function od(a2) {
  a2.onreadystatechange && a2.onreadystatechange.call(a2);
}
function P(a2) {
  B.call(this);
  this.headers = /* @__PURE__ */ new Map();
  this.u = a2 || null;
  this.h = false;
  this.C = this.g = null;
  this.I = "";
  this.m = 0;
  this.j = "";
  this.l = this.G = this.v = this.F = false;
  this.B = 0;
  this.A = null;
  this.K = sd;
  this.L = this.M = false;
}
function xd(a2) {
  return z && "number" === typeof a2.timeout && void 0 !== a2.ontimeout;
}
function vd(a2, b2) {
  a2.h = false;
  a2.g && (a2.l = true, a2.g.abort(), a2.l = false);
  a2.j = b2;
  a2.m = 5;
  yd(a2);
  zd(a2);
}
function yd(a2) {
  a2.F || (a2.F = true, C(a2, "complete"), C(a2, "error"));
}
function Ad(a2) {
  if (a2.h && "undefined" != typeof goog && (!a2.C[1] || 4 != H(a2) || 2 != a2.da())) {
    if (a2.v && 4 == H(a2))
      yb(a2.La, 0, a2);
    else if (C(a2, "readystatechange"), 4 == H(a2)) {
      a2.h = false;
      try {
        const h = a2.da();
        a:
          switch (h) {
            case 200:
            case 201:
            case 202:
            case 204:
            case 206:
            case 304:
            case 1223:
              var b2 = true;
              break a;
            default:
              b2 = false;
          }
        var c2;
        if (!(c2 = b2)) {
          var d;
          if (d = 0 === h) {
            var e3 = String(a2.I).match(Lc)[1] || null;
            !e3 && l.self && l.self.location && (e3 = l.self.location.protocol.slice(0, -1));
            d = !td.test(e3 ? e3.toLowerCase() : "");
          }
          c2 = d;
        }
        if (c2)
          C(a2, "complete"), C(a2, "success");
        else {
          a2.m = 6;
          try {
            var f = 2 < H(a2) ? a2.g.statusText : "";
          } catch (n2) {
            f = "";
          }
          a2.j = f + " [" + a2.da() + "]";
          yd(a2);
        }
      } finally {
        zd(a2);
      }
    }
  }
}
function zd(a2, b2) {
  if (a2.g) {
    wd(a2);
    const c2 = a2.g, d = a2.C[0] ? () => {
    } : null;
    a2.g = null;
    a2.C = null;
    b2 || C(a2, "ready");
    try {
      c2.onreadystatechange = d;
    } catch (e3) {
    }
  }
}
function wd(a2) {
  a2.g && a2.L && (a2.g.ontimeout = null);
  a2.A && (l.clearTimeout(a2.A), a2.A = null);
}
function H(a2) {
  return a2.g ? a2.g.readyState : 0;
}
function mc(a2) {
  try {
    if (!a2.g)
      return null;
    if ("response" in a2.g)
      return a2.g.response;
    switch (a2.K) {
      case sd:
      case "text":
        return a2.g.responseText;
      case "arraybuffer":
        if ("mozResponseArrayBuffer" in a2.g)
          return a2.g.mozResponseArrayBuffer;
    }
    return null;
  } catch (b2) {
    return null;
  }
}
function tc(a2) {
  const b2 = {};
  a2 = (a2.g && 2 <= H(a2) ? a2.g.getAllResponseHeaders() || "" : "").split("\r\n");
  for (let d = 0; d < a2.length; d++) {
    if (x(a2[d]))
      continue;
    var c2 = qb(a2[d]);
    const e3 = c2[0];
    c2 = c2[1];
    if ("string" !== typeof c2)
      continue;
    c2 = c2.trim();
    const f = b2[e3] || [];
    b2[e3] = f;
    f.push(c2);
  }
  Oa(b2, function(d) {
    return d.join(", ");
  });
}
function Bd(a2) {
  let b2 = "";
  Na(a2, function(c2, d) {
    b2 += d;
    b2 += ":";
    b2 += c2;
    b2 += "\r\n";
  });
  return b2;
}
function Cd(a2, b2, c2) {
  a: {
    for (d in c2) {
      var d = false;
      break a;
    }
    d = true;
  }
  d || (c2 = Bd(c2), "string" === typeof a2 ? null != c2 && encodeURIComponent(String(c2)) : K(a2, b2, c2));
}
function Dd(a2, b2, c2) {
  return c2 && c2.internalChannelParams ? c2.internalChannelParams[a2] || b2 : b2;
}
function Ed(a2) {
  this.Ga = 0;
  this.j = [];
  this.l = new Gb();
  this.pa = this.wa = this.I = this.Y = this.g = this.Da = this.F = this.na = this.o = this.U = this.s = null;
  this.fb = this.W = 0;
  this.cb = Dd("failFast", false, a2);
  this.G = this.v = this.u = this.m = this.h = null;
  this.aa = true;
  this.Fa = this.V = -1;
  this.ba = this.A = this.C = 0;
  this.ab = Dd("baseRetryDelayMs", 5e3, a2);
  this.hb = Dd("retryDelaySeedMs", 1e4, a2);
  this.eb = Dd("forwardChannelMaxRetries", 2, a2);
  this.xa = Dd("forwardChannelRequestTimeoutMs", 2e4, a2);
  this.va = a2 && a2.xmlHttpFactory || void 0;
  this.Ha = a2 && a2.useFetchStreams || false;
  this.L = void 0;
  this.J = a2 && a2.supportsCrossDomainXhr || false;
  this.K = "";
  this.i = new cd(a2 && a2.concurrentRequestLimit);
  this.Ja = new hd();
  this.P = a2 && a2.fastHandshake || false;
  this.O = a2 && a2.encodeInitMessageHeaders || false;
  this.P && this.O && (this.O = false);
  this.bb = a2 && a2.bc || false;
  a2 && a2.Ea && this.l.Ea();
  a2 && a2.forceLongPolling && (this.aa = false);
  this.ca = !this.P && this.aa && a2 && a2.detectBufferingProxy || false;
  this.qa = void 0;
  a2 && a2.longPollingTimeout && 0 < a2.longPollingTimeout && (this.qa = a2.longPollingTimeout);
  this.oa = void 0;
  this.S = 0;
  this.M = false;
  this.ma = this.B = null;
}
function Hc(a2) {
  Fd(a2);
  if (3 == a2.H) {
    var b2 = a2.W++, c2 = G(a2.I);
    K(c2, "SID", a2.K);
    K(c2, "RID", b2);
    K(c2, "TYPE", "terminate");
    Gd(a2, c2);
    b2 = new bc(a2, a2.l, b2);
    b2.L = 2;
    b2.A = hc(G(c2));
    c2 = false;
    if (l.navigator && l.navigator.sendBeacon)
      try {
        c2 = l.navigator.sendBeacon(b2.A.toString(), "");
      } catch (d) {
      }
    !c2 && l.Image && (new Image().src = b2.A, c2 = true);
    c2 || (b2.g = lc(b2.l, null), b2.g.ha(b2.A));
    b2.G = Date.now();
    jc(b2);
  }
  Hd(a2);
}
function zc(a2) {
  a2.g && (vc(a2), a2.g.cancel(), a2.g = null);
}
function Fd(a2) {
  zc(a2);
  a2.u && (l.clearTimeout(a2.u), a2.u = null);
  yc(a2);
  a2.i.cancel();
  a2.m && ("number" === typeof a2.m && l.clearTimeout(a2.m), a2.m = null);
}
function Gc(a2) {
  if (!ed(a2.i) && !a2.m) {
    a2.m = true;
    var b2 = a2.Na;
    sb || vb();
    tb || (sb(), tb = true);
    mb.add(b2, a2);
    a2.C = 0;
  }
}
function Id(a2, b2) {
  if (Bc(a2.i) >= a2.i.j - (a2.m ? 1 : 0))
    return false;
  if (a2.m)
    return a2.j = b2.F.concat(a2.j), true;
  if (1 == a2.H || 2 == a2.H || a2.C >= (a2.cb ? 0 : a2.eb))
    return false;
  a2.m = Rb(q(a2.Na, a2, b2), Jd(a2, a2.C));
  a2.C++;
  return true;
}
function Ld(a2, b2) {
  var c2;
  b2 ? c2 = b2.m : c2 = a2.W++;
  const d = G(a2.I);
  K(d, "SID", a2.K);
  K(d, "RID", c2);
  K(d, "AID", a2.V);
  Gd(a2, d);
  a2.o && a2.s && Cd(d, a2.o, a2.s);
  c2 = new bc(a2, a2.l, c2, a2.C + 1);
  null === a2.o && (c2.I = a2.s);
  b2 && (a2.j = b2.F.concat(a2.j));
  b2 = Kd(a2, c2, 1e3);
  c2.setTimeout(Math.round(0.5 * a2.xa) + Math.round(0.5 * a2.xa * Math.random()));
  Cc(a2.i, c2);
  gc(c2, d, b2);
}
function Gd(a2, b2) {
  a2.na && Na(a2.na, function(c2, d) {
    K(b2, d, c2);
  });
  a2.h && Kc({}, function(c2, d) {
    K(b2, d, c2);
  });
}
function Kd(a2, b2, c2) {
  c2 = Math.min(a2.j.length, c2);
  var d = a2.h ? q(a2.h.Va, a2.h, a2) : null;
  a: {
    var e3 = a2.j;
    let f = -1;
    for (; ; ) {
      const h = ["count=" + c2];
      -1 == f ? 0 < c2 ? (f = e3[0].g, h.push("ofs=" + f)) : f = 0 : h.push("ofs=" + f);
      let n2 = true;
      for (let t2 = 0; t2 < c2; t2++) {
        let m = e3[t2].g;
        const u2 = e3[t2].map;
        m -= f;
        if (0 > m)
          f = Math.max(0, e3[t2].g - 100), n2 = false;
        else
          try {
            id(u2, h, "req" + m + "_");
          } catch (L2) {
            d && d(u2);
          }
      }
      if (n2) {
        d = h.join("&");
        break a;
      }
    }
  }
  a2 = a2.j.splice(0, c2);
  b2.F = a2;
  return d;
}
function Fc(a2) {
  if (!a2.g && !a2.u) {
    a2.ba = 1;
    var b2 = a2.Ma;
    sb || vb();
    tb || (sb(), tb = true);
    mb.add(b2, a2);
    a2.A = 0;
  }
}
function Ac(a2) {
  if (a2.g || a2.u || 3 <= a2.A)
    return false;
  a2.ba++;
  a2.u = Rb(q(a2.Ma, a2), Jd(a2, a2.A));
  a2.A++;
  return true;
}
function vc(a2) {
  null != a2.B && (l.clearTimeout(a2.B), a2.B = null);
}
function Md(a2) {
  a2.g = new bc(a2, a2.l, "rpc", a2.ba);
  null === a2.o && (a2.g.I = a2.s);
  a2.g.O = 0;
  var b2 = G(a2.wa);
  K(b2, "RID", "rpc");
  K(b2, "SID", a2.K);
  K(b2, "AID", a2.V);
  K(b2, "CI", a2.G ? "0" : "1");
  !a2.G && a2.qa && K(b2, "TO", a2.qa);
  K(b2, "TYPE", "xmlhttp");
  Gd(a2, b2);
  a2.o && a2.s && Cd(b2, a2.o, a2.s);
  a2.L && a2.g.setTimeout(a2.L);
  var c2 = a2.g;
  a2 = a2.pa;
  c2.L = 1;
  c2.A = hc(G(b2));
  c2.u = null;
  c2.S = true;
  ic(c2, a2);
}
function yc(a2) {
  null != a2.v && (l.clearTimeout(a2.v), a2.v = null);
}
function sc(a2, b2) {
  var c2 = null;
  if (a2.g == b2) {
    yc(a2);
    vc(a2);
    a2.g = null;
    var d = 2;
  } else if (xc(a2.i, b2))
    c2 = b2.F, Ec(a2.i, b2), d = 1;
  else
    return;
  if (0 != a2.H) {
    if (b2.i)
      if (1 == d) {
        c2 = b2.u ? b2.u.length : 0;
        b2 = Date.now() - b2.G;
        var e3 = a2.C;
        d = Mb();
        C(d, new Qb(d, c2));
        Gc(a2);
      } else
        Fc(a2);
    else if (e3 = b2.s, 3 == e3 || 0 == e3 && 0 < b2.ca || !(1 == d && Id(a2, b2) || 2 == d && Ac(a2)))
      switch (c2 && 0 < c2.length && (b2 = a2.i, b2.i = b2.i.concat(c2)), e3) {
        case 1:
          J(a2, 5);
          break;
        case 4:
          J(a2, 10);
          break;
        case 3:
          J(a2, 6);
          break;
        default:
          J(a2, 2);
      }
  }
}
function Jd(a2, b2) {
  let c2 = a2.ab + Math.floor(Math.random() * a2.hb);
  a2.isActive() || (c2 *= 2);
  return c2 * b2;
}
function J(a2, b2) {
  a2.l.info("Error code " + b2);
  if (2 == b2) {
    var c2 = null;
    a2.h && (c2 = null);
    var d = q(a2.pb, a2);
    c2 || (c2 = new M("//www.google.com/images/cleardot.gif"), l.location && "http" == l.location.protocol || Nc(c2, "https"), hc(c2));
    jd(c2.toString(), d);
  } else
    F(2);
  a2.H = 0;
  a2.h && a2.h.za(b2);
  Hd(a2);
  Fd(a2);
}
function Hd(a2) {
  a2.H = 0;
  a2.ma = [];
  if (a2.h) {
    const b2 = fd(a2.i);
    if (0 != b2.length || 0 != a2.j.length)
      na(a2.ma, b2), na(a2.ma, a2.j), a2.i.i.length = 0, ma(a2.j), a2.j.length = 0;
    a2.h.ya();
  }
}
function Dc(a2, b2, c2) {
  var d = c2 instanceof M ? G(c2) : new M(c2);
  if ("" != d.g)
    b2 && (d.g = b2 + "." + d.g), Oc(d, d.m);
  else {
    var e3 = l.location;
    d = e3.protocol;
    b2 = b2 ? b2 + "." + e3.hostname : e3.hostname;
    e3 = +e3.port;
    var f = new M(null);
    d && Nc(f, d);
    b2 && (f.g = b2);
    e3 && Oc(f, e3);
    c2 && (f.l = c2);
    d = f;
  }
  c2 = a2.F;
  b2 = a2.Da;
  c2 && b2 && K(d, c2, b2);
  K(d, "VER", a2.ra);
  Gd(a2, d);
  return d;
}
function lc(a2, b2, c2) {
  if (b2 && !a2.J)
    throw Error("Can't create secondary domain capable XhrIo object.");
  b2 = a2.Ha && !a2.va ? new P(new ld({ ob: c2 })) : new P(a2.va);
  b2.Oa(a2.J);
  return b2;
}
function Nd() {
}
function Od() {
  if (z && !(10 <= Number(Fa)))
    throw Error("Environmental error: no available transport.");
}
function Q(a2, b2) {
  B.call(this);
  this.g = new Ed(b2);
  this.l = a2;
  this.h = b2 && b2.messageUrlParams || null;
  a2 = b2 && b2.messageHeaders || null;
  b2 && b2.clientProtocolHeaderRequired && (a2 ? a2["X-Client-Protocol"] = "webchannel" : a2 = { "X-Client-Protocol": "webchannel" });
  this.g.s = a2;
  a2 = b2 && b2.initMessageHeaders || null;
  b2 && b2.messageContentType && (a2 ? a2["X-WebChannel-Content-Type"] = b2.messageContentType : a2 = { "X-WebChannel-Content-Type": b2.messageContentType });
  b2 && b2.Ca && (a2 ? a2["X-WebChannel-Client-Profile"] = b2.Ca : a2 = { "X-WebChannel-Client-Profile": b2.Ca });
  this.g.U = a2;
  (a2 = b2 && b2.cc) && !x(a2) && (this.g.o = a2);
  this.A = b2 && b2.supportsCrossDomainXhr || false;
  this.v = b2 && b2.sendRawJson || false;
  (b2 = b2 && b2.httpSessionIdParam) && !x(b2) && (this.g.F = b2, a2 = this.h, null !== a2 && b2 in a2 && (a2 = this.h, b2 in a2 && delete a2[b2]));
  this.j = new R(this);
}
function Pd(a2) {
  Yb.call(this);
  a2.__headers__ && (this.headers = a2.__headers__, this.statusCode = a2.__status__, delete a2.__headers__, delete a2.__status__);
  var b2 = a2.__sm__;
  if (b2) {
    a: {
      for (const c2 in b2) {
        a2 = c2;
        break a;
      }
      a2 = void 0;
    }
    if (this.i = a2)
      a2 = this.i, b2 = null !== b2 && a2 in b2 ? b2[a2] : void 0;
    this.data = b2;
  } else
    this.data = a2;
}
function Qd() {
  Zb.call(this);
  this.status = 1;
}
function R(a2) {
  this.g = a2;
}
function Rd() {
  this.blockSize = -1;
}
function S() {
  this.blockSize = -1;
  this.blockSize = 64;
  this.g = Array(4);
  this.m = Array(this.blockSize);
  this.i = this.h = 0;
  this.reset();
}
function Sd(a2, b2, c2) {
  c2 || (c2 = 0);
  var d = Array(16);
  if ("string" === typeof b2)
    for (var e3 = 0; 16 > e3; ++e3)
      d[e3] = b2.charCodeAt(c2++) | b2.charCodeAt(c2++) << 8 | b2.charCodeAt(c2++) << 16 | b2.charCodeAt(c2++) << 24;
  else
    for (e3 = 0; 16 > e3; ++e3)
      d[e3] = b2[c2++] | b2[c2++] << 8 | b2[c2++] << 16 | b2[c2++] << 24;
  b2 = a2.g[0];
  c2 = a2.g[1];
  e3 = a2.g[2];
  var f = a2.g[3];
  var h = b2 + (f ^ c2 & (e3 ^ f)) + d[0] + 3614090360 & 4294967295;
  b2 = c2 + (h << 7 & 4294967295 | h >>> 25);
  h = f + (e3 ^ b2 & (c2 ^ e3)) + d[1] + 3905402710 & 4294967295;
  f = b2 + (h << 12 & 4294967295 | h >>> 20);
  h = e3 + (c2 ^ f & (b2 ^ c2)) + d[2] + 606105819 & 4294967295;
  e3 = f + (h << 17 & 4294967295 | h >>> 15);
  h = c2 + (b2 ^ e3 & (f ^ b2)) + d[3] + 3250441966 & 4294967295;
  c2 = e3 + (h << 22 & 4294967295 | h >>> 10);
  h = b2 + (f ^ c2 & (e3 ^ f)) + d[4] + 4118548399 & 4294967295;
  b2 = c2 + (h << 7 & 4294967295 | h >>> 25);
  h = f + (e3 ^ b2 & (c2 ^ e3)) + d[5] + 1200080426 & 4294967295;
  f = b2 + (h << 12 & 4294967295 | h >>> 20);
  h = e3 + (c2 ^ f & (b2 ^ c2)) + d[6] + 2821735955 & 4294967295;
  e3 = f + (h << 17 & 4294967295 | h >>> 15);
  h = c2 + (b2 ^ e3 & (f ^ b2)) + d[7] + 4249261313 & 4294967295;
  c2 = e3 + (h << 22 & 4294967295 | h >>> 10);
  h = b2 + (f ^ c2 & (e3 ^ f)) + d[8] + 1770035416 & 4294967295;
  b2 = c2 + (h << 7 & 4294967295 | h >>> 25);
  h = f + (e3 ^ b2 & (c2 ^ e3)) + d[9] + 2336552879 & 4294967295;
  f = b2 + (h << 12 & 4294967295 | h >>> 20);
  h = e3 + (c2 ^ f & (b2 ^ c2)) + d[10] + 4294925233 & 4294967295;
  e3 = f + (h << 17 & 4294967295 | h >>> 15);
  h = c2 + (b2 ^ e3 & (f ^ b2)) + d[11] + 2304563134 & 4294967295;
  c2 = e3 + (h << 22 & 4294967295 | h >>> 10);
  h = b2 + (f ^ c2 & (e3 ^ f)) + d[12] + 1804603682 & 4294967295;
  b2 = c2 + (h << 7 & 4294967295 | h >>> 25);
  h = f + (e3 ^ b2 & (c2 ^ e3)) + d[13] + 4254626195 & 4294967295;
  f = b2 + (h << 12 & 4294967295 | h >>> 20);
  h = e3 + (c2 ^ f & (b2 ^ c2)) + d[14] + 2792965006 & 4294967295;
  e3 = f + (h << 17 & 4294967295 | h >>> 15);
  h = c2 + (b2 ^ e3 & (f ^ b2)) + d[15] + 1236535329 & 4294967295;
  c2 = e3 + (h << 22 & 4294967295 | h >>> 10);
  h = b2 + (e3 ^ f & (c2 ^ e3)) + d[1] + 4129170786 & 4294967295;
  b2 = c2 + (h << 5 & 4294967295 | h >>> 27);
  h = f + (c2 ^ e3 & (b2 ^ c2)) + d[6] + 3225465664 & 4294967295;
  f = b2 + (h << 9 & 4294967295 | h >>> 23);
  h = e3 + (b2 ^ c2 & (f ^ b2)) + d[11] + 643717713 & 4294967295;
  e3 = f + (h << 14 & 4294967295 | h >>> 18);
  h = c2 + (f ^ b2 & (e3 ^ f)) + d[0] + 3921069994 & 4294967295;
  c2 = e3 + (h << 20 & 4294967295 | h >>> 12);
  h = b2 + (e3 ^ f & (c2 ^ e3)) + d[5] + 3593408605 & 4294967295;
  b2 = c2 + (h << 5 & 4294967295 | h >>> 27);
  h = f + (c2 ^ e3 & (b2 ^ c2)) + d[10] + 38016083 & 4294967295;
  f = b2 + (h << 9 & 4294967295 | h >>> 23);
  h = e3 + (b2 ^ c2 & (f ^ b2)) + d[15] + 3634488961 & 4294967295;
  e3 = f + (h << 14 & 4294967295 | h >>> 18);
  h = c2 + (f ^ b2 & (e3 ^ f)) + d[4] + 3889429448 & 4294967295;
  c2 = e3 + (h << 20 & 4294967295 | h >>> 12);
  h = b2 + (e3 ^ f & (c2 ^ e3)) + d[9] + 568446438 & 4294967295;
  b2 = c2 + (h << 5 & 4294967295 | h >>> 27);
  h = f + (c2 ^ e3 & (b2 ^ c2)) + d[14] + 3275163606 & 4294967295;
  f = b2 + (h << 9 & 4294967295 | h >>> 23);
  h = e3 + (b2 ^ c2 & (f ^ b2)) + d[3] + 4107603335 & 4294967295;
  e3 = f + (h << 14 & 4294967295 | h >>> 18);
  h = c2 + (f ^ b2 & (e3 ^ f)) + d[8] + 1163531501 & 4294967295;
  c2 = e3 + (h << 20 & 4294967295 | h >>> 12);
  h = b2 + (e3 ^ f & (c2 ^ e3)) + d[13] + 2850285829 & 4294967295;
  b2 = c2 + (h << 5 & 4294967295 | h >>> 27);
  h = f + (c2 ^ e3 & (b2 ^ c2)) + d[2] + 4243563512 & 4294967295;
  f = b2 + (h << 9 & 4294967295 | h >>> 23);
  h = e3 + (b2 ^ c2 & (f ^ b2)) + d[7] + 1735328473 & 4294967295;
  e3 = f + (h << 14 & 4294967295 | h >>> 18);
  h = c2 + (f ^ b2 & (e3 ^ f)) + d[12] + 2368359562 & 4294967295;
  c2 = e3 + (h << 20 & 4294967295 | h >>> 12);
  h = b2 + (c2 ^ e3 ^ f) + d[5] + 4294588738 & 4294967295;
  b2 = c2 + (h << 4 & 4294967295 | h >>> 28);
  h = f + (b2 ^ c2 ^ e3) + d[8] + 2272392833 & 4294967295;
  f = b2 + (h << 11 & 4294967295 | h >>> 21);
  h = e3 + (f ^ b2 ^ c2) + d[11] + 1839030562 & 4294967295;
  e3 = f + (h << 16 & 4294967295 | h >>> 16);
  h = c2 + (e3 ^ f ^ b2) + d[14] + 4259657740 & 4294967295;
  c2 = e3 + (h << 23 & 4294967295 | h >>> 9);
  h = b2 + (c2 ^ e3 ^ f) + d[1] + 2763975236 & 4294967295;
  b2 = c2 + (h << 4 & 4294967295 | h >>> 28);
  h = f + (b2 ^ c2 ^ e3) + d[4] + 1272893353 & 4294967295;
  f = b2 + (h << 11 & 4294967295 | h >>> 21);
  h = e3 + (f ^ b2 ^ c2) + d[7] + 4139469664 & 4294967295;
  e3 = f + (h << 16 & 4294967295 | h >>> 16);
  h = c2 + (e3 ^ f ^ b2) + d[10] + 3200236656 & 4294967295;
  c2 = e3 + (h << 23 & 4294967295 | h >>> 9);
  h = b2 + (c2 ^ e3 ^ f) + d[13] + 681279174 & 4294967295;
  b2 = c2 + (h << 4 & 4294967295 | h >>> 28);
  h = f + (b2 ^ c2 ^ e3) + d[0] + 3936430074 & 4294967295;
  f = b2 + (h << 11 & 4294967295 | h >>> 21);
  h = e3 + (f ^ b2 ^ c2) + d[3] + 3572445317 & 4294967295;
  e3 = f + (h << 16 & 4294967295 | h >>> 16);
  h = c2 + (e3 ^ f ^ b2) + d[6] + 76029189 & 4294967295;
  c2 = e3 + (h << 23 & 4294967295 | h >>> 9);
  h = b2 + (c2 ^ e3 ^ f) + d[9] + 3654602809 & 4294967295;
  b2 = c2 + (h << 4 & 4294967295 | h >>> 28);
  h = f + (b2 ^ c2 ^ e3) + d[12] + 3873151461 & 4294967295;
  f = b2 + (h << 11 & 4294967295 | h >>> 21);
  h = e3 + (f ^ b2 ^ c2) + d[15] + 530742520 & 4294967295;
  e3 = f + (h << 16 & 4294967295 | h >>> 16);
  h = c2 + (e3 ^ f ^ b2) + d[2] + 3299628645 & 4294967295;
  c2 = e3 + (h << 23 & 4294967295 | h >>> 9);
  h = b2 + (e3 ^ (c2 | ~f)) + d[0] + 4096336452 & 4294967295;
  b2 = c2 + (h << 6 & 4294967295 | h >>> 26);
  h = f + (c2 ^ (b2 | ~e3)) + d[7] + 1126891415 & 4294967295;
  f = b2 + (h << 10 & 4294967295 | h >>> 22);
  h = e3 + (b2 ^ (f | ~c2)) + d[14] + 2878612391 & 4294967295;
  e3 = f + (h << 15 & 4294967295 | h >>> 17);
  h = c2 + (f ^ (e3 | ~b2)) + d[5] + 4237533241 & 4294967295;
  c2 = e3 + (h << 21 & 4294967295 | h >>> 11);
  h = b2 + (e3 ^ (c2 | ~f)) + d[12] + 1700485571 & 4294967295;
  b2 = c2 + (h << 6 & 4294967295 | h >>> 26);
  h = f + (c2 ^ (b2 | ~e3)) + d[3] + 2399980690 & 4294967295;
  f = b2 + (h << 10 & 4294967295 | h >>> 22);
  h = e3 + (b2 ^ (f | ~c2)) + d[10] + 4293915773 & 4294967295;
  e3 = f + (h << 15 & 4294967295 | h >>> 17);
  h = c2 + (f ^ (e3 | ~b2)) + d[1] + 2240044497 & 4294967295;
  c2 = e3 + (h << 21 & 4294967295 | h >>> 11);
  h = b2 + (e3 ^ (c2 | ~f)) + d[8] + 1873313359 & 4294967295;
  b2 = c2 + (h << 6 & 4294967295 | h >>> 26);
  h = f + (c2 ^ (b2 | ~e3)) + d[15] + 4264355552 & 4294967295;
  f = b2 + (h << 10 & 4294967295 | h >>> 22);
  h = e3 + (b2 ^ (f | ~c2)) + d[6] + 2734768916 & 4294967295;
  e3 = f + (h << 15 & 4294967295 | h >>> 17);
  h = c2 + (f ^ (e3 | ~b2)) + d[13] + 1309151649 & 4294967295;
  c2 = e3 + (h << 21 & 4294967295 | h >>> 11);
  h = b2 + (e3 ^ (c2 | ~f)) + d[4] + 4149444226 & 4294967295;
  b2 = c2 + (h << 6 & 4294967295 | h >>> 26);
  h = f + (c2 ^ (b2 | ~e3)) + d[11] + 3174756917 & 4294967295;
  f = b2 + (h << 10 & 4294967295 | h >>> 22);
  h = e3 + (b2 ^ (f | ~c2)) + d[2] + 718787259 & 4294967295;
  e3 = f + (h << 15 & 4294967295 | h >>> 17);
  h = c2 + (f ^ (e3 | ~b2)) + d[9] + 3951481745 & 4294967295;
  a2.g[0] = a2.g[0] + b2 & 4294967295;
  a2.g[1] = a2.g[1] + (e3 + (h << 21 & 4294967295 | h >>> 11)) & 4294967295;
  a2.g[2] = a2.g[2] + e3 & 4294967295;
  a2.g[3] = a2.g[3] + f & 4294967295;
}
function T(a2, b2) {
  this.h = b2;
  for (var c2 = [], d = true, e3 = a2.length - 1; 0 <= e3; e3--) {
    var f = a2[e3] | 0;
    d && f == b2 || (c2[e3] = f, d = false);
  }
  this.g = c2;
}
function Td(a2) {
  return -128 <= a2 && 128 > a2 ? ra(a2, function(b2) {
    return new T([b2 | 0], 0 > b2 ? -1 : 0);
  }) : new T([a2 | 0], 0 > a2 ? -1 : 0);
}
function U(a2) {
  if (isNaN(a2) || !isFinite(a2))
    return V;
  if (0 > a2)
    return W(U(-a2));
  for (var b2 = [], c2 = 1, d = 0; a2 >= c2; d++)
    b2[d] = a2 / c2 | 0, c2 *= Ud;
  return new T(b2, 0);
}
function Vd(a2, b2) {
  if (0 == a2.length)
    throw Error("number format error: empty string");
  b2 = b2 || 10;
  if (2 > b2 || 36 < b2)
    throw Error("radix out of range: " + b2);
  if ("-" == a2.charAt(0))
    return W(Vd(a2.substring(1), b2));
  if (0 <= a2.indexOf("-"))
    throw Error('number format error: interior "-" character');
  for (var c2 = U(Math.pow(b2, 8)), d = V, e3 = 0; e3 < a2.length; e3 += 8) {
    var f = Math.min(8, a2.length - e3), h = parseInt(a2.substring(e3, e3 + f), b2);
    8 > f ? (f = U(Math.pow(b2, f)), d = d.R(f).add(U(h))) : (d = d.R(c2), d = d.add(U(h)));
  }
  return d;
}
function Y(a2) {
  if (0 != a2.h)
    return false;
  for (var b2 = 0; b2 < a2.g.length; b2++)
    if (0 != a2.g[b2])
      return false;
  return true;
}
function X(a2) {
  return -1 == a2.h;
}
function W(a2) {
  for (var b2 = a2.g.length, c2 = [], d = 0; d < b2; d++)
    c2[d] = ~a2.g[d];
  return new T(c2, ~a2.h).add(Wd);
}
function Zd(a2, b2) {
  return a2.add(W(b2));
}
function $d(a2, b2) {
  for (; (a2[b2] & 65535) != a2[b2]; )
    a2[b2 + 1] += a2[b2] >>> 16, a2[b2] &= 65535, b2++;
}
function ae(a2, b2) {
  this.g = a2;
  this.h = b2;
}
function Yd(a2, b2) {
  if (Y(b2))
    throw Error("division by zero");
  if (Y(a2))
    return new ae(V, V);
  if (X(a2))
    return b2 = Yd(W(a2), b2), new ae(W(b2.g), W(b2.h));
  if (X(b2))
    return b2 = Yd(a2, W(b2)), new ae(W(b2.g), b2.h);
  if (30 < a2.g.length) {
    if (X(a2) || X(b2))
      throw Error("slowDivide_ only works with positive integers.");
    for (var c2 = Wd, d = b2; 0 >= d.X(a2); )
      c2 = be(c2), d = be(d);
    var e3 = Z(c2, 1), f = Z(d, 1);
    d = Z(d, 2);
    for (c2 = Z(c2, 2); !Y(d); ) {
      var h = f.add(d);
      0 >= h.X(a2) && (e3 = e3.add(c2), f = h);
      d = Z(d, 1);
      c2 = Z(c2, 1);
    }
    b2 = Zd(a2, e3.R(b2));
    return new ae(e3, b2);
  }
  for (e3 = V; 0 <= a2.X(b2); ) {
    c2 = Math.max(1, Math.floor(a2.ea() / b2.ea()));
    d = Math.ceil(Math.log(c2) / Math.LN2);
    d = 48 >= d ? 1 : Math.pow(2, d - 48);
    f = U(c2);
    for (h = f.R(b2); X(h) || 0 < h.X(a2); )
      c2 -= d, f = U(c2), h = f.R(b2);
    Y(f) && (f = Wd);
    e3 = e3.add(f);
    a2 = Zd(a2, h);
  }
  return new ae(e3, a2);
}
function be(a2) {
  for (var b2 = a2.g.length + 1, c2 = [], d = 0; d < b2; d++)
    c2[d] = a2.D(d) << 1 | a2.D(d - 1) >>> 31;
  return new T(c2, a2.h);
}
function Z(a2, b2) {
  var c2 = b2 >> 5;
  b2 %= 32;
  for (var d = a2.g.length - c2, e3 = [], f = 0; f < d; f++)
    e3[f] = 0 < b2 ? a2.D(f + c2) >>> b2 | a2.D(f + c2 + 1) << 32 - b2 : a2.D(f + c2);
  return new T(e3, a2.h);
}
var commonjsGlobal;
var esm;
var k;
var goog;
var l;
var ca;
var da;
var ia;
var ka;
var oa;
var ta;
var z;
var ua;
var va;
var wa;
var xa;
var za;
var Aa;
var Ba;
var Ca;
var Da;
var Ea;
var Fa;
var Ga;
var Ha;
var Ia;
var Qa;
var Va;
var Wa;
var hb;
var jb;
var kb;
var nb;
var ob;
var pb;
var sb;
var tb;
var mb;
var vb;
var ub;
var Ab;
var Cb;
var E;
var Lb;
var Sb;
var Tb;
var Xb;
var $b;
var cc;
var ec;
var fc;
var Lc;
var Tc;
var Vc;
var Uc;
var Yc;
var Wc;
var bd;
var dd;
var gd;
var nd;
var rd;
var sd;
var td;
var ud;
var sa;
var Ud;
var V;
var Wd;
var Xd;
var createWebChannelTransport;
var getStatEventTarget;
var ErrorCode;
var EventType;
var Event2;
var Stat;
var FetchXmlHttpFactory;
var WebChannel;
var XhrIo;
var Md5;
var Integer;
var init_index_esm20175 = __esm({
  "node_modules/@firebase/webchannel-wrapper/dist/esm/index.esm2017.js"() {
    commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    esm = {};
    goog = goog || {};
    l = commonjsGlobal || self;
    ca = "closure_uid_" + (1e9 * Math.random() >>> 0);
    da = 0;
    ia = 0;
    v.prototype.s = false;
    v.prototype.sa = function() {
      if (!this.s && (this.s = true, this.N(), 0 != ia)) {
        ba(this);
      }
    };
    v.prototype.N = function() {
      if (this.o)
        for (; this.o.length; )
          this.o.shift()();
    };
    ka = Array.prototype.indexOf ? function(a2, b2) {
      return Array.prototype.indexOf.call(a2, b2, void 0);
    } : function(a2, b2) {
      if ("string" === typeof a2)
        return "string" !== typeof b2 || 1 != b2.length ? -1 : a2.indexOf(b2, 0);
      for (let c2 = 0; c2 < a2.length; c2++)
        if (c2 in a2 && a2[c2] === b2)
          return c2;
      return -1;
    };
    w.prototype.h = function() {
      this.defaultPrevented = true;
    };
    oa = function() {
      if (!l.addEventListener || !Object.defineProperty)
        return false;
      var a2 = false, b2 = Object.defineProperty({}, "passive", { get: function() {
        a2 = true;
      } });
      try {
        const c2 = () => {
        };
        l.addEventListener("test", c2, b2);
        l.removeEventListener("test", c2, b2);
      } catch (c2) {
      }
      return a2;
    }();
    qa[" "] = function() {
    };
    ta = y("Opera");
    z = y("Trident") || y("MSIE");
    ua = y("Edge");
    va = ua || z;
    wa = y("Gecko") && !(-1 != pa().toLowerCase().indexOf("webkit") && !y("Edge")) && !(y("Trident") || y("MSIE")) && !y("Edge");
    xa = -1 != pa().toLowerCase().indexOf("webkit") && !y("Edge");
    a: {
      Aa = "", Ba = function() {
        var a2 = pa();
        if (wa)
          return /rv:([^\);]+)(\)|;)/.exec(a2);
        if (ua)
          return /Edge\/([\d\.]+)/.exec(a2);
        if (z)
          return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a2);
        if (xa)
          return /WebKit\/(\S+)/.exec(a2);
        if (ta)
          return /(?:Version)[ \/]?(\S+)/.exec(a2);
      }();
      Ba && (Aa = Ba ? Ba[1] : "");
      if (z) {
        Ca = ya();
        if (null != Ca && Ca > parseFloat(Aa)) {
          za = String(Ca);
          break a;
        }
      }
      za = Aa;
    }
    if (l.document && z) {
      Ea = ya();
      Da = Ea ? Ea : parseInt(za, 10) || void 0;
    } else
      Da = void 0;
    Fa = Da;
    r(A, w);
    Ga = { 2: "touch", 3: "pen", 4: "mouse" };
    A.prototype.h = function() {
      A.$.h.call(this);
      var a2 = this.i;
      a2.preventDefault ? a2.preventDefault() : a2.returnValue = false;
    };
    Ha = "closure_listenable_" + (1e6 * Math.random() | 0);
    Ia = 0;
    Qa = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
    Sa.prototype.add = function(a2, b2, c2, d, e3) {
      var f = a2.toString();
      a2 = this.g[f];
      a2 || (a2 = this.g[f] = [], this.h++);
      var h = Ta(a2, b2, d, e3);
      -1 < h ? (b2 = a2[h], c2 || (b2.ia = false)) : (b2 = new Ja(b2, this.src, f, !!d, e3), b2.ia = c2, a2.push(b2));
      return b2;
    };
    Va = "closure_lm_" + (1e6 * Math.random() | 0);
    Wa = {};
    hb = "__closure_events_fn_" + (1e9 * Math.random() >>> 0);
    r(B, v);
    B.prototype[Ha] = true;
    B.prototype.removeEventListener = function(a2, b2, c2, d) {
      fb(this, a2, b2, c2, d);
    };
    B.prototype.N = function() {
      B.$.N.call(this);
      if (this.i) {
        var a2 = this.i, c2;
        for (c2 in a2.g) {
          for (var d = a2.g[c2], e3 = 0; e3 < d.length; e3++)
            Ma(d[e3]);
          delete a2.g[c2];
          a2.h--;
        }
      }
      this.J = null;
    };
    B.prototype.O = function(a2, b2, c2, d) {
      return this.i.add(String(a2), b2, false, c2, d);
    };
    B.prototype.P = function(a2, b2, c2, d) {
      return this.i.add(String(a2), b2, true, c2, d);
    };
    jb = l.JSON.stringify;
    kb = class {
      constructor(a2, b2) {
        this.i = a2;
        this.j = b2;
        this.h = 0;
        this.g = null;
      }
      get() {
        let a2;
        0 < this.h ? (this.h--, a2 = this.g, this.g = a2.next, a2.next = null) : a2 = this.i();
        return a2;
      }
    };
    nb = class {
      constructor() {
        this.h = this.g = null;
      }
      add(a2, b2) {
        const c2 = ob.get();
        c2.set(a2, b2);
        this.h ? this.h.next = c2 : this.g = c2;
        this.h = c2;
      }
    };
    ob = new kb(() => new pb(), (a2) => a2.reset());
    pb = class {
      constructor() {
        this.next = this.g = this.h = null;
      }
      set(a2, b2) {
        this.h = a2;
        this.g = b2;
        this.next = null;
      }
      reset() {
        this.next = this.g = this.h = null;
      }
    };
    tb = false;
    mb = new nb();
    vb = () => {
      const a2 = l.Promise.resolve(void 0);
      sb = () => {
        a2.then(ub);
      };
    };
    ub = () => {
      for (var a2; a2 = lb(); ) {
        try {
          a2.h.call(a2.g);
        } catch (c2) {
          rb(c2);
        }
        var b2 = ob;
        b2.j(a2);
        100 > b2.h && (b2.h++, a2.next = b2.g, b2.g = a2);
      }
      tb = false;
    };
    r(wb, B);
    k = wb.prototype;
    k.ga = false;
    k.T = null;
    k.qb = function() {
      if (this.ga) {
        var a2 = Date.now() - this.l;
        0 < a2 && a2 < 0.8 * this.h ? this.T = this.g.setTimeout(this.j, this.h - a2) : (this.T && (this.g.clearTimeout(this.T), this.T = null), C(this, "tick"), this.ga && (xb(this), this.start()));
      }
    };
    k.start = function() {
      this.ga = true;
      this.T || (this.T = this.g.setTimeout(this.j, this.h), this.l = Date.now());
    };
    k.N = function() {
      wb.$.N.call(this);
      xb(this);
      delete this.g;
    };
    Ab = class extends v {
      constructor(a2, b2) {
        super();
        this.m = a2;
        this.j = b2;
        this.h = null;
        this.i = false;
        this.g = null;
      }
      l(a2) {
        this.h = arguments;
        this.g ? this.i = true : zb(this);
      }
      N() {
        super.N();
        this.g && (l.clearTimeout(this.g), this.g = null, this.i = false, this.h = null);
      }
    };
    r(Bb, v);
    Cb = [];
    Bb.prototype.N = function() {
      Bb.$.N.call(this);
      Fb(this);
    };
    Bb.prototype.handleEvent = function() {
      throw Error("EventHandler.handleEvent not implemented");
    };
    Gb.prototype.Ea = function() {
      this.g = false;
    };
    Gb.prototype.info = function() {
    };
    E = {};
    Lb = null;
    E.Ta = "serverreachability";
    r(Nb, w);
    E.STAT_EVENT = "statevent";
    r(Pb, w);
    E.Ua = "timingevent";
    r(Qb, w);
    Sb = { NO_ERROR: 0, rb: 1, Eb: 2, Db: 3, yb: 4, Cb: 5, Fb: 6, Qa: 7, TIMEOUT: 8, Ib: 9 };
    Tb = { wb: "complete", Sb: "success", Ra: "error", Qa: "abort", Kb: "ready", Lb: "readystatechange", TIMEOUT: "timeout", Gb: "incrementaldata", Jb: "progress", zb: "downloadprogress", $b: "uploadprogress" };
    Ub.prototype.h = null;
    Xb = { OPEN: "a", vb: "b", Ra: "c", Hb: "d" };
    r(Yb, w);
    r(Zb, w);
    r(ac, Ub);
    ac.prototype.g = function() {
      return new XMLHttpRequest();
    };
    ac.prototype.i = function() {
      return {};
    };
    $b = new ac();
    cc = 45e3;
    ec = {};
    fc = {};
    k = bc.prototype;
    k.setTimeout = function(a2) {
      this.P = a2;
    };
    k.nb = function(a2) {
      a2 = a2.target;
      const b2 = this.M;
      b2 && 3 == H(a2) ? b2.l() : this.Pa(a2);
    };
    k.Pa = function(a2) {
      try {
        if (a2 == this.g)
          a: {
            const u2 = H(this.g);
            var b2 = this.g.Ia();
            const L2 = this.g.da();
            if (!(3 > u2) && (3 != u2 || va || this.g && (this.h.h || this.g.ja() || mc(this.g)))) {
              this.J || 4 != u2 || 7 == b2 || (8 == b2 || 0 >= L2 ? Ob(3) : Ob(2));
              nc(this);
              var c2 = this.g.da();
              this.ca = c2;
              b:
                if (oc(this)) {
                  var d = mc(this.g);
                  a2 = "";
                  var e3 = d.length, f = 4 == H(this.g);
                  if (!this.h.i) {
                    if ("undefined" === typeof TextDecoder) {
                      I(this);
                      pc(this);
                      var h = "";
                      break b;
                    }
                    this.h.i = new l.TextDecoder();
                  }
                  for (b2 = 0; b2 < e3; b2++)
                    this.h.h = true, a2 += this.h.i.decode(d[b2], { stream: f && b2 == e3 - 1 });
                  d.length = 0;
                  this.h.g += a2;
                  this.o = 0;
                  h = this.h.g;
                } else
                  h = this.g.ja();
              this.i = 200 == c2;
              Ib(this.j, this.v, this.B, this.m, this.W, u2, c2);
              if (this.i) {
                if (this.aa && !this.K) {
                  b: {
                    if (this.g) {
                      var n2, t2 = this.g;
                      if ((n2 = t2.g ? t2.g.getResponseHeader("X-HTTP-Initial-Response") : null) && !x(n2)) {
                        var m = n2;
                        break b;
                      }
                    }
                    m = null;
                  }
                  if (c2 = m)
                    D(this.j, this.m, c2, "Initial handshake response via X-HTTP-Initial-Response"), this.K = true, qc(this, c2);
                  else {
                    this.i = false;
                    this.s = 3;
                    F(12);
                    I(this);
                    pc(this);
                    break a;
                  }
                }
                this.S ? (rc(this, u2, h), va && this.i && 3 == u2 && (Eb(this.U, this.V, "tick", this.mb), this.V.start())) : (D(this.j, this.m, h, null), qc(this, h));
                4 == u2 && I(this);
                this.i && !this.J && (4 == u2 ? sc(this.l, this) : (this.i = false, jc(this)));
              } else
                tc(this.g), 400 == c2 && 0 < h.indexOf("Unknown SID") ? (this.s = 3, F(12)) : (this.s = 0, F(13)), I(this), pc(this);
            }
          }
      } catch (u2) {
      } finally {
      }
    };
    k.mb = function() {
      if (this.g) {
        var a2 = H(this.g), b2 = this.g.ja();
        this.o < b2.length && (nc(this), rc(this, a2, b2), this.i && 4 != a2 && jc(this));
      }
    };
    k.cancel = function() {
      this.J = true;
      I(this);
    };
    k.lb = function() {
      this.C = null;
      const a2 = Date.now();
      0 <= a2 - this.Y ? (Kb(this.j, this.B), 2 != this.L && (Ob(), F(17)), I(this), this.s = 2, pc(this)) : wc(this, this.Y - a2);
    };
    Lc = RegExp("^(?:([^:/?#.]+):)?(?://(?:([^\\\\/?#]*)@)?([^\\\\/?#]*?)(?::([0-9]+))?(?=[\\\\/?#]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#([\\s\\S]*))?$");
    M.prototype.toString = function() {
      var a2 = [], b2 = this.j;
      b2 && a2.push(Sc(b2, Tc, true), ":");
      var c2 = this.g;
      if (c2 || "file" == b2)
        a2.push("//"), (b2 = this.s) && a2.push(Sc(b2, Tc, true), "@"), a2.push(encodeURIComponent(String(c2)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")), c2 = this.m, null != c2 && a2.push(":", String(c2));
      if (c2 = this.l)
        this.g && "/" != c2.charAt(0) && a2.push("/"), a2.push(Sc(c2, "/" == c2.charAt(0) ? Uc : Vc, true));
      (c2 = this.i.toString()) && a2.push("?", c2);
      (c2 = this.o) && a2.push("#", Sc(c2, Wc));
      return a2.join("");
    };
    Tc = /[#\/\?@]/g;
    Vc = /[#\?:]/g;
    Uc = /[#\?]/g;
    Yc = /[#\?@]/g;
    Wc = /#/g;
    k = Pc.prototype;
    k.add = function(a2, b2) {
      N(this);
      this.i = null;
      a2 = O(this, a2);
      var c2 = this.g.get(a2);
      c2 || this.g.set(a2, c2 = []);
      c2.push(b2);
      this.h += 1;
      return this;
    };
    k.forEach = function(a2, b2) {
      N(this);
      this.g.forEach(function(c2, d) {
        c2.forEach(function(e3) {
          a2.call(b2, e3, d, this);
        }, this);
      }, this);
    };
    k.ta = function() {
      N(this);
      const a2 = Array.from(this.g.values()), b2 = Array.from(this.g.keys()), c2 = [];
      for (let d = 0; d < b2.length; d++) {
        const e3 = a2[d];
        for (let f = 0; f < e3.length; f++)
          c2.push(b2[d]);
      }
      return c2;
    };
    k.Z = function(a2) {
      N(this);
      let b2 = [];
      if ("string" === typeof a2)
        ad(this, a2) && (b2 = b2.concat(this.g.get(O(this, a2))));
      else {
        a2 = Array.from(this.g.values());
        for (let c2 = 0; c2 < a2.length; c2++)
          b2 = b2.concat(a2[c2]);
      }
      return b2;
    };
    k.set = function(a2, b2) {
      N(this);
      this.i = null;
      a2 = O(this, a2);
      ad(this, a2) && (this.h -= this.g.get(a2).length);
      this.g.set(a2, [b2]);
      this.h += 1;
      return this;
    };
    k.get = function(a2, b2) {
      if (!a2)
        return b2;
      a2 = this.Z(a2);
      return 0 < a2.length ? String(a2[0]) : b2;
    };
    k.toString = function() {
      if (this.i)
        return this.i;
      if (!this.g)
        return "";
      const a2 = [], b2 = Array.from(this.g.keys());
      for (var c2 = 0; c2 < b2.length; c2++) {
        var d = b2[c2];
        const f = encodeURIComponent(String(d)), h = this.Z(d);
        for (d = 0; d < h.length; d++) {
          var e3 = f;
          "" !== h[d] && (e3 += "=" + encodeURIComponent(String(h[d])));
          a2.push(e3);
        }
      }
      return this.i = a2.join("&");
    };
    bd = class {
      constructor(a2, b2) {
        this.g = a2;
        this.map = b2;
      }
    };
    dd = 10;
    cd.prototype.cancel = function() {
      this.i = fd(this);
      if (this.h)
        this.h.cancel(), this.h = null;
      else if (this.g && 0 !== this.g.size) {
        for (const a2 of this.g.values())
          a2.cancel();
        this.g.clear();
      }
    };
    gd = class {
      stringify(a2) {
        return l.JSON.stringify(a2, void 0);
      }
      parse(a2) {
        return l.JSON.parse(a2, void 0);
      }
    };
    r(ld, Ub);
    ld.prototype.g = function() {
      return new md(this.l, this.j);
    };
    ld.prototype.i = /* @__PURE__ */ function(a2) {
      return function() {
        return a2;
      };
    }({});
    r(md, B);
    nd = 0;
    k = md.prototype;
    k.open = function(a2, b2) {
      if (this.readyState != nd)
        throw this.abort(), Error("Error reopening a connection");
      this.C = a2;
      this.B = b2;
      this.readyState = 1;
      od(this);
    };
    k.send = function(a2) {
      if (1 != this.readyState)
        throw this.abort(), Error("need to call open() first. ");
      this.g = true;
      const b2 = { headers: this.v, method: this.C, credentials: this.m, cache: void 0 };
      a2 && (b2.body = a2);
      (this.F || l).fetch(new Request(this.B, b2)).then(this.$a.bind(this), this.ka.bind(this));
    };
    k.abort = function() {
      this.response = this.responseText = "";
      this.v = new Headers();
      this.status = 0;
      this.j && this.j.cancel("Request was aborted.").catch(() => {
      });
      1 <= this.readyState && this.g && 4 != this.readyState && (this.g = false, pd(this));
      this.readyState = nd;
    };
    k.$a = function(a2) {
      if (this.g && (this.l = a2, this.h || (this.status = this.l.status, this.statusText = this.l.statusText, this.h = a2.headers, this.readyState = 2, od(this)), this.g && (this.readyState = 3, od(this), this.g)))
        if ("arraybuffer" === this.responseType)
          a2.arrayBuffer().then(this.Ya.bind(this), this.ka.bind(this));
        else if ("undefined" !== typeof l.ReadableStream && "body" in a2) {
          this.j = a2.body.getReader();
          if (this.u) {
            if (this.responseType)
              throw Error('responseType must be empty for "streamBinaryChunks" mode responses.');
            this.response = [];
          } else
            this.response = this.responseText = "", this.A = new TextDecoder();
          qd(this);
        } else
          a2.text().then(this.Za.bind(this), this.ka.bind(this));
    };
    k.Xa = function(a2) {
      if (this.g) {
        if (this.u && a2.value)
          this.response.push(a2.value);
        else if (!this.u) {
          var b2 = a2.value ? a2.value : new Uint8Array(0);
          if (b2 = this.A.decode(b2, { stream: !a2.done }))
            this.response = this.responseText += b2;
        }
        a2.done ? pd(this) : od(this);
        3 == this.readyState && qd(this);
      }
    };
    k.Za = function(a2) {
      this.g && (this.response = this.responseText = a2, pd(this));
    };
    k.Ya = function(a2) {
      this.g && (this.response = a2, pd(this));
    };
    k.ka = function() {
      this.g && pd(this);
    };
    k.setRequestHeader = function(a2, b2) {
      this.v.append(a2, b2);
    };
    k.getResponseHeader = function(a2) {
      return this.h ? this.h.get(a2.toLowerCase()) || "" : "";
    };
    k.getAllResponseHeaders = function() {
      if (!this.h)
        return "";
      const a2 = [], b2 = this.h.entries();
      for (var c2 = b2.next(); !c2.done; )
        c2 = c2.value, a2.push(c2[0] + ": " + c2[1]), c2 = b2.next();
      return a2.join("\r\n");
    };
    Object.defineProperty(md.prototype, "withCredentials", { get: function() {
      return "include" === this.m;
    }, set: function(a2) {
      this.m = a2 ? "include" : "same-origin";
    } });
    rd = l.JSON.parse;
    r(P, B);
    sd = "";
    td = /^https?$/i;
    ud = ["POST", "PUT"];
    k = P.prototype;
    k.Oa = function(a2) {
      this.M = a2;
    };
    k.ha = function(a2, b2, c2, d) {
      if (this.g)
        throw Error("[goog.net.XhrIo] Object is active with another request=" + this.I + "; newUri=" + a2);
      b2 = b2 ? b2.toUpperCase() : "GET";
      this.I = a2;
      this.j = "";
      this.m = 0;
      this.F = false;
      this.h = true;
      this.g = this.u ? this.u.g() : $b.g();
      this.C = this.u ? Vb(this.u) : Vb($b);
      this.g.onreadystatechange = q(this.La, this);
      try {
        this.G = true, this.g.open(b2, String(a2), true), this.G = false;
      } catch (f) {
        vd(this, f);
        return;
      }
      a2 = c2 || "";
      c2 = new Map(this.headers);
      if (d)
        if (Object.getPrototypeOf(d) === Object.prototype)
          for (var e3 in d)
            c2.set(e3, d[e3]);
        else if ("function" === typeof d.keys && "function" === typeof d.get)
          for (const f of d.keys())
            c2.set(f, d.get(f));
        else
          throw Error("Unknown input type for opt_headers: " + String(d));
      d = Array.from(c2.keys()).find((f) => "content-type" == f.toLowerCase());
      e3 = l.FormData && a2 instanceof l.FormData;
      !(0 <= ka(ud, b2)) || d || e3 || c2.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");
      for (const [f, h] of c2)
        this.g.setRequestHeader(f, h);
      this.K && (this.g.responseType = this.K);
      "withCredentials" in this.g && this.g.withCredentials !== this.M && (this.g.withCredentials = this.M);
      try {
        wd(this), 0 < this.B && ((this.L = xd(this.g)) ? (this.g.timeout = this.B, this.g.ontimeout = q(this.ua, this)) : this.A = yb(this.ua, this.B, this)), this.v = true, this.g.send(a2), this.v = false;
      } catch (f) {
        vd(this, f);
      }
    };
    k.ua = function() {
      "undefined" != typeof goog && this.g && (this.j = "Timed out after " + this.B + "ms, aborting", this.m = 8, C(this, "timeout"), this.abort(8));
    };
    k.abort = function(a2) {
      this.g && this.h && (this.h = false, this.l = true, this.g.abort(), this.l = false, this.m = a2 || 7, C(this, "complete"), C(this, "abort"), zd(this));
    };
    k.N = function() {
      this.g && (this.h && (this.h = false, this.l = true, this.g.abort(), this.l = false), zd(this, true));
      P.$.N.call(this);
    };
    k.La = function() {
      this.s || (this.G || this.v || this.l ? Ad(this) : this.kb());
    };
    k.kb = function() {
      Ad(this);
    };
    k.isActive = function() {
      return !!this.g;
    };
    k.da = function() {
      try {
        return 2 < H(this) ? this.g.status : -1;
      } catch (a2) {
        return -1;
      }
    };
    k.ja = function() {
      try {
        return this.g ? this.g.responseText : "";
      } catch (a2) {
        return "";
      }
    };
    k.Wa = function(a2) {
      if (this.g) {
        var b2 = this.g.responseText;
        a2 && 0 == b2.indexOf(a2) && (b2 = b2.substring(a2.length));
        return rd(b2);
      }
    };
    k.Ia = function() {
      return this.m;
    };
    k.Sa = function() {
      return "string" === typeof this.j ? this.j : String(this.j);
    };
    k = Ed.prototype;
    k.ra = 8;
    k.H = 1;
    k.Na = function(a2) {
      if (this.m)
        if (this.m = null, 1 == this.H) {
          if (!a2) {
            this.W = Math.floor(1e5 * Math.random());
            a2 = this.W++;
            const e3 = new bc(this, this.l, a2);
            let f = this.s;
            this.U && (f ? (f = Pa(f), Ra(f, this.U)) : f = this.U);
            null !== this.o || this.O || (e3.I = f, f = null);
            if (this.P)
              a: {
                var b2 = 0;
                for (var c2 = 0; c2 < this.j.length; c2++) {
                  b: {
                    var d = this.j[c2];
                    if ("__data__" in d.map && (d = d.map.__data__, "string" === typeof d)) {
                      d = d.length;
                      break b;
                    }
                    d = void 0;
                  }
                  if (void 0 === d)
                    break;
                  b2 += d;
                  if (4096 < b2) {
                    b2 = c2;
                    break a;
                  }
                  if (4096 === b2 || c2 === this.j.length - 1) {
                    b2 = c2 + 1;
                    break a;
                  }
                }
                b2 = 1e3;
              }
            else
              b2 = 1e3;
            b2 = Kd(this, e3, b2);
            c2 = G(this.I);
            K(c2, "RID", a2);
            K(c2, "CVER", 22);
            this.F && K(c2, "X-HTTP-Session-Id", this.F);
            Gd(this, c2);
            f && (this.O ? b2 = "headers=" + encodeURIComponent(String(Bd(f))) + "&" + b2 : this.o && Cd(c2, this.o, f));
            Cc(this.i, e3);
            this.bb && K(c2, "TYPE", "init");
            this.P ? (K(c2, "$req", b2), K(c2, "SID", "null"), e3.aa = true, gc(e3, c2, null)) : gc(e3, c2, b2);
            this.H = 2;
          }
        } else
          3 == this.H && (a2 ? Ld(this, a2) : 0 == this.j.length || ed(this.i) || Ld(this));
    };
    k.Ma = function() {
      this.u = null;
      Md(this);
      if (this.ca && !(this.M || null == this.g || 0 >= this.S)) {
        var a2 = 2 * this.S;
        this.l.info("BP detection timer enabled: " + a2);
        this.B = Rb(q(this.jb, this), a2);
      }
    };
    k.jb = function() {
      this.B && (this.B = null, this.l.info("BP detection timeout reached."), this.l.info("Buffering proxy detected and switch to long-polling!"), this.G = false, this.M = true, F(10), zc(this), Md(this));
    };
    k.ib = function() {
      null != this.v && (this.v = null, zc(this), Ac(this), F(19));
    };
    k.pb = function(a2) {
      a2 ? (this.l.info("Successfully pinged google.com"), F(2)) : (this.l.info("Failed to ping google.com"), F(1));
    };
    k.isActive = function() {
      return !!this.h && this.h.isActive(this);
    };
    k = Nd.prototype;
    k.Ba = function() {
    };
    k.Aa = function() {
    };
    k.za = function() {
    };
    k.ya = function() {
    };
    k.isActive = function() {
      return true;
    };
    k.Va = function() {
    };
    Od.prototype.g = function(a2, b2) {
      return new Q(a2, b2);
    };
    r(Q, B);
    Q.prototype.m = function() {
      this.g.h = this.j;
      this.A && (this.g.J = true);
      var a2 = this.g, b2 = this.l, c2 = this.h || void 0;
      F(0);
      a2.Y = b2;
      a2.na = c2 || {};
      a2.G = a2.aa;
      a2.I = Dc(a2, null, a2.Y);
      Gc(a2);
    };
    Q.prototype.close = function() {
      Hc(this.g);
    };
    Q.prototype.u = function(a2) {
      var b2 = this.g;
      if ("string" === typeof a2) {
        var c2 = {};
        c2.__data__ = a2;
        a2 = c2;
      } else
        this.v && (c2 = {}, c2.__data__ = jb(a2), a2 = c2);
      b2.j.push(new bd(b2.fb++, a2));
      3 == b2.H && Gc(b2);
    };
    Q.prototype.N = function() {
      this.g.h = null;
      delete this.j;
      Hc(this.g);
      delete this.g;
      Q.$.N.call(this);
    };
    r(Pd, Yb);
    r(Qd, Zb);
    r(R, Nd);
    R.prototype.Ba = function() {
      C(this.g, "a");
    };
    R.prototype.Aa = function(a2) {
      C(this.g, new Pd(a2));
    };
    R.prototype.za = function(a2) {
      C(this.g, new Qd());
    };
    R.prototype.ya = function() {
      C(this.g, "b");
    };
    r(S, Rd);
    S.prototype.reset = function() {
      this.g[0] = 1732584193;
      this.g[1] = 4023233417;
      this.g[2] = 2562383102;
      this.g[3] = 271733878;
      this.i = this.h = 0;
    };
    S.prototype.j = function(a2, b2) {
      void 0 === b2 && (b2 = a2.length);
      for (var c2 = b2 - this.blockSize, d = this.m, e3 = this.h, f = 0; f < b2; ) {
        if (0 == e3)
          for (; f <= c2; )
            Sd(this, a2, f), f += this.blockSize;
        if ("string" === typeof a2)
          for (; f < b2; ) {
            if (d[e3++] = a2.charCodeAt(f++), e3 == this.blockSize) {
              Sd(this, d);
              e3 = 0;
              break;
            }
          }
        else
          for (; f < b2; )
            if (d[e3++] = a2[f++], e3 == this.blockSize) {
              Sd(this, d);
              e3 = 0;
              break;
            }
      }
      this.h = e3;
      this.i += b2;
    };
    S.prototype.l = function() {
      var a2 = Array((56 > this.h ? this.blockSize : 2 * this.blockSize) - this.h);
      a2[0] = 128;
      for (var b2 = 1; b2 < a2.length - 8; ++b2)
        a2[b2] = 0;
      var c2 = 8 * this.i;
      for (b2 = a2.length - 8; b2 < a2.length; ++b2)
        a2[b2] = c2 & 255, c2 /= 256;
      this.j(a2);
      a2 = Array(16);
      for (b2 = c2 = 0; 4 > b2; ++b2)
        for (var d = 0; 32 > d; d += 8)
          a2[c2++] = this.g[b2] >>> d & 255;
      return a2;
    };
    sa = {};
    Ud = 4294967296;
    V = Td(0);
    Wd = Td(1);
    Xd = Td(16777216);
    k = T.prototype;
    k.ea = function() {
      if (X(this))
        return -W(this).ea();
      for (var a2 = 0, b2 = 1, c2 = 0; c2 < this.g.length; c2++) {
        var d = this.D(c2);
        a2 += (0 <= d ? d : Ud + d) * b2;
        b2 *= Ud;
      }
      return a2;
    };
    k.toString = function(a2) {
      a2 = a2 || 10;
      if (2 > a2 || 36 < a2)
        throw Error("radix out of range: " + a2);
      if (Y(this))
        return "0";
      if (X(this))
        return "-" + W(this).toString(a2);
      for (var b2 = U(Math.pow(a2, 6)), c2 = this, d = ""; ; ) {
        var e3 = Yd(c2, b2).g;
        c2 = Zd(c2, e3.R(b2));
        var f = ((0 < c2.g.length ? c2.g[0] : c2.h) >>> 0).toString(a2);
        c2 = e3;
        if (Y(c2))
          return f + d;
        for (; 6 > f.length; )
          f = "0" + f;
        d = f + d;
      }
    };
    k.D = function(a2) {
      return 0 > a2 ? 0 : a2 < this.g.length ? this.g[a2] : this.h;
    };
    k.X = function(a2) {
      a2 = Zd(this, a2);
      return X(a2) ? -1 : Y(a2) ? 0 : 1;
    };
    k.abs = function() {
      return X(this) ? W(this) : this;
    };
    k.add = function(a2) {
      for (var b2 = Math.max(this.g.length, a2.g.length), c2 = [], d = 0, e3 = 0; e3 <= b2; e3++) {
        var f = d + (this.D(e3) & 65535) + (a2.D(e3) & 65535), h = (f >>> 16) + (this.D(e3) >>> 16) + (a2.D(e3) >>> 16);
        d = h >>> 16;
        f &= 65535;
        h &= 65535;
        c2[e3] = h << 16 | f;
      }
      return new T(c2, c2[c2.length - 1] & -2147483648 ? -1 : 0);
    };
    k.R = function(a2) {
      if (Y(this) || Y(a2))
        return V;
      if (X(this))
        return X(a2) ? W(this).R(W(a2)) : W(W(this).R(a2));
      if (X(a2))
        return W(this.R(W(a2)));
      if (0 > this.X(Xd) && 0 > a2.X(Xd))
        return U(this.ea() * a2.ea());
      for (var b2 = this.g.length + a2.g.length, c2 = [], d = 0; d < 2 * b2; d++)
        c2[d] = 0;
      for (d = 0; d < this.g.length; d++)
        for (var e3 = 0; e3 < a2.g.length; e3++) {
          var f = this.D(d) >>> 16, h = this.D(d) & 65535, n2 = a2.D(e3) >>> 16, t2 = a2.D(e3) & 65535;
          c2[2 * d + 2 * e3] += h * t2;
          $d(c2, 2 * d + 2 * e3);
          c2[2 * d + 2 * e3 + 1] += f * t2;
          $d(c2, 2 * d + 2 * e3 + 1);
          c2[2 * d + 2 * e3 + 1] += h * n2;
          $d(c2, 2 * d + 2 * e3 + 1);
          c2[2 * d + 2 * e3 + 2] += f * n2;
          $d(c2, 2 * d + 2 * e3 + 2);
        }
      for (d = 0; d < b2; d++)
        c2[d] = c2[2 * d + 1] << 16 | c2[2 * d];
      for (d = b2; d < 2 * b2; d++)
        c2[d] = 0;
      return new T(c2, 0);
    };
    k.gb = function(a2) {
      return Yd(this, a2).h;
    };
    k.and = function(a2) {
      for (var b2 = Math.max(this.g.length, a2.g.length), c2 = [], d = 0; d < b2; d++)
        c2[d] = this.D(d) & a2.D(d);
      return new T(c2, this.h & a2.h);
    };
    k.or = function(a2) {
      for (var b2 = Math.max(this.g.length, a2.g.length), c2 = [], d = 0; d < b2; d++)
        c2[d] = this.D(d) | a2.D(d);
      return new T(c2, this.h | a2.h);
    };
    k.xor = function(a2) {
      for (var b2 = Math.max(this.g.length, a2.g.length), c2 = [], d = 0; d < b2; d++)
        c2[d] = this.D(d) ^ a2.D(d);
      return new T(c2, this.h ^ a2.h);
    };
    Od.prototype.createWebChannel = Od.prototype.g;
    Q.prototype.send = Q.prototype.u;
    Q.prototype.open = Q.prototype.m;
    Q.prototype.close = Q.prototype.close;
    Sb.NO_ERROR = 0;
    Sb.TIMEOUT = 8;
    Sb.HTTP_ERROR = 6;
    Tb.COMPLETE = "complete";
    Wb.EventType = Xb;
    Xb.OPEN = "a";
    Xb.CLOSE = "b";
    Xb.ERROR = "c";
    Xb.MESSAGE = "d";
    B.prototype.listen = B.prototype.O;
    P.prototype.listenOnce = P.prototype.P;
    P.prototype.getLastError = P.prototype.Sa;
    P.prototype.getLastErrorCode = P.prototype.Ia;
    P.prototype.getStatus = P.prototype.da;
    P.prototype.getResponseJson = P.prototype.Wa;
    P.prototype.getResponseText = P.prototype.ja;
    P.prototype.send = P.prototype.ha;
    P.prototype.setWithCredentials = P.prototype.Oa;
    S.prototype.digest = S.prototype.l;
    S.prototype.reset = S.prototype.reset;
    S.prototype.update = S.prototype.j;
    T.prototype.add = T.prototype.add;
    T.prototype.multiply = T.prototype.R;
    T.prototype.modulo = T.prototype.gb;
    T.prototype.compare = T.prototype.X;
    T.prototype.toNumber = T.prototype.ea;
    T.prototype.toString = T.prototype.toString;
    T.prototype.getBits = T.prototype.D;
    T.fromNumber = U;
    T.fromString = Vd;
    createWebChannelTransport = esm.createWebChannelTransport = function() {
      return new Od();
    };
    getStatEventTarget = esm.getStatEventTarget = function() {
      return Mb();
    };
    ErrorCode = esm.ErrorCode = Sb;
    EventType = esm.EventType = Tb;
    Event2 = esm.Event = E;
    Stat = esm.Stat = { xb: 0, Ab: 1, Bb: 2, Ub: 3, Zb: 4, Wb: 5, Xb: 6, Vb: 7, Tb: 8, Yb: 9, PROXY: 10, NOPROXY: 11, Rb: 12, Nb: 13, Ob: 14, Mb: 15, Pb: 16, Qb: 17, tb: 18, sb: 19, ub: 20 };
    FetchXmlHttpFactory = esm.FetchXmlHttpFactory = ld;
    WebChannel = esm.WebChannel = Wb;
    XhrIo = esm.XhrIo = P;
    Md5 = esm.Md5 = S;
    Integer = esm.Integer = T;
  }
});
function __PRIVATE_getLogLevel() {
  return b.logLevel;
}
function __PRIVATE_logDebug(e3, ...t2) {
  if (b.logLevel <= LogLevel.DEBUG) {
    const n2 = t2.map(__PRIVATE_argToString);
    b.debug(`Firestore (${S2}): ${e3}`, ...n2);
  }
}
function __PRIVATE_logError(e3, ...t2) {
  if (b.logLevel <= LogLevel.ERROR) {
    const n2 = t2.map(__PRIVATE_argToString);
    b.error(`Firestore (${S2}): ${e3}`, ...n2);
  }
}
function __PRIVATE_logWarn(e3, ...t2) {
  if (b.logLevel <= LogLevel.WARN) {
    const n2 = t2.map(__PRIVATE_argToString);
    b.warn(`Firestore (${S2}): ${e3}`, ...n2);
  }
}
function __PRIVATE_argToString(e3) {
  if ("string" == typeof e3)
    return e3;
  try {
    return function __PRIVATE_formatJSON(e4) {
      return JSON.stringify(e4);
    }(e3);
  } catch (t2) {
    return e3;
  }
}
function fail(e3 = "Unexpected state") {
  const t2 = `FIRESTORE (${S2}) INTERNAL ASSERTION FAILED: ` + e3;
  throw __PRIVATE_logError(t2), new Error(t2);
}
function __PRIVATE_hardAssert(e3, t2) {
  e3 || fail();
}
function __PRIVATE_debugCast(e3, t2) {
  return e3;
}
function __PRIVATE_randomBytes(e3) {
  const t2 = (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    "undefined" != typeof self && (self.crypto || self.msCrypto)
  ), n2 = new Uint8Array(e3);
  if (t2 && "function" == typeof t2.getRandomValues)
    t2.getRandomValues(n2);
  else
    for (let t3 = 0; t3 < e3; t3++)
      n2[t3] = Math.floor(256 * Math.random());
  return n2;
}
function __PRIVATE_primitiveComparator(e3, t2) {
  return e3 < t2 ? -1 : e3 > t2 ? 1 : 0;
}
function __PRIVATE_arrayEquals(e3, t2, n2) {
  return e3.length === t2.length && e3.every((e4, r4) => n2(e4, t2[r4]));
}
function __PRIVATE_newIndexOffsetSuccessorFromReadTime(e3, t2) {
  const n2 = e3.toTimestamp().seconds, r4 = e3.toTimestamp().nanoseconds + 1, i3 = SnapshotVersion.fromTimestamp(1e9 === r4 ? new Timestamp(n2 + 1, 0) : new Timestamp(n2, r4));
  return new IndexOffset(i3, DocumentKey.empty(), t2);
}
function __PRIVATE_newIndexOffsetFromDocument(e3) {
  return new IndexOffset(e3.readTime, e3.key, -1);
}
function __PRIVATE_indexOffsetComparator(e3, t2) {
  let n2 = e3.readTime.compareTo(t2.readTime);
  return 0 !== n2 ? n2 : (n2 = DocumentKey.comparator(e3.documentKey, t2.documentKey), 0 !== n2 ? n2 : __PRIVATE_primitiveComparator(e3.largestBatchId, t2.largestBatchId));
}
async function __PRIVATE_ignoreIfPrimaryLeaseLoss(e3) {
  if (e3.code !== D2.FAILED_PRECONDITION || e3.message !== v2)
    throw e3;
  __PRIVATE_logDebug("LocalStore", "Unexpectedly lost primary lease");
}
function __PRIVATE_isIndexedDbTransactionError(e3) {
  return "IndexedDbTransactionError" === e3.name;
}
function __PRIVATE_wrapRequest(e3) {
  return new PersistencePromise((t2, n2) => {
    e3.onsuccess = (e4) => {
      const n3 = e4.target.result;
      t2(n3);
    }, e3.onerror = (e4) => {
      const t3 = __PRIVATE_checkForAndReportiOSError(e4.target.error);
      n2(t3);
    };
  });
}
function __PRIVATE_checkForAndReportiOSError(e3) {
  const t2 = __PRIVATE_SimpleDb.S(getUA());
  if (t2 >= 12.2 && t2 < 13) {
    const t3 = "An internal error was encountered in the Indexed Database server";
    if (e3.message.indexOf(t3) >= 0) {
      const e4 = new FirestoreError("internal", `IOS_INDEXEDDB_BUG1: IndexedDb has thrown '${t3}'. This is likely due to an unavoidable bug in iOS. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.`);
      return F2 || (F2 = true, // Throw a global exception outside of this promise chain, for the user to
      // potentially catch.
      setTimeout(() => {
        throw e4;
      }, 0)), e4;
    }
  }
  return e3;
}
function __PRIVATE_isNullOrUndefined(e3) {
  return null == e3;
}
function __PRIVATE_isNegativeZero(e3) {
  return 0 === e3 && 1 / e3 == -1 / 0;
}
function isSafeInteger(e3) {
  return "number" == typeof e3 && Number.isInteger(e3) && !__PRIVATE_isNegativeZero(e3) && e3 <= Number.MAX_SAFE_INTEGER && e3 >= Number.MIN_SAFE_INTEGER;
}
function __PRIVATE_objectSize(e3) {
  let t2 = 0;
  for (const n2 in e3)
    Object.prototype.hasOwnProperty.call(e3, n2) && t2++;
  return t2;
}
function forEach(e3, t2) {
  for (const n2 in e3)
    Object.prototype.hasOwnProperty.call(e3, n2) && t2(n2, e3[n2]);
}
function isEmpty(e3) {
  for (const t2 in e3)
    if (Object.prototype.hasOwnProperty.call(e3, t2))
      return false;
  return true;
}
function __PRIVATE_normalizeTimestamp(e3) {
  if (__PRIVATE_hardAssert(!!e3), "string" == typeof e3) {
    let t2 = 0;
    const n2 = ee.exec(e3);
    if (__PRIVATE_hardAssert(!!n2), n2[1]) {
      let e4 = n2[1];
      e4 = (e4 + "000000000").substr(0, 9), t2 = Number(e4);
    }
    const r4 = new Date(e3);
    return {
      seconds: Math.floor(r4.getTime() / 1e3),
      nanos: t2
    };
  }
  return {
    seconds: __PRIVATE_normalizeNumber(e3.seconds),
    nanos: __PRIVATE_normalizeNumber(e3.nanos)
  };
}
function __PRIVATE_normalizeNumber(e3) {
  return "number" == typeof e3 ? e3 : "string" == typeof e3 ? Number(e3) : 0;
}
function __PRIVATE_normalizeByteString(e3) {
  return "string" == typeof e3 ? ByteString.fromBase64String(e3) : ByteString.fromUint8Array(e3);
}
function __PRIVATE_isServerTimestamp(e3) {
  var t2, n2;
  return "server_timestamp" === (null === (n2 = ((null === (t2 = null == e3 ? void 0 : e3.mapValue) || void 0 === t2 ? void 0 : t2.fields) || {}).__type__) || void 0 === n2 ? void 0 : n2.stringValue);
}
function __PRIVATE_getPreviousValue(e3) {
  const t2 = e3.mapValue.fields.__previous_value__;
  return __PRIVATE_isServerTimestamp(t2) ? __PRIVATE_getPreviousValue(t2) : t2;
}
function __PRIVATE_getLocalWriteTime(e3) {
  const t2 = __PRIVATE_normalizeTimestamp(e3.mapValue.fields.__local_write_time__.timestampValue);
  return new Timestamp(t2.seconds, t2.nanos);
}
function __PRIVATE_typeOrder(e3) {
  return "nullValue" in e3 ? 0 : "booleanValue" in e3 ? 1 : "integerValue" in e3 || "doubleValue" in e3 ? 2 : "timestampValue" in e3 ? 3 : "stringValue" in e3 ? 5 : "bytesValue" in e3 ? 6 : "referenceValue" in e3 ? 7 : "geoPointValue" in e3 ? 8 : "arrayValue" in e3 ? 9 : "mapValue" in e3 ? __PRIVATE_isServerTimestamp(e3) ? 4 : __PRIVATE_isMaxValue(e3) ? 9007199254740991 : 10 : fail();
}
function __PRIVATE_valueEquals(e3, t2) {
  if (e3 === t2)
    return true;
  const n2 = __PRIVATE_typeOrder(e3);
  if (n2 !== __PRIVATE_typeOrder(t2))
    return false;
  switch (n2) {
    case 0:
    case 9007199254740991:
      return true;
    case 1:
      return e3.booleanValue === t2.booleanValue;
    case 4:
      return __PRIVATE_getLocalWriteTime(e3).isEqual(__PRIVATE_getLocalWriteTime(t2));
    case 3:
      return function __PRIVATE_timestampEquals(e4, t3) {
        if ("string" == typeof e4.timestampValue && "string" == typeof t3.timestampValue && e4.timestampValue.length === t3.timestampValue.length)
          return e4.timestampValue === t3.timestampValue;
        const n3 = __PRIVATE_normalizeTimestamp(e4.timestampValue), r4 = __PRIVATE_normalizeTimestamp(t3.timestampValue);
        return n3.seconds === r4.seconds && n3.nanos === r4.nanos;
      }(e3, t2);
    case 5:
      return e3.stringValue === t2.stringValue;
    case 6:
      return function __PRIVATE_blobEquals(e4, t3) {
        return __PRIVATE_normalizeByteString(e4.bytesValue).isEqual(__PRIVATE_normalizeByteString(t3.bytesValue));
      }(e3, t2);
    case 7:
      return e3.referenceValue === t2.referenceValue;
    case 8:
      return function __PRIVATE_geoPointEquals(e4, t3) {
        return __PRIVATE_normalizeNumber(e4.geoPointValue.latitude) === __PRIVATE_normalizeNumber(t3.geoPointValue.latitude) && __PRIVATE_normalizeNumber(e4.geoPointValue.longitude) === __PRIVATE_normalizeNumber(t3.geoPointValue.longitude);
      }(e3, t2);
    case 2:
      return function __PRIVATE_numberEquals(e4, t3) {
        if ("integerValue" in e4 && "integerValue" in t3)
          return __PRIVATE_normalizeNumber(e4.integerValue) === __PRIVATE_normalizeNumber(t3.integerValue);
        if ("doubleValue" in e4 && "doubleValue" in t3) {
          const n3 = __PRIVATE_normalizeNumber(e4.doubleValue), r4 = __PRIVATE_normalizeNumber(t3.doubleValue);
          return n3 === r4 ? __PRIVATE_isNegativeZero(n3) === __PRIVATE_isNegativeZero(r4) : isNaN(n3) && isNaN(r4);
        }
        return false;
      }(e3, t2);
    case 9:
      return __PRIVATE_arrayEquals(e3.arrayValue.values || [], t2.arrayValue.values || [], __PRIVATE_valueEquals);
    case 10:
      return function __PRIVATE_objectEquals(e4, t3) {
        const n3 = e4.mapValue.fields || {}, r4 = t3.mapValue.fields || {};
        if (__PRIVATE_objectSize(n3) !== __PRIVATE_objectSize(r4))
          return false;
        for (const e5 in n3)
          if (n3.hasOwnProperty(e5) && (void 0 === r4[e5] || !__PRIVATE_valueEquals(n3[e5], r4[e5])))
            return false;
        return true;
      }(e3, t2);
    default:
      return fail();
  }
}
function __PRIVATE_arrayValueContains(e3, t2) {
  return void 0 !== (e3.values || []).find((e4) => __PRIVATE_valueEquals(e4, t2));
}
function __PRIVATE_valueCompare(e3, t2) {
  if (e3 === t2)
    return 0;
  const n2 = __PRIVATE_typeOrder(e3), r4 = __PRIVATE_typeOrder(t2);
  if (n2 !== r4)
    return __PRIVATE_primitiveComparator(n2, r4);
  switch (n2) {
    case 0:
    case 9007199254740991:
      return 0;
    case 1:
      return __PRIVATE_primitiveComparator(e3.booleanValue, t2.booleanValue);
    case 2:
      return function __PRIVATE_compareNumbers(e4, t3) {
        const n3 = __PRIVATE_normalizeNumber(e4.integerValue || e4.doubleValue), r5 = __PRIVATE_normalizeNumber(t3.integerValue || t3.doubleValue);
        return n3 < r5 ? -1 : n3 > r5 ? 1 : n3 === r5 ? 0 : (
          // one or both are NaN.
          isNaN(n3) ? isNaN(r5) ? 0 : -1 : 1
        );
      }(e3, t2);
    case 3:
      return __PRIVATE_compareTimestamps(e3.timestampValue, t2.timestampValue);
    case 4:
      return __PRIVATE_compareTimestamps(__PRIVATE_getLocalWriteTime(e3), __PRIVATE_getLocalWriteTime(t2));
    case 5:
      return __PRIVATE_primitiveComparator(e3.stringValue, t2.stringValue);
    case 6:
      return function __PRIVATE_compareBlobs(e4, t3) {
        const n3 = __PRIVATE_normalizeByteString(e4), r5 = __PRIVATE_normalizeByteString(t3);
        return n3.compareTo(r5);
      }(e3.bytesValue, t2.bytesValue);
    case 7:
      return function __PRIVATE_compareReferences(e4, t3) {
        const n3 = e4.split("/"), r5 = t3.split("/");
        for (let e5 = 0; e5 < n3.length && e5 < r5.length; e5++) {
          const t4 = __PRIVATE_primitiveComparator(n3[e5], r5[e5]);
          if (0 !== t4)
            return t4;
        }
        return __PRIVATE_primitiveComparator(n3.length, r5.length);
      }(e3.referenceValue, t2.referenceValue);
    case 8:
      return function __PRIVATE_compareGeoPoints(e4, t3) {
        const n3 = __PRIVATE_primitiveComparator(__PRIVATE_normalizeNumber(e4.latitude), __PRIVATE_normalizeNumber(t3.latitude));
        if (0 !== n3)
          return n3;
        return __PRIVATE_primitiveComparator(__PRIVATE_normalizeNumber(e4.longitude), __PRIVATE_normalizeNumber(t3.longitude));
      }(e3.geoPointValue, t2.geoPointValue);
    case 9:
      return function __PRIVATE_compareArrays(e4, t3) {
        const n3 = e4.values || [], r5 = t3.values || [];
        for (let e5 = 0; e5 < n3.length && e5 < r5.length; ++e5) {
          const t4 = __PRIVATE_valueCompare(n3[e5], r5[e5]);
          if (t4)
            return t4;
        }
        return __PRIVATE_primitiveComparator(n3.length, r5.length);
      }(e3.arrayValue, t2.arrayValue);
    case 10:
      return function __PRIVATE_compareMaps(e4, t3) {
        if (e4 === te.mapValue && t3 === te.mapValue)
          return 0;
        if (e4 === te.mapValue)
          return 1;
        if (t3 === te.mapValue)
          return -1;
        const n3 = e4.fields || {}, r5 = Object.keys(n3), i3 = t3.fields || {}, s3 = Object.keys(i3);
        r5.sort(), s3.sort();
        for (let e5 = 0; e5 < r5.length && e5 < s3.length; ++e5) {
          const t4 = __PRIVATE_primitiveComparator(r5[e5], s3[e5]);
          if (0 !== t4)
            return t4;
          const o2 = __PRIVATE_valueCompare(n3[r5[e5]], i3[s3[e5]]);
          if (0 !== o2)
            return o2;
        }
        return __PRIVATE_primitiveComparator(r5.length, s3.length);
      }(e3.mapValue, t2.mapValue);
    default:
      throw fail();
  }
}
function __PRIVATE_compareTimestamps(e3, t2) {
  if ("string" == typeof e3 && "string" == typeof t2 && e3.length === t2.length)
    return __PRIVATE_primitiveComparator(e3, t2);
  const n2 = __PRIVATE_normalizeTimestamp(e3), r4 = __PRIVATE_normalizeTimestamp(t2), i3 = __PRIVATE_primitiveComparator(n2.seconds, r4.seconds);
  return 0 !== i3 ? i3 : __PRIVATE_primitiveComparator(n2.nanos, r4.nanos);
}
function canonicalId(e3) {
  return __PRIVATE_canonifyValue(e3);
}
function __PRIVATE_canonifyValue(e3) {
  return "nullValue" in e3 ? "null" : "booleanValue" in e3 ? "" + e3.booleanValue : "integerValue" in e3 ? "" + e3.integerValue : "doubleValue" in e3 ? "" + e3.doubleValue : "timestampValue" in e3 ? function __PRIVATE_canonifyTimestamp(e4) {
    const t2 = __PRIVATE_normalizeTimestamp(e4);
    return `time(${t2.seconds},${t2.nanos})`;
  }(e3.timestampValue) : "stringValue" in e3 ? e3.stringValue : "bytesValue" in e3 ? function __PRIVATE_canonifyByteString(e4) {
    return __PRIVATE_normalizeByteString(e4).toBase64();
  }(e3.bytesValue) : "referenceValue" in e3 ? function __PRIVATE_canonifyReference(e4) {
    return DocumentKey.fromName(e4).toString();
  }(e3.referenceValue) : "geoPointValue" in e3 ? function __PRIVATE_canonifyGeoPoint(e4) {
    return `geo(${e4.latitude},${e4.longitude})`;
  }(e3.geoPointValue) : "arrayValue" in e3 ? function __PRIVATE_canonifyArray(e4) {
    let t2 = "[", n2 = true;
    for (const r4 of e4.values || [])
      n2 ? n2 = false : t2 += ",", t2 += __PRIVATE_canonifyValue(r4);
    return t2 + "]";
  }(e3.arrayValue) : "mapValue" in e3 ? function __PRIVATE_canonifyMap(e4) {
    const t2 = Object.keys(e4.fields || {}).sort();
    let n2 = "{", r4 = true;
    for (const i3 of t2)
      r4 ? r4 = false : n2 += ",", n2 += `${i3}:${__PRIVATE_canonifyValue(e4.fields[i3])}`;
    return n2 + "}";
  }(e3.mapValue) : fail();
}
function isInteger(e3) {
  return !!e3 && "integerValue" in e3;
}
function isArray(e3) {
  return !!e3 && "arrayValue" in e3;
}
function __PRIVATE_isNullValue(e3) {
  return !!e3 && "nullValue" in e3;
}
function __PRIVATE_isNanValue(e3) {
  return !!e3 && "doubleValue" in e3 && isNaN(Number(e3.doubleValue));
}
function __PRIVATE_isMapValue(e3) {
  return !!e3 && "mapValue" in e3;
}
function __PRIVATE_deepClone(e3) {
  if (e3.geoPointValue)
    return {
      geoPointValue: Object.assign({}, e3.geoPointValue)
    };
  if (e3.timestampValue && "object" == typeof e3.timestampValue)
    return {
      timestampValue: Object.assign({}, e3.timestampValue)
    };
  if (e3.mapValue) {
    const t2 = {
      mapValue: {
        fields: {}
      }
    };
    return forEach(e3.mapValue.fields, (e4, n2) => t2.mapValue.fields[e4] = __PRIVATE_deepClone(n2)), t2;
  }
  if (e3.arrayValue) {
    const t2 = {
      arrayValue: {
        values: []
      }
    };
    for (let n2 = 0; n2 < (e3.arrayValue.values || []).length; ++n2)
      t2.arrayValue.values[n2] = __PRIVATE_deepClone(e3.arrayValue.values[n2]);
    return t2;
  }
  return Object.assign({}, e3);
}
function __PRIVATE_isMaxValue(e3) {
  return "__max__" === (((e3.mapValue || {}).fields || {}).__type__ || {}).stringValue;
}
function __PRIVATE_extractFieldMask(e3) {
  const t2 = [];
  return forEach(e3.fields, (e4, n2) => {
    const r4 = new FieldPath$1([e4]);
    if (__PRIVATE_isMapValue(n2)) {
      const e5 = __PRIVATE_extractFieldMask(n2.mapValue).fields;
      if (0 === e5.length)
        t2.push(r4);
      else
        for (const n3 of e5)
          t2.push(r4.child(n3));
    } else
      t2.push(r4);
  }), new FieldMask(t2);
}
function __PRIVATE_boundCompareToDocument(e3, t2, n2) {
  let r4 = 0;
  for (let i3 = 0; i3 < e3.position.length; i3++) {
    const s3 = t2[i3], o2 = e3.position[i3];
    if (s3.field.isKeyField())
      r4 = DocumentKey.comparator(DocumentKey.fromName(o2.referenceValue), n2.key);
    else {
      r4 = __PRIVATE_valueCompare(o2, n2.data.field(s3.field));
    }
    if ("desc" === s3.dir && (r4 *= -1), 0 !== r4)
      break;
  }
  return r4;
}
function __PRIVATE_boundEquals(e3, t2) {
  if (null === e3)
    return null === t2;
  if (null === t2)
    return false;
  if (e3.inclusive !== t2.inclusive || e3.position.length !== t2.position.length)
    return false;
  for (let n2 = 0; n2 < e3.position.length; n2++) {
    if (!__PRIVATE_valueEquals(e3.position[n2], t2.position[n2]))
      return false;
  }
  return true;
}
function __PRIVATE_orderByEquals(e3, t2) {
  return e3.dir === t2.dir && e3.field.isEqual(t2.field);
}
function __PRIVATE_compositeFilterIsConjunction(e3) {
  return "and" === e3.op;
}
function __PRIVATE_compositeFilterIsFlatConjunction(e3) {
  return __PRIVATE_compositeFilterIsFlat(e3) && __PRIVATE_compositeFilterIsConjunction(e3);
}
function __PRIVATE_compositeFilterIsFlat(e3) {
  for (const t2 of e3.filters)
    if (t2 instanceof CompositeFilter)
      return false;
  return true;
}
function __PRIVATE_canonifyFilter(e3) {
  if (e3 instanceof FieldFilter)
    return e3.field.canonicalString() + e3.op.toString() + canonicalId(e3.value);
  if (__PRIVATE_compositeFilterIsFlatConjunction(e3))
    return e3.filters.map((e4) => __PRIVATE_canonifyFilter(e4)).join(",");
  {
    const t2 = e3.filters.map((e4) => __PRIVATE_canonifyFilter(e4)).join(",");
    return `${e3.op}(${t2})`;
  }
}
function __PRIVATE_filterEquals(e3, t2) {
  return e3 instanceof FieldFilter ? function __PRIVATE_fieldFilterEquals(e4, t3) {
    return t3 instanceof FieldFilter && e4.op === t3.op && e4.field.isEqual(t3.field) && __PRIVATE_valueEquals(e4.value, t3.value);
  }(e3, t2) : e3 instanceof CompositeFilter ? function __PRIVATE_compositeFilterEquals(e4, t3) {
    if (t3 instanceof CompositeFilter && e4.op === t3.op && e4.filters.length === t3.filters.length) {
      return e4.filters.reduce((e5, n2, r4) => e5 && __PRIVATE_filterEquals(n2, t3.filters[r4]), true);
    }
    return false;
  }(e3, t2) : void fail();
}
function __PRIVATE_stringifyFilter(e3) {
  return e3 instanceof FieldFilter ? function __PRIVATE_stringifyFieldFilter(e4) {
    return `${e4.field.canonicalString()} ${e4.op} ${canonicalId(e4.value)}`;
  }(e3) : e3 instanceof CompositeFilter ? function __PRIVATE_stringifyCompositeFilter(e4) {
    return e4.op.toString() + " {" + e4.getFilters().map(__PRIVATE_stringifyFilter).join(" ,") + "}";
  }(e3) : "Filter";
}
function __PRIVATE_extractDocumentKeysFromArrayValue(e3, t2) {
  var n2;
  return ((null === (n2 = t2.arrayValue) || void 0 === n2 ? void 0 : n2.values) || []).map((e4) => DocumentKey.fromName(e4.referenceValue));
}
function __PRIVATE_newTarget(e3, t2 = null, n2 = [], r4 = [], i3 = null, s3 = null, o2 = null) {
  return new __PRIVATE_TargetImpl(e3, t2, n2, r4, i3, s3, o2);
}
function __PRIVATE_canonifyTarget(e3) {
  const t2 = __PRIVATE_debugCast(e3);
  if (null === t2.ce) {
    let e4 = t2.path.canonicalString();
    null !== t2.collectionGroup && (e4 += "|cg:" + t2.collectionGroup), e4 += "|f:", e4 += t2.filters.map((e5) => __PRIVATE_canonifyFilter(e5)).join(","), e4 += "|ob:", e4 += t2.orderBy.map((e5) => function __PRIVATE_canonifyOrderBy(e6) {
      return e6.field.canonicalString() + e6.dir;
    }(e5)).join(","), __PRIVATE_isNullOrUndefined(t2.limit) || (e4 += "|l:", e4 += t2.limit), t2.startAt && (e4 += "|lb:", e4 += t2.startAt.inclusive ? "b:" : "a:", e4 += t2.startAt.position.map((e5) => canonicalId(e5)).join(",")), t2.endAt && (e4 += "|ub:", e4 += t2.endAt.inclusive ? "a:" : "b:", e4 += t2.endAt.position.map((e5) => canonicalId(e5)).join(",")), t2.ce = e4;
  }
  return t2.ce;
}
function __PRIVATE_targetEquals(e3, t2) {
  if (e3.limit !== t2.limit)
    return false;
  if (e3.orderBy.length !== t2.orderBy.length)
    return false;
  for (let n2 = 0; n2 < e3.orderBy.length; n2++)
    if (!__PRIVATE_orderByEquals(e3.orderBy[n2], t2.orderBy[n2]))
      return false;
  if (e3.filters.length !== t2.filters.length)
    return false;
  for (let n2 = 0; n2 < e3.filters.length; n2++)
    if (!__PRIVATE_filterEquals(e3.filters[n2], t2.filters[n2]))
      return false;
  return e3.collectionGroup === t2.collectionGroup && (!!e3.path.isEqual(t2.path) && (!!__PRIVATE_boundEquals(e3.startAt, t2.startAt) && __PRIVATE_boundEquals(e3.endAt, t2.endAt)));
}
function __PRIVATE_targetIsDocumentTarget(e3) {
  return DocumentKey.isDocumentKey(e3.path) && null === e3.collectionGroup && 0 === e3.filters.length;
}
function __PRIVATE_newQuery(e3, t2, n2, r4, i3, s3, o2, _) {
  return new __PRIVATE_QueryImpl(e3, t2, n2, r4, i3, s3, o2, _);
}
function __PRIVATE_newQueryForPath(e3) {
  return new __PRIVATE_QueryImpl(e3);
}
function __PRIVATE_queryMatchesAllDocuments(e3) {
  return 0 === e3.filters.length && null === e3.limit && null == e3.startAt && null == e3.endAt && (0 === e3.explicitOrderBy.length || 1 === e3.explicitOrderBy.length && e3.explicitOrderBy[0].field.isKeyField());
}
function __PRIVATE_isCollectionGroupQuery(e3) {
  return null !== e3.collectionGroup;
}
function __PRIVATE_queryNormalizedOrderBy(e3) {
  const t2 = __PRIVATE_debugCast(e3);
  if (null === t2.le) {
    t2.le = [];
    const e4 = /* @__PURE__ */ new Set();
    for (const n3 of t2.explicitOrderBy)
      t2.le.push(n3), e4.add(n3.field.canonicalString());
    const n2 = t2.explicitOrderBy.length > 0 ? t2.explicitOrderBy[t2.explicitOrderBy.length - 1].dir : "asc", r4 = function __PRIVATE_getInequalityFilterFields(e5) {
      let t3 = new SortedSet(FieldPath$1.comparator);
      return e5.filters.forEach((e6) => {
        e6.getFlattenedFilters().forEach((e7) => {
          e7.isInequality() && (t3 = t3.add(e7.field));
        });
      }), t3;
    }(t2);
    r4.forEach((r5) => {
      e4.has(r5.canonicalString()) || r5.isKeyField() || t2.le.push(new OrderBy(r5, n2));
    }), // Add the document key field to the last if it is not explicitly ordered.
    e4.has(FieldPath$1.keyField().canonicalString()) || t2.le.push(new OrderBy(FieldPath$1.keyField(), n2));
  }
  return t2.le;
}
function __PRIVATE_queryToTarget(e3) {
  const t2 = __PRIVATE_debugCast(e3);
  return t2.he || (t2.he = __PRIVATE__queryToTarget(t2, __PRIVATE_queryNormalizedOrderBy(e3))), t2.he;
}
function __PRIVATE__queryToTarget(e3, t2) {
  if ("F" === e3.limitType)
    return __PRIVATE_newTarget(e3.path, e3.collectionGroup, t2, e3.filters, e3.limit, e3.startAt, e3.endAt);
  {
    t2 = t2.map((e4) => {
      const t3 = "desc" === e4.dir ? "asc" : "desc";
      return new OrderBy(e4.field, t3);
    });
    const n2 = e3.endAt ? new Bound(e3.endAt.position, e3.endAt.inclusive) : null, r4 = e3.startAt ? new Bound(e3.startAt.position, e3.startAt.inclusive) : null;
    return __PRIVATE_newTarget(e3.path, e3.collectionGroup, t2, e3.filters, e3.limit, n2, r4);
  }
}
function __PRIVATE_queryWithLimit(e3, t2, n2) {
  return new __PRIVATE_QueryImpl(e3.path, e3.collectionGroup, e3.explicitOrderBy.slice(), e3.filters.slice(), t2, n2, e3.startAt, e3.endAt);
}
function __PRIVATE_queryEquals(e3, t2) {
  return __PRIVATE_targetEquals(__PRIVATE_queryToTarget(e3), __PRIVATE_queryToTarget(t2)) && e3.limitType === t2.limitType;
}
function __PRIVATE_canonifyQuery(e3) {
  return `${__PRIVATE_canonifyTarget(__PRIVATE_queryToTarget(e3))}|lt:${e3.limitType}`;
}
function __PRIVATE_stringifyQuery(e3) {
  return `Query(target=${function __PRIVATE_stringifyTarget(e4) {
    let t2 = e4.path.canonicalString();
    return null !== e4.collectionGroup && (t2 += " collectionGroup=" + e4.collectionGroup), e4.filters.length > 0 && (t2 += `, filters: [${e4.filters.map((e5) => __PRIVATE_stringifyFilter(e5)).join(", ")}]`), __PRIVATE_isNullOrUndefined(e4.limit) || (t2 += ", limit: " + e4.limit), e4.orderBy.length > 0 && (t2 += `, orderBy: [${e4.orderBy.map((e5) => function __PRIVATE_stringifyOrderBy(e6) {
      return `${e6.field.canonicalString()} (${e6.dir})`;
    }(e5)).join(", ")}]`), e4.startAt && (t2 += ", startAt: ", t2 += e4.startAt.inclusive ? "b:" : "a:", t2 += e4.startAt.position.map((e5) => canonicalId(e5)).join(",")), e4.endAt && (t2 += ", endAt: ", t2 += e4.endAt.inclusive ? "a:" : "b:", t2 += e4.endAt.position.map((e5) => canonicalId(e5)).join(",")), `Target(${t2})`;
  }(__PRIVATE_queryToTarget(e3))}; limitType=${e3.limitType})`;
}
function __PRIVATE_queryMatches(e3, t2) {
  return t2.isFoundDocument() && function __PRIVATE_queryMatchesPathAndCollectionGroup(e4, t3) {
    const n2 = t3.key.path;
    return null !== e4.collectionGroup ? t3.key.hasCollectionId(e4.collectionGroup) && e4.path.isPrefixOf(n2) : DocumentKey.isDocumentKey(e4.path) ? e4.path.isEqual(n2) : e4.path.isImmediateParentOf(n2);
  }(e3, t2) && function __PRIVATE_queryMatchesOrderBy(e4, t3) {
    for (const n2 of __PRIVATE_queryNormalizedOrderBy(e4))
      if (!n2.field.isKeyField() && null === t3.data.field(n2.field))
        return false;
    return true;
  }(e3, t2) && function __PRIVATE_queryMatchesFilters(e4, t3) {
    for (const n2 of e4.filters)
      if (!n2.matches(t3))
        return false;
    return true;
  }(e3, t2) && function __PRIVATE_queryMatchesBounds(e4, t3) {
    if (e4.startAt && !/**
    * Returns true if a document sorts before a bound using the provided sort
    * order.
    */
    function __PRIVATE_boundSortsBeforeDocument(e5, t4, n2) {
      const r4 = __PRIVATE_boundCompareToDocument(e5, t4, n2);
      return e5.inclusive ? r4 <= 0 : r4 < 0;
    }(e4.startAt, __PRIVATE_queryNormalizedOrderBy(e4), t3))
      return false;
    if (e4.endAt && !function __PRIVATE_boundSortsAfterDocument(e5, t4, n2) {
      const r4 = __PRIVATE_boundCompareToDocument(e5, t4, n2);
      return e5.inclusive ? r4 >= 0 : r4 > 0;
    }(e4.endAt, __PRIVATE_queryNormalizedOrderBy(e4), t3))
      return false;
    return true;
  }(e3, t2);
}
function __PRIVATE_queryCollectionGroup(e3) {
  return e3.collectionGroup || (e3.path.length % 2 == 1 ? e3.path.lastSegment() : e3.path.get(e3.path.length - 2));
}
function __PRIVATE_newQueryComparator(e3) {
  return (t2, n2) => {
    let r4 = false;
    for (const i3 of __PRIVATE_queryNormalizedOrderBy(e3)) {
      const e4 = __PRIVATE_compareDocs(i3, t2, n2);
      if (0 !== e4)
        return e4;
      r4 = r4 || i3.field.isKeyField();
    }
    return 0;
  };
}
function __PRIVATE_compareDocs(e3, t2, n2) {
  const r4 = e3.field.isKeyField() ? DocumentKey.comparator(t2.key, n2.key) : function __PRIVATE_compareDocumentsByField(e4, t3, n3) {
    const r5 = t3.data.field(e4), i3 = n3.data.field(e4);
    return null !== r5 && null !== i3 ? __PRIVATE_valueCompare(r5, i3) : fail();
  }(e3.field, t2, n2);
  switch (e3.dir) {
    case "asc":
      return r4;
    case "desc":
      return -1 * r4;
    default:
      return fail();
  }
}
function __PRIVATE_mutableDocumentMap() {
  return re;
}
function documentMap(...e3) {
  let t2 = ie;
  for (const n2 of e3)
    t2 = t2.insert(n2.key, n2);
  return t2;
}
function __PRIVATE_convertOverlayedDocumentMapToDocumentMap(e3) {
  let t2 = ie;
  return e3.forEach((e4, n2) => t2 = t2.insert(e4, n2.overlayedDocument)), t2;
}
function __PRIVATE_newOverlayMap() {
  return __PRIVATE_newDocumentKeyMap();
}
function __PRIVATE_newMutationMap() {
  return __PRIVATE_newDocumentKeyMap();
}
function __PRIVATE_newDocumentKeyMap() {
  return new ObjectMap((e3) => e3.toString(), (e3, t2) => e3.isEqual(t2));
}
function __PRIVATE_documentKeySet(...e3) {
  let t2 = oe;
  for (const n2 of e3)
    t2 = t2.add(n2);
  return t2;
}
function __PRIVATE_targetIdSet() {
  return _e;
}
function __PRIVATE_toDouble(e3, t2) {
  if (e3.useProto3Json) {
    if (isNaN(t2))
      return {
        doubleValue: "NaN"
      };
    if (t2 === 1 / 0)
      return {
        doubleValue: "Infinity"
      };
    if (t2 === -1 / 0)
      return {
        doubleValue: "-Infinity"
      };
  }
  return {
    doubleValue: __PRIVATE_isNegativeZero(t2) ? "-0" : t2
  };
}
function __PRIVATE_toInteger(e3) {
  return {
    integerValue: "" + e3
  };
}
function toNumber(e3, t2) {
  return isSafeInteger(t2) ? __PRIVATE_toInteger(t2) : __PRIVATE_toDouble(e3, t2);
}
function __PRIVATE_applyTransformOperationToLocalView(e3, t2, n2) {
  return e3 instanceof __PRIVATE_ServerTimestampTransform ? function serverTimestamp$1(e4, t3) {
    const n3 = {
      fields: {
        __type__: {
          stringValue: "server_timestamp"
        },
        __local_write_time__: {
          timestampValue: {
            seconds: e4.seconds,
            nanos: e4.nanoseconds
          }
        }
      }
    };
    return t3 && __PRIVATE_isServerTimestamp(t3) && (t3 = __PRIVATE_getPreviousValue(t3)), t3 && (n3.fields.__previous_value__ = t3), {
      mapValue: n3
    };
  }(n2, t2) : e3 instanceof __PRIVATE_ArrayUnionTransformOperation ? __PRIVATE_applyArrayUnionTransformOperation(e3, t2) : e3 instanceof __PRIVATE_ArrayRemoveTransformOperation ? __PRIVATE_applyArrayRemoveTransformOperation(e3, t2) : function __PRIVATE_applyNumericIncrementTransformOperationToLocalView(e4, t3) {
    const n3 = __PRIVATE_computeTransformOperationBaseValue(e4, t3), r4 = asNumber(n3) + asNumber(e4.Ie);
    return isInteger(n3) && isInteger(e4.Ie) ? __PRIVATE_toInteger(r4) : __PRIVATE_toDouble(e4.serializer, r4);
  }(e3, t2);
}
function __PRIVATE_applyTransformOperationToRemoteDocument(e3, t2, n2) {
  return e3 instanceof __PRIVATE_ArrayUnionTransformOperation ? __PRIVATE_applyArrayUnionTransformOperation(e3, t2) : e3 instanceof __PRIVATE_ArrayRemoveTransformOperation ? __PRIVATE_applyArrayRemoveTransformOperation(e3, t2) : n2;
}
function __PRIVATE_computeTransformOperationBaseValue(e3, t2) {
  return e3 instanceof __PRIVATE_NumericIncrementTransformOperation ? (
    /** Returns true if `value` is either an IntegerValue or a DoubleValue. */
    function __PRIVATE_isNumber(e4) {
      return isInteger(e4) || function __PRIVATE_isDouble(e5) {
        return !!e5 && "doubleValue" in e5;
      }(e4);
    }(t2) ? t2 : {
      integerValue: 0
    }
  ) : null;
}
function __PRIVATE_applyArrayUnionTransformOperation(e3, t2) {
  const n2 = __PRIVATE_coercedFieldValuesArray(t2);
  for (const t3 of e3.elements)
    n2.some((e4) => __PRIVATE_valueEquals(e4, t3)) || n2.push(t3);
  return {
    arrayValue: {
      values: n2
    }
  };
}
function __PRIVATE_applyArrayRemoveTransformOperation(e3, t2) {
  let n2 = __PRIVATE_coercedFieldValuesArray(t2);
  for (const t3 of e3.elements)
    n2 = n2.filter((e4) => !__PRIVATE_valueEquals(e4, t3));
  return {
    arrayValue: {
      values: n2
    }
  };
}
function asNumber(e3) {
  return __PRIVATE_normalizeNumber(e3.integerValue || e3.doubleValue);
}
function __PRIVATE_coercedFieldValuesArray(e3) {
  return isArray(e3) && e3.arrayValue.values ? e3.arrayValue.values.slice() : [];
}
function __PRIVATE_fieldTransformEquals(e3, t2) {
  return e3.field.isEqual(t2.field) && function __PRIVATE_transformOperationEquals(e4, t3) {
    return e4 instanceof __PRIVATE_ArrayUnionTransformOperation && t3 instanceof __PRIVATE_ArrayUnionTransformOperation || e4 instanceof __PRIVATE_ArrayRemoveTransformOperation && t3 instanceof __PRIVATE_ArrayRemoveTransformOperation ? __PRIVATE_arrayEquals(e4.elements, t3.elements, __PRIVATE_valueEquals) : e4 instanceof __PRIVATE_NumericIncrementTransformOperation && t3 instanceof __PRIVATE_NumericIncrementTransformOperation ? __PRIVATE_valueEquals(e4.Ie, t3.Ie) : e4 instanceof __PRIVATE_ServerTimestampTransform && t3 instanceof __PRIVATE_ServerTimestampTransform;
  }(e3.transform, t2.transform);
}
function __PRIVATE_preconditionIsValidForDocument(e3, t2) {
  return void 0 !== e3.updateTime ? t2.isFoundDocument() && t2.version.isEqual(e3.updateTime) : void 0 === e3.exists || e3.exists === t2.isFoundDocument();
}
function __PRIVATE_calculateOverlayMutation(e3, t2) {
  if (!e3.hasLocalMutations || t2 && 0 === t2.fields.length)
    return null;
  if (null === t2)
    return e3.isNoDocument() ? new __PRIVATE_DeleteMutation(e3.key, Precondition.none()) : new __PRIVATE_SetMutation(e3.key, e3.data, Precondition.none());
  {
    const n2 = e3.data, r4 = ObjectValue.empty();
    let i3 = new SortedSet(FieldPath$1.comparator);
    for (let e4 of t2.fields)
      if (!i3.has(e4)) {
        let t3 = n2.field(e4);
        null === t3 && e4.length > 1 && (e4 = e4.popLast(), t3 = n2.field(e4)), null === t3 ? r4.delete(e4) : r4.set(e4, t3), i3 = i3.add(e4);
      }
    return new __PRIVATE_PatchMutation(e3.key, r4, new FieldMask(i3.toArray()), Precondition.none());
  }
}
function __PRIVATE_mutationApplyToRemoteDocument(e3, t2, n2) {
  e3 instanceof __PRIVATE_SetMutation ? function __PRIVATE_setMutationApplyToRemoteDocument(e4, t3, n3) {
    const r4 = e4.value.clone(), i3 = __PRIVATE_serverTransformResults(e4.fieldTransforms, t3, n3.transformResults);
    r4.setAll(i3), t3.convertToFoundDocument(n3.version, r4).setHasCommittedMutations();
  }(e3, t2, n2) : e3 instanceof __PRIVATE_PatchMutation ? function __PRIVATE_patchMutationApplyToRemoteDocument(e4, t3, n3) {
    if (!__PRIVATE_preconditionIsValidForDocument(e4.precondition, t3))
      return void t3.convertToUnknownDocument(n3.version);
    const r4 = __PRIVATE_serverTransformResults(e4.fieldTransforms, t3, n3.transformResults), i3 = t3.data;
    i3.setAll(__PRIVATE_getPatch(e4)), i3.setAll(r4), t3.convertToFoundDocument(n3.version, i3).setHasCommittedMutations();
  }(e3, t2, n2) : function __PRIVATE_deleteMutationApplyToRemoteDocument(e4, t3, n3) {
    t3.convertToNoDocument(n3.version).setHasCommittedMutations();
  }(0, t2, n2);
}
function __PRIVATE_mutationApplyToLocalView(e3, t2, n2, r4) {
  return e3 instanceof __PRIVATE_SetMutation ? function __PRIVATE_setMutationApplyToLocalView(e4, t3, n3, r5) {
    if (!__PRIVATE_preconditionIsValidForDocument(e4.precondition, t3))
      return n3;
    const i3 = e4.value.clone(), s3 = __PRIVATE_localTransformResults(e4.fieldTransforms, r5, t3);
    return i3.setAll(s3), t3.convertToFoundDocument(t3.version, i3).setHasLocalMutations(), null;
  }(e3, t2, n2, r4) : e3 instanceof __PRIVATE_PatchMutation ? function __PRIVATE_patchMutationApplyToLocalView(e4, t3, n3, r5) {
    if (!__PRIVATE_preconditionIsValidForDocument(e4.precondition, t3))
      return n3;
    const i3 = __PRIVATE_localTransformResults(e4.fieldTransforms, r5, t3), s3 = t3.data;
    if (s3.setAll(__PRIVATE_getPatch(e4)), s3.setAll(i3), t3.convertToFoundDocument(t3.version, s3).setHasLocalMutations(), null === n3)
      return null;
    return n3.unionWith(e4.fieldMask.fields).unionWith(e4.fieldTransforms.map((e5) => e5.field));
  }(e3, t2, n2, r4) : function __PRIVATE_deleteMutationApplyToLocalView(e4, t3, n3) {
    if (__PRIVATE_preconditionIsValidForDocument(e4.precondition, t3))
      return t3.convertToNoDocument(t3.version).setHasLocalMutations(), null;
    return n3;
  }(e3, t2, n2);
}
function __PRIVATE_mutationExtractBaseValue(e3, t2) {
  let n2 = null;
  for (const r4 of e3.fieldTransforms) {
    const e4 = t2.data.field(r4.field), i3 = __PRIVATE_computeTransformOperationBaseValue(r4.transform, e4 || null);
    null != i3 && (null === n2 && (n2 = ObjectValue.empty()), n2.set(r4.field, i3));
  }
  return n2 || null;
}
function __PRIVATE_mutationEquals(e3, t2) {
  return e3.type === t2.type && (!!e3.key.isEqual(t2.key) && (!!e3.precondition.isEqual(t2.precondition) && (!!function __PRIVATE_fieldTransformsAreEqual(e4, t3) {
    return void 0 === e4 && void 0 === t3 || !(!e4 || !t3) && __PRIVATE_arrayEquals(e4, t3, (e5, t4) => __PRIVATE_fieldTransformEquals(e5, t4));
  }(e3.fieldTransforms, t2.fieldTransforms) && (0 === e3.type ? e3.value.isEqual(t2.value) : 1 !== e3.type || e3.data.isEqual(t2.data) && e3.fieldMask.isEqual(t2.fieldMask)))));
}
function __PRIVATE_getPatch(e3) {
  const t2 = /* @__PURE__ */ new Map();
  return e3.fieldMask.fields.forEach((n2) => {
    if (!n2.isEmpty()) {
      const r4 = e3.data.field(n2);
      t2.set(n2, r4);
    }
  }), t2;
}
function __PRIVATE_serverTransformResults(e3, t2, n2) {
  const r4 = /* @__PURE__ */ new Map();
  __PRIVATE_hardAssert(e3.length === n2.length);
  for (let i3 = 0; i3 < n2.length; i3++) {
    const s3 = e3[i3], o2 = s3.transform, _ = t2.data.field(s3.field);
    r4.set(s3.field, __PRIVATE_applyTransformOperationToRemoteDocument(o2, _, n2[i3]));
  }
  return r4;
}
function __PRIVATE_localTransformResults(e3, t2, n2) {
  const r4 = /* @__PURE__ */ new Map();
  for (const i3 of e3) {
    const e4 = i3.transform, s3 = n2.data.field(i3.field);
    r4.set(i3.field, __PRIVATE_applyTransformOperationToLocalView(e4, s3, t2));
  }
  return r4;
}
function __PRIVATE_isPermanentError(e3) {
  switch (e3) {
    default:
      return fail();
    case D2.CANCELLED:
    case D2.UNKNOWN:
    case D2.DEADLINE_EXCEEDED:
    case D2.RESOURCE_EXHAUSTED:
    case D2.INTERNAL:
    case D2.UNAVAILABLE:
    case D2.UNAUTHENTICATED:
      return false;
    case D2.INVALID_ARGUMENT:
    case D2.NOT_FOUND:
    case D2.ALREADY_EXISTS:
    case D2.PERMISSION_DENIED:
    case D2.FAILED_PRECONDITION:
    case D2.ABORTED:
    case D2.OUT_OF_RANGE:
    case D2.UNIMPLEMENTED:
    case D2.DATA_LOSS:
      return true;
  }
}
function __PRIVATE_mapCodeFromRpcCode(e3) {
  if (void 0 === e3)
    return __PRIVATE_logError("GRPC error has no .code"), D2.UNKNOWN;
  switch (e3) {
    case ae2.OK:
      return D2.OK;
    case ae2.CANCELLED:
      return D2.CANCELLED;
    case ae2.UNKNOWN:
      return D2.UNKNOWN;
    case ae2.DEADLINE_EXCEEDED:
      return D2.DEADLINE_EXCEEDED;
    case ae2.RESOURCE_EXHAUSTED:
      return D2.RESOURCE_EXHAUSTED;
    case ae2.INTERNAL:
      return D2.INTERNAL;
    case ae2.UNAVAILABLE:
      return D2.UNAVAILABLE;
    case ae2.UNAUTHENTICATED:
      return D2.UNAUTHENTICATED;
    case ae2.INVALID_ARGUMENT:
      return D2.INVALID_ARGUMENT;
    case ae2.NOT_FOUND:
      return D2.NOT_FOUND;
    case ae2.ALREADY_EXISTS:
      return D2.ALREADY_EXISTS;
    case ae2.PERMISSION_DENIED:
      return D2.PERMISSION_DENIED;
    case ae2.FAILED_PRECONDITION:
      return D2.FAILED_PRECONDITION;
    case ae2.ABORTED:
      return D2.ABORTED;
    case ae2.OUT_OF_RANGE:
      return D2.OUT_OF_RANGE;
    case ae2.UNIMPLEMENTED:
      return D2.UNIMPLEMENTED;
    case ae2.DATA_LOSS:
      return D2.DATA_LOSS;
    default:
      return fail();
  }
}
function __PRIVATE_newTextEncoder() {
  return new TextEncoder();
}
function __PRIVATE_getMd5HashValue(e3) {
  const t2 = __PRIVATE_newTextEncoder().encode(e3), n2 = new Md5();
  return n2.update(t2), new Uint8Array(n2.digest());
}
function __PRIVATE_get64BitUints(e3) {
  const t2 = new DataView(e3.buffer), n2 = t2.getUint32(
    0,
    /* littleEndian= */
    true
  ), r4 = t2.getUint32(
    4,
    /* littleEndian= */
    true
  ), i3 = t2.getUint32(
    8,
    /* littleEndian= */
    true
  ), s3 = t2.getUint32(
    12,
    /* littleEndian= */
    true
  );
  return [new Integer([n2, r4], 0), new Integer([i3, s3], 0)];
}
function __PRIVATE_documentTargetMap() {
  return new SortedMap(DocumentKey.comparator);
}
function __PRIVATE_snapshotChangesMap() {
  return new SortedMap(DocumentKey.comparator);
}
function __PRIVATE_toInt32Proto(e3, t2) {
  return e3.useProto3Json || __PRIVATE_isNullOrUndefined(t2) ? t2 : {
    value: t2
  };
}
function toTimestamp(e3, t2) {
  if (e3.useProto3Json) {
    return `${new Date(1e3 * t2.seconds).toISOString().replace(/\.\d*/, "").replace("Z", "")}.${("000000000" + t2.nanoseconds).slice(-9)}Z`;
  }
  return {
    seconds: "" + t2.seconds,
    nanos: t2.nanoseconds
  };
}
function __PRIVATE_toBytes(e3, t2) {
  return e3.useProto3Json ? t2.toBase64() : t2.toUint8Array();
}
function __PRIVATE_toVersion(e3, t2) {
  return toTimestamp(e3, t2.toTimestamp());
}
function __PRIVATE_fromVersion(e3) {
  return __PRIVATE_hardAssert(!!e3), SnapshotVersion.fromTimestamp(function fromTimestamp(e4) {
    const t2 = __PRIVATE_normalizeTimestamp(e4);
    return new Timestamp(t2.seconds, t2.nanos);
  }(e3));
}
function __PRIVATE_toResourceName(e3, t2) {
  return __PRIVATE_toResourcePath(e3, t2).canonicalString();
}
function __PRIVATE_toResourcePath(e3, t2) {
  const n2 = function __PRIVATE_fullyQualifiedPrefixPath(e4) {
    return new ResourcePath(["projects", e4.projectId, "databases", e4.database]);
  }(e3).child("documents");
  return void 0 === t2 ? n2 : n2.child(t2);
}
function __PRIVATE_fromResourceName(e3) {
  const t2 = ResourcePath.fromString(e3);
  return __PRIVATE_hardAssert(__PRIVATE_isValidResourceName(t2)), t2;
}
function __PRIVATE_toName(e3, t2) {
  return __PRIVATE_toResourceName(e3.databaseId, t2.path);
}
function fromName(e3, t2) {
  const n2 = __PRIVATE_fromResourceName(t2);
  if (n2.get(1) !== e3.databaseId.projectId)
    throw new FirestoreError(D2.INVALID_ARGUMENT, "Tried to deserialize key from different project: " + n2.get(1) + " vs " + e3.databaseId.projectId);
  if (n2.get(3) !== e3.databaseId.database)
    throw new FirestoreError(D2.INVALID_ARGUMENT, "Tried to deserialize key from different database: " + n2.get(3) + " vs " + e3.databaseId.database);
  return new DocumentKey(__PRIVATE_extractLocalPathFromResourceName(n2));
}
function __PRIVATE_toQueryPath(e3, t2) {
  return __PRIVATE_toResourceName(e3.databaseId, t2);
}
function __PRIVATE_fromQueryPath(e3) {
  const t2 = __PRIVATE_fromResourceName(e3);
  return 4 === t2.length ? ResourcePath.emptyPath() : __PRIVATE_extractLocalPathFromResourceName(t2);
}
function __PRIVATE_getEncodedDatabaseId(e3) {
  return new ResourcePath(["projects", e3.databaseId.projectId, "databases", e3.databaseId.database]).canonicalString();
}
function __PRIVATE_extractLocalPathFromResourceName(e3) {
  return __PRIVATE_hardAssert(e3.length > 4 && "documents" === e3.get(4)), e3.popFirst(5);
}
function __PRIVATE_toMutationDocument(e3, t2, n2) {
  return {
    name: __PRIVATE_toName(e3, t2),
    fields: n2.value.mapValue.fields
  };
}
function __PRIVATE_fromWatchChange(e3, t2) {
  let n2;
  if ("targetChange" in t2) {
    t2.targetChange;
    const r4 = function __PRIVATE_fromWatchTargetChangeState(e4) {
      return "NO_CHANGE" === e4 ? 0 : "ADD" === e4 ? 1 : "REMOVE" === e4 ? 2 : "CURRENT" === e4 ? 3 : "RESET" === e4 ? 4 : fail();
    }(t2.targetChange.targetChangeType || "NO_CHANGE"), i3 = t2.targetChange.targetIds || [], s3 = function __PRIVATE_fromBytes(e4, t3) {
      return e4.useProto3Json ? (__PRIVATE_hardAssert(void 0 === t3 || "string" == typeof t3), ByteString.fromBase64String(t3 || "")) : (__PRIVATE_hardAssert(void 0 === t3 || t3 instanceof Uint8Array), ByteString.fromUint8Array(t3 || new Uint8Array()));
    }(e3, t2.targetChange.resumeToken), o2 = t2.targetChange.cause, _ = o2 && function __PRIVATE_fromRpcStatus(e4) {
      const t3 = void 0 === e4.code ? D2.UNKNOWN : __PRIVATE_mapCodeFromRpcCode(e4.code);
      return new FirestoreError(t3, e4.message || "");
    }(o2);
    n2 = new __PRIVATE_WatchTargetChange(r4, i3, s3, _ || null);
  } else if ("documentChange" in t2) {
    t2.documentChange;
    const r4 = t2.documentChange;
    r4.document, r4.document.name, r4.document.updateTime;
    const i3 = fromName(e3, r4.document.name), s3 = __PRIVATE_fromVersion(r4.document.updateTime), o2 = r4.document.createTime ? __PRIVATE_fromVersion(r4.document.createTime) : SnapshotVersion.min(), _ = new ObjectValue({
      mapValue: {
        fields: r4.document.fields
      }
    }), a2 = MutableDocument.newFoundDocument(i3, s3, o2, _), u2 = r4.targetIds || [], c2 = r4.removedTargetIds || [];
    n2 = new __PRIVATE_DocumentWatchChange(u2, c2, a2.key, a2);
  } else if ("documentDelete" in t2) {
    t2.documentDelete;
    const r4 = t2.documentDelete;
    r4.document;
    const i3 = fromName(e3, r4.document), s3 = r4.readTime ? __PRIVATE_fromVersion(r4.readTime) : SnapshotVersion.min(), o2 = MutableDocument.newNoDocument(i3, s3), _ = r4.removedTargetIds || [];
    n2 = new __PRIVATE_DocumentWatchChange([], _, o2.key, o2);
  } else if ("documentRemove" in t2) {
    t2.documentRemove;
    const r4 = t2.documentRemove;
    r4.document;
    const i3 = fromName(e3, r4.document), s3 = r4.removedTargetIds || [];
    n2 = new __PRIVATE_DocumentWatchChange([], s3, i3, null);
  } else {
    if (!("filter" in t2))
      return fail();
    {
      t2.filter;
      const e4 = t2.filter;
      e4.targetId;
      const { count: r4 = 0, unchangedNames: i3 } = e4, s3 = new ExistenceFilter(r4, i3), o2 = e4.targetId;
      n2 = new __PRIVATE_ExistenceFilterChange(o2, s3);
    }
  }
  return n2;
}
function toMutation(e3, t2) {
  let n2;
  if (t2 instanceof __PRIVATE_SetMutation)
    n2 = {
      update: __PRIVATE_toMutationDocument(e3, t2.key, t2.value)
    };
  else if (t2 instanceof __PRIVATE_DeleteMutation)
    n2 = {
      delete: __PRIVATE_toName(e3, t2.key)
    };
  else if (t2 instanceof __PRIVATE_PatchMutation)
    n2 = {
      update: __PRIVATE_toMutationDocument(e3, t2.key, t2.data),
      updateMask: __PRIVATE_toDocumentMask(t2.fieldMask)
    };
  else {
    if (!(t2 instanceof __PRIVATE_VerifyMutation))
      return fail();
    n2 = {
      verify: __PRIVATE_toName(e3, t2.key)
    };
  }
  return t2.fieldTransforms.length > 0 && (n2.updateTransforms = t2.fieldTransforms.map((e4) => function __PRIVATE_toFieldTransform(e5, t3) {
    const n3 = t3.transform;
    if (n3 instanceof __PRIVATE_ServerTimestampTransform)
      return {
        fieldPath: t3.field.canonicalString(),
        setToServerValue: "REQUEST_TIME"
      };
    if (n3 instanceof __PRIVATE_ArrayUnionTransformOperation)
      return {
        fieldPath: t3.field.canonicalString(),
        appendMissingElements: {
          values: n3.elements
        }
      };
    if (n3 instanceof __PRIVATE_ArrayRemoveTransformOperation)
      return {
        fieldPath: t3.field.canonicalString(),
        removeAllFromArray: {
          values: n3.elements
        }
      };
    if (n3 instanceof __PRIVATE_NumericIncrementTransformOperation)
      return {
        fieldPath: t3.field.canonicalString(),
        increment: n3.Ie
      };
    throw fail();
  }(0, e4))), t2.precondition.isNone || (n2.currentDocument = function __PRIVATE_toPrecondition(e4, t3) {
    return void 0 !== t3.updateTime ? {
      updateTime: __PRIVATE_toVersion(e4, t3.updateTime)
    } : void 0 !== t3.exists ? {
      exists: t3.exists
    } : fail();
  }(e3, t2.precondition)), n2;
}
function __PRIVATE_fromWriteResults(e3, t2) {
  return e3 && e3.length > 0 ? (__PRIVATE_hardAssert(void 0 !== t2), e3.map((e4) => function __PRIVATE_fromWriteResult(e5, t3) {
    let n2 = e5.updateTime ? __PRIVATE_fromVersion(e5.updateTime) : __PRIVATE_fromVersion(t3);
    return n2.isEqual(SnapshotVersion.min()) && // The Firestore Emulator currently returns an update time of 0 for
    // deletes of non-existing documents (rather than null). This breaks the
    // test "get deleted doc while offline with source=cache" as NoDocuments
    // with version 0 are filtered by IndexedDb's RemoteDocumentCache.
    // TODO(#2149): Remove this when Emulator is fixed
    (n2 = __PRIVATE_fromVersion(t3)), new MutationResult(n2, e5.transformResults || []);
  }(e4, t2))) : [];
}
function __PRIVATE_toDocumentsTarget(e3, t2) {
  return {
    documents: [__PRIVATE_toQueryPath(e3, t2.path)]
  };
}
function __PRIVATE_toQueryTarget(e3, t2) {
  const n2 = {
    structuredQuery: {}
  }, r4 = t2.path;
  let i3;
  null !== t2.collectionGroup ? (i3 = r4, n2.structuredQuery.from = [{
    collectionId: t2.collectionGroup,
    allDescendants: true
  }]) : (i3 = r4.popLast(), n2.structuredQuery.from = [{
    collectionId: r4.lastSegment()
  }]), n2.parent = __PRIVATE_toQueryPath(e3, i3);
  const s3 = function __PRIVATE_toFilters(e4) {
    if (0 === e4.length)
      return;
    return __PRIVATE_toFilter(CompositeFilter.create(
      e4,
      "and"
      /* CompositeOperator.AND */
    ));
  }(t2.filters);
  s3 && (n2.structuredQuery.where = s3);
  const o2 = function __PRIVATE_toOrder(e4) {
    if (0 === e4.length)
      return;
    return e4.map((e5) => (
      // visible for testing
      function __PRIVATE_toPropertyOrder(e6) {
        return {
          field: __PRIVATE_toFieldPathReference(e6.field),
          direction: __PRIVATE_toDirection(e6.dir)
        };
      }(e5)
    ));
  }(t2.orderBy);
  o2 && (n2.structuredQuery.orderBy = o2);
  const _ = __PRIVATE_toInt32Proto(e3, t2.limit);
  return null !== _ && (n2.structuredQuery.limit = _), t2.startAt && (n2.structuredQuery.startAt = function __PRIVATE_toStartAtCursor(e4) {
    return {
      before: e4.inclusive,
      values: e4.position
    };
  }(t2.startAt)), t2.endAt && (n2.structuredQuery.endAt = function __PRIVATE_toEndAtCursor(e4) {
    return {
      before: !e4.inclusive,
      values: e4.position
    };
  }(t2.endAt)), {
    ut: n2,
    parent: i3
  };
}
function __PRIVATE_convertQueryTargetToQuery(e3) {
  let t2 = __PRIVATE_fromQueryPath(e3.parent);
  const n2 = e3.structuredQuery, r4 = n2.from ? n2.from.length : 0;
  let i3 = null;
  if (r4 > 0) {
    __PRIVATE_hardAssert(1 === r4);
    const e4 = n2.from[0];
    e4.allDescendants ? i3 = e4.collectionId : t2 = t2.child(e4.collectionId);
  }
  let s3 = [];
  n2.where && (s3 = function __PRIVATE_fromFilters(e4) {
    const t3 = __PRIVATE_fromFilter(e4);
    if (t3 instanceof CompositeFilter && __PRIVATE_compositeFilterIsFlatConjunction(t3))
      return t3.getFilters();
    return [t3];
  }(n2.where));
  let o2 = [];
  n2.orderBy && (o2 = function __PRIVATE_fromOrder(e4) {
    return e4.map((e5) => function __PRIVATE_fromPropertyOrder(e6) {
      return new OrderBy(
        __PRIVATE_fromFieldPathReference(e6.field),
        // visible for testing
        function __PRIVATE_fromDirection(e7) {
          switch (e7) {
            case "ASCENDING":
              return "asc";
            case "DESCENDING":
              return "desc";
            default:
              return;
          }
        }(e6.direction)
      );
    }(e5));
  }(n2.orderBy));
  let _ = null;
  n2.limit && (_ = function __PRIVATE_fromInt32Proto(e4) {
    let t3;
    return t3 = "object" == typeof e4 ? e4.value : e4, __PRIVATE_isNullOrUndefined(t3) ? null : t3;
  }(n2.limit));
  let a2 = null;
  n2.startAt && (a2 = function __PRIVATE_fromStartAtCursor(e4) {
    const t3 = !!e4.before, n3 = e4.values || [];
    return new Bound(n3, t3);
  }(n2.startAt));
  let u2 = null;
  return n2.endAt && (u2 = function __PRIVATE_fromEndAtCursor(e4) {
    const t3 = !e4.before, n3 = e4.values || [];
    return new Bound(n3, t3);
  }(n2.endAt)), __PRIVATE_newQuery(t2, i3, o2, s3, _, "F", a2, u2);
}
function __PRIVATE_toListenRequestLabels(e3, t2) {
  const n2 = function __PRIVATE_toLabel(e4) {
    switch (e4) {
      case "TargetPurposeListen":
        return null;
      case "TargetPurposeExistenceFilterMismatch":
        return "existence-filter-mismatch";
      case "TargetPurposeExistenceFilterMismatchBloom":
        return "existence-filter-mismatch-bloom";
      case "TargetPurposeLimboResolution":
        return "limbo-document";
      default:
        return fail();
    }
  }(t2.purpose);
  return null == n2 ? null : {
    "goog-listen-tags": n2
  };
}
function __PRIVATE_fromFilter(e3) {
  return void 0 !== e3.unaryFilter ? function __PRIVATE_fromUnaryFilter(e4) {
    switch (e4.unaryFilter.op) {
      case "IS_NAN":
        const t2 = __PRIVATE_fromFieldPathReference(e4.unaryFilter.field);
        return FieldFilter.create(t2, "==", {
          doubleValue: NaN
        });
      case "IS_NULL":
        const n2 = __PRIVATE_fromFieldPathReference(e4.unaryFilter.field);
        return FieldFilter.create(n2, "==", {
          nullValue: "NULL_VALUE"
        });
      case "IS_NOT_NAN":
        const r4 = __PRIVATE_fromFieldPathReference(e4.unaryFilter.field);
        return FieldFilter.create(r4, "!=", {
          doubleValue: NaN
        });
      case "IS_NOT_NULL":
        const i3 = __PRIVATE_fromFieldPathReference(e4.unaryFilter.field);
        return FieldFilter.create(i3, "!=", {
          nullValue: "NULL_VALUE"
        });
      default:
        return fail();
    }
  }(e3) : void 0 !== e3.fieldFilter ? function __PRIVATE_fromFieldFilter(e4) {
    return FieldFilter.create(__PRIVATE_fromFieldPathReference(e4.fieldFilter.field), function __PRIVATE_fromOperatorName(e5) {
      switch (e5) {
        case "EQUAL":
          return "==";
        case "NOT_EQUAL":
          return "!=";
        case "GREATER_THAN":
          return ">";
        case "GREATER_THAN_OR_EQUAL":
          return ">=";
        case "LESS_THAN":
          return "<";
        case "LESS_THAN_OR_EQUAL":
          return "<=";
        case "ARRAY_CONTAINS":
          return "array-contains";
        case "IN":
          return "in";
        case "NOT_IN":
          return "not-in";
        case "ARRAY_CONTAINS_ANY":
          return "array-contains-any";
        default:
          return fail();
      }
    }(e4.fieldFilter.op), e4.fieldFilter.value);
  }(e3) : void 0 !== e3.compositeFilter ? function __PRIVATE_fromCompositeFilter(e4) {
    return CompositeFilter.create(e4.compositeFilter.filters.map((e5) => __PRIVATE_fromFilter(e5)), function __PRIVATE_fromCompositeOperatorName(e5) {
      switch (e5) {
        case "AND":
          return "and";
        case "OR":
          return "or";
        default:
          return fail();
      }
    }(e4.compositeFilter.op));
  }(e3) : fail();
}
function __PRIVATE_toDirection(e3) {
  return he[e3];
}
function __PRIVATE_toOperatorName(e3) {
  return Pe[e3];
}
function __PRIVATE_toCompositeOperatorName(e3) {
  return Ie[e3];
}
function __PRIVATE_toFieldPathReference(e3) {
  return {
    fieldPath: e3.canonicalString()
  };
}
function __PRIVATE_fromFieldPathReference(e3) {
  return FieldPath$1.fromServerFormat(e3.fieldPath);
}
function __PRIVATE_toFilter(e3) {
  return e3 instanceof FieldFilter ? function __PRIVATE_toUnaryOrFieldFilter(e4) {
    if ("==" === e4.op) {
      if (__PRIVATE_isNanValue(e4.value))
        return {
          unaryFilter: {
            field: __PRIVATE_toFieldPathReference(e4.field),
            op: "IS_NAN"
          }
        };
      if (__PRIVATE_isNullValue(e4.value))
        return {
          unaryFilter: {
            field: __PRIVATE_toFieldPathReference(e4.field),
            op: "IS_NULL"
          }
        };
    } else if ("!=" === e4.op) {
      if (__PRIVATE_isNanValue(e4.value))
        return {
          unaryFilter: {
            field: __PRIVATE_toFieldPathReference(e4.field),
            op: "IS_NOT_NAN"
          }
        };
      if (__PRIVATE_isNullValue(e4.value))
        return {
          unaryFilter: {
            field: __PRIVATE_toFieldPathReference(e4.field),
            op: "IS_NOT_NULL"
          }
        };
    }
    return {
      fieldFilter: {
        field: __PRIVATE_toFieldPathReference(e4.field),
        op: __PRIVATE_toOperatorName(e4.op),
        value: e4.value
      }
    };
  }(e3) : e3 instanceof CompositeFilter ? function __PRIVATE_toCompositeFilter(e4) {
    const t2 = e4.getFilters().map((e5) => __PRIVATE_toFilter(e5));
    if (1 === t2.length)
      return t2[0];
    return {
      compositeFilter: {
        op: __PRIVATE_toCompositeOperatorName(e4.op),
        filters: t2
      }
    };
  }(e3) : fail();
}
function __PRIVATE_toDocumentMask(e3) {
  const t2 = [];
  return e3.fields.forEach((e4) => t2.push(e4.canonicalString())), {
    fieldPaths: t2
  };
}
function __PRIVATE_isValidResourceName(e3) {
  return e3.length >= 4 && "projects" === e3.get(0) && "databases" === e3.get(2);
}
function __PRIVATE_fromBundledQuery(e3) {
  const t2 = __PRIVATE_convertQueryTargetToQuery({
    parent: e3.parent,
    structuredQuery: e3.structuredQuery
  });
  return "LAST" === e3.limitType ? __PRIVATE_queryWithLimit(
    t2,
    t2.limit,
    "L"
    /* LimitType.Last */
  ) : t2;
}
function __PRIVATE_newLocalStore(e3, t2, n2, r4) {
  return new __PRIVATE_LocalStoreImpl(e3, t2, n2, r4);
}
async function __PRIVATE_localStoreHandleUserChange(e3, t2) {
  const n2 = __PRIVATE_debugCast(e3);
  return await n2.persistence.runTransaction("Handle user change", "readonly", (e4) => {
    let r4;
    return n2.mutationQueue.getAllMutationBatches(e4).next((i3) => (r4 = i3, n2._s(t2), n2.mutationQueue.getAllMutationBatches(e4))).next((t3) => {
      const i3 = [], s3 = [];
      let o2 = __PRIVATE_documentKeySet();
      for (const e5 of r4) {
        i3.push(e5.batchId);
        for (const t4 of e5.mutations)
          o2 = o2.add(t4.key);
      }
      for (const e5 of t3) {
        s3.push(e5.batchId);
        for (const t4 of e5.mutations)
          o2 = o2.add(t4.key);
      }
      return n2.localDocuments.getDocuments(e4, o2).next((e5) => ({
        us: e5,
        removedBatchIds: i3,
        addedBatchIds: s3
      }));
    });
  });
}
function __PRIVATE_localStoreAcknowledgeBatch(e3, t2) {
  const n2 = __PRIVATE_debugCast(e3);
  return n2.persistence.runTransaction("Acknowledge batch", "readwrite-primary", (e4) => {
    const r4 = t2.batch.keys(), i3 = n2.os.newChangeBuffer({
      trackRemovals: true
    });
    return function __PRIVATE_applyWriteToRemoteDocuments(e5, t3, n3, r5) {
      const i4 = n3.batch, s3 = i4.keys();
      let o2 = PersistencePromise.resolve();
      return s3.forEach((e6) => {
        o2 = o2.next(() => r5.getEntry(t3, e6)).next((t4) => {
          const s4 = n3.docVersions.get(e6);
          __PRIVATE_hardAssert(null !== s4), t4.version.compareTo(s4) < 0 && (i4.applyToRemoteDocument(t4, n3), t4.isValidDocument() && // We use the commitVersion as the readTime rather than the
          // document's updateTime since the updateTime is not advanced
          // for updates that do not modify the underlying document.
          (t4.setReadTime(n3.commitVersion), r5.addEntry(t4)));
        });
      }), o2.next(() => e5.mutationQueue.removeMutationBatch(t3, i4));
    }(n2, e4, t2, i3).next(() => i3.apply(e4)).next(() => n2.mutationQueue.performConsistencyCheck(e4)).next(() => n2.documentOverlayCache.removeOverlaysForBatchId(e4, r4, t2.batch.batchId)).next(() => n2.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(e4, function __PRIVATE_getKeysWithTransformResults(e5) {
      let t3 = __PRIVATE_documentKeySet();
      for (let n3 = 0; n3 < e5.mutationResults.length; ++n3) {
        e5.mutationResults[n3].transformResults.length > 0 && (t3 = t3.add(e5.batch.mutations[n3].key));
      }
      return t3;
    }(t2))).next(() => n2.localDocuments.getDocuments(e4, r4));
  });
}
function __PRIVATE_localStoreGetLastRemoteSnapshotVersion(e3) {
  const t2 = __PRIVATE_debugCast(e3);
  return t2.persistence.runTransaction("Get last remote snapshot version", "readonly", (e4) => t2.Qr.getLastRemoteSnapshotVersion(e4));
}
function __PRIVATE_localStoreApplyRemoteEventToLocalCache(e3, t2) {
  const n2 = __PRIVATE_debugCast(e3), r4 = t2.snapshotVersion;
  let i3 = n2.ns;
  return n2.persistence.runTransaction("Apply remote event", "readwrite-primary", (e4) => {
    const s3 = n2.os.newChangeBuffer({
      trackRemovals: true
    });
    i3 = n2.ns;
    const o2 = [];
    t2.targetChanges.forEach((s4, _2) => {
      const a3 = i3.get(_2);
      if (!a3)
        return;
      o2.push(n2.Qr.removeMatchingKeys(e4, s4.removedDocuments, _2).next(() => n2.Qr.addMatchingKeys(e4, s4.addedDocuments, _2)));
      let u2 = a3.withSequenceNumber(e4.currentSequenceNumber);
      null !== t2.targetMismatches.get(_2) ? u2 = u2.withResumeToken(ByteString.EMPTY_BYTE_STRING, SnapshotVersion.min()).withLastLimboFreeSnapshotVersion(SnapshotVersion.min()) : s4.resumeToken.approximateByteSize() > 0 && (u2 = u2.withResumeToken(s4.resumeToken, r4)), i3 = i3.insert(_2, u2), // Update the target data if there are target changes (or if
      // sufficient time has passed since the last update).
      /**
      * Returns true if the newTargetData should be persisted during an update of
      * an active target. TargetData should always be persisted when a target is
      * being released and should not call this function.
      *
      * While the target is active, TargetData updates can be omitted when nothing
      * about the target has changed except metadata like the resume token or
      * snapshot version. Occasionally it's worth the extra write to prevent these
      * values from getting too stale after a crash, but this doesn't have to be
      * too frequent.
      */
      function __PRIVATE_shouldPersistTargetData(e5, t3, n3) {
        if (0 === e5.resumeToken.approximateByteSize())
          return true;
        if (t3.snapshotVersion.toMicroseconds() - e5.snapshotVersion.toMicroseconds() >= 3e8)
          return true;
        return n3.addedDocuments.size + n3.modifiedDocuments.size + n3.removedDocuments.size > 0;
      }(a3, u2, s4) && o2.push(n2.Qr.updateTargetData(e4, u2));
    });
    let _ = __PRIVATE_mutableDocumentMap(), a2 = __PRIVATE_documentKeySet();
    if (t2.documentUpdates.forEach((r5) => {
      t2.resolvedLimboDocuments.has(r5) && o2.push(n2.persistence.referenceDelegate.updateLimboDocument(e4, r5));
    }), // Each loop iteration only affects its "own" doc, so it's safe to get all
    // the remote documents in advance in a single call.
    o2.push(__PRIVATE_populateDocumentChangeBuffer(e4, s3, t2.documentUpdates).next((e5) => {
      _ = e5.cs, a2 = e5.ls;
    })), !r4.isEqual(SnapshotVersion.min())) {
      const t3 = n2.Qr.getLastRemoteSnapshotVersion(e4).next((t4) => n2.Qr.setTargetsMetadata(e4, e4.currentSequenceNumber, r4));
      o2.push(t3);
    }
    return PersistencePromise.waitFor(o2).next(() => s3.apply(e4)).next(() => n2.localDocuments.getLocalViewOfDocuments(e4, _, a2)).next(() => _);
  }).then((e4) => (n2.ns = i3, e4));
}
function __PRIVATE_populateDocumentChangeBuffer(e3, t2, n2) {
  let r4 = __PRIVATE_documentKeySet(), i3 = __PRIVATE_documentKeySet();
  return n2.forEach((e4) => r4 = r4.add(e4)), t2.getEntries(e3, r4).next((e4) => {
    let r5 = __PRIVATE_mutableDocumentMap();
    return n2.forEach((n3, s3) => {
      const o2 = e4.get(n3);
      s3.isFoundDocument() !== o2.isFoundDocument() && (i3 = i3.add(n3)), // Note: The order of the steps below is important, since we want
      // to ensure that rejected limbo resolutions (which fabricate
      // NoDocuments with SnapshotVersion.min()) never add documents to
      // cache.
      s3.isNoDocument() && s3.version.isEqual(SnapshotVersion.min()) ? (
        // NoDocuments with SnapshotVersion.min() are used in manufactured
        // events. We remove these documents from cache since we lost
        // access.
        (t2.removeEntry(n3, s3.readTime), r5 = r5.insert(n3, s3))
      ) : !o2.isValidDocument() || s3.version.compareTo(o2.version) > 0 || 0 === s3.version.compareTo(o2.version) && o2.hasPendingWrites ? (t2.addEntry(s3), r5 = r5.insert(n3, s3)) : __PRIVATE_logDebug("LocalStore", "Ignoring outdated watch update for ", n3, ". Current version:", o2.version, " Watch version:", s3.version);
    }), {
      cs: r5,
      ls: i3
    };
  });
}
function __PRIVATE_localStoreGetNextMutationBatch(e3, t2) {
  const n2 = __PRIVATE_debugCast(e3);
  return n2.persistence.runTransaction("Get next mutation batch", "readonly", (e4) => (void 0 === t2 && (t2 = -1), n2.mutationQueue.getNextMutationBatchAfterBatchId(e4, t2)));
}
function __PRIVATE_localStoreAllocateTarget(e3, t2) {
  const n2 = __PRIVATE_debugCast(e3);
  return n2.persistence.runTransaction("Allocate target", "readwrite", (e4) => {
    let r4;
    return n2.Qr.getTargetData(e4, t2).next((i3) => i3 ? (
      // This target has been listened to previously, so reuse the
      // previous targetID.
      // TODO(mcg): freshen last accessed date?
      (r4 = i3, PersistencePromise.resolve(r4))
    ) : n2.Qr.allocateTargetId(e4).next((i4) => (r4 = new TargetData(t2, i4, "TargetPurposeListen", e4.currentSequenceNumber), n2.Qr.addTargetData(e4, r4).next(() => r4))));
  }).then((e4) => {
    const r4 = n2.ns.get(e4.targetId);
    return (null === r4 || e4.snapshotVersion.compareTo(r4.snapshotVersion) > 0) && (n2.ns = n2.ns.insert(e4.targetId, e4), n2.rs.set(t2, e4.targetId)), e4;
  });
}
async function __PRIVATE_localStoreReleaseTarget(e3, t2, n2) {
  const r4 = __PRIVATE_debugCast(e3), i3 = r4.ns.get(t2), s3 = n2 ? "readwrite" : "readwrite-primary";
  try {
    n2 || await r4.persistence.runTransaction("Release target", s3, (e4) => r4.persistence.referenceDelegate.removeTarget(e4, i3));
  } catch (e4) {
    if (!__PRIVATE_isIndexedDbTransactionError(e4))
      throw e4;
    __PRIVATE_logDebug("LocalStore", `Failed to update sequence numbers for target ${t2}: ${e4}`);
  }
  r4.ns = r4.ns.remove(t2), r4.rs.delete(i3.target);
}
function __PRIVATE_localStoreExecuteQuery(e3, t2, n2) {
  const r4 = __PRIVATE_debugCast(e3);
  let i3 = SnapshotVersion.min(), s3 = __PRIVATE_documentKeySet();
  return r4.persistence.runTransaction(
    "Execute query",
    "readwrite",
    // Use readwrite instead of readonly so indexes can be created
    // Use readwrite instead of readonly so indexes can be created
    (e4) => function __PRIVATE_localStoreGetTargetData(e5, t3, n3) {
      const r5 = __PRIVATE_debugCast(e5), i4 = r5.rs.get(n3);
      return void 0 !== i4 ? PersistencePromise.resolve(r5.ns.get(i4)) : r5.Qr.getTargetData(t3, n3);
    }(r4, e4, __PRIVATE_queryToTarget(t2)).next((t3) => {
      if (t3)
        return i3 = t3.lastLimboFreeSnapshotVersion, r4.Qr.getMatchingKeysForTargetId(e4, t3.targetId).next((e5) => {
          s3 = e5;
        });
    }).next(() => r4.ts.getDocumentsMatchingQuery(e4, t2, n2 ? i3 : SnapshotVersion.min(), n2 ? s3 : __PRIVATE_documentKeySet())).next((e5) => (__PRIVATE_setMaxReadTime(r4, __PRIVATE_queryCollectionGroup(t2), e5), {
      documents: e5,
      hs: s3
    }))
  );
}
function __PRIVATE_setMaxReadTime(e3, t2, n2) {
  let r4 = e3.ss.get(t2) || SnapshotVersion.min();
  n2.forEach((e4, t3) => {
    t3.readTime.compareTo(r4) > 0 && (r4 = t3.readTime);
  }), e3.ss.set(t2, r4);
}
function __PRIVATE_generateUniqueDebugId() {
  return null === Ae ? Ae = function __PRIVATE_generateInitialUniqueDebugId() {
    return 268435456 + Math.round(2147483648 * Math.random());
  }() : Ae++, "0x" + Ae.toString(16);
}
function getDocument() {
  return "undefined" != typeof document ? document : null;
}
function __PRIVATE_newSerializer(e3) {
  return new JsonProtoSerializer(
    e3,
    /* useProto3Json= */
    true
  );
}
async function __PRIVATE_enableNetworkInternal(e3) {
  if (__PRIVATE_canUseNetwork(e3))
    for (const t2 of e3.F_)
      await t2(
        /* enabled= */
        true
      );
}
async function __PRIVATE_disableNetworkInternal(e3) {
  for (const t2 of e3.F_)
    await t2(
      /* enabled= */
      false
    );
}
function __PRIVATE_remoteStoreListen(e3, t2) {
  const n2 = __PRIVATE_debugCast(e3);
  n2.C_.has(t2.targetId) || // Mark this as something the client is currently listening for.
  (n2.C_.set(t2.targetId, t2), __PRIVATE_shouldStartWatchStream(n2) ? (
    // The listen will be sent in onWatchStreamOpen
    __PRIVATE_startWatchStream(n2)
  ) : __PRIVATE_ensureWatchStream(n2).Jo() && __PRIVATE_sendWatchRequest(n2, t2));
}
function __PRIVATE_remoteStoreUnlisten(e3, t2) {
  const n2 = __PRIVATE_debugCast(e3), r4 = __PRIVATE_ensureWatchStream(n2);
  n2.C_.delete(t2), r4.Jo() && __PRIVATE_sendUnwatchRequest(n2, t2), 0 === n2.C_.size && (r4.Jo() ? r4.Xo() : __PRIVATE_canUseNetwork(n2) && // Revert to OnlineState.Unknown if the watch stream is not open and we
  // have no listeners, since without any listens to send we cannot
  // confirm if the stream is healthy and upgrade to OnlineState.Online.
  n2.x_.set(
    "Unknown"
    /* OnlineState.Unknown */
  ));
}
function __PRIVATE_sendWatchRequest(e3, t2) {
  if (e3.O_.Oe(t2.targetId), t2.resumeToken.approximateByteSize() > 0 || t2.snapshotVersion.compareTo(SnapshotVersion.min()) > 0) {
    const n2 = e3.remoteSyncer.getRemoteKeysForTarget(t2.targetId).size;
    t2 = t2.withExpectedCount(n2);
  }
  __PRIVATE_ensureWatchStream(e3).c_(t2);
}
function __PRIVATE_sendUnwatchRequest(e3, t2) {
  e3.O_.Oe(t2), __PRIVATE_ensureWatchStream(e3).l_(t2);
}
function __PRIVATE_startWatchStream(e3) {
  e3.O_ = new __PRIVATE_WatchChangeAggregator({
    getRemoteKeysForTarget: (t2) => e3.remoteSyncer.getRemoteKeysForTarget(t2),
    _t: (t2) => e3.C_.get(t2) || null,
    nt: () => e3.datastore.serializer.databaseId
  }), __PRIVATE_ensureWatchStream(e3).start(), e3.x_.p_();
}
function __PRIVATE_shouldStartWatchStream(e3) {
  return __PRIVATE_canUseNetwork(e3) && !__PRIVATE_ensureWatchStream(e3).Ho() && e3.C_.size > 0;
}
function __PRIVATE_canUseNetwork(e3) {
  return 0 === __PRIVATE_debugCast(e3).v_.size;
}
function __PRIVATE_cleanUpWatchStreamState(e3) {
  e3.O_ = void 0;
}
async function __PRIVATE_onWatchStreamOpen(e3) {
  e3.C_.forEach((t2, n2) => {
    __PRIVATE_sendWatchRequest(e3, t2);
  });
}
async function __PRIVATE_onWatchStreamClose(e3, t2) {
  __PRIVATE_cleanUpWatchStreamState(e3), // If we still need the watch stream, retry the connection.
  __PRIVATE_shouldStartWatchStream(e3) ? (e3.x_.S_(t2), __PRIVATE_startWatchStream(e3)) : (
    // No need to restart watch stream because there are no active targets.
    // The online state is set to unknown because there is no active attempt
    // at establishing a connection
    e3.x_.set(
      "Unknown"
      /* OnlineState.Unknown */
    )
  );
}
async function __PRIVATE_onWatchStreamChange(e3, t2, n2) {
  if (
    // Mark the client as online since we got a message from the server
    e3.x_.set(
      "Online"
      /* OnlineState.Online */
    ), t2 instanceof __PRIVATE_WatchTargetChange && 2 === t2.state && t2.cause
  )
    try {
      await /** Handles an error on a target */
      async function __PRIVATE_handleTargetError(e4, t3) {
        const n3 = t3.cause;
        for (const r4 of t3.targetIds)
          e4.C_.has(r4) && (await e4.remoteSyncer.rejectListen(r4, n3), e4.C_.delete(r4), e4.O_.removeTarget(r4));
      }(e3, t2);
    } catch (n3) {
      __PRIVATE_logDebug("RemoteStore", "Failed to remove targets %s: %s ", t2.targetIds.join(","), n3), await __PRIVATE_disableNetworkUntilRecovery(e3, n3);
    }
  else if (t2 instanceof __PRIVATE_DocumentWatchChange ? e3.O_.$e(t2) : t2 instanceof __PRIVATE_ExistenceFilterChange ? e3.O_.Je(t2) : e3.O_.Ge(t2), !n2.isEqual(SnapshotVersion.min()))
    try {
      const t3 = await __PRIVATE_localStoreGetLastRemoteSnapshotVersion(e3.localStore);
      n2.compareTo(t3) >= 0 && // We have received a target change with a global snapshot if the snapshot
      // version is not equal to SnapshotVersion.min().
      await /**
      * Takes a batch of changes from the Datastore, repackages them as a
      * RemoteEvent, and passes that on to the listener, which is typically the
      * SyncEngine.
      */
      function __PRIVATE_raiseWatchSnapshot(e4, t4) {
        const n3 = e4.O_.it(t4);
        return n3.targetChanges.forEach((n4, r4) => {
          if (n4.resumeToken.approximateByteSize() > 0) {
            const i3 = e4.C_.get(r4);
            i3 && e4.C_.set(r4, i3.withResumeToken(n4.resumeToken, t4));
          }
        }), // Re-establish listens for the targets that have been invalidated by
        // existence filter mismatches.
        n3.targetMismatches.forEach((t5, n4) => {
          const r4 = e4.C_.get(t5);
          if (!r4)
            return;
          e4.C_.set(t5, r4.withResumeToken(ByteString.EMPTY_BYTE_STRING, r4.snapshotVersion)), // Cause a hard reset by unwatching and rewatching immediately, but
          // deliberately don't send a resume token so that we get a full update.
          __PRIVATE_sendUnwatchRequest(e4, t5);
          const i3 = new TargetData(r4.target, t5, n4, r4.sequenceNumber);
          __PRIVATE_sendWatchRequest(e4, i3);
        }), e4.remoteSyncer.applyRemoteEvent(n3);
      }(e3, n2);
    } catch (t3) {
      __PRIVATE_logDebug("RemoteStore", "Failed to raise snapshot:", t3), await __PRIVATE_disableNetworkUntilRecovery(e3, t3);
    }
}
async function __PRIVATE_disableNetworkUntilRecovery(e3, t2, n2) {
  if (!__PRIVATE_isIndexedDbTransactionError(t2))
    throw t2;
  e3.v_.add(
    1
    /* OfflineCause.IndexedDbFailed */
  ), // Disable network and raise offline snapshots
  await __PRIVATE_disableNetworkInternal(e3), e3.x_.set(
    "Offline"
    /* OnlineState.Offline */
  ), n2 || // Use a simple read operation to determine if IndexedDB recovered.
  // Ideally, we would expose a health check directly on SimpleDb, but
  // RemoteStore only has access to persistence through LocalStore.
  (n2 = () => __PRIVATE_localStoreGetLastRemoteSnapshotVersion(e3.localStore)), // Probe IndexedDB periodically and re-enable network
  e3.asyncQueue.enqueueRetryable(async () => {
    __PRIVATE_logDebug("RemoteStore", "Retrying IndexedDB access"), await n2(), e3.v_.delete(
      1
      /* OfflineCause.IndexedDbFailed */
    ), await __PRIVATE_enableNetworkInternal(e3);
  });
}
function __PRIVATE_executeWithRecovery(e3, t2) {
  return t2().catch((n2) => __PRIVATE_disableNetworkUntilRecovery(e3, n2, t2));
}
async function __PRIVATE_fillWritePipeline(e3) {
  const t2 = __PRIVATE_debugCast(e3), n2 = __PRIVATE_ensureWriteStream(t2);
  let r4 = t2.D_.length > 0 ? t2.D_[t2.D_.length - 1].batchId : -1;
  for (; __PRIVATE_canAddToWritePipeline(t2); )
    try {
      const e4 = await __PRIVATE_localStoreGetNextMutationBatch(t2.localStore, r4);
      if (null === e4) {
        0 === t2.D_.length && n2.Xo();
        break;
      }
      r4 = e4.batchId, __PRIVATE_addToWritePipeline(t2, e4);
    } catch (e4) {
      await __PRIVATE_disableNetworkUntilRecovery(t2, e4);
    }
  __PRIVATE_shouldStartWriteStream(t2) && __PRIVATE_startWriteStream(t2);
}
function __PRIVATE_canAddToWritePipeline(e3) {
  return __PRIVATE_canUseNetwork(e3) && e3.D_.length < 10;
}
function __PRIVATE_addToWritePipeline(e3, t2) {
  e3.D_.push(t2);
  const n2 = __PRIVATE_ensureWriteStream(e3);
  n2.Jo() && n2.P_ && n2.I_(t2.mutations);
}
function __PRIVATE_shouldStartWriteStream(e3) {
  return __PRIVATE_canUseNetwork(e3) && !__PRIVATE_ensureWriteStream(e3).Ho() && e3.D_.length > 0;
}
function __PRIVATE_startWriteStream(e3) {
  __PRIVATE_ensureWriteStream(e3).start();
}
async function __PRIVATE_onWriteStreamOpen(e3) {
  __PRIVATE_ensureWriteStream(e3).d_();
}
async function __PRIVATE_onWriteHandshakeComplete(e3) {
  const t2 = __PRIVATE_ensureWriteStream(e3);
  for (const n2 of e3.D_)
    t2.I_(n2.mutations);
}
async function __PRIVATE_onMutationResult(e3, t2, n2) {
  const r4 = e3.D_.shift(), i3 = MutationBatchResult.from(r4, t2, n2);
  await __PRIVATE_executeWithRecovery(e3, () => e3.remoteSyncer.applySuccessfulWrite(i3)), // It's possible that with the completion of this mutation another
  // slot has freed up.
  await __PRIVATE_fillWritePipeline(e3);
}
async function __PRIVATE_onWriteStreamClose(e3, t2) {
  t2 && __PRIVATE_ensureWriteStream(e3).P_ && // This error affects the actual write.
  await async function __PRIVATE_handleWriteError(e4, t3) {
    if (function __PRIVATE_isPermanentWriteError(e5) {
      return __PRIVATE_isPermanentError(e5) && e5 !== D2.ABORTED;
    }(t3.code)) {
      const n2 = e4.D_.shift();
      __PRIVATE_ensureWriteStream(e4).Zo(), await __PRIVATE_executeWithRecovery(e4, () => e4.remoteSyncer.rejectFailedWrite(n2.batchId, t3)), // It's possible that with the completion of this mutation
      // another slot has freed up.
      await __PRIVATE_fillWritePipeline(e4);
    }
  }(e3, t2), // The write stream might have been started by refilling the write
  // pipeline for failed writes
  __PRIVATE_shouldStartWriteStream(e3) && __PRIVATE_startWriteStream(e3);
}
async function __PRIVATE_remoteStoreHandleCredentialChange(e3, t2) {
  const n2 = __PRIVATE_debugCast(e3);
  n2.asyncQueue.verifyOperationInProgress(), __PRIVATE_logDebug("RemoteStore", "RemoteStore received new credentials");
  const r4 = __PRIVATE_canUseNetwork(n2);
  n2.v_.add(
    3
    /* OfflineCause.CredentialChange */
  ), await __PRIVATE_disableNetworkInternal(n2), r4 && // Don't set the network status to Unknown if we are offline.
  n2.x_.set(
    "Unknown"
    /* OnlineState.Unknown */
  ), await n2.remoteSyncer.handleCredentialChange(t2), n2.v_.delete(
    3
    /* OfflineCause.CredentialChange */
  ), await __PRIVATE_enableNetworkInternal(n2);
}
async function __PRIVATE_remoteStoreApplyPrimaryState(e3, t2) {
  const n2 = __PRIVATE_debugCast(e3);
  t2 ? (n2.v_.delete(
    2
    /* OfflineCause.IsSecondary */
  ), await __PRIVATE_enableNetworkInternal(n2)) : t2 || (n2.v_.add(
    2
    /* OfflineCause.IsSecondary */
  ), await __PRIVATE_disableNetworkInternal(n2), n2.x_.set(
    "Unknown"
    /* OnlineState.Unknown */
  ));
}
function __PRIVATE_ensureWatchStream(e3) {
  return e3.N_ || // Create stream (but note that it is not started yet).
  (e3.N_ = function __PRIVATE_newPersistentWatchStream(e4, t2, n2) {
    const r4 = __PRIVATE_debugCast(e4);
    return r4.R_(), new __PRIVATE_PersistentListenStream(t2, r4.connection, r4.authCredentials, r4.appCheckCredentials, r4.serializer, n2);
  }(e3.datastore, e3.asyncQueue, {
    Po: __PRIVATE_onWatchStreamOpen.bind(null, e3),
    To: __PRIVATE_onWatchStreamClose.bind(null, e3),
    u_: __PRIVATE_onWatchStreamChange.bind(null, e3)
  }), e3.F_.push(async (t2) => {
    t2 ? (e3.N_.Zo(), __PRIVATE_shouldStartWatchStream(e3) ? __PRIVATE_startWatchStream(e3) : e3.x_.set(
      "Unknown"
      /* OnlineState.Unknown */
    )) : (await e3.N_.stop(), __PRIVATE_cleanUpWatchStreamState(e3));
  })), e3.N_;
}
function __PRIVATE_ensureWriteStream(e3) {
  return e3.B_ || // Create stream (but note that it is not started yet).
  (e3.B_ = function __PRIVATE_newPersistentWriteStream(e4, t2, n2) {
    const r4 = __PRIVATE_debugCast(e4);
    return r4.R_(), new __PRIVATE_PersistentWriteStream(t2, r4.connection, r4.authCredentials, r4.appCheckCredentials, r4.serializer, n2);
  }(e3.datastore, e3.asyncQueue, {
    Po: __PRIVATE_onWriteStreamOpen.bind(null, e3),
    To: __PRIVATE_onWriteStreamClose.bind(null, e3),
    E_: __PRIVATE_onWriteHandshakeComplete.bind(null, e3),
    T_: __PRIVATE_onMutationResult.bind(null, e3)
  }), e3.F_.push(async (t2) => {
    t2 ? (e3.B_.Zo(), // This will start the write stream if necessary.
    await __PRIVATE_fillWritePipeline(e3)) : (await e3.B_.stop(), e3.D_.length > 0 && (__PRIVATE_logDebug("RemoteStore", `Stopping write stream with ${e3.D_.length} pending writes`), e3.D_ = []));
  })), e3.B_;
}
function __PRIVATE_wrapInUserErrorIfRecoverable(e3, t2) {
  if (__PRIVATE_logError("AsyncQueue", `${t2}: ${e3}`), __PRIVATE_isIndexedDbTransactionError(e3))
    return new FirestoreError(D2.UNAVAILABLE, `${t2}: ${e3}`);
  throw e3;
}
async function __PRIVATE_eventManagerListen(e3, t2) {
  const n2 = __PRIVATE_debugCast(e3), r4 = t2.query;
  let i3 = false, s3 = n2.queries.get(r4);
  if (s3 || (i3 = true, s3 = new __PRIVATE_QueryListenersInfo()), i3)
    try {
      s3.q_ = await n2.onListen(r4);
    } catch (e4) {
      const n3 = __PRIVATE_wrapInUserErrorIfRecoverable(e4, `Initialization of query '${__PRIVATE_stringifyQuery(t2.query)}' failed`);
      return void t2.onError(n3);
    }
  if (n2.queries.set(r4, s3), s3.Q_.push(t2), // Run global snapshot listeners if a consistent snapshot has been emitted.
  t2.U_(n2.onlineState), s3.q_) {
    t2.W_(s3.q_) && __PRIVATE_raiseSnapshotsInSyncEvent(n2);
  }
}
async function __PRIVATE_eventManagerUnlisten(e3, t2) {
  const n2 = __PRIVATE_debugCast(e3), r4 = t2.query;
  let i3 = false;
  const s3 = n2.queries.get(r4);
  if (s3) {
    const e4 = s3.Q_.indexOf(t2);
    e4 >= 0 && (s3.Q_.splice(e4, 1), i3 = 0 === s3.Q_.length);
  }
  if (i3)
    return n2.queries.delete(r4), n2.onUnlisten(r4);
}
function __PRIVATE_eventManagerOnWatchChange(e3, t2) {
  const n2 = __PRIVATE_debugCast(e3);
  let r4 = false;
  for (const e4 of t2) {
    const t3 = e4.query, i3 = n2.queries.get(t3);
    if (i3) {
      for (const t4 of i3.Q_)
        t4.W_(e4) && (r4 = true);
      i3.q_ = e4;
    }
  }
  r4 && __PRIVATE_raiseSnapshotsInSyncEvent(n2);
}
function __PRIVATE_eventManagerOnWatchError(e3, t2, n2) {
  const r4 = __PRIVATE_debugCast(e3), i3 = r4.queries.get(t2);
  if (i3)
    for (const e4 of i3.Q_)
      e4.onError(n2);
  r4.queries.delete(t2);
}
function __PRIVATE_raiseSnapshotsInSyncEvent(e3) {
  e3.K_.forEach((e4) => {
    e4.next();
  });
}
async function __PRIVATE_syncEngineListen(e3, t2) {
  const n2 = __PRIVATE_ensureWatchCallbacks(e3);
  let r4, i3;
  const s3 = n2.ga.get(t2);
  if (s3)
    r4 = s3.targetId, n2.sharedClientState.addLocalQueryTarget(r4), i3 = s3.view.Va();
  else {
    const e4 = await __PRIVATE_localStoreAllocateTarget(n2.localStore, __PRIVATE_queryToTarget(t2)), s4 = n2.sharedClientState.addLocalQueryTarget(e4.targetId);
    r4 = e4.targetId, i3 = await __PRIVATE_initializeViewAndComputeSnapshot(n2, t2, r4, "current" === s4, e4.resumeToken), n2.isPrimaryClient && __PRIVATE_remoteStoreListen(n2.remoteStore, e4);
  }
  return i3;
}
async function __PRIVATE_initializeViewAndComputeSnapshot(e3, t2, n2, r4, i3) {
  e3.Ma = (t3, n3, r5) => async function __PRIVATE_applyDocChanges(e4, t4, n4, r6) {
    let i4 = t4.view.ha(n4);
    i4.Xi && // The query has a limit and some docs were removed, so we need
    // to re-run the query against the local store to make sure we
    // didn't lose any good docs that had been past the limit.
    (i4 = await __PRIVATE_localStoreExecuteQuery(
      e4.localStore,
      t4.query,
      /* usePreviousResults= */
      false
    ).then(({ documents: e5 }) => t4.view.ha(e5, i4)));
    const s4 = r6 && r6.targetChanges.get(t4.targetId), o3 = r6 && null != r6.targetMismatches.get(t4.targetId), _2 = t4.view.applyChanges(
      i4,
      /* limboResolutionEnabled= */
      e4.isPrimaryClient,
      s4,
      o3
    );
    return __PRIVATE_updateTrackedLimbos(e4, t4.targetId, _2.da), _2.snapshot;
  }(e3, t3, n3, r5);
  const s3 = await __PRIVATE_localStoreExecuteQuery(
    e3.localStore,
    t2,
    /* usePreviousResults= */
    true
  ), o2 = new __PRIVATE_View(t2, s3.hs), _ = o2.ha(s3.documents), a2 = TargetChange.createSynthesizedTargetChangeForCurrentChange(n2, r4 && "Offline" !== e3.onlineState, i3), u2 = o2.applyChanges(
    _,
    /* limboResolutionEnabled= */
    e3.isPrimaryClient,
    a2
  );
  __PRIVATE_updateTrackedLimbos(e3, n2, u2.da);
  const c2 = new __PRIVATE_QueryView(t2, n2, o2);
  return e3.ga.set(t2, c2), e3.pa.has(n2) ? e3.pa.get(n2).push(t2) : e3.pa.set(n2, [t2]), u2.snapshot;
}
async function __PRIVATE_syncEngineUnlisten(e3, t2) {
  const n2 = __PRIVATE_debugCast(e3), r4 = n2.ga.get(t2), i3 = n2.pa.get(r4.targetId);
  if (i3.length > 1)
    return n2.pa.set(r4.targetId, i3.filter((e4) => !__PRIVATE_queryEquals(e4, t2))), void n2.ga.delete(t2);
  if (n2.isPrimaryClient) {
    n2.sharedClientState.removeLocalQueryTarget(r4.targetId);
    n2.sharedClientState.isActiveQueryTarget(r4.targetId) || await __PRIVATE_localStoreReleaseTarget(
      n2.localStore,
      r4.targetId,
      /*keepPersistedTargetData=*/
      false
    ).then(() => {
      n2.sharedClientState.clearQueryState(r4.targetId), __PRIVATE_remoteStoreUnlisten(n2.remoteStore, r4.targetId), __PRIVATE_removeAndCleanupTarget(n2, r4.targetId);
    }).catch(__PRIVATE_ignoreIfPrimaryLeaseLoss);
  } else
    __PRIVATE_removeAndCleanupTarget(n2, r4.targetId), await __PRIVATE_localStoreReleaseTarget(
      n2.localStore,
      r4.targetId,
      /*keepPersistedTargetData=*/
      true
    );
}
async function __PRIVATE_syncEngineWrite(e3, t2, n2) {
  const r4 = __PRIVATE_syncEngineEnsureWriteCallbacks(e3);
  try {
    const e4 = await function __PRIVATE_localStoreWriteLocally(e5, t3) {
      const n3 = __PRIVATE_debugCast(e5), r5 = Timestamp.now(), i3 = t3.reduce((e6, t4) => e6.add(t4.key), __PRIVATE_documentKeySet());
      let s3, o2;
      return n3.persistence.runTransaction("Locally write mutations", "readwrite", (e6) => {
        let _ = __PRIVATE_mutableDocumentMap(), a2 = __PRIVATE_documentKeySet();
        return n3.os.getEntries(e6, i3).next((e7) => {
          _ = e7, _.forEach((e8, t4) => {
            t4.isValidDocument() || (a2 = a2.add(e8));
          });
        }).next(() => n3.localDocuments.getOverlayedDocuments(e6, _)).next((i4) => {
          s3 = i4;
          const o3 = [];
          for (const e7 of t3) {
            const t4 = __PRIVATE_mutationExtractBaseValue(e7, s3.get(e7.key).overlayedDocument);
            null != t4 && // NOTE: The base state should only be applied if there's some
            // existing document to override, so use a Precondition of
            // exists=true
            o3.push(new __PRIVATE_PatchMutation(e7.key, t4, __PRIVATE_extractFieldMask(t4.value.mapValue), Precondition.exists(true)));
          }
          return n3.mutationQueue.addMutationBatch(e6, r5, o3, t3);
        }).next((t4) => {
          o2 = t4;
          const r6 = t4.applyToLocalDocumentSet(s3, a2);
          return n3.documentOverlayCache.saveOverlays(e6, t4.batchId, r6);
        });
      }).then(() => ({
        batchId: o2.batchId,
        changes: __PRIVATE_convertOverlayedDocumentMapToDocumentMap(s3)
      }));
    }(r4.localStore, t2);
    r4.sharedClientState.addPendingMutation(e4.batchId), function __PRIVATE_addMutationCallback(e5, t3, n3) {
      let r5 = e5.Da[e5.currentUser.toKey()];
      r5 || (r5 = new SortedMap(__PRIVATE_primitiveComparator));
      r5 = r5.insert(t3, n3), e5.Da[e5.currentUser.toKey()] = r5;
    }(r4, e4.batchId, n2), await __PRIVATE_syncEngineEmitNewSnapsAndNotifyLocalStore(r4, e4.changes), await __PRIVATE_fillWritePipeline(r4.remoteStore);
  } catch (e4) {
    const t3 = __PRIVATE_wrapInUserErrorIfRecoverable(e4, "Failed to persist write");
    n2.reject(t3);
  }
}
async function __PRIVATE_syncEngineApplyRemoteEvent(e3, t2) {
  const n2 = __PRIVATE_debugCast(e3);
  try {
    const e4 = await __PRIVATE_localStoreApplyRemoteEventToLocalCache(n2.localStore, t2);
    t2.targetChanges.forEach((e5, t3) => {
      const r4 = n2.Sa.get(t3);
      r4 && // Since this is a limbo resolution lookup, it's for a single document
      // and it could be added, modified, or removed, but not a combination.
      (__PRIVATE_hardAssert(e5.addedDocuments.size + e5.modifiedDocuments.size + e5.removedDocuments.size <= 1), e5.addedDocuments.size > 0 ? r4.ma = true : e5.modifiedDocuments.size > 0 ? __PRIVATE_hardAssert(r4.ma) : e5.removedDocuments.size > 0 && (__PRIVATE_hardAssert(r4.ma), r4.ma = false));
    }), await __PRIVATE_syncEngineEmitNewSnapsAndNotifyLocalStore(n2, e4, t2);
  } catch (e4) {
    await __PRIVATE_ignoreIfPrimaryLeaseLoss(e4);
  }
}
function __PRIVATE_syncEngineApplyOnlineStateChange(e3, t2, n2) {
  const r4 = __PRIVATE_debugCast(e3);
  if (r4.isPrimaryClient && 0 === n2 || !r4.isPrimaryClient && 1 === n2) {
    const e4 = [];
    r4.ga.forEach((n3, r5) => {
      const i3 = r5.view.U_(t2);
      i3.snapshot && e4.push(i3.snapshot);
    }), function __PRIVATE_eventManagerOnOnlineStateChange(e5, t3) {
      const n3 = __PRIVATE_debugCast(e5);
      n3.onlineState = t3;
      let r5 = false;
      n3.queries.forEach((e6, n4) => {
        for (const e7 of n4.Q_)
          e7.U_(t3) && (r5 = true);
      }), r5 && __PRIVATE_raiseSnapshotsInSyncEvent(n3);
    }(r4.eventManager, t2), e4.length && r4.fa.u_(e4), r4.onlineState = t2, r4.isPrimaryClient && r4.sharedClientState.setOnlineState(t2);
  }
}
async function __PRIVATE_syncEngineRejectListen(e3, t2, n2) {
  const r4 = __PRIVATE_debugCast(e3);
  r4.sharedClientState.updateQueryState(t2, "rejected", n2);
  const i3 = r4.Sa.get(t2), s3 = i3 && i3.key;
  if (s3) {
    let e4 = new SortedMap(DocumentKey.comparator);
    e4 = e4.insert(s3, MutableDocument.newNoDocument(s3, SnapshotVersion.min()));
    const n3 = __PRIVATE_documentKeySet().add(s3), i4 = new RemoteEvent(
      SnapshotVersion.min(),
      /* targetChanges= */
      /* @__PURE__ */ new Map(),
      /* targetMismatches= */
      new SortedMap(__PRIVATE_primitiveComparator),
      e4,
      n3
    );
    await __PRIVATE_syncEngineApplyRemoteEvent(r4, i4), // Since this query failed, we won't want to manually unlisten to it.
    // We only remove it from bookkeeping after we successfully applied the
    // RemoteEvent. If `applyRemoteEvent()` throws, we want to re-listen to
    // this query when the RemoteStore restarts the Watch stream, which should
    // re-trigger the target failure.
    r4.wa = r4.wa.remove(s3), r4.Sa.delete(t2), __PRIVATE_pumpEnqueuedLimboResolutions(r4);
  } else
    await __PRIVATE_localStoreReleaseTarget(
      r4.localStore,
      t2,
      /* keepPersistedTargetData */
      false
    ).then(() => __PRIVATE_removeAndCleanupTarget(r4, t2, n2)).catch(__PRIVATE_ignoreIfPrimaryLeaseLoss);
}
async function __PRIVATE_syncEngineApplySuccessfulWrite(e3, t2) {
  const n2 = __PRIVATE_debugCast(e3), r4 = t2.batch.batchId;
  try {
    const e4 = await __PRIVATE_localStoreAcknowledgeBatch(n2.localStore, t2);
    __PRIVATE_processUserCallback(
      n2,
      r4,
      /*error=*/
      null
    ), __PRIVATE_triggerPendingWritesCallbacks(n2, r4), n2.sharedClientState.updateMutationState(r4, "acknowledged"), await __PRIVATE_syncEngineEmitNewSnapsAndNotifyLocalStore(n2, e4);
  } catch (e4) {
    await __PRIVATE_ignoreIfPrimaryLeaseLoss(e4);
  }
}
async function __PRIVATE_syncEngineRejectFailedWrite(e3, t2, n2) {
  const r4 = __PRIVATE_debugCast(e3);
  try {
    const e4 = await function __PRIVATE_localStoreRejectBatch(e5, t3) {
      const n3 = __PRIVATE_debugCast(e5);
      return n3.persistence.runTransaction("Reject batch", "readwrite-primary", (e6) => {
        let r5;
        return n3.mutationQueue.lookupMutationBatch(e6, t3).next((t4) => (__PRIVATE_hardAssert(null !== t4), r5 = t4.keys(), n3.mutationQueue.removeMutationBatch(e6, t4))).next(() => n3.mutationQueue.performConsistencyCheck(e6)).next(() => n3.documentOverlayCache.removeOverlaysForBatchId(e6, r5, t3)).next(() => n3.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(e6, r5)).next(() => n3.localDocuments.getDocuments(e6, r5));
      });
    }(r4.localStore, t2);
    __PRIVATE_processUserCallback(r4, t2, n2), __PRIVATE_triggerPendingWritesCallbacks(r4, t2), r4.sharedClientState.updateMutationState(t2, "rejected", n2), await __PRIVATE_syncEngineEmitNewSnapsAndNotifyLocalStore(r4, e4);
  } catch (n3) {
    await __PRIVATE_ignoreIfPrimaryLeaseLoss(n3);
  }
}
function __PRIVATE_triggerPendingWritesCallbacks(e3, t2) {
  (e3.Ca.get(t2) || []).forEach((e4) => {
    e4.resolve();
  }), e3.Ca.delete(t2);
}
function __PRIVATE_processUserCallback(e3, t2, n2) {
  const r4 = __PRIVATE_debugCast(e3);
  let i3 = r4.Da[r4.currentUser.toKey()];
  if (i3) {
    const e4 = i3.get(t2);
    e4 && (n2 ? e4.reject(n2) : e4.resolve(), i3 = i3.remove(t2)), r4.Da[r4.currentUser.toKey()] = i3;
  }
}
function __PRIVATE_removeAndCleanupTarget(e3, t2, n2 = null) {
  e3.sharedClientState.removeLocalQueryTarget(t2);
  for (const r4 of e3.pa.get(t2))
    e3.ga.delete(r4), n2 && e3.fa.xa(r4, n2);
  if (e3.pa.delete(t2), e3.isPrimaryClient) {
    e3.ba.Vr(t2).forEach((t3) => {
      e3.ba.containsKey(t3) || // We removed the last reference for this key
      __PRIVATE_removeLimboTarget(e3, t3);
    });
  }
}
function __PRIVATE_removeLimboTarget(e3, t2) {
  e3.ya.delete(t2.path.canonicalString());
  const n2 = e3.wa.get(t2);
  null !== n2 && (__PRIVATE_remoteStoreUnlisten(e3.remoteStore, n2), e3.wa = e3.wa.remove(t2), e3.Sa.delete(n2), __PRIVATE_pumpEnqueuedLimboResolutions(e3));
}
function __PRIVATE_updateTrackedLimbos(e3, t2, n2) {
  for (const r4 of n2)
    if (r4 instanceof __PRIVATE_AddedLimboDocument)
      e3.ba.addReference(r4.key, t2), __PRIVATE_trackLimboChange(e3, r4);
    else if (r4 instanceof __PRIVATE_RemovedLimboDocument) {
      __PRIVATE_logDebug("SyncEngine", "Document no longer in limbo: " + r4.key), e3.ba.removeReference(r4.key, t2);
      e3.ba.containsKey(r4.key) || // We removed the last reference for this key
      __PRIVATE_removeLimboTarget(e3, r4.key);
    } else
      fail();
}
function __PRIVATE_trackLimboChange(e3, t2) {
  const n2 = t2.key, r4 = n2.path.canonicalString();
  e3.wa.get(n2) || e3.ya.has(r4) || (__PRIVATE_logDebug("SyncEngine", "New document in limbo: " + n2), e3.ya.add(r4), __PRIVATE_pumpEnqueuedLimboResolutions(e3));
}
function __PRIVATE_pumpEnqueuedLimboResolutions(e3) {
  for (; e3.ya.size > 0 && e3.wa.size < e3.maxConcurrentLimboResolutions; ) {
    const t2 = e3.ya.values().next().value;
    e3.ya.delete(t2);
    const n2 = new DocumentKey(ResourcePath.fromString(t2)), r4 = e3.va.next();
    e3.Sa.set(r4, new LimboResolution(n2)), e3.wa = e3.wa.insert(n2, r4), __PRIVATE_remoteStoreListen(e3.remoteStore, new TargetData(__PRIVATE_queryToTarget(__PRIVATE_newQueryForPath(n2.path)), r4, "TargetPurposeLimboResolution", __PRIVATE_ListenSequence._e));
  }
}
async function __PRIVATE_syncEngineEmitNewSnapsAndNotifyLocalStore(e3, t2, n2) {
  const r4 = __PRIVATE_debugCast(e3), i3 = [], s3 = [], o2 = [];
  r4.ga.isEmpty() || (r4.ga.forEach((e4, _) => {
    o2.push(r4.Ma(_, t2, n2).then((e5) => {
      if (
        // If there are changes, or we are handling a global snapshot, notify
        // secondary clients to update query state.
        (e5 || n2) && r4.isPrimaryClient && r4.sharedClientState.updateQueryState(_.targetId, (null == e5 ? void 0 : e5.fromCache) ? "not-current" : "current"), e5
      ) {
        i3.push(e5);
        const t3 = __PRIVATE_LocalViewChanges.Ki(_.targetId, e5);
        s3.push(t3);
      }
    }));
  }), await Promise.all(o2), r4.fa.u_(i3), await async function __PRIVATE_localStoreNotifyLocalViewChanges(e4, t3) {
    const n3 = __PRIVATE_debugCast(e4);
    try {
      await n3.persistence.runTransaction("notifyLocalViewChanges", "readwrite", (e5) => PersistencePromise.forEach(t3, (t4) => PersistencePromise.forEach(t4.qi, (r5) => n3.persistence.referenceDelegate.addReference(e5, t4.targetId, r5)).next(() => PersistencePromise.forEach(t4.Qi, (r5) => n3.persistence.referenceDelegate.removeReference(e5, t4.targetId, r5)))));
    } catch (e5) {
      if (!__PRIVATE_isIndexedDbTransactionError(e5))
        throw e5;
      __PRIVATE_logDebug("LocalStore", "Failed to update sequence numbers: " + e5);
    }
    for (const e5 of t3) {
      const t4 = e5.targetId;
      if (!e5.fromCache) {
        const e6 = n3.ns.get(t4), r5 = e6.snapshotVersion, i4 = e6.withLastLimboFreeSnapshotVersion(r5);
        n3.ns = n3.ns.insert(t4, i4);
      }
    }
  }(r4.localStore, s3));
}
async function __PRIVATE_syncEngineHandleCredentialChange(e3, t2) {
  const n2 = __PRIVATE_debugCast(e3);
  if (!n2.currentUser.isEqual(t2)) {
    __PRIVATE_logDebug("SyncEngine", "User change. New user:", t2.toKey());
    const e4 = await __PRIVATE_localStoreHandleUserChange(n2.localStore, t2);
    n2.currentUser = t2, // Fails tasks waiting for pending writes requested by previous user.
    function __PRIVATE_rejectOutstandingPendingWritesCallbacks(e5, t3) {
      e5.Ca.forEach((e6) => {
        e6.forEach((e7) => {
          e7.reject(new FirestoreError(D2.CANCELLED, t3));
        });
      }), e5.Ca.clear();
    }(n2, "'waitForPendingWrites' promise is rejected due to a user change."), // TODO(b/114226417): Consider calling this only in the primary tab.
    n2.sharedClientState.handleUserChange(t2, e4.removedBatchIds, e4.addedBatchIds), await __PRIVATE_syncEngineEmitNewSnapsAndNotifyLocalStore(n2, e4.us);
  }
}
function __PRIVATE_syncEngineGetRemoteKeysForTarget(e3, t2) {
  const n2 = __PRIVATE_debugCast(e3), r4 = n2.Sa.get(t2);
  if (r4 && r4.ma)
    return __PRIVATE_documentKeySet().add(r4.key);
  {
    let e4 = __PRIVATE_documentKeySet();
    const r5 = n2.pa.get(t2);
    if (!r5)
      return e4;
    for (const t3 of r5) {
      const r6 = n2.ga.get(t3);
      e4 = e4.unionWith(r6.view.la);
    }
    return e4;
  }
}
function __PRIVATE_ensureWatchCallbacks(e3) {
  const t2 = __PRIVATE_debugCast(e3);
  return t2.remoteStore.remoteSyncer.applyRemoteEvent = __PRIVATE_syncEngineApplyRemoteEvent.bind(null, t2), t2.remoteStore.remoteSyncer.getRemoteKeysForTarget = __PRIVATE_syncEngineGetRemoteKeysForTarget.bind(null, t2), t2.remoteStore.remoteSyncer.rejectListen = __PRIVATE_syncEngineRejectListen.bind(null, t2), t2.fa.u_ = __PRIVATE_eventManagerOnWatchChange.bind(null, t2.eventManager), t2.fa.xa = __PRIVATE_eventManagerOnWatchError.bind(null, t2.eventManager), t2;
}
function __PRIVATE_syncEngineEnsureWriteCallbacks(e3) {
  const t2 = __PRIVATE_debugCast(e3);
  return t2.remoteStore.remoteSyncer.applySuccessfulWrite = __PRIVATE_syncEngineApplySuccessfulWrite.bind(null, t2), t2.remoteStore.remoteSyncer.rejectFailedWrite = __PRIVATE_syncEngineRejectFailedWrite.bind(null, t2), t2;
}
async function __PRIVATE_setOfflineComponentProvider(e3, t2) {
  e3.asyncQueue.verifyOperationInProgress(), __PRIVATE_logDebug("FirestoreClient", "Initializing OfflineComponentProvider");
  const n2 = e3.configuration;
  await t2.initialize(n2);
  let r4 = n2.initialUser;
  e3.setCredentialChangeListener(async (e4) => {
    r4.isEqual(e4) || (await __PRIVATE_localStoreHandleUserChange(t2.localStore, e4), r4 = e4);
  }), // When a user calls clearPersistence() in one client, all other clients
  // need to be terminated to allow the delete to succeed.
  t2.persistence.setDatabaseDeletedListener(() => e3.terminate()), e3._offlineComponents = t2;
}
async function __PRIVATE_setOnlineComponentProvider(e3, t2) {
  e3.asyncQueue.verifyOperationInProgress();
  const n2 = await __PRIVATE_ensureOfflineComponents(e3);
  __PRIVATE_logDebug("FirestoreClient", "Initializing OnlineComponentProvider"), await t2.initialize(n2, e3.configuration), // The CredentialChangeListener of the online component provider takes
  // precedence over the offline component provider.
  e3.setCredentialChangeListener((e4) => __PRIVATE_remoteStoreHandleCredentialChange(t2.remoteStore, e4)), e3.setAppCheckTokenChangeListener((e4, n3) => __PRIVATE_remoteStoreHandleCredentialChange(t2.remoteStore, n3)), e3._onlineComponents = t2;
}
function __PRIVATE_canFallbackFromIndexedDbError(e3) {
  return "FirebaseError" === e3.name ? e3.code === D2.FAILED_PRECONDITION || e3.code === D2.UNIMPLEMENTED : !("undefined" != typeof DOMException && e3 instanceof DOMException) || // When the browser is out of quota we could get either quota exceeded
  // or an aborted error depending on whether the error happened during
  // schema migration.
  (22 === e3.code || 20 === e3.code || // Firefox Private Browsing mode disables IndexedDb and returns
  // INVALID_STATE for any usage.
  11 === e3.code);
}
async function __PRIVATE_ensureOfflineComponents(e3) {
  if (!e3._offlineComponents)
    if (e3._uninitializedComponentsProvider) {
      __PRIVATE_logDebug("FirestoreClient", "Using user provided OfflineComponentProvider");
      try {
        await __PRIVATE_setOfflineComponentProvider(e3, e3._uninitializedComponentsProvider._offline);
      } catch (t2) {
        const n2 = t2;
        if (!__PRIVATE_canFallbackFromIndexedDbError(n2))
          throw n2;
        __PRIVATE_logWarn("Error using user provided cache. Falling back to memory cache: " + n2), await __PRIVATE_setOfflineComponentProvider(e3, new MemoryOfflineComponentProvider());
      }
    } else
      __PRIVATE_logDebug("FirestoreClient", "Using default OfflineComponentProvider"), await __PRIVATE_setOfflineComponentProvider(e3, new MemoryOfflineComponentProvider());
  return e3._offlineComponents;
}
async function __PRIVATE_ensureOnlineComponents(e3) {
  return e3._onlineComponents || (e3._uninitializedComponentsProvider ? (__PRIVATE_logDebug("FirestoreClient", "Using user provided OnlineComponentProvider"), await __PRIVATE_setOnlineComponentProvider(e3, e3._uninitializedComponentsProvider._online)) : (__PRIVATE_logDebug("FirestoreClient", "Using default OnlineComponentProvider"), await __PRIVATE_setOnlineComponentProvider(e3, new OnlineComponentProvider()))), e3._onlineComponents;
}
function __PRIVATE_getSyncEngine(e3) {
  return __PRIVATE_ensureOnlineComponents(e3).then((e4) => e4.syncEngine);
}
async function __PRIVATE_getEventManager(e3) {
  const t2 = await __PRIVATE_ensureOnlineComponents(e3), n2 = t2.eventManager;
  return n2.onListen = __PRIVATE_syncEngineListen.bind(null, t2.syncEngine), n2.onUnlisten = __PRIVATE_syncEngineUnlisten.bind(null, t2.syncEngine), n2;
}
function __PRIVATE_firestoreClientGetDocumentsViaSnapshotListener(e3, t2, n2 = {}) {
  const r4 = new __PRIVATE_Deferred();
  return e3.asyncQueue.enqueueAndForget(async () => function __PRIVATE_executeQueryViaSnapshotListener(e4, t3, n3, r5, i3) {
    const s3 = new __PRIVATE_AsyncObserver({
      next: (n4) => {
        t3.enqueueAndForget(() => __PRIVATE_eventManagerUnlisten(e4, o2)), n4.fromCache && "server" === r5.source ? i3.reject(new FirestoreError(D2.UNAVAILABLE, 'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to "server" to retrieve the cached documents.)')) : i3.resolve(n4);
      },
      error: (e5) => i3.reject(e5)
    }), o2 = new __PRIVATE_QueryListener(n3, s3, {
      includeMetadataChanges: true,
      Z_: true
    });
    return __PRIVATE_eventManagerListen(e4, o2);
  }(await __PRIVATE_getEventManager(e3), e3.asyncQueue, t2, n2, r4)), r4.promise;
}
function __PRIVATE_cloneLongPollingOptions(e3) {
  const t2 = {};
  return void 0 !== e3.timeoutSeconds && (t2.timeoutSeconds = e3.timeoutSeconds), t2;
}
function __PRIVATE_validateNonEmptyArgument(e3, t2, n2) {
  if (!n2)
    throw new FirestoreError(D2.INVALID_ARGUMENT, `Function ${e3}() cannot be called with an empty ${t2}.`);
}
function __PRIVATE_validateIsNotUsedTogether(e3, t2, n2, r4) {
  if (true === t2 && true === r4)
    throw new FirestoreError(D2.INVALID_ARGUMENT, `${e3} and ${n2} cannot be used together.`);
}
function __PRIVATE_validateDocumentPath(e3) {
  if (!DocumentKey.isDocumentKey(e3))
    throw new FirestoreError(D2.INVALID_ARGUMENT, `Invalid document reference. Document references must have an even number of segments, but ${e3} has ${e3.length}.`);
}
function __PRIVATE_validateCollectionPath(e3) {
  if (DocumentKey.isDocumentKey(e3))
    throw new FirestoreError(D2.INVALID_ARGUMENT, `Invalid collection reference. Collection references must have an odd number of segments, but ${e3} has ${e3.length}.`);
}
function __PRIVATE_valueDescription(e3) {
  if (void 0 === e3)
    return "undefined";
  if (null === e3)
    return "null";
  if ("string" == typeof e3)
    return e3.length > 20 && (e3 = `${e3.substring(0, 20)}...`), JSON.stringify(e3);
  if ("number" == typeof e3 || "boolean" == typeof e3)
    return "" + e3;
  if ("object" == typeof e3) {
    if (e3 instanceof Array)
      return "an array";
    {
      const t2 = (
        /** try to get the constructor name for an object. */
        function __PRIVATE_tryGetCustomObjectType(e4) {
          if (e4.constructor)
            return e4.constructor.name;
          return null;
        }(e3)
      );
      return t2 ? `a custom ${t2} object` : "an object";
    }
  }
  return "function" == typeof e3 ? "a function" : fail();
}
function __PRIVATE_cast(e3, t2) {
  if ("_delegate" in e3 && // Unwrap Compat types
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  (e3 = e3._delegate), !(e3 instanceof t2)) {
    if (t2.name === e3.constructor.name)
      throw new FirestoreError(D2.INVALID_ARGUMENT, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");
    {
      const n2 = __PRIVATE_valueDescription(e3);
      throw new FirestoreError(D2.INVALID_ARGUMENT, `Expected type '${t2.name}', but it was: ${n2}`);
    }
  }
  return e3;
}
function connectFirestoreEmulator(e3, t2, n2, r4 = {}) {
  var i3;
  const s3 = (e3 = __PRIVATE_cast(e3, Firestore$1))._getSettings(), o2 = `${t2}:${n2}`;
  if ("firestore.googleapis.com" !== s3.host && s3.host !== o2 && __PRIVATE_logWarn("Host has been set in both settings() and connectFirestoreEmulator(), emulator host will be used."), e3._setSettings(Object.assign(Object.assign({}, s3), {
    host: o2,
    ssl: false
  })), r4.mockUserToken) {
    let t3, n3;
    if ("string" == typeof r4.mockUserToken)
      t3 = r4.mockUserToken, n3 = User.MOCK_USER;
    else {
      t3 = createMockUserToken(r4.mockUserToken, null === (i3 = e3._app) || void 0 === i3 ? void 0 : i3.options.projectId);
      const s4 = r4.mockUserToken.sub || r4.mockUserToken.user_id;
      if (!s4)
        throw new FirestoreError(D2.INVALID_ARGUMENT, "mockUserToken must contain 'sub' or 'user_id' field!");
      n3 = new User(s4);
    }
    e3._authCredentials = new __PRIVATE_EmulatorAuthCredentialsProvider(new __PRIVATE_OAuthToken(t3, n3));
  }
}
function collection(e3, t2, ...n2) {
  if (e3 = getModularInstance(e3), __PRIVATE_validateNonEmptyArgument("collection", "path", t2), e3 instanceof Firestore$1) {
    const r4 = ResourcePath.fromString(t2, ...n2);
    return __PRIVATE_validateCollectionPath(r4), new CollectionReference(
      e3,
      /* converter= */
      null,
      r4
    );
  }
  {
    if (!(e3 instanceof DocumentReference || e3 instanceof CollectionReference))
      throw new FirestoreError(D2.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const r4 = e3._path.child(ResourcePath.fromString(t2, ...n2));
    return __PRIVATE_validateCollectionPath(r4), new CollectionReference(
      e3.firestore,
      /* converter= */
      null,
      r4
    );
  }
}
function doc(e3, t2, ...n2) {
  if (e3 = getModularInstance(e3), // We allow omission of 'pathString' but explicitly prohibit passing in both
  // 'undefined' and 'null'.
  1 === arguments.length && (t2 = __PRIVATE_AutoId.newId()), __PRIVATE_validateNonEmptyArgument("doc", "path", t2), e3 instanceof Firestore$1) {
    const r4 = ResourcePath.fromString(t2, ...n2);
    return __PRIVATE_validateDocumentPath(r4), new DocumentReference(
      e3,
      /* converter= */
      null,
      new DocumentKey(r4)
    );
  }
  {
    if (!(e3 instanceof DocumentReference || e3 instanceof CollectionReference))
      throw new FirestoreError(D2.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const r4 = e3._path.child(ResourcePath.fromString(t2, ...n2));
    return __PRIVATE_validateDocumentPath(r4), new DocumentReference(e3.firestore, e3 instanceof CollectionReference ? e3.converter : null, new DocumentKey(r4));
  }
}
function getFirestore(t2, n2) {
  const r4 = "object" == typeof t2 ? t2 : getApp(), i3 = "string" == typeof t2 ? t2 : n2 || "(default)", s3 = _getProvider(r4, "firestore").getImmediate({
    identifier: i3
  });
  if (!s3._initialized) {
    const e3 = getDefaultEmulatorHostnameAndPort("firestore");
    e3 && connectFirestoreEmulator(s3, ...e3);
  }
  return s3;
}
function ensureFirestoreConfigured(e3) {
  return e3._firestoreClient || __PRIVATE_configureFirestore(e3), e3._firestoreClient.verifyNotTerminated(), e3._firestoreClient;
}
function __PRIVATE_configureFirestore(e3) {
  var t2, n2, r4;
  const i3 = e3._freezeSettings(), s3 = function __PRIVATE_makeDatabaseInfo(e4, t3, n3, r5) {
    return new DatabaseInfo(e4, t3, n3, r5.host, r5.ssl, r5.experimentalForceLongPolling, r5.experimentalAutoDetectLongPolling, __PRIVATE_cloneLongPollingOptions(r5.experimentalLongPollingOptions), r5.useFetchStreams);
  }(e3._databaseId, (null === (t2 = e3._app) || void 0 === t2 ? void 0 : t2.options.appId) || "", e3._persistenceKey, i3);
  e3._firestoreClient = new FirestoreClient(e3._authCredentials, e3._appCheckCredentials, e3._queue, s3), (null === (n2 = i3.localCache) || void 0 === n2 ? void 0 : n2._offlineComponentProvider) && (null === (r4 = i3.localCache) || void 0 === r4 ? void 0 : r4._onlineComponentProvider) && (e3._firestoreClient._uninitializedComponentsProvider = {
    _offlineKind: i3.localCache.kind,
    _offline: i3.localCache._offlineComponentProvider,
    _online: i3.localCache._onlineComponentProvider
  });
}
function __PRIVATE_isWrite(e3) {
  switch (e3) {
    case 0:
    case 2:
    case 1:
      return true;
    case 3:
    case 4:
      return false;
    default:
      throw fail();
  }
}
function __PRIVATE_newUserDataReader(e3) {
  const t2 = e3._freezeSettings(), n2 = __PRIVATE_newSerializer(e3._databaseId);
  return new __PRIVATE_UserDataReader(e3._databaseId, !!t2.ignoreUndefinedProperties, n2);
}
function __PRIVATE_parseSetData(e3, t2, n2, r4, i3, s3 = {}) {
  const o2 = e3.Su(s3.merge || s3.mergeFields ? 2 : 0, t2, n2, i3);
  __PRIVATE_validatePlainObject("Data must be an object, but it was:", o2, r4);
  const _ = __PRIVATE_parseObject(r4, o2);
  let a2, u2;
  if (s3.merge)
    a2 = new FieldMask(o2.fieldMask), u2 = o2.fieldTransforms;
  else if (s3.mergeFields) {
    const e4 = [];
    for (const r5 of s3.mergeFields) {
      const i4 = __PRIVATE_fieldPathFromArgument$1(t2, r5, n2);
      if (!o2.contains(i4))
        throw new FirestoreError(D2.INVALID_ARGUMENT, `Field '${i4}' is specified in your field mask but missing from your input data.`);
      __PRIVATE_fieldMaskContains(e4, i4) || e4.push(i4);
    }
    a2 = new FieldMask(e4), u2 = o2.fieldTransforms.filter((e5) => a2.covers(e5.field));
  } else
    a2 = null, u2 = o2.fieldTransforms;
  return new ParsedSetData(new ObjectValue(_), a2, u2);
}
function __PRIVATE_parseData(e3, t2) {
  if (__PRIVATE_looksLikeJsonObject(
    // Unwrap the API type from the Compat SDK. This will return the API type
    // from firestore-exp.
    e3 = getModularInstance(e3)
  ))
    return __PRIVATE_validatePlainObject("Unsupported field value:", t2, e3), __PRIVATE_parseObject(e3, t2);
  if (e3 instanceof FieldValue)
    return function __PRIVATE_parseSentinelFieldValue(e4, t3) {
      if (!__PRIVATE_isWrite(t3.du))
        throw t3.pu(`${e4._methodName}() can only be used with update() and set()`);
      if (!t3.path)
        throw t3.pu(`${e4._methodName}() is not currently supported inside arrays`);
      const n2 = e4._toFieldTransform(t3);
      n2 && t3.fieldTransforms.push(n2);
    }(e3, t2), null;
  if (void 0 === e3 && t2.ignoreUndefinedProperties)
    return null;
  if (
    // If context.path is null we are inside an array and we don't support
    // field mask paths more granular than the top-level array.
    t2.path && t2.fieldMask.push(t2.path), e3 instanceof Array
  ) {
    if (t2.settings.Vu && 4 !== t2.du)
      throw t2.pu("Nested arrays are not supported");
    return function __PRIVATE_parseArray(e4, t3) {
      const n2 = [];
      let r4 = 0;
      for (const i3 of e4) {
        let e5 = __PRIVATE_parseData(i3, t3.gu(r4));
        null == e5 && // Just include nulls in the array for fields being replaced with a
        // sentinel.
        (e5 = {
          nullValue: "NULL_VALUE"
        }), n2.push(e5), r4++;
      }
      return {
        arrayValue: {
          values: n2
        }
      };
    }(e3, t2);
  }
  return function __PRIVATE_parseScalarValue(e4, t3) {
    if (null === (e4 = getModularInstance(e4)))
      return {
        nullValue: "NULL_VALUE"
      };
    if ("number" == typeof e4)
      return toNumber(t3.serializer, e4);
    if ("boolean" == typeof e4)
      return {
        booleanValue: e4
      };
    if ("string" == typeof e4)
      return {
        stringValue: e4
      };
    if (e4 instanceof Date) {
      const n2 = Timestamp.fromDate(e4);
      return {
        timestampValue: toTimestamp(t3.serializer, n2)
      };
    }
    if (e4 instanceof Timestamp) {
      const n2 = new Timestamp(e4.seconds, 1e3 * Math.floor(e4.nanoseconds / 1e3));
      return {
        timestampValue: toTimestamp(t3.serializer, n2)
      };
    }
    if (e4 instanceof GeoPoint)
      return {
        geoPointValue: {
          latitude: e4.latitude,
          longitude: e4.longitude
        }
      };
    if (e4 instanceof Bytes)
      return {
        bytesValue: __PRIVATE_toBytes(t3.serializer, e4._byteString)
      };
    if (e4 instanceof DocumentReference) {
      const n2 = t3.databaseId, r4 = e4.firestore._databaseId;
      if (!r4.isEqual(n2))
        throw t3.pu(`Document reference is for database ${r4.projectId}/${r4.database} but should be for database ${n2.projectId}/${n2.database}`);
      return {
        referenceValue: __PRIVATE_toResourceName(e4.firestore._databaseId || t3.databaseId, e4._key.path)
      };
    }
    throw t3.pu(`Unsupported field value: ${__PRIVATE_valueDescription(e4)}`);
  }(e3, t2);
}
function __PRIVATE_parseObject(e3, t2) {
  const n2 = {};
  return isEmpty(e3) ? (
    // If we encounter an empty object, we explicitly add it to the update
    // mask to ensure that the server creates a map entry.
    t2.path && t2.path.length > 0 && t2.fieldMask.push(t2.path)
  ) : forEach(e3, (e4, r4) => {
    const i3 = __PRIVATE_parseData(r4, t2.Ru(e4));
    null != i3 && (n2[e4] = i3);
  }), {
    mapValue: {
      fields: n2
    }
  };
}
function __PRIVATE_looksLikeJsonObject(e3) {
  return !("object" != typeof e3 || null === e3 || e3 instanceof Array || e3 instanceof Date || e3 instanceof Timestamp || e3 instanceof GeoPoint || e3 instanceof Bytes || e3 instanceof DocumentReference || e3 instanceof FieldValue);
}
function __PRIVATE_validatePlainObject(e3, t2, n2) {
  if (!__PRIVATE_looksLikeJsonObject(n2) || !function __PRIVATE_isPlainObject(e4) {
    return "object" == typeof e4 && null !== e4 && (Object.getPrototypeOf(e4) === Object.prototype || null === Object.getPrototypeOf(e4));
  }(n2)) {
    const r4 = __PRIVATE_valueDescription(n2);
    throw "an object" === r4 ? t2.pu(e3 + " a custom object") : t2.pu(e3 + " " + r4);
  }
}
function __PRIVATE_fieldPathFromArgument$1(e3, t2, n2) {
  if (
    // If required, replace the FieldPath Compat class with with the firestore-exp
    // FieldPath.
    (t2 = getModularInstance(t2)) instanceof FieldPath
  )
    return t2._internalPath;
  if ("string" == typeof t2)
    return __PRIVATE_fieldPathFromDotSeparatedString(e3, t2);
  throw __PRIVATE_createError(
    "Field path arguments must be of type string or ",
    e3,
    /* hasConverter= */
    false,
    /* path= */
    void 0,
    n2
  );
}
function __PRIVATE_fieldPathFromDotSeparatedString(e3, t2, n2) {
  if (t2.search(pe) >= 0)
    throw __PRIVATE_createError(
      `Invalid field path (${t2}). Paths must not contain '~', '*', '/', '[', or ']'`,
      e3,
      /* hasConverter= */
      false,
      /* path= */
      void 0,
      n2
    );
  try {
    return new FieldPath(...t2.split("."))._internalPath;
  } catch (r4) {
    throw __PRIVATE_createError(
      `Invalid field path (${t2}). Paths must not be empty, begin with '.', end with '.', or contain '..'`,
      e3,
      /* hasConverter= */
      false,
      /* path= */
      void 0,
      n2
    );
  }
}
function __PRIVATE_createError(e3, t2, n2, r4, i3) {
  const s3 = r4 && !r4.isEmpty(), o2 = void 0 !== i3;
  let _ = `Function ${t2}() called with invalid data`;
  n2 && (_ += " (via `toFirestore()`)"), _ += ". ";
  let a2 = "";
  return (s3 || o2) && (a2 += " (found", s3 && (a2 += ` in field ${r4}`), o2 && (a2 += ` in document ${i3}`), a2 += ")"), new FirestoreError(D2.INVALID_ARGUMENT, _ + e3 + a2);
}
function __PRIVATE_fieldMaskContains(e3, t2) {
  return e3.some((e4) => e4.isEqual(t2));
}
function __PRIVATE_fieldPathFromArgument(e3, t2) {
  return "string" == typeof t2 ? __PRIVATE_fieldPathFromDotSeparatedString(e3, t2) : t2 instanceof FieldPath ? t2._internalPath : t2._delegate._internalPath;
}
function __PRIVATE_validateHasExplicitOrderByForLimitToLast(e3) {
  if ("L" === e3.limitType && 0 === e3.explicitOrderBy.length)
    throw new FirestoreError(D2.UNIMPLEMENTED, "limitToLast() queries require specifying at least one orderBy() clause");
}
function __PRIVATE_applyFirestoreDataConverter(e3, t2, n2) {
  let r4;
  return r4 = e3 ? n2 && (n2.merge || n2.mergeFields) ? e3.toFirestore(t2, n2) : e3.toFirestore(t2) : t2, r4;
}
function __PRIVATE_resultChangeType(e3) {
  switch (e3) {
    case 0:
      return "added";
    case 2:
    case 3:
      return "modified";
    case 1:
      return "removed";
    default:
      return fail();
  }
}
function getDocs(e3) {
  e3 = __PRIVATE_cast(e3, Query);
  const t2 = __PRIVATE_cast(e3.firestore, Firestore), n2 = ensureFirestoreConfigured(t2), r4 = new __PRIVATE_ExpUserDataWriter(t2);
  return __PRIVATE_validateHasExplicitOrderByForLimitToLast(e3._query), __PRIVATE_firestoreClientGetDocumentsViaSnapshotListener(n2, e3._query).then((n3) => new QuerySnapshot(t2, r4, e3, n3));
}
function setDoc(e3, t2, n2) {
  e3 = __PRIVATE_cast(e3, DocumentReference);
  const r4 = __PRIVATE_cast(e3.firestore, Firestore), i3 = __PRIVATE_applyFirestoreDataConverter(e3.converter, t2, n2);
  return executeWrite(r4, [__PRIVATE_parseSetData(__PRIVATE_newUserDataReader(r4), "setDoc", e3._key, i3, null !== e3.converter, n2).toMutation(e3._key, Precondition.none())]);
}
function deleteDoc(e3) {
  return executeWrite(__PRIVATE_cast(e3.firestore, Firestore), [new __PRIVATE_DeleteMutation(e3._key, Precondition.none())]);
}
function executeWrite(e3, t2) {
  return function __PRIVATE_firestoreClientWrite(e4, t3) {
    const n2 = new __PRIVATE_Deferred();
    return e4.asyncQueue.enqueueAndForget(async () => __PRIVATE_syncEngineWrite(await __PRIVATE_getSyncEngine(e4), t3, n2)), n2.promise;
  }(ensureFirestoreConfigured(e3), t2);
}
var w2;
var User;
var S2;
var b;
var D2;
var FirestoreError;
var __PRIVATE_Deferred;
var __PRIVATE_OAuthToken;
var __PRIVATE_EmptyAuthCredentialsProvider;
var __PRIVATE_EmulatorAuthCredentialsProvider;
var __PRIVATE_FirebaseAuthCredentialsProvider;
var __PRIVATE_FirstPartyToken;
var __PRIVATE_FirstPartyAuthCredentialsProvider;
var AppCheckToken;
var __PRIVATE_FirebaseAppCheckTokenProvider;
var __PRIVATE_AutoId;
var Timestamp;
var SnapshotVersion;
var BasePath;
var ResourcePath;
var C2;
var FieldPath$1;
var DocumentKey;
var FieldIndex;
var IndexOffset;
var v2;
var PersistenceTransaction;
var PersistencePromise;
var __PRIVATE_SimpleDbTransaction;
var __PRIVATE_SimpleDb;
var __PRIVATE_IterationController;
var __PRIVATE_IndexedDbTransactionError;
var __PRIVATE_SimpleDbStore;
var F2;
var __PRIVATE_ListenSequence;
var H2;
var J2;
var Y2;
var Z2;
var X2;
var SortedMap;
var SortedMapIterator;
var LLRBNode;
var SortedSet;
var SortedSetIterator;
var FieldMask;
var __PRIVATE_Base64DecodeError;
var ByteString;
var ee;
var DatabaseInfo;
var DatabaseId;
var te;
var ObjectValue;
var MutableDocument;
var Bound;
var OrderBy;
var Filter;
var FieldFilter;
var CompositeFilter;
var __PRIVATE_KeyFieldFilter;
var __PRIVATE_KeyFieldInFilter;
var __PRIVATE_KeyFieldNotInFilter;
var __PRIVATE_ArrayContainsFilter;
var __PRIVATE_InFilter;
var __PRIVATE_NotInFilter;
var __PRIVATE_ArrayContainsAnyFilter;
var __PRIVATE_TargetImpl;
var __PRIVATE_QueryImpl;
var ObjectMap;
var re;
var ie;
var se;
var oe;
var _e;
var TransformOperation;
var __PRIVATE_ServerTimestampTransform;
var __PRIVATE_ArrayUnionTransformOperation;
var __PRIVATE_ArrayRemoveTransformOperation;
var __PRIVATE_NumericIncrementTransformOperation;
var MutationResult;
var Precondition;
var Mutation;
var __PRIVATE_SetMutation;
var __PRIVATE_PatchMutation;
var __PRIVATE_DeleteMutation;
var __PRIVATE_VerifyMutation;
var MutationBatch;
var MutationBatchResult;
var Overlay;
var ExistenceFilter;
var ae2;
var ue;
var ce;
var le;
var BloomFilter;
var __PRIVATE_BloomFilterError;
var RemoteEvent;
var TargetChange;
var __PRIVATE_DocumentWatchChange;
var __PRIVATE_ExistenceFilterChange;
var __PRIVATE_WatchTargetChange;
var __PRIVATE_TargetState;
var __PRIVATE_WatchChangeAggregator;
var he;
var Pe;
var Ie;
var JsonProtoSerializer;
var TargetData;
var __PRIVATE_LocalSerializer;
var __PRIVATE_FirestoreIndexValueWriter;
var __PRIVATE_MemoryIndexManager;
var __PRIVATE_MemoryCollectionParentIndex;
var Te;
var LruParams;
var __PRIVATE_TargetIdGenerator;
var RemoteDocumentChangeBuffer;
var OverlayedDocument;
var LocalDocumentsView;
var __PRIVATE_MemoryBundleCache;
var __PRIVATE_MemoryDocumentOverlayCache;
var __PRIVATE_ReferenceSet;
var __PRIVATE_DocReference;
var __PRIVATE_MemoryMutationQueue;
var __PRIVATE_MemoryRemoteDocumentCacheImpl;
var __PRIVATE_MemoryRemoteDocumentChangeBuffer;
var __PRIVATE_MemoryTargetCache;
var __PRIVATE_MemoryPersistence;
var __PRIVATE_MemoryTransaction;
var __PRIVATE_MemoryEagerDelegate;
var __PRIVATE_LocalViewChanges;
var QueryContext;
var __PRIVATE_QueryEngine;
var __PRIVATE_LocalStoreImpl;
var __PRIVATE_LocalClientState;
var __PRIVATE_MemorySharedClientState;
var __PRIVATE_NoopConnectivityMonitor;
var __PRIVATE_BrowserConnectivityMonitor;
var Ae;
var Re;
var __PRIVATE_StreamBridge;
var Ve;
var __PRIVATE_WebChannelConnection;
var __PRIVATE_ExponentialBackoff;
var __PRIVATE_PersistentStream;
var __PRIVATE_PersistentListenStream;
var __PRIVATE_PersistentWriteStream;
var __PRIVATE_DatastoreImpl;
var __PRIVATE_OnlineStateTracker;
var __PRIVATE_RemoteStoreImpl;
var DelayedOperation;
var DocumentSet;
var __PRIVATE_DocumentChangeSet;
var ViewSnapshot;
var __PRIVATE_QueryListenersInfo;
var __PRIVATE_EventManagerImpl;
var __PRIVATE_QueryListener;
var __PRIVATE_AddedLimboDocument;
var __PRIVATE_RemovedLimboDocument;
var __PRIVATE_View;
var __PRIVATE_QueryView;
var LimboResolution;
var __PRIVATE_SyncEngineImpl;
var MemoryOfflineComponentProvider;
var OnlineComponentProvider;
var __PRIVATE_AsyncObserver;
var FirestoreClient;
var me;
var FirestoreSettingsImpl;
var Firestore$1;
var Query;
var DocumentReference;
var CollectionReference;
var __PRIVATE_AsyncQueueImpl;
var Firestore;
var Bytes;
var FieldPath;
var FieldValue;
var GeoPoint;
var ge;
var ParsedSetData;
var __PRIVATE_ParseContextImpl;
var __PRIVATE_UserDataReader;
var pe;
var DocumentSnapshot$1;
var QueryDocumentSnapshot$1;
var AbstractUserDataWriter;
var SnapshotMetadata;
var DocumentSnapshot;
var QueryDocumentSnapshot;
var QuerySnapshot;
var __PRIVATE_ExpUserDataWriter;
var init_index_esm20176 = __esm({
  "node_modules/@firebase/firestore/dist/index.esm2017.js"() {
    init_index_esm20174();
    init_index_esm20172();
    init_index_esm20173();
    init_index_esm2017();
    init_index_esm20175();
    w2 = "@firebase/firestore";
    User = class {
      constructor(e3) {
        this.uid = e3;
      }
      isAuthenticated() {
        return null != this.uid;
      }
      /**
       * Returns a key representing this user, suitable for inclusion in a
       * dictionary.
       */
      toKey() {
        return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user";
      }
      isEqual(e3) {
        return e3.uid === this.uid;
      }
    };
    User.UNAUTHENTICATED = new User(null), // TODO(mikelehen): Look into getting a proper uid-equivalent for
    // non-FirebaseAuth providers.
    User.GOOGLE_CREDENTIALS = new User("google-credentials-uid"), User.FIRST_PARTY = new User("first-party-uid"), User.MOCK_USER = new User("mock-user");
    S2 = "10.8.1";
    b = new Logger("@firebase/firestore");
    D2 = {
      // Causes are copied from:
      // https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h
      /** Not an error; returned on success. */
      OK: "ok",
      /** The operation was cancelled (typically by the caller). */
      CANCELLED: "cancelled",
      /** Unknown error or an error from a different error domain. */
      UNKNOWN: "unknown",
      /**
       * Client specified an invalid argument. Note that this differs from
       * FAILED_PRECONDITION. INVALID_ARGUMENT indicates arguments that are
       * problematic regardless of the state of the system (e.g., a malformed file
       * name).
       */
      INVALID_ARGUMENT: "invalid-argument",
      /**
       * Deadline expired before operation could complete. For operations that
       * change the state of the system, this error may be returned even if the
       * operation has completed successfully. For example, a successful response
       * from a server could have been delayed long enough for the deadline to
       * expire.
       */
      DEADLINE_EXCEEDED: "deadline-exceeded",
      /** Some requested entity (e.g., file or directory) was not found. */
      NOT_FOUND: "not-found",
      /**
       * Some entity that we attempted to create (e.g., file or directory) already
       * exists.
       */
      ALREADY_EXISTS: "already-exists",
      /**
       * The caller does not have permission to execute the specified operation.
       * PERMISSION_DENIED must not be used for rejections caused by exhausting
       * some resource (use RESOURCE_EXHAUSTED instead for those errors).
       * PERMISSION_DENIED must not be used if the caller can not be identified
       * (use UNAUTHENTICATED instead for those errors).
       */
      PERMISSION_DENIED: "permission-denied",
      /**
       * The request does not have valid authentication credentials for the
       * operation.
       */
      UNAUTHENTICATED: "unauthenticated",
      /**
       * Some resource has been exhausted, perhaps a per-user quota, or perhaps the
       * entire file system is out of space.
       */
      RESOURCE_EXHAUSTED: "resource-exhausted",
      /**
       * Operation was rejected because the system is not in a state required for
       * the operation's execution. For example, directory to be deleted may be
       * non-empty, an rmdir operation is applied to a non-directory, etc.
       *
       * A litmus test that may help a service implementor in deciding
       * between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:
       *  (a) Use UNAVAILABLE if the client can retry just the failing call.
       *  (b) Use ABORTED if the client should retry at a higher-level
       *      (e.g., restarting a read-modify-write sequence).
       *  (c) Use FAILED_PRECONDITION if the client should not retry until
       *      the system state has been explicitly fixed. E.g., if an "rmdir"
       *      fails because the directory is non-empty, FAILED_PRECONDITION
       *      should be returned since the client should not retry unless
       *      they have first fixed up the directory by deleting files from it.
       *  (d) Use FAILED_PRECONDITION if the client performs conditional
       *      REST Get/Update/Delete on a resource and the resource on the
       *      server does not match the condition. E.g., conflicting
       *      read-modify-write on the same resource.
       */
      FAILED_PRECONDITION: "failed-precondition",
      /**
       * The operation was aborted, typically due to a concurrency issue like
       * sequencer check failures, transaction aborts, etc.
       *
       * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,
       * and UNAVAILABLE.
       */
      ABORTED: "aborted",
      /**
       * Operation was attempted past the valid range. E.g., seeking or reading
       * past end of file.
       *
       * Unlike INVALID_ARGUMENT, this error indicates a problem that may be fixed
       * if the system state changes. For example, a 32-bit file system will
       * generate INVALID_ARGUMENT if asked to read at an offset that is not in the
       * range [0,2^32-1], but it will generate OUT_OF_RANGE if asked to read from
       * an offset past the current file size.
       *
       * There is a fair bit of overlap between FAILED_PRECONDITION and
       * OUT_OF_RANGE. We recommend using OUT_OF_RANGE (the more specific error)
       * when it applies so that callers who are iterating through a space can
       * easily look for an OUT_OF_RANGE error to detect when they are done.
       */
      OUT_OF_RANGE: "out-of-range",
      /** Operation is not implemented or not supported/enabled in this service. */
      UNIMPLEMENTED: "unimplemented",
      /**
       * Internal errors. Means some invariants expected by underlying System has
       * been broken. If you see one of these errors, Something is very broken.
       */
      INTERNAL: "internal",
      /**
       * The service is currently unavailable. This is a most likely a transient
       * condition and may be corrected by retrying with a backoff.
       *
       * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,
       * and UNAVAILABLE.
       */
      UNAVAILABLE: "unavailable",
      /** Unrecoverable data loss or corruption. */
      DATA_LOSS: "data-loss"
    };
    FirestoreError = class extends FirebaseError {
      /** @hideconstructor */
      constructor(e3, t2) {
        super(e3, t2), this.code = e3, this.message = t2, // HACK: We write a toString property directly because Error is not a real
        // class and so inheritance does not work correctly. We could alternatively
        // do the same "back-door inheritance" trick that FirebaseError does.
        this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;
      }
    };
    __PRIVATE_Deferred = class {
      constructor() {
        this.promise = new Promise((e3, t2) => {
          this.resolve = e3, this.reject = t2;
        });
      }
    };
    __PRIVATE_OAuthToken = class {
      constructor(e3, t2) {
        this.user = t2, this.type = "OAuth", this.headers = /* @__PURE__ */ new Map(), this.headers.set("Authorization", `Bearer ${e3}`);
      }
    };
    __PRIVATE_EmptyAuthCredentialsProvider = class {
      getToken() {
        return Promise.resolve(null);
      }
      invalidateToken() {
      }
      start(e3, t2) {
        e3.enqueueRetryable(() => t2(User.UNAUTHENTICATED));
      }
      shutdown() {
      }
    };
    __PRIVATE_EmulatorAuthCredentialsProvider = class {
      constructor(e3) {
        this.token = e3, /**
        * Stores the listener registered with setChangeListener()
        * This isn't actually necessary since the UID never changes, but we use this
        * to verify the listen contract is adhered to in tests.
        */
        this.changeListener = null;
      }
      getToken() {
        return Promise.resolve(this.token);
      }
      invalidateToken() {
      }
      start(e3, t2) {
        this.changeListener = t2, // Fire with initial user.
        e3.enqueueRetryable(() => t2(this.token.user));
      }
      shutdown() {
        this.changeListener = null;
      }
    };
    __PRIVATE_FirebaseAuthCredentialsProvider = class {
      constructor(e3) {
        this.t = e3, /** Tracks the current User. */
        this.currentUser = User.UNAUTHENTICATED, /**
        * Counter used to detect if the token changed while a getToken request was
        * outstanding.
        */
        this.i = 0, this.forceRefresh = false, this.auth = null;
      }
      start(e3, t2) {
        let n2 = this.i;
        const __PRIVATE_guardedChangeListener = (e4) => this.i !== n2 ? (n2 = this.i, t2(e4)) : Promise.resolve();
        let r4 = new __PRIVATE_Deferred();
        this.o = () => {
          this.i++, this.currentUser = this.u(), r4.resolve(), r4 = new __PRIVATE_Deferred(), e3.enqueueRetryable(() => __PRIVATE_guardedChangeListener(this.currentUser));
        };
        const __PRIVATE_awaitNextToken = () => {
          const t3 = r4;
          e3.enqueueRetryable(async () => {
            await t3.promise, await __PRIVATE_guardedChangeListener(this.currentUser);
          });
        }, __PRIVATE_registerAuth = (e4) => {
          __PRIVATE_logDebug("FirebaseAuthCredentialsProvider", "Auth detected"), this.auth = e4, this.auth.addAuthTokenListener(this.o), __PRIVATE_awaitNextToken();
        };
        this.t.onInit((e4) => __PRIVATE_registerAuth(e4)), // Our users can initialize Auth right after Firestore, so we give it
        // a chance to register itself with the component framework before we
        // determine whether to start up in unauthenticated mode.
        setTimeout(() => {
          if (!this.auth) {
            const e4 = this.t.getImmediate({
              optional: true
            });
            e4 ? __PRIVATE_registerAuth(e4) : (
              // If auth is still not available, proceed with `null` user
              (__PRIVATE_logDebug("FirebaseAuthCredentialsProvider", "Auth not yet detected"), r4.resolve(), r4 = new __PRIVATE_Deferred())
            );
          }
        }, 0), __PRIVATE_awaitNextToken();
      }
      getToken() {
        const e3 = this.i, t2 = this.forceRefresh;
        return this.forceRefresh = false, this.auth ? this.auth.getToken(t2).then((t3) => (
          // Cancel the request since the token changed while the request was
          // outstanding so the response is potentially for a previous user (which
          // user, we can't be sure).
          this.i !== e3 ? (__PRIVATE_logDebug("FirebaseAuthCredentialsProvider", "getToken aborted due to token change."), this.getToken()) : t3 ? (__PRIVATE_hardAssert("string" == typeof t3.accessToken), new __PRIVATE_OAuthToken(t3.accessToken, this.currentUser)) : null
        )) : Promise.resolve(null);
      }
      invalidateToken() {
        this.forceRefresh = true;
      }
      shutdown() {
        this.auth && this.auth.removeAuthTokenListener(this.o);
      }
      // Auth.getUid() can return null even with a user logged in. It is because
      // getUid() is synchronous, but the auth code populating Uid is asynchronous.
      // This method should only be called in the AuthTokenListener callback
      // to guarantee to get the actual user.
      u() {
        const e3 = this.auth && this.auth.getUid();
        return __PRIVATE_hardAssert(null === e3 || "string" == typeof e3), new User(e3);
      }
    };
    __PRIVATE_FirstPartyToken = class {
      constructor(e3, t2, n2) {
        this.l = e3, this.h = t2, this.P = n2, this.type = "FirstParty", this.user = User.FIRST_PARTY, this.I = /* @__PURE__ */ new Map();
      }
      /**
       * Gets an authorization token, using a provided factory function, or return
       * null.
       */
      T() {
        return this.P ? this.P() : null;
      }
      get headers() {
        this.I.set("X-Goog-AuthUser", this.l);
        const e3 = this.T();
        return e3 && this.I.set("Authorization", e3), this.h && this.I.set("X-Goog-Iam-Authorization-Token", this.h), this.I;
      }
    };
    __PRIVATE_FirstPartyAuthCredentialsProvider = class {
      constructor(e3, t2, n2) {
        this.l = e3, this.h = t2, this.P = n2;
      }
      getToken() {
        return Promise.resolve(new __PRIVATE_FirstPartyToken(this.l, this.h, this.P));
      }
      start(e3, t2) {
        e3.enqueueRetryable(() => t2(User.FIRST_PARTY));
      }
      shutdown() {
      }
      invalidateToken() {
      }
    };
    AppCheckToken = class {
      constructor(e3) {
        this.value = e3, this.type = "AppCheck", this.headers = /* @__PURE__ */ new Map(), e3 && e3.length > 0 && this.headers.set("x-firebase-appcheck", this.value);
      }
    };
    __PRIVATE_FirebaseAppCheckTokenProvider = class {
      constructor(e3) {
        this.A = e3, this.forceRefresh = false, this.appCheck = null, this.R = null;
      }
      start(e3, t2) {
        const onTokenChanged = (e4) => {
          null != e4.error && __PRIVATE_logDebug("FirebaseAppCheckTokenProvider", `Error getting App Check token; using placeholder token instead. Error: ${e4.error.message}`);
          const n2 = e4.token !== this.R;
          return this.R = e4.token, __PRIVATE_logDebug("FirebaseAppCheckTokenProvider", `Received ${n2 ? "new" : "existing"} token.`), n2 ? t2(e4.token) : Promise.resolve();
        };
        this.o = (t3) => {
          e3.enqueueRetryable(() => onTokenChanged(t3));
        };
        const __PRIVATE_registerAppCheck = (e4) => {
          __PRIVATE_logDebug("FirebaseAppCheckTokenProvider", "AppCheck detected"), this.appCheck = e4, this.appCheck.addTokenListener(this.o);
        };
        this.A.onInit((e4) => __PRIVATE_registerAppCheck(e4)), // Our users can initialize AppCheck after Firestore, so we give it
        // a chance to register itself with the component framework.
        setTimeout(() => {
          if (!this.appCheck) {
            const e4 = this.A.getImmediate({
              optional: true
            });
            e4 ? __PRIVATE_registerAppCheck(e4) : (
              // If AppCheck is still not available, proceed without it.
              __PRIVATE_logDebug("FirebaseAppCheckTokenProvider", "AppCheck not yet detected")
            );
          }
        }, 0);
      }
      getToken() {
        const e3 = this.forceRefresh;
        return this.forceRefresh = false, this.appCheck ? this.appCheck.getToken(e3).then((e4) => e4 ? (__PRIVATE_hardAssert("string" == typeof e4.token), this.R = e4.token, new AppCheckToken(e4.token)) : null) : Promise.resolve(null);
      }
      invalidateToken() {
        this.forceRefresh = true;
      }
      shutdown() {
        this.appCheck && this.appCheck.removeTokenListener(this.o);
      }
    };
    __PRIVATE_AutoId = class {
      static newId() {
        const e3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", t2 = Math.floor(256 / e3.length) * e3.length;
        let n2 = "";
        for (; n2.length < 20; ) {
          const r4 = __PRIVATE_randomBytes(40);
          for (let i3 = 0; i3 < r4.length; ++i3)
            n2.length < 20 && r4[i3] < t2 && (n2 += e3.charAt(r4[i3] % e3.length));
        }
        return n2;
      }
    };
    Timestamp = class _Timestamp {
      /**
       * Creates a new timestamp.
       *
       * @param seconds - The number of seconds of UTC time since Unix epoch
       *     1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
       *     9999-12-31T23:59:59Z inclusive.
       * @param nanoseconds - The non-negative fractions of a second at nanosecond
       *     resolution. Negative second values with fractions must still have
       *     non-negative nanoseconds values that count forward in time. Must be
       *     from 0 to 999,999,999 inclusive.
       */
      constructor(e3, t2) {
        if (this.seconds = e3, this.nanoseconds = t2, t2 < 0)
          throw new FirestoreError(D2.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + t2);
        if (t2 >= 1e9)
          throw new FirestoreError(D2.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + t2);
        if (e3 < -62135596800)
          throw new FirestoreError(D2.INVALID_ARGUMENT, "Timestamp seconds out of range: " + e3);
        if (e3 >= 253402300800)
          throw new FirestoreError(D2.INVALID_ARGUMENT, "Timestamp seconds out of range: " + e3);
      }
      /**
       * Creates a new timestamp with the current date, with millisecond precision.
       *
       * @returns a new timestamp representing the current date.
       */
      static now() {
        return _Timestamp.fromMillis(Date.now());
      }
      /**
       * Creates a new timestamp from the given date.
       *
       * @param date - The date to initialize the `Timestamp` from.
       * @returns A new `Timestamp` representing the same point in time as the given
       *     date.
       */
      static fromDate(e3) {
        return _Timestamp.fromMillis(e3.getTime());
      }
      /**
       * Creates a new timestamp from the given number of milliseconds.
       *
       * @param milliseconds - Number of milliseconds since Unix epoch
       *     1970-01-01T00:00:00Z.
       * @returns A new `Timestamp` representing the same point in time as the given
       *     number of milliseconds.
       */
      static fromMillis(e3) {
        const t2 = Math.floor(e3 / 1e3), n2 = Math.floor(1e6 * (e3 - 1e3 * t2));
        return new _Timestamp(t2, n2);
      }
      /**
       * Converts a `Timestamp` to a JavaScript `Date` object. This conversion
       * causes a loss of precision since `Date` objects only support millisecond
       * precision.
       *
       * @returns JavaScript `Date` object representing the same point in time as
       *     this `Timestamp`, with millisecond precision.
       */
      toDate() {
        return new Date(this.toMillis());
      }
      /**
       * Converts a `Timestamp` to a numeric timestamp (in milliseconds since
       * epoch). This operation causes a loss of precision.
       *
       * @returns The point in time corresponding to this timestamp, represented as
       *     the number of milliseconds since Unix epoch 1970-01-01T00:00:00Z.
       */
      toMillis() {
        return 1e3 * this.seconds + this.nanoseconds / 1e6;
      }
      _compareTo(e3) {
        return this.seconds === e3.seconds ? __PRIVATE_primitiveComparator(this.nanoseconds, e3.nanoseconds) : __PRIVATE_primitiveComparator(this.seconds, e3.seconds);
      }
      /**
       * Returns true if this `Timestamp` is equal to the provided one.
       *
       * @param other - The `Timestamp` to compare against.
       * @returns true if this `Timestamp` is equal to the provided one.
       */
      isEqual(e3) {
        return e3.seconds === this.seconds && e3.nanoseconds === this.nanoseconds;
      }
      /** Returns a textual representation of this `Timestamp`. */
      toString() {
        return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")";
      }
      /** Returns a JSON-serializable representation of this `Timestamp`. */
      toJSON() {
        return {
          seconds: this.seconds,
          nanoseconds: this.nanoseconds
        };
      }
      /**
       * Converts this object to a primitive string, which allows `Timestamp` objects
       * to be compared using the `>`, `<=`, `>=` and `>` operators.
       */
      valueOf() {
        const e3 = this.seconds - -62135596800;
        return String(e3).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0");
      }
    };
    SnapshotVersion = class _SnapshotVersion {
      constructor(e3) {
        this.timestamp = e3;
      }
      static fromTimestamp(e3) {
        return new _SnapshotVersion(e3);
      }
      static min() {
        return new _SnapshotVersion(new Timestamp(0, 0));
      }
      static max() {
        return new _SnapshotVersion(new Timestamp(253402300799, 999999999));
      }
      compareTo(e3) {
        return this.timestamp._compareTo(e3.timestamp);
      }
      isEqual(e3) {
        return this.timestamp.isEqual(e3.timestamp);
      }
      /** Returns a number representation of the version for use in spec tests. */
      toMicroseconds() {
        return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3;
      }
      toString() {
        return "SnapshotVersion(" + this.timestamp.toString() + ")";
      }
      toTimestamp() {
        return this.timestamp;
      }
    };
    BasePath = class _BasePath {
      constructor(e3, t2, n2) {
        void 0 === t2 ? t2 = 0 : t2 > e3.length && fail(), void 0 === n2 ? n2 = e3.length - t2 : n2 > e3.length - t2 && fail(), this.segments = e3, this.offset = t2, this.len = n2;
      }
      get length() {
        return this.len;
      }
      isEqual(e3) {
        return 0 === _BasePath.comparator(this, e3);
      }
      child(e3) {
        const t2 = this.segments.slice(this.offset, this.limit());
        return e3 instanceof _BasePath ? e3.forEach((e4) => {
          t2.push(e4);
        }) : t2.push(e3), this.construct(t2);
      }
      /** The index of one past the last segment of the path. */
      limit() {
        return this.offset + this.length;
      }
      popFirst(e3) {
        return e3 = void 0 === e3 ? 1 : e3, this.construct(this.segments, this.offset + e3, this.length - e3);
      }
      popLast() {
        return this.construct(this.segments, this.offset, this.length - 1);
      }
      firstSegment() {
        return this.segments[this.offset];
      }
      lastSegment() {
        return this.get(this.length - 1);
      }
      get(e3) {
        return this.segments[this.offset + e3];
      }
      isEmpty() {
        return 0 === this.length;
      }
      isPrefixOf(e3) {
        if (e3.length < this.length)
          return false;
        for (let t2 = 0; t2 < this.length; t2++)
          if (this.get(t2) !== e3.get(t2))
            return false;
        return true;
      }
      isImmediateParentOf(e3) {
        if (this.length + 1 !== e3.length)
          return false;
        for (let t2 = 0; t2 < this.length; t2++)
          if (this.get(t2) !== e3.get(t2))
            return false;
        return true;
      }
      forEach(e3) {
        for (let t2 = this.offset, n2 = this.limit(); t2 < n2; t2++)
          e3(this.segments[t2]);
      }
      toArray() {
        return this.segments.slice(this.offset, this.limit());
      }
      static comparator(e3, t2) {
        const n2 = Math.min(e3.length, t2.length);
        for (let r4 = 0; r4 < n2; r4++) {
          const n3 = e3.get(r4), i3 = t2.get(r4);
          if (n3 < i3)
            return -1;
          if (n3 > i3)
            return 1;
        }
        return e3.length < t2.length ? -1 : e3.length > t2.length ? 1 : 0;
      }
    };
    ResourcePath = class _ResourcePath extends BasePath {
      construct(e3, t2, n2) {
        return new _ResourcePath(e3, t2, n2);
      }
      canonicalString() {
        return this.toArray().join("/");
      }
      toString() {
        return this.canonicalString();
      }
      /**
       * Returns a string representation of this path
       * where each path segment has been encoded with
       * `encodeURIComponent`.
       */
      toUriEncodedString() {
        return this.toArray().map(encodeURIComponent).join("/");
      }
      /**
       * Creates a resource path from the given slash-delimited string. If multiple
       * arguments are provided, all components are combined. Leading and trailing
       * slashes from all components are ignored.
       */
      static fromString(...e3) {
        const t2 = [];
        for (const n2 of e3) {
          if (n2.indexOf("//") >= 0)
            throw new FirestoreError(D2.INVALID_ARGUMENT, `Invalid segment (${n2}). Paths must not contain // in them.`);
          t2.push(...n2.split("/").filter((e4) => e4.length > 0));
        }
        return new _ResourcePath(t2);
      }
      static emptyPath() {
        return new _ResourcePath([]);
      }
    };
    C2 = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
    FieldPath$1 = class _FieldPath$1 extends BasePath {
      construct(e3, t2, n2) {
        return new _FieldPath$1(e3, t2, n2);
      }
      /**
       * Returns true if the string could be used as a segment in a field path
       * without escaping.
       */
      static isValidIdentifier(e3) {
        return C2.test(e3);
      }
      canonicalString() {
        return this.toArray().map((e3) => (e3 = e3.replace(/\\/g, "\\\\").replace(/`/g, "\\`"), _FieldPath$1.isValidIdentifier(e3) || (e3 = "`" + e3 + "`"), e3)).join(".");
      }
      toString() {
        return this.canonicalString();
      }
      /**
       * Returns true if this field references the key of a document.
       */
      isKeyField() {
        return 1 === this.length && "__name__" === this.get(0);
      }
      /**
       * The field designating the key of a document.
       */
      static keyField() {
        return new _FieldPath$1(["__name__"]);
      }
      /**
       * Parses a field string from the given server-formatted string.
       *
       * - Splitting the empty string is not allowed (for now at least).
       * - Empty segments within the string (e.g. if there are two consecutive
       *   separators) are not allowed.
       *
       * TODO(b/37244157): we should make this more strict. Right now, it allows
       * non-identifier path components, even if they aren't escaped.
       */
      static fromServerFormat(e3) {
        const t2 = [];
        let n2 = "", r4 = 0;
        const __PRIVATE_addCurrentSegment = () => {
          if (0 === n2.length)
            throw new FirestoreError(D2.INVALID_ARGUMENT, `Invalid field path (${e3}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);
          t2.push(n2), n2 = "";
        };
        let i3 = false;
        for (; r4 < e3.length; ) {
          const t3 = e3[r4];
          if ("\\" === t3) {
            if (r4 + 1 === e3.length)
              throw new FirestoreError(D2.INVALID_ARGUMENT, "Path has trailing escape character: " + e3);
            const t4 = e3[r4 + 1];
            if ("\\" !== t4 && "." !== t4 && "`" !== t4)
              throw new FirestoreError(D2.INVALID_ARGUMENT, "Path has invalid escape sequence: " + e3);
            n2 += t4, r4 += 2;
          } else
            "`" === t3 ? (i3 = !i3, r4++) : "." !== t3 || i3 ? (n2 += t3, r4++) : (__PRIVATE_addCurrentSegment(), r4++);
        }
        if (__PRIVATE_addCurrentSegment(), i3)
          throw new FirestoreError(D2.INVALID_ARGUMENT, "Unterminated ` in path: " + e3);
        return new _FieldPath$1(t2);
      }
      static emptyPath() {
        return new _FieldPath$1([]);
      }
    };
    DocumentKey = class _DocumentKey {
      constructor(e3) {
        this.path = e3;
      }
      static fromPath(e3) {
        return new _DocumentKey(ResourcePath.fromString(e3));
      }
      static fromName(e3) {
        return new _DocumentKey(ResourcePath.fromString(e3).popFirst(5));
      }
      static empty() {
        return new _DocumentKey(ResourcePath.emptyPath());
      }
      get collectionGroup() {
        return this.path.popLast().lastSegment();
      }
      /** Returns true if the document is in the specified collectionId. */
      hasCollectionId(e3) {
        return this.path.length >= 2 && this.path.get(this.path.length - 2) === e3;
      }
      /** Returns the collection group (i.e. the name of the parent collection) for this key. */
      getCollectionGroup() {
        return this.path.get(this.path.length - 2);
      }
      /** Returns the fully qualified path to the parent collection. */
      getCollectionPath() {
        return this.path.popLast();
      }
      isEqual(e3) {
        return null !== e3 && 0 === ResourcePath.comparator(this.path, e3.path);
      }
      toString() {
        return this.path.toString();
      }
      static comparator(e3, t2) {
        return ResourcePath.comparator(e3.path, t2.path);
      }
      static isDocumentKey(e3) {
        return e3.length % 2 == 0;
      }
      /**
       * Creates and returns a new document key with the given segments.
       *
       * @param segments - The segments of the path to the document
       * @returns A new instance of DocumentKey
       */
      static fromSegments(e3) {
        return new _DocumentKey(new ResourcePath(e3.slice()));
      }
    };
    FieldIndex = class {
      constructor(e3, t2, n2, r4) {
        this.indexId = e3, this.collectionGroup = t2, this.fields = n2, this.indexState = r4;
      }
    };
    FieldIndex.UNKNOWN_ID = -1;
    IndexOffset = class _IndexOffset {
      constructor(e3, t2, n2) {
        this.readTime = e3, this.documentKey = t2, this.largestBatchId = n2;
      }
      /** Returns an offset that sorts before all regular offsets. */
      static min() {
        return new _IndexOffset(SnapshotVersion.min(), DocumentKey.empty(), -1);
      }
      /** Returns an offset that sorts after all regular offsets. */
      static max() {
        return new _IndexOffset(SnapshotVersion.max(), DocumentKey.empty(), -1);
      }
    };
    v2 = "The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.";
    PersistenceTransaction = class {
      constructor() {
        this.onCommittedListeners = [];
      }
      addOnCommittedListener(e3) {
        this.onCommittedListeners.push(e3);
      }
      raiseOnCommittedEvent() {
        this.onCommittedListeners.forEach((e3) => e3());
      }
    };
    PersistencePromise = class _PersistencePromise {
      constructor(e3) {
        this.nextCallback = null, this.catchCallback = null, // When the operation resolves, we'll set result or error and mark isDone.
        this.result = void 0, this.error = void 0, this.isDone = false, // Set to true when .then() or .catch() are called and prevents additional
        // chaining.
        this.callbackAttached = false, e3((e4) => {
          this.isDone = true, this.result = e4, this.nextCallback && // value should be defined unless T is Void, but we can't express
          // that in the type system.
          this.nextCallback(e4);
        }, (e4) => {
          this.isDone = true, this.error = e4, this.catchCallback && this.catchCallback(e4);
        });
      }
      catch(e3) {
        return this.next(void 0, e3);
      }
      next(e3, t2) {
        return this.callbackAttached && fail(), this.callbackAttached = true, this.isDone ? this.error ? this.wrapFailure(t2, this.error) : this.wrapSuccess(e3, this.result) : new _PersistencePromise((n2, r4) => {
          this.nextCallback = (t3) => {
            this.wrapSuccess(e3, t3).next(n2, r4);
          }, this.catchCallback = (e4) => {
            this.wrapFailure(t2, e4).next(n2, r4);
          };
        });
      }
      toPromise() {
        return new Promise((e3, t2) => {
          this.next(e3, t2);
        });
      }
      wrapUserFunction(e3) {
        try {
          const t2 = e3();
          return t2 instanceof _PersistencePromise ? t2 : _PersistencePromise.resolve(t2);
        } catch (e4) {
          return _PersistencePromise.reject(e4);
        }
      }
      wrapSuccess(e3, t2) {
        return e3 ? this.wrapUserFunction(() => e3(t2)) : _PersistencePromise.resolve(t2);
      }
      wrapFailure(e3, t2) {
        return e3 ? this.wrapUserFunction(() => e3(t2)) : _PersistencePromise.reject(t2);
      }
      static resolve(e3) {
        return new _PersistencePromise((t2, n2) => {
          t2(e3);
        });
      }
      static reject(e3) {
        return new _PersistencePromise((t2, n2) => {
          n2(e3);
        });
      }
      static waitFor(e3) {
        return new _PersistencePromise((t2, n2) => {
          let r4 = 0, i3 = 0, s3 = false;
          e3.forEach((e4) => {
            ++r4, e4.next(() => {
              ++i3, s3 && i3 === r4 && t2();
            }, (e5) => n2(e5));
          }), s3 = true, i3 === r4 && t2();
        });
      }
      /**
       * Given an array of predicate functions that asynchronously evaluate to a
       * boolean, implements a short-circuiting `or` between the results. Predicates
       * will be evaluated until one of them returns `true`, then stop. The final
       * result will be whether any of them returned `true`.
       */
      static or(e3) {
        let t2 = _PersistencePromise.resolve(false);
        for (const n2 of e3)
          t2 = t2.next((e4) => e4 ? _PersistencePromise.resolve(e4) : n2());
        return t2;
      }
      static forEach(e3, t2) {
        const n2 = [];
        return e3.forEach((e4, r4) => {
          n2.push(t2.call(this, e4, r4));
        }), this.waitFor(n2);
      }
      /**
       * Concurrently map all array elements through asynchronous function.
       */
      static mapArray(e3, t2) {
        return new _PersistencePromise((n2, r4) => {
          const i3 = e3.length, s3 = new Array(i3);
          let o2 = 0;
          for (let _ = 0; _ < i3; _++) {
            const a2 = _;
            t2(e3[a2]).next((e4) => {
              s3[a2] = e4, ++o2, o2 === i3 && n2(s3);
            }, (e4) => r4(e4));
          }
        });
      }
      /**
       * An alternative to recursive PersistencePromise calls, that avoids
       * potential memory problems from unbounded chains of promises.
       *
       * The `action` will be called repeatedly while `condition` is true.
       */
      static doWhile(e3, t2) {
        return new _PersistencePromise((n2, r4) => {
          const process2 = () => {
            true === e3() ? t2().next(() => {
              process2();
            }, r4) : n2();
          };
          process2();
        });
      }
    };
    __PRIVATE_SimpleDbTransaction = class ___PRIVATE_SimpleDbTransaction {
      constructor(e3, t2) {
        this.action = e3, this.transaction = t2, this.aborted = false, /**
        * A `Promise` that resolves with the result of the IndexedDb transaction.
        */
        this.V = new __PRIVATE_Deferred(), this.transaction.oncomplete = () => {
          this.V.resolve();
        }, this.transaction.onabort = () => {
          t2.error ? this.V.reject(new __PRIVATE_IndexedDbTransactionError(e3, t2.error)) : this.V.resolve();
        }, this.transaction.onerror = (t3) => {
          const n2 = __PRIVATE_checkForAndReportiOSError(t3.target.error);
          this.V.reject(new __PRIVATE_IndexedDbTransactionError(e3, n2));
        };
      }
      static open(e3, t2, n2, r4) {
        try {
          return new ___PRIVATE_SimpleDbTransaction(t2, e3.transaction(r4, n2));
        } catch (e4) {
          throw new __PRIVATE_IndexedDbTransactionError(t2, e4);
        }
      }
      get m() {
        return this.V.promise;
      }
      abort(e3) {
        e3 && this.V.reject(e3), this.aborted || (__PRIVATE_logDebug("SimpleDb", "Aborting transaction:", e3 ? e3.message : "Client-initiated abort"), this.aborted = true, this.transaction.abort());
      }
      g() {
        const e3 = this.transaction;
        this.aborted || "function" != typeof e3.commit || e3.commit();
      }
      /**
       * Returns a SimpleDbStore<KeyType, ValueType> for the specified store. All
       * operations performed on the SimpleDbStore happen within the context of this
       * transaction and it cannot be used anymore once the transaction is
       * completed.
       *
       * Note that we can't actually enforce that the KeyType and ValueType are
       * correct, but they allow type safety through the rest of the consuming code.
       */
      store(e3) {
        const t2 = this.transaction.objectStore(e3);
        return new __PRIVATE_SimpleDbStore(t2);
      }
    };
    __PRIVATE_SimpleDb = class ___PRIVATE_SimpleDb {
      /*
       * Creates a new SimpleDb wrapper for IndexedDb database `name`.
       *
       * Note that `version` must not be a downgrade. IndexedDB does not support
       * downgrading the schema version. We currently do not support any way to do
       * versioning outside of IndexedDB's versioning mechanism, as only
       * version-upgrade transactions are allowed to do things like create
       * objectstores.
       */
      constructor(e3, t2, n2) {
        this.name = e3, this.version = t2, this.p = n2;
        12.2 === ___PRIVATE_SimpleDb.S(getUA()) && __PRIVATE_logError("Firestore persistence suffers from a bug in iOS 12.2 Safari that may cause your app to stop working. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.");
      }
      /** Deletes the specified database. */
      static delete(e3) {
        return __PRIVATE_logDebug("SimpleDb", "Removing database:", e3), __PRIVATE_wrapRequest(window.indexedDB.deleteDatabase(e3)).toPromise();
      }
      /** Returns true if IndexedDB is available in the current environment. */
      static D() {
        if (!isIndexedDBAvailable())
          return false;
        if (___PRIVATE_SimpleDb.C())
          return true;
        const e3 = getUA(), t2 = ___PRIVATE_SimpleDb.S(e3), n2 = 0 < t2 && t2 < 10, r4 = ___PRIVATE_SimpleDb.v(e3), i3 = 0 < r4 && r4 < 4.5;
        return !(e3.indexOf("MSIE ") > 0 || e3.indexOf("Trident/") > 0 || e3.indexOf("Edge/") > 0 || n2 || i3);
      }
      /**
       * Returns true if the backing IndexedDB store is the Node IndexedDBShim
       * (see https://github.com/axemclion/IndexedDBShim).
       */
      static C() {
        var e3;
        return "undefined" != typeof process && "YES" === (null === (e3 = process.__PRIVATE_env) || void 0 === e3 ? void 0 : e3.F);
      }
      /** Helper to get a typed SimpleDbStore from a transaction. */
      static M(e3, t2) {
        return e3.store(t2);
      }
      // visible for testing
      /** Parse User Agent to determine iOS version. Returns -1 if not found. */
      static S(e3) {
        const t2 = e3.match(/i(?:phone|pad|pod) os ([\d_]+)/i), n2 = t2 ? t2[1].split("_").slice(0, 2).join(".") : "-1";
        return Number(n2);
      }
      // visible for testing
      /** Parse User Agent to determine Android version. Returns -1 if not found. */
      static v(e3) {
        const t2 = e3.match(/Android ([\d.]+)/i), n2 = t2 ? t2[1].split(".").slice(0, 2).join(".") : "-1";
        return Number(n2);
      }
      /**
       * Opens the specified database, creating or upgrading it if necessary.
       */
      async O(e3) {
        return this.db || (__PRIVATE_logDebug("SimpleDb", "Opening database:", this.name), this.db = await new Promise((t2, n2) => {
          const r4 = indexedDB.open(this.name, this.version);
          r4.onsuccess = (e4) => {
            const n3 = e4.target.result;
            t2(n3);
          }, r4.onblocked = () => {
            n2(new __PRIVATE_IndexedDbTransactionError(e3, "Cannot upgrade IndexedDB schema while another tab is open. Close all tabs that access Firestore and reload this page to proceed."));
          }, r4.onerror = (t3) => {
            const r5 = t3.target.error;
            "VersionError" === r5.name ? n2(new FirestoreError(D2.FAILED_PRECONDITION, "A newer version of the Firestore SDK was previously used and so the persisted data is not compatible with the version of the SDK you are now using. The SDK will operate with persistence disabled. If you need persistence, please re-upgrade to a newer version of the SDK or else clear the persisted IndexedDB data for your app to start fresh.")) : "InvalidStateError" === r5.name ? n2(new FirestoreError(D2.FAILED_PRECONDITION, "Unable to open an IndexedDB connection. This could be due to running in a private browsing session on a browser whose private browsing sessions do not support IndexedDB: " + r5)) : n2(new __PRIVATE_IndexedDbTransactionError(e3, r5));
          }, r4.onupgradeneeded = (e4) => {
            __PRIVATE_logDebug("SimpleDb", 'Database "' + this.name + '" requires upgrade from version:', e4.oldVersion);
            const t3 = e4.target.result;
            this.p.N(t3, r4.transaction, e4.oldVersion, this.version).next(() => {
              __PRIVATE_logDebug("SimpleDb", "Database upgrade to version " + this.version + " complete");
            });
          };
        })), this.B && (this.db.onversionchange = (e4) => this.B(e4)), this.db;
      }
      L(e3) {
        this.B = e3, this.db && (this.db.onversionchange = (t2) => e3(t2));
      }
      async runTransaction(e3, t2, n2, r4) {
        const i3 = "readonly" === t2;
        let s3 = 0;
        for (; ; ) {
          ++s3;
          try {
            this.db = await this.O(e3);
            const t3 = __PRIVATE_SimpleDbTransaction.open(this.db, e3, i3 ? "readonly" : "readwrite", n2), s4 = r4(t3).next((e4) => (t3.g(), e4)).catch((e4) => (
              // Abort the transaction if there was an error.
              (t3.abort(e4), PersistencePromise.reject(e4))
            )).toPromise();
            return s4.catch(() => {
            }), // Wait for the transaction to complete (i.e. IndexedDb's onsuccess event to
            // fire), but still return the original transactionFnResult back to the
            // caller.
            await t3.m, s4;
          } catch (e4) {
            const t3 = e4, n3 = "FirebaseError" !== t3.name && s3 < 3;
            if (__PRIVATE_logDebug("SimpleDb", "Transaction failed with error:", t3.message, "Retrying:", n3), this.close(), !n3)
              return Promise.reject(t3);
          }
        }
      }
      close() {
        this.db && this.db.close(), this.db = void 0;
      }
    };
    __PRIVATE_IterationController = class {
      constructor(e3) {
        this.k = e3, this.q = false, this.K = null;
      }
      get isDone() {
        return this.q;
      }
      get $() {
        return this.K;
      }
      set cursor(e3) {
        this.k = e3;
      }
      /**
       * This function can be called to stop iteration at any point.
       */
      done() {
        this.q = true;
      }
      /**
       * This function can be called to skip to that next key, which could be
       * an index or a primary key.
       */
      U(e3) {
        this.K = e3;
      }
      /**
       * Delete the current cursor value from the object store.
       *
       * NOTE: You CANNOT do this with a keysOnly query.
       */
      delete() {
        return __PRIVATE_wrapRequest(this.k.delete());
      }
    };
    __PRIVATE_IndexedDbTransactionError = class extends FirestoreError {
      constructor(e3, t2) {
        super(D2.UNAVAILABLE, `IndexedDB transaction '${e3}' failed: ${t2}`), this.name = "IndexedDbTransactionError";
      }
    };
    __PRIVATE_SimpleDbStore = class {
      constructor(e3) {
        this.store = e3;
      }
      put(e3, t2) {
        let n2;
        return void 0 !== t2 ? (__PRIVATE_logDebug("SimpleDb", "PUT", this.store.name, e3, t2), n2 = this.store.put(t2, e3)) : (__PRIVATE_logDebug("SimpleDb", "PUT", this.store.name, "<auto-key>", e3), n2 = this.store.put(e3)), __PRIVATE_wrapRequest(n2);
      }
      /**
       * Adds a new value into an Object Store and returns the new key. Similar to
       * IndexedDb's `add()`, this method will fail on primary key collisions.
       *
       * @param value - The object to write.
       * @returns The key of the value to add.
       */
      add(e3) {
        __PRIVATE_logDebug("SimpleDb", "ADD", this.store.name, e3, e3);
        return __PRIVATE_wrapRequest(this.store.add(e3));
      }
      /**
       * Gets the object with the specified key from the specified store, or null
       * if no object exists with the specified key.
       *
       * @key The key of the object to get.
       * @returns The object with the specified key or null if no object exists.
       */
      get(e3) {
        return __PRIVATE_wrapRequest(this.store.get(e3)).next((t2) => (
          // Normalize nonexistence to null.
          (void 0 === t2 && (t2 = null), __PRIVATE_logDebug("SimpleDb", "GET", this.store.name, e3, t2), t2)
        ));
      }
      delete(e3) {
        __PRIVATE_logDebug("SimpleDb", "DELETE", this.store.name, e3);
        return __PRIVATE_wrapRequest(this.store.delete(e3));
      }
      /**
       * If we ever need more of the count variants, we can add overloads. For now,
       * all we need is to count everything in a store.
       *
       * Returns the number of rows in the store.
       */
      count() {
        __PRIVATE_logDebug("SimpleDb", "COUNT", this.store.name);
        return __PRIVATE_wrapRequest(this.store.count());
      }
      W(e3, t2) {
        const n2 = this.options(e3, t2), r4 = n2.index ? this.store.index(n2.index) : this.store;
        if ("function" == typeof r4.getAll) {
          const e4 = r4.getAll(n2.range);
          return new PersistencePromise((t3, n3) => {
            e4.onerror = (e5) => {
              n3(e5.target.error);
            }, e4.onsuccess = (e5) => {
              t3(e5.target.result);
            };
          });
        }
        {
          const e4 = this.cursor(n2), t3 = [];
          return this.G(e4, (e5, n3) => {
            t3.push(n3);
          }).next(() => t3);
        }
      }
      /**
       * Loads the first `count` elements from the provided index range. Loads all
       * elements if no limit is provided.
       */
      j(e3, t2) {
        const n2 = this.store.getAll(e3, null === t2 ? void 0 : t2);
        return new PersistencePromise((e4, t3) => {
          n2.onerror = (e5) => {
            t3(e5.target.error);
          }, n2.onsuccess = (t4) => {
            e4(t4.target.result);
          };
        });
      }
      H(e3, t2) {
        __PRIVATE_logDebug("SimpleDb", "DELETE ALL", this.store.name);
        const n2 = this.options(e3, t2);
        n2.J = false;
        const r4 = this.cursor(n2);
        return this.G(r4, (e4, t3, n3) => n3.delete());
      }
      Y(e3, t2) {
        let n2;
        t2 ? n2 = e3 : (n2 = {}, t2 = e3);
        const r4 = this.cursor(n2);
        return this.G(r4, t2);
      }
      /**
       * Iterates over a store, but waits for the given callback to complete for
       * each entry before iterating the next entry. This allows the callback to do
       * asynchronous work to determine if this iteration should continue.
       *
       * The provided callback should return `true` to continue iteration, and
       * `false` otherwise.
       */
      Z(e3) {
        const t2 = this.cursor({});
        return new PersistencePromise((n2, r4) => {
          t2.onerror = (e4) => {
            const t3 = __PRIVATE_checkForAndReportiOSError(e4.target.error);
            r4(t3);
          }, t2.onsuccess = (t3) => {
            const r5 = t3.target.result;
            r5 ? e3(r5.primaryKey, r5.value).next((e4) => {
              e4 ? r5.continue() : n2();
            }) : n2();
          };
        });
      }
      G(e3, t2) {
        const n2 = [];
        return new PersistencePromise((r4, i3) => {
          e3.onerror = (e4) => {
            i3(e4.target.error);
          }, e3.onsuccess = (e4) => {
            const i4 = e4.target.result;
            if (!i4)
              return void r4();
            const s3 = new __PRIVATE_IterationController(i4), o2 = t2(i4.primaryKey, i4.value, s3);
            if (o2 instanceof PersistencePromise) {
              const e5 = o2.catch((e6) => (s3.done(), PersistencePromise.reject(e6)));
              n2.push(e5);
            }
            s3.isDone ? r4() : null === s3.$ ? i4.continue() : i4.continue(s3.$);
          };
        }).next(() => PersistencePromise.waitFor(n2));
      }
      options(e3, t2) {
        let n2;
        return void 0 !== e3 && ("string" == typeof e3 ? n2 = e3 : t2 = e3), {
          index: n2,
          range: t2
        };
      }
      cursor(e3) {
        let t2 = "next";
        if (e3.reverse && (t2 = "prev"), e3.index) {
          const n2 = this.store.index(e3.index);
          return e3.J ? n2.openKeyCursor(e3.range, t2) : n2.openCursor(e3.range, t2);
        }
        return this.store.openCursor(e3.range, t2);
      }
    };
    F2 = false;
    __PRIVATE_ListenSequence = class {
      constructor(e3, t2) {
        this.previousValue = e3, t2 && (t2.sequenceNumberHandler = (e4) => this.se(e4), this.oe = (e4) => t2.writeSequenceNumber(e4));
      }
      se(e3) {
        return this.previousValue = Math.max(e3, this.previousValue), this.previousValue;
      }
      next() {
        const e3 = ++this.previousValue;
        return this.oe && this.oe(e3), e3;
      }
    };
    __PRIVATE_ListenSequence._e = -1;
    H2 = [...[...[...[...["mutationQueues", "mutations", "documentMutations", "remoteDocuments", "targets", "owner", "targetGlobal", "targetDocuments"], "clientMetadata"], "remoteDocumentGlobal"], "collectionParents"], "bundles", "namedQueries"];
    J2 = [...H2, "documentOverlays"];
    Y2 = ["mutationQueues", "mutations", "documentMutations", "remoteDocumentsV14", "targets", "owner", "targetGlobal", "targetDocuments", "clientMetadata", "remoteDocumentGlobal", "collectionParents", "bundles", "namedQueries", "documentOverlays"];
    Z2 = Y2;
    X2 = [...Z2, "indexConfiguration", "indexState", "indexEntries"];
    SortedMap = class _SortedMap {
      constructor(e3, t2) {
        this.comparator = e3, this.root = t2 || LLRBNode.EMPTY;
      }
      // Returns a copy of the map, with the specified key/value added or replaced.
      insert(e3, t2) {
        return new _SortedMap(this.comparator, this.root.insert(e3, t2, this.comparator).copy(null, null, LLRBNode.BLACK, null, null));
      }
      // Returns a copy of the map, with the specified key removed.
      remove(e3) {
        return new _SortedMap(this.comparator, this.root.remove(e3, this.comparator).copy(null, null, LLRBNode.BLACK, null, null));
      }
      // Returns the value of the node with the given key, or null.
      get(e3) {
        let t2 = this.root;
        for (; !t2.isEmpty(); ) {
          const n2 = this.comparator(e3, t2.key);
          if (0 === n2)
            return t2.value;
          n2 < 0 ? t2 = t2.left : n2 > 0 && (t2 = t2.right);
        }
        return null;
      }
      // Returns the index of the element in this sorted map, or -1 if it doesn't
      // exist.
      indexOf(e3) {
        let t2 = 0, n2 = this.root;
        for (; !n2.isEmpty(); ) {
          const r4 = this.comparator(e3, n2.key);
          if (0 === r4)
            return t2 + n2.left.size;
          r4 < 0 ? n2 = n2.left : (
            // Count all nodes left of the node plus the node itself
            (t2 += n2.left.size + 1, n2 = n2.right)
          );
        }
        return -1;
      }
      isEmpty() {
        return this.root.isEmpty();
      }
      // Returns the total number of nodes in the map.
      get size() {
        return this.root.size;
      }
      // Returns the minimum key in the map.
      minKey() {
        return this.root.minKey();
      }
      // Returns the maximum key in the map.
      maxKey() {
        return this.root.maxKey();
      }
      // Traverses the map in key order and calls the specified action function
      // for each key/value pair. If action returns true, traversal is aborted.
      // Returns the first truthy value returned by action, or the last falsey
      // value returned by action.
      inorderTraversal(e3) {
        return this.root.inorderTraversal(e3);
      }
      forEach(e3) {
        this.inorderTraversal((t2, n2) => (e3(t2, n2), false));
      }
      toString() {
        const e3 = [];
        return this.inorderTraversal((t2, n2) => (e3.push(`${t2}:${n2}`), false)), `{${e3.join(", ")}}`;
      }
      // Traverses the map in reverse key order and calls the specified action
      // function for each key/value pair. If action returns true, traversal is
      // aborted.
      // Returns the first truthy value returned by action, or the last falsey
      // value returned by action.
      reverseTraversal(e3) {
        return this.root.reverseTraversal(e3);
      }
      // Returns an iterator over the SortedMap.
      getIterator() {
        return new SortedMapIterator(this.root, null, this.comparator, false);
      }
      getIteratorFrom(e3) {
        return new SortedMapIterator(this.root, e3, this.comparator, false);
      }
      getReverseIterator() {
        return new SortedMapIterator(this.root, null, this.comparator, true);
      }
      getReverseIteratorFrom(e3) {
        return new SortedMapIterator(this.root, e3, this.comparator, true);
      }
    };
    SortedMapIterator = class {
      constructor(e3, t2, n2, r4) {
        this.isReverse = r4, this.nodeStack = [];
        let i3 = 1;
        for (; !e3.isEmpty(); )
          if (i3 = t2 ? n2(e3.key, t2) : 1, // flip the comparison if we're going in reverse
          t2 && r4 && (i3 *= -1), i3 < 0)
            e3 = this.isReverse ? e3.left : e3.right;
          else {
            if (0 === i3) {
              this.nodeStack.push(e3);
              break;
            }
            this.nodeStack.push(e3), e3 = this.isReverse ? e3.right : e3.left;
          }
      }
      getNext() {
        let e3 = this.nodeStack.pop();
        const t2 = {
          key: e3.key,
          value: e3.value
        };
        if (this.isReverse)
          for (e3 = e3.left; !e3.isEmpty(); )
            this.nodeStack.push(e3), e3 = e3.right;
        else
          for (e3 = e3.right; !e3.isEmpty(); )
            this.nodeStack.push(e3), e3 = e3.left;
        return t2;
      }
      hasNext() {
        return this.nodeStack.length > 0;
      }
      peek() {
        if (0 === this.nodeStack.length)
          return null;
        const e3 = this.nodeStack[this.nodeStack.length - 1];
        return {
          key: e3.key,
          value: e3.value
        };
      }
    };
    LLRBNode = class _LLRBNode {
      constructor(e3, t2, n2, r4, i3) {
        this.key = e3, this.value = t2, this.color = null != n2 ? n2 : _LLRBNode.RED, this.left = null != r4 ? r4 : _LLRBNode.EMPTY, this.right = null != i3 ? i3 : _LLRBNode.EMPTY, this.size = this.left.size + 1 + this.right.size;
      }
      // Returns a copy of the current node, optionally replacing pieces of it.
      copy(e3, t2, n2, r4, i3) {
        return new _LLRBNode(null != e3 ? e3 : this.key, null != t2 ? t2 : this.value, null != n2 ? n2 : this.color, null != r4 ? r4 : this.left, null != i3 ? i3 : this.right);
      }
      isEmpty() {
        return false;
      }
      // Traverses the tree in key order and calls the specified action function
      // for each node. If action returns true, traversal is aborted.
      // Returns the first truthy value returned by action, or the last falsey
      // value returned by action.
      inorderTraversal(e3) {
        return this.left.inorderTraversal(e3) || e3(this.key, this.value) || this.right.inorderTraversal(e3);
      }
      // Traverses the tree in reverse key order and calls the specified action
      // function for each node. If action returns true, traversal is aborted.
      // Returns the first truthy value returned by action, or the last falsey
      // value returned by action.
      reverseTraversal(e3) {
        return this.right.reverseTraversal(e3) || e3(this.key, this.value) || this.left.reverseTraversal(e3);
      }
      // Returns the minimum node in the tree.
      min() {
        return this.left.isEmpty() ? this : this.left.min();
      }
      // Returns the maximum key in the tree.
      minKey() {
        return this.min().key;
      }
      // Returns the maximum key in the tree.
      maxKey() {
        return this.right.isEmpty() ? this.key : this.right.maxKey();
      }
      // Returns new tree, with the key/value added.
      insert(e3, t2, n2) {
        let r4 = this;
        const i3 = n2(e3, r4.key);
        return r4 = i3 < 0 ? r4.copy(null, null, null, r4.left.insert(e3, t2, n2), null) : 0 === i3 ? r4.copy(null, t2, null, null, null) : r4.copy(null, null, null, null, r4.right.insert(e3, t2, n2)), r4.fixUp();
      }
      removeMin() {
        if (this.left.isEmpty())
          return _LLRBNode.EMPTY;
        let e3 = this;
        return e3.left.isRed() || e3.left.left.isRed() || (e3 = e3.moveRedLeft()), e3 = e3.copy(null, null, null, e3.left.removeMin(), null), e3.fixUp();
      }
      // Returns new tree, with the specified item removed.
      remove(e3, t2) {
        let n2, r4 = this;
        if (t2(e3, r4.key) < 0)
          r4.left.isEmpty() || r4.left.isRed() || r4.left.left.isRed() || (r4 = r4.moveRedLeft()), r4 = r4.copy(null, null, null, r4.left.remove(e3, t2), null);
        else {
          if (r4.left.isRed() && (r4 = r4.rotateRight()), r4.right.isEmpty() || r4.right.isRed() || r4.right.left.isRed() || (r4 = r4.moveRedRight()), 0 === t2(e3, r4.key)) {
            if (r4.right.isEmpty())
              return _LLRBNode.EMPTY;
            n2 = r4.right.min(), r4 = r4.copy(n2.key, n2.value, null, null, r4.right.removeMin());
          }
          r4 = r4.copy(null, null, null, null, r4.right.remove(e3, t2));
        }
        return r4.fixUp();
      }
      isRed() {
        return this.color;
      }
      // Returns new tree after performing any needed rotations.
      fixUp() {
        let e3 = this;
        return e3.right.isRed() && !e3.left.isRed() && (e3 = e3.rotateLeft()), e3.left.isRed() && e3.left.left.isRed() && (e3 = e3.rotateRight()), e3.left.isRed() && e3.right.isRed() && (e3 = e3.colorFlip()), e3;
      }
      moveRedLeft() {
        let e3 = this.colorFlip();
        return e3.right.left.isRed() && (e3 = e3.copy(null, null, null, null, e3.right.rotateRight()), e3 = e3.rotateLeft(), e3 = e3.colorFlip()), e3;
      }
      moveRedRight() {
        let e3 = this.colorFlip();
        return e3.left.left.isRed() && (e3 = e3.rotateRight(), e3 = e3.colorFlip()), e3;
      }
      rotateLeft() {
        const e3 = this.copy(null, null, _LLRBNode.RED, null, this.right.left);
        return this.right.copy(null, null, this.color, e3, null);
      }
      rotateRight() {
        const e3 = this.copy(null, null, _LLRBNode.RED, this.left.right, null);
        return this.left.copy(null, null, this.color, null, e3);
      }
      colorFlip() {
        const e3 = this.left.copy(null, null, !this.left.color, null, null), t2 = this.right.copy(null, null, !this.right.color, null, null);
        return this.copy(null, null, !this.color, e3, t2);
      }
      // For testing.
      checkMaxDepth() {
        const e3 = this.check();
        return Math.pow(2, e3) <= this.size + 1;
      }
      // In a balanced RB tree, the black-depth (number of black nodes) from root to
      // leaves is equal on both sides.  This function verifies that or asserts.
      check() {
        if (this.isRed() && this.left.isRed())
          throw fail();
        if (this.right.isRed())
          throw fail();
        const e3 = this.left.check();
        if (e3 !== this.right.check())
          throw fail();
        return e3 + (this.isRed() ? 0 : 1);
      }
    };
    LLRBNode.EMPTY = null, LLRBNode.RED = true, LLRBNode.BLACK = false;
    LLRBNode.EMPTY = new // Represents an empty node (a leaf node in the Red-Black Tree).
    class LLRBEmptyNode {
      constructor() {
        this.size = 0;
      }
      get key() {
        throw fail();
      }
      get value() {
        throw fail();
      }
      get color() {
        throw fail();
      }
      get left() {
        throw fail();
      }
      get right() {
        throw fail();
      }
      // Returns a copy of the current node.
      copy(e3, t2, n2, r4, i3) {
        return this;
      }
      // Returns a copy of the tree, with the specified key/value added.
      insert(e3, t2, n2) {
        return new LLRBNode(e3, t2);
      }
      // Returns a copy of the tree, with the specified key removed.
      remove(e3, t2) {
        return this;
      }
      isEmpty() {
        return true;
      }
      inorderTraversal(e3) {
        return false;
      }
      reverseTraversal(e3) {
        return false;
      }
      minKey() {
        return null;
      }
      maxKey() {
        return null;
      }
      isRed() {
        return false;
      }
      // For testing.
      checkMaxDepth() {
        return true;
      }
      check() {
        return 0;
      }
    }();
    SortedSet = class _SortedSet {
      constructor(e3) {
        this.comparator = e3, this.data = new SortedMap(this.comparator);
      }
      has(e3) {
        return null !== this.data.get(e3);
      }
      first() {
        return this.data.minKey();
      }
      last() {
        return this.data.maxKey();
      }
      get size() {
        return this.data.size;
      }
      indexOf(e3) {
        return this.data.indexOf(e3);
      }
      /** Iterates elements in order defined by "comparator" */
      forEach(e3) {
        this.data.inorderTraversal((t2, n2) => (e3(t2), false));
      }
      /** Iterates over `elem`s such that: range[0] &lt;= elem &lt; range[1]. */
      forEachInRange(e3, t2) {
        const n2 = this.data.getIteratorFrom(e3[0]);
        for (; n2.hasNext(); ) {
          const r4 = n2.getNext();
          if (this.comparator(r4.key, e3[1]) >= 0)
            return;
          t2(r4.key);
        }
      }
      /**
       * Iterates over `elem`s such that: start &lt;= elem until false is returned.
       */
      forEachWhile(e3, t2) {
        let n2;
        for (n2 = void 0 !== t2 ? this.data.getIteratorFrom(t2) : this.data.getIterator(); n2.hasNext(); ) {
          if (!e3(n2.getNext().key))
            return;
        }
      }
      /** Finds the least element greater than or equal to `elem`. */
      firstAfterOrEqual(e3) {
        const t2 = this.data.getIteratorFrom(e3);
        return t2.hasNext() ? t2.getNext().key : null;
      }
      getIterator() {
        return new SortedSetIterator(this.data.getIterator());
      }
      getIteratorFrom(e3) {
        return new SortedSetIterator(this.data.getIteratorFrom(e3));
      }
      /** Inserts or updates an element */
      add(e3) {
        return this.copy(this.data.remove(e3).insert(e3, true));
      }
      /** Deletes an element */
      delete(e3) {
        return this.has(e3) ? this.copy(this.data.remove(e3)) : this;
      }
      isEmpty() {
        return this.data.isEmpty();
      }
      unionWith(e3) {
        let t2 = this;
        return t2.size < e3.size && (t2 = e3, e3 = this), e3.forEach((e4) => {
          t2 = t2.add(e4);
        }), t2;
      }
      isEqual(e3) {
        if (!(e3 instanceof _SortedSet))
          return false;
        if (this.size !== e3.size)
          return false;
        const t2 = this.data.getIterator(), n2 = e3.data.getIterator();
        for (; t2.hasNext(); ) {
          const e4 = t2.getNext().key, r4 = n2.getNext().key;
          if (0 !== this.comparator(e4, r4))
            return false;
        }
        return true;
      }
      toArray() {
        const e3 = [];
        return this.forEach((t2) => {
          e3.push(t2);
        }), e3;
      }
      toString() {
        const e3 = [];
        return this.forEach((t2) => e3.push(t2)), "SortedSet(" + e3.toString() + ")";
      }
      copy(e3) {
        const t2 = new _SortedSet(this.comparator);
        return t2.data = e3, t2;
      }
    };
    SortedSetIterator = class {
      constructor(e3) {
        this.iter = e3;
      }
      getNext() {
        return this.iter.getNext().key;
      }
      hasNext() {
        return this.iter.hasNext();
      }
    };
    FieldMask = class _FieldMask {
      constructor(e3) {
        this.fields = e3, // TODO(dimond): validation of FieldMask
        // Sort the field mask to support `FieldMask.isEqual()` and assert below.
        e3.sort(FieldPath$1.comparator);
      }
      static empty() {
        return new _FieldMask([]);
      }
      /**
       * Returns a new FieldMask object that is the result of adding all the given
       * fields paths to this field mask.
       */
      unionWith(e3) {
        let t2 = new SortedSet(FieldPath$1.comparator);
        for (const e4 of this.fields)
          t2 = t2.add(e4);
        for (const n2 of e3)
          t2 = t2.add(n2);
        return new _FieldMask(t2.toArray());
      }
      /**
       * Verifies that `fieldPath` is included by at least one field in this field
       * mask.
       *
       * This is an O(n) operation, where `n` is the size of the field mask.
       */
      covers(e3) {
        for (const t2 of this.fields)
          if (t2.isPrefixOf(e3))
            return true;
        return false;
      }
      isEqual(e3) {
        return __PRIVATE_arrayEquals(this.fields, e3.fields, (e4, t2) => e4.isEqual(t2));
      }
    };
    __PRIVATE_Base64DecodeError = class extends Error {
      constructor() {
        super(...arguments), this.name = "Base64DecodeError";
      }
    };
    ByteString = class _ByteString {
      constructor(e3) {
        this.binaryString = e3;
      }
      static fromBase64String(e3) {
        const t2 = function __PRIVATE_decodeBase64(e4) {
          try {
            return atob(e4);
          } catch (e5) {
            throw "undefined" != typeof DOMException && e5 instanceof DOMException ? new __PRIVATE_Base64DecodeError("Invalid base64 string: " + e5) : e5;
          }
        }(e3);
        return new _ByteString(t2);
      }
      static fromUint8Array(e3) {
        const t2 = (
          /**
          * Helper function to convert an Uint8array to a binary string.
          */
          function __PRIVATE_binaryStringFromUint8Array(e4) {
            let t3 = "";
            for (let n2 = 0; n2 < e4.length; ++n2)
              t3 += String.fromCharCode(e4[n2]);
            return t3;
          }(e3)
        );
        return new _ByteString(t2);
      }
      [Symbol.iterator]() {
        let e3 = 0;
        return {
          next: () => e3 < this.binaryString.length ? {
            value: this.binaryString.charCodeAt(e3++),
            done: false
          } : {
            value: void 0,
            done: true
          }
        };
      }
      toBase64() {
        return function __PRIVATE_encodeBase64(e3) {
          return btoa(e3);
        }(this.binaryString);
      }
      toUint8Array() {
        return function __PRIVATE_uint8ArrayFromBinaryString(e3) {
          const t2 = new Uint8Array(e3.length);
          for (let n2 = 0; n2 < e3.length; n2++)
            t2[n2] = e3.charCodeAt(n2);
          return t2;
        }(this.binaryString);
      }
      approximateByteSize() {
        return 2 * this.binaryString.length;
      }
      compareTo(e3) {
        return __PRIVATE_primitiveComparator(this.binaryString, e3.binaryString);
      }
      isEqual(e3) {
        return this.binaryString === e3.binaryString;
      }
    };
    ByteString.EMPTY_BYTE_STRING = new ByteString("");
    ee = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
    DatabaseInfo = class {
      /**
       * Constructs a DatabaseInfo using the provided host, databaseId and
       * persistenceKey.
       *
       * @param databaseId - The database to use.
       * @param appId - The Firebase App Id.
       * @param persistenceKey - A unique identifier for this Firestore's local
       * storage (used in conjunction with the databaseId).
       * @param host - The Firestore backend host to connect to.
       * @param ssl - Whether to use SSL when connecting.
       * @param forceLongPolling - Whether to use the forceLongPolling option
       * when using WebChannel as the network transport.
       * @param autoDetectLongPolling - Whether to use the detectBufferingProxy
       * option when using WebChannel as the network transport.
       * @param longPollingOptions Options that configure long-polling.
       * @param useFetchStreams Whether to use the Fetch API instead of
       * XMLHTTPRequest
       */
      constructor(e3, t2, n2, r4, i3, s3, o2, _, a2) {
        this.databaseId = e3, this.appId = t2, this.persistenceKey = n2, this.host = r4, this.ssl = i3, this.forceLongPolling = s3, this.autoDetectLongPolling = o2, this.longPollingOptions = _, this.useFetchStreams = a2;
      }
    };
    DatabaseId = class _DatabaseId {
      constructor(e3, t2) {
        this.projectId = e3, this.database = t2 || "(default)";
      }
      static empty() {
        return new _DatabaseId("", "");
      }
      get isDefaultDatabase() {
        return "(default)" === this.database;
      }
      isEqual(e3) {
        return e3 instanceof _DatabaseId && e3.projectId === this.projectId && e3.database === this.database;
      }
    };
    te = {
      mapValue: {
        fields: {
          __type__: {
            stringValue: "__max__"
          }
        }
      }
    };
    ObjectValue = class _ObjectValue {
      constructor(e3) {
        this.value = e3;
      }
      static empty() {
        return new _ObjectValue({
          mapValue: {}
        });
      }
      /**
       * Returns the value at the given path or null.
       *
       * @param path - the path to search
       * @returns The value at the path or null if the path is not set.
       */
      field(e3) {
        if (e3.isEmpty())
          return this.value;
        {
          let t2 = this.value;
          for (let n2 = 0; n2 < e3.length - 1; ++n2)
            if (t2 = (t2.mapValue.fields || {})[e3.get(n2)], !__PRIVATE_isMapValue(t2))
              return null;
          return t2 = (t2.mapValue.fields || {})[e3.lastSegment()], t2 || null;
        }
      }
      /**
       * Sets the field to the provided value.
       *
       * @param path - The field path to set.
       * @param value - The value to set.
       */
      set(e3, t2) {
        this.getFieldsMap(e3.popLast())[e3.lastSegment()] = __PRIVATE_deepClone(t2);
      }
      /**
       * Sets the provided fields to the provided values.
       *
       * @param data - A map of fields to values (or null for deletes).
       */
      setAll(e3) {
        let t2 = FieldPath$1.emptyPath(), n2 = {}, r4 = [];
        e3.forEach((e4, i4) => {
          if (!t2.isImmediateParentOf(i4)) {
            const e5 = this.getFieldsMap(t2);
            this.applyChanges(e5, n2, r4), n2 = {}, r4 = [], t2 = i4.popLast();
          }
          e4 ? n2[i4.lastSegment()] = __PRIVATE_deepClone(e4) : r4.push(i4.lastSegment());
        });
        const i3 = this.getFieldsMap(t2);
        this.applyChanges(i3, n2, r4);
      }
      /**
       * Removes the field at the specified path. If there is no field at the
       * specified path, nothing is changed.
       *
       * @param path - The field path to remove.
       */
      delete(e3) {
        const t2 = this.field(e3.popLast());
        __PRIVATE_isMapValue(t2) && t2.mapValue.fields && delete t2.mapValue.fields[e3.lastSegment()];
      }
      isEqual(e3) {
        return __PRIVATE_valueEquals(this.value, e3.value);
      }
      /**
       * Returns the map that contains the leaf element of `path`. If the parent
       * entry does not yet exist, or if it is not a map, a new map will be created.
       */
      getFieldsMap(e3) {
        let t2 = this.value;
        t2.mapValue.fields || (t2.mapValue = {
          fields: {}
        });
        for (let n2 = 0; n2 < e3.length; ++n2) {
          let r4 = t2.mapValue.fields[e3.get(n2)];
          __PRIVATE_isMapValue(r4) && r4.mapValue.fields || (r4 = {
            mapValue: {
              fields: {}
            }
          }, t2.mapValue.fields[e3.get(n2)] = r4), t2 = r4;
        }
        return t2.mapValue.fields;
      }
      /**
       * Modifies `fieldsMap` by adding, replacing or deleting the specified
       * entries.
       */
      applyChanges(e3, t2, n2) {
        forEach(t2, (t3, n3) => e3[t3] = n3);
        for (const t3 of n2)
          delete e3[t3];
      }
      clone() {
        return new _ObjectValue(__PRIVATE_deepClone(this.value));
      }
    };
    MutableDocument = class _MutableDocument {
      constructor(e3, t2, n2, r4, i3, s3, o2) {
        this.key = e3, this.documentType = t2, this.version = n2, this.readTime = r4, this.createTime = i3, this.data = s3, this.documentState = o2;
      }
      /**
       * Creates a document with no known version or data, but which can serve as
       * base document for mutations.
       */
      static newInvalidDocument(e3) {
        return new _MutableDocument(
          e3,
          0,
          /* version */
          SnapshotVersion.min(),
          /* readTime */
          SnapshotVersion.min(),
          /* createTime */
          SnapshotVersion.min(),
          ObjectValue.empty(),
          0
          /* DocumentState.SYNCED */
        );
      }
      /**
       * Creates a new document that is known to exist with the given data at the
       * given version.
       */
      static newFoundDocument(e3, t2, n2, r4) {
        return new _MutableDocument(
          e3,
          1,
          /* version */
          t2,
          /* readTime */
          SnapshotVersion.min(),
          /* createTime */
          n2,
          r4,
          0
          /* DocumentState.SYNCED */
        );
      }
      /** Creates a new document that is known to not exist at the given version. */
      static newNoDocument(e3, t2) {
        return new _MutableDocument(
          e3,
          2,
          /* version */
          t2,
          /* readTime */
          SnapshotVersion.min(),
          /* createTime */
          SnapshotVersion.min(),
          ObjectValue.empty(),
          0
          /* DocumentState.SYNCED */
        );
      }
      /**
       * Creates a new document that is known to exist at the given version but
       * whose data is not known (e.g. a document that was updated without a known
       * base document).
       */
      static newUnknownDocument(e3, t2) {
        return new _MutableDocument(
          e3,
          3,
          /* version */
          t2,
          /* readTime */
          SnapshotVersion.min(),
          /* createTime */
          SnapshotVersion.min(),
          ObjectValue.empty(),
          2
          /* DocumentState.HAS_COMMITTED_MUTATIONS */
        );
      }
      /**
       * Changes the document type to indicate that it exists and that its version
       * and data are known.
       */
      convertToFoundDocument(e3, t2) {
        return !this.createTime.isEqual(SnapshotVersion.min()) || 2 !== this.documentType && 0 !== this.documentType || (this.createTime = e3), this.version = e3, this.documentType = 1, this.data = t2, this.documentState = 0, this;
      }
      /**
       * Changes the document type to indicate that it doesn't exist at the given
       * version.
       */
      convertToNoDocument(e3) {
        return this.version = e3, this.documentType = 2, this.data = ObjectValue.empty(), this.documentState = 0, this;
      }
      /**
       * Changes the document type to indicate that it exists at a given version but
       * that its data is not known (e.g. a document that was updated without a known
       * base document).
       */
      convertToUnknownDocument(e3) {
        return this.version = e3, this.documentType = 3, this.data = ObjectValue.empty(), this.documentState = 2, this;
      }
      setHasCommittedMutations() {
        return this.documentState = 2, this;
      }
      setHasLocalMutations() {
        return this.documentState = 1, this.version = SnapshotVersion.min(), this;
      }
      setReadTime(e3) {
        return this.readTime = e3, this;
      }
      get hasLocalMutations() {
        return 1 === this.documentState;
      }
      get hasCommittedMutations() {
        return 2 === this.documentState;
      }
      get hasPendingWrites() {
        return this.hasLocalMutations || this.hasCommittedMutations;
      }
      isValidDocument() {
        return 0 !== this.documentType;
      }
      isFoundDocument() {
        return 1 === this.documentType;
      }
      isNoDocument() {
        return 2 === this.documentType;
      }
      isUnknownDocument() {
        return 3 === this.documentType;
      }
      isEqual(e3) {
        return e3 instanceof _MutableDocument && this.key.isEqual(e3.key) && this.version.isEqual(e3.version) && this.documentType === e3.documentType && this.documentState === e3.documentState && this.data.isEqual(e3.data);
      }
      mutableCopy() {
        return new _MutableDocument(this.key, this.documentType, this.version, this.readTime, this.createTime, this.data.clone(), this.documentState);
      }
      toString() {
        return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {createTime: ${this.createTime}}), {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`;
      }
    };
    Bound = class {
      constructor(e3, t2) {
        this.position = e3, this.inclusive = t2;
      }
    };
    OrderBy = class {
      constructor(e3, t2 = "asc") {
        this.field = e3, this.dir = t2;
      }
    };
    Filter = class {
    };
    FieldFilter = class _FieldFilter extends Filter {
      constructor(e3, t2, n2) {
        super(), this.field = e3, this.op = t2, this.value = n2;
      }
      /**
       * Creates a filter based on the provided arguments.
       */
      static create(e3, t2, n2) {
        return e3.isKeyField() ? "in" === t2 || "not-in" === t2 ? this.createKeyFieldInFilter(e3, t2, n2) : new __PRIVATE_KeyFieldFilter(e3, t2, n2) : "array-contains" === t2 ? new __PRIVATE_ArrayContainsFilter(e3, n2) : "in" === t2 ? new __PRIVATE_InFilter(e3, n2) : "not-in" === t2 ? new __PRIVATE_NotInFilter(e3, n2) : "array-contains-any" === t2 ? new __PRIVATE_ArrayContainsAnyFilter(e3, n2) : new _FieldFilter(e3, t2, n2);
      }
      static createKeyFieldInFilter(e3, t2, n2) {
        return "in" === t2 ? new __PRIVATE_KeyFieldInFilter(e3, n2) : new __PRIVATE_KeyFieldNotInFilter(e3, n2);
      }
      matches(e3) {
        const t2 = e3.data.field(this.field);
        return "!=" === this.op ? null !== t2 && this.matchesComparison(__PRIVATE_valueCompare(t2, this.value)) : null !== t2 && __PRIVATE_typeOrder(this.value) === __PRIVATE_typeOrder(t2) && this.matchesComparison(__PRIVATE_valueCompare(t2, this.value));
      }
      matchesComparison(e3) {
        switch (this.op) {
          case "<":
            return e3 < 0;
          case "<=":
            return e3 <= 0;
          case "==":
            return 0 === e3;
          case "!=":
            return 0 !== e3;
          case ">":
            return e3 > 0;
          case ">=":
            return e3 >= 0;
          default:
            return fail();
        }
      }
      isInequality() {
        return [
          "<",
          "<=",
          ">",
          ">=",
          "!=",
          "not-in"
          /* Operator.NOT_IN */
        ].indexOf(this.op) >= 0;
      }
      getFlattenedFilters() {
        return [this];
      }
      getFilters() {
        return [this];
      }
    };
    CompositeFilter = class _CompositeFilter extends Filter {
      constructor(e3, t2) {
        super(), this.filters = e3, this.op = t2, this.ue = null;
      }
      /**
       * Creates a filter based on the provided arguments.
       */
      static create(e3, t2) {
        return new _CompositeFilter(e3, t2);
      }
      matches(e3) {
        return __PRIVATE_compositeFilterIsConjunction(this) ? void 0 === this.filters.find((t2) => !t2.matches(e3)) : void 0 !== this.filters.find((t2) => t2.matches(e3));
      }
      getFlattenedFilters() {
        return null !== this.ue || (this.ue = this.filters.reduce((e3, t2) => e3.concat(t2.getFlattenedFilters()), [])), this.ue;
      }
      // Returns a mutable copy of `this.filters`
      getFilters() {
        return Object.assign([], this.filters);
      }
    };
    __PRIVATE_KeyFieldFilter = class extends FieldFilter {
      constructor(e3, t2, n2) {
        super(e3, t2, n2), this.key = DocumentKey.fromName(n2.referenceValue);
      }
      matches(e3) {
        const t2 = DocumentKey.comparator(e3.key, this.key);
        return this.matchesComparison(t2);
      }
    };
    __PRIVATE_KeyFieldInFilter = class extends FieldFilter {
      constructor(e3, t2) {
        super(e3, "in", t2), this.keys = __PRIVATE_extractDocumentKeysFromArrayValue("in", t2);
      }
      matches(e3) {
        return this.keys.some((t2) => t2.isEqual(e3.key));
      }
    };
    __PRIVATE_KeyFieldNotInFilter = class extends FieldFilter {
      constructor(e3, t2) {
        super(e3, "not-in", t2), this.keys = __PRIVATE_extractDocumentKeysFromArrayValue("not-in", t2);
      }
      matches(e3) {
        return !this.keys.some((t2) => t2.isEqual(e3.key));
      }
    };
    __PRIVATE_ArrayContainsFilter = class extends FieldFilter {
      constructor(e3, t2) {
        super(e3, "array-contains", t2);
      }
      matches(e3) {
        const t2 = e3.data.field(this.field);
        return isArray(t2) && __PRIVATE_arrayValueContains(t2.arrayValue, this.value);
      }
    };
    __PRIVATE_InFilter = class extends FieldFilter {
      constructor(e3, t2) {
        super(e3, "in", t2);
      }
      matches(e3) {
        const t2 = e3.data.field(this.field);
        return null !== t2 && __PRIVATE_arrayValueContains(this.value.arrayValue, t2);
      }
    };
    __PRIVATE_NotInFilter = class extends FieldFilter {
      constructor(e3, t2) {
        super(e3, "not-in", t2);
      }
      matches(e3) {
        if (__PRIVATE_arrayValueContains(this.value.arrayValue, {
          nullValue: "NULL_VALUE"
        }))
          return false;
        const t2 = e3.data.field(this.field);
        return null !== t2 && !__PRIVATE_arrayValueContains(this.value.arrayValue, t2);
      }
    };
    __PRIVATE_ArrayContainsAnyFilter = class extends FieldFilter {
      constructor(e3, t2) {
        super(e3, "array-contains-any", t2);
      }
      matches(e3) {
        const t2 = e3.data.field(this.field);
        return !(!isArray(t2) || !t2.arrayValue.values) && t2.arrayValue.values.some((e4) => __PRIVATE_arrayValueContains(this.value.arrayValue, e4));
      }
    };
    __PRIVATE_TargetImpl = class {
      constructor(e3, t2 = null, n2 = [], r4 = [], i3 = null, s3 = null, o2 = null) {
        this.path = e3, this.collectionGroup = t2, this.orderBy = n2, this.filters = r4, this.limit = i3, this.startAt = s3, this.endAt = o2, this.ce = null;
      }
    };
    __PRIVATE_QueryImpl = class {
      /**
       * Initializes a Query with a path and optional additional query constraints.
       * Path must currently be empty if this is a collection group query.
       */
      constructor(e3, t2 = null, n2 = [], r4 = [], i3 = null, s3 = "F", o2 = null, _ = null) {
        this.path = e3, this.collectionGroup = t2, this.explicitOrderBy = n2, this.filters = r4, this.limit = i3, this.limitType = s3, this.startAt = o2, this.endAt = _, this.le = null, // The corresponding `Target` of this `Query` instance, for use with
        // non-aggregate queries.
        this.he = null, // The corresponding `Target` of this `Query` instance, for use with
        // aggregate queries. Unlike targets for non-aggregate queries,
        // aggregate query targets do not contain normalized order-bys, they only
        // contain explicit order-bys.
        this.Pe = null, this.startAt, this.endAt;
      }
    };
    ObjectMap = class {
      constructor(e3, t2) {
        this.mapKeyFn = e3, this.equalsFn = t2, /**
        * The inner map for a key/value pair. Due to the possibility of collisions we
        * keep a list of entries that we do a linear search through to find an actual
        * match. Note that collisions should be rare, so we still expect near
        * constant time lookups in practice.
        */
        this.inner = {}, /** The number of entries stored in the map */
        this.innerSize = 0;
      }
      /** Get a value for this key, or undefined if it does not exist. */
      get(e3) {
        const t2 = this.mapKeyFn(e3), n2 = this.inner[t2];
        if (void 0 !== n2) {
          for (const [t3, r4] of n2)
            if (this.equalsFn(t3, e3))
              return r4;
        }
      }
      has(e3) {
        return void 0 !== this.get(e3);
      }
      /** Put this key and value in the map. */
      set(e3, t2) {
        const n2 = this.mapKeyFn(e3), r4 = this.inner[n2];
        if (void 0 === r4)
          return this.inner[n2] = [[e3, t2]], void this.innerSize++;
        for (let n3 = 0; n3 < r4.length; n3++)
          if (this.equalsFn(r4[n3][0], e3))
            return void (r4[n3] = [e3, t2]);
        r4.push([e3, t2]), this.innerSize++;
      }
      /**
       * Remove this key from the map. Returns a boolean if anything was deleted.
       */
      delete(e3) {
        const t2 = this.mapKeyFn(e3), n2 = this.inner[t2];
        if (void 0 === n2)
          return false;
        for (let r4 = 0; r4 < n2.length; r4++)
          if (this.equalsFn(n2[r4][0], e3))
            return 1 === n2.length ? delete this.inner[t2] : n2.splice(r4, 1), this.innerSize--, true;
        return false;
      }
      forEach(e3) {
        forEach(this.inner, (t2, n2) => {
          for (const [t3, r4] of n2)
            e3(t3, r4);
        });
      }
      isEmpty() {
        return isEmpty(this.inner);
      }
      size() {
        return this.innerSize;
      }
    };
    re = new SortedMap(DocumentKey.comparator);
    ie = new SortedMap(DocumentKey.comparator);
    se = new SortedMap(DocumentKey.comparator);
    oe = new SortedSet(DocumentKey.comparator);
    _e = new SortedSet(__PRIVATE_primitiveComparator);
    TransformOperation = class {
      constructor() {
        this._ = void 0;
      }
    };
    __PRIVATE_ServerTimestampTransform = class extends TransformOperation {
    };
    __PRIVATE_ArrayUnionTransformOperation = class extends TransformOperation {
      constructor(e3) {
        super(), this.elements = e3;
      }
    };
    __PRIVATE_ArrayRemoveTransformOperation = class extends TransformOperation {
      constructor(e3) {
        super(), this.elements = e3;
      }
    };
    __PRIVATE_NumericIncrementTransformOperation = class extends TransformOperation {
      constructor(e3, t2) {
        super(), this.serializer = e3, this.Ie = t2;
      }
    };
    MutationResult = class {
      constructor(e3, t2) {
        this.version = e3, this.transformResults = t2;
      }
    };
    Precondition = class _Precondition {
      constructor(e3, t2) {
        this.updateTime = e3, this.exists = t2;
      }
      /** Creates a new empty Precondition. */
      static none() {
        return new _Precondition();
      }
      /** Creates a new Precondition with an exists flag. */
      static exists(e3) {
        return new _Precondition(void 0, e3);
      }
      /** Creates a new Precondition based on a version a document exists at. */
      static updateTime(e3) {
        return new _Precondition(e3);
      }
      /** Returns whether this Precondition is empty. */
      get isNone() {
        return void 0 === this.updateTime && void 0 === this.exists;
      }
      isEqual(e3) {
        return this.exists === e3.exists && (this.updateTime ? !!e3.updateTime && this.updateTime.isEqual(e3.updateTime) : !e3.updateTime);
      }
    };
    Mutation = class {
    };
    __PRIVATE_SetMutation = class extends Mutation {
      constructor(e3, t2, n2, r4 = []) {
        super(), this.key = e3, this.value = t2, this.precondition = n2, this.fieldTransforms = r4, this.type = 0;
      }
      getFieldMask() {
        return null;
      }
    };
    __PRIVATE_PatchMutation = class extends Mutation {
      constructor(e3, t2, n2, r4, i3 = []) {
        super(), this.key = e3, this.data = t2, this.fieldMask = n2, this.precondition = r4, this.fieldTransforms = i3, this.type = 1;
      }
      getFieldMask() {
        return this.fieldMask;
      }
    };
    __PRIVATE_DeleteMutation = class extends Mutation {
      constructor(e3, t2) {
        super(), this.key = e3, this.precondition = t2, this.type = 2, this.fieldTransforms = [];
      }
      getFieldMask() {
        return null;
      }
    };
    __PRIVATE_VerifyMutation = class extends Mutation {
      constructor(e3, t2) {
        super(), this.key = e3, this.precondition = t2, this.type = 3, this.fieldTransforms = [];
      }
      getFieldMask() {
        return null;
      }
    };
    MutationBatch = class {
      /**
       * @param batchId - The unique ID of this mutation batch.
       * @param localWriteTime - The original write time of this mutation.
       * @param baseMutations - Mutations that are used to populate the base
       * values when this mutation is applied locally. This can be used to locally
       * overwrite values that are persisted in the remote document cache. Base
       * mutations are never sent to the backend.
       * @param mutations - The user-provided mutations in this mutation batch.
       * User-provided mutations are applied both locally and remotely on the
       * backend.
       */
      constructor(e3, t2, n2, r4) {
        this.batchId = e3, this.localWriteTime = t2, this.baseMutations = n2, this.mutations = r4;
      }
      /**
       * Applies all the mutations in this MutationBatch to the specified document
       * to compute the state of the remote document
       *
       * @param document - The document to apply mutations to.
       * @param batchResult - The result of applying the MutationBatch to the
       * backend.
       */
      applyToRemoteDocument(e3, t2) {
        const n2 = t2.mutationResults;
        for (let t3 = 0; t3 < this.mutations.length; t3++) {
          const r4 = this.mutations[t3];
          if (r4.key.isEqual(e3.key)) {
            __PRIVATE_mutationApplyToRemoteDocument(r4, e3, n2[t3]);
          }
        }
      }
      /**
       * Computes the local view of a document given all the mutations in this
       * batch.
       *
       * @param document - The document to apply mutations to.
       * @param mutatedFields - Fields that have been updated before applying this mutation batch.
       * @returns A `FieldMask` representing all the fields that are mutated.
       */
      applyToLocalView(e3, t2) {
        for (const n2 of this.baseMutations)
          n2.key.isEqual(e3.key) && (t2 = __PRIVATE_mutationApplyToLocalView(n2, e3, t2, this.localWriteTime));
        for (const n2 of this.mutations)
          n2.key.isEqual(e3.key) && (t2 = __PRIVATE_mutationApplyToLocalView(n2, e3, t2, this.localWriteTime));
        return t2;
      }
      /**
       * Computes the local view for all provided documents given the mutations in
       * this batch. Returns a `DocumentKey` to `Mutation` map which can be used to
       * replace all the mutation applications.
       */
      applyToLocalDocumentSet(e3, t2) {
        const n2 = __PRIVATE_newMutationMap();
        return this.mutations.forEach((r4) => {
          const i3 = e3.get(r4.key), s3 = i3.overlayedDocument;
          let o2 = this.applyToLocalView(s3, i3.mutatedFields);
          o2 = t2.has(r4.key) ? null : o2;
          const _ = __PRIVATE_calculateOverlayMutation(s3, o2);
          null !== _ && n2.set(r4.key, _), s3.isValidDocument() || s3.convertToNoDocument(SnapshotVersion.min());
        }), n2;
      }
      keys() {
        return this.mutations.reduce((e3, t2) => e3.add(t2.key), __PRIVATE_documentKeySet());
      }
      isEqual(e3) {
        return this.batchId === e3.batchId && __PRIVATE_arrayEquals(this.mutations, e3.mutations, (e4, t2) => __PRIVATE_mutationEquals(e4, t2)) && __PRIVATE_arrayEquals(this.baseMutations, e3.baseMutations, (e4, t2) => __PRIVATE_mutationEquals(e4, t2));
      }
    };
    MutationBatchResult = class _MutationBatchResult {
      constructor(e3, t2, n2, r4) {
        this.batch = e3, this.commitVersion = t2, this.mutationResults = n2, this.docVersions = r4;
      }
      /**
       * Creates a new MutationBatchResult for the given batch and results. There
       * must be one result for each mutation in the batch. This static factory
       * caches a document=&gt;version mapping (docVersions).
       */
      static from(e3, t2, n2) {
        __PRIVATE_hardAssert(e3.mutations.length === n2.length);
        let r4 = /* @__PURE__ */ function __PRIVATE_documentVersionMap() {
          return se;
        }();
        const i3 = e3.mutations;
        for (let e4 = 0; e4 < i3.length; e4++)
          r4 = r4.insert(i3[e4].key, n2[e4].version);
        return new _MutationBatchResult(e3, t2, n2, r4);
      }
    };
    Overlay = class {
      constructor(e3, t2) {
        this.largestBatchId = e3, this.mutation = t2;
      }
      getKey() {
        return this.mutation.key;
      }
      isEqual(e3) {
        return null !== e3 && this.mutation === e3.mutation;
      }
      toString() {
        return `Overlay{
      largestBatchId: ${this.largestBatchId},
      mutation: ${this.mutation.toString()}
    }`;
      }
    };
    ExistenceFilter = class {
      constructor(e3, t2) {
        this.count = e3, this.unchangedNames = t2;
      }
    };
    (ue = ae2 || (ae2 = {}))[ue.OK = 0] = "OK", ue[ue.CANCELLED = 1] = "CANCELLED", ue[ue.UNKNOWN = 2] = "UNKNOWN", ue[ue.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", ue[ue.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", ue[ue.NOT_FOUND = 5] = "NOT_FOUND", ue[ue.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", ue[ue.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", ue[ue.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", ue[ue.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", ue[ue.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", ue[ue.ABORTED = 10] = "ABORTED", ue[ue.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", ue[ue.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", ue[ue.INTERNAL = 13] = "INTERNAL", ue[ue.UNAVAILABLE = 14] = "UNAVAILABLE", ue[ue.DATA_LOSS = 15] = "DATA_LOSS";
    ce = null;
    le = new Integer([4294967295, 4294967295], 0);
    BloomFilter = class _BloomFilter {
      constructor(e3, t2, n2) {
        if (this.bitmap = e3, this.padding = t2, this.hashCount = n2, t2 < 0 || t2 >= 8)
          throw new __PRIVATE_BloomFilterError(`Invalid padding: ${t2}`);
        if (n2 < 0)
          throw new __PRIVATE_BloomFilterError(`Invalid hash count: ${n2}`);
        if (e3.length > 0 && 0 === this.hashCount)
          throw new __PRIVATE_BloomFilterError(`Invalid hash count: ${n2}`);
        if (0 === e3.length && 0 !== t2)
          throw new __PRIVATE_BloomFilterError(`Invalid padding when bitmap length is 0: ${t2}`);
        this.Te = 8 * e3.length - t2, // Set the bit count in Integer to avoid repetition in mightContain().
        this.Ee = Integer.fromNumber(this.Te);
      }
      // Calculate the ith hash value based on the hashed 64bit integers,
      // and calculate its corresponding bit index in the bitmap to be checked.
      de(e3, t2, n2) {
        let r4 = e3.add(t2.multiply(Integer.fromNumber(n2)));
        return 1 === r4.compare(le) && (r4 = new Integer([r4.getBits(0), r4.getBits(1)], 0)), r4.modulo(this.Ee).toNumber();
      }
      // Return whether the bit on the given index in the bitmap is set to 1.
      Ae(e3) {
        return 0 != (this.bitmap[Math.floor(e3 / 8)] & 1 << e3 % 8);
      }
      mightContain(e3) {
        if (0 === this.Te)
          return false;
        const t2 = __PRIVATE_getMd5HashValue(e3), [n2, r4] = __PRIVATE_get64BitUints(t2);
        for (let e4 = 0; e4 < this.hashCount; e4++) {
          const t3 = this.de(n2, r4, e4);
          if (!this.Ae(t3))
            return false;
        }
        return true;
      }
      /** Create bloom filter for testing purposes only. */
      static create(e3, t2, n2) {
        const r4 = e3 % 8 == 0 ? 0 : 8 - e3 % 8, i3 = new Uint8Array(Math.ceil(e3 / 8)), s3 = new _BloomFilter(i3, r4, t2);
        return n2.forEach((e4) => s3.insert(e4)), s3;
      }
      insert(e3) {
        if (0 === this.Te)
          return;
        const t2 = __PRIVATE_getMd5HashValue(e3), [n2, r4] = __PRIVATE_get64BitUints(t2);
        for (let e4 = 0; e4 < this.hashCount; e4++) {
          const t3 = this.de(n2, r4, e4);
          this.Re(t3);
        }
      }
      Re(e3) {
        const t2 = Math.floor(e3 / 8), n2 = e3 % 8;
        this.bitmap[t2] |= 1 << n2;
      }
    };
    __PRIVATE_BloomFilterError = class extends Error {
      constructor() {
        super(...arguments), this.name = "BloomFilterError";
      }
    };
    RemoteEvent = class _RemoteEvent {
      constructor(e3, t2, n2, r4, i3) {
        this.snapshotVersion = e3, this.targetChanges = t2, this.targetMismatches = n2, this.documentUpdates = r4, this.resolvedLimboDocuments = i3;
      }
      /**
       * HACK: Views require RemoteEvents in order to determine whether the view is
       * CURRENT, but secondary tabs don't receive remote events. So this method is
       * used to create a synthesized RemoteEvent that can be used to apply a
       * CURRENT status change to a View, for queries executed in a different tab.
       */
      // PORTING NOTE: Multi-tab only
      static createSynthesizedRemoteEventForCurrentChange(e3, t2, n2) {
        const r4 = /* @__PURE__ */ new Map();
        return r4.set(e3, TargetChange.createSynthesizedTargetChangeForCurrentChange(e3, t2, n2)), new _RemoteEvent(SnapshotVersion.min(), r4, new SortedMap(__PRIVATE_primitiveComparator), __PRIVATE_mutableDocumentMap(), __PRIVATE_documentKeySet());
      }
    };
    TargetChange = class _TargetChange {
      constructor(e3, t2, n2, r4, i3) {
        this.resumeToken = e3, this.current = t2, this.addedDocuments = n2, this.modifiedDocuments = r4, this.removedDocuments = i3;
      }
      /**
       * This method is used to create a synthesized TargetChanges that can be used to
       * apply a CURRENT status change to a View (for queries executed in a different
       * tab) or for new queries (to raise snapshots with correct CURRENT status).
       */
      static createSynthesizedTargetChangeForCurrentChange(e3, t2, n2) {
        return new _TargetChange(n2, t2, __PRIVATE_documentKeySet(), __PRIVATE_documentKeySet(), __PRIVATE_documentKeySet());
      }
    };
    __PRIVATE_DocumentWatchChange = class {
      constructor(e3, t2, n2, r4) {
        this.Ve = e3, this.removedTargetIds = t2, this.key = n2, this.me = r4;
      }
    };
    __PRIVATE_ExistenceFilterChange = class {
      constructor(e3, t2) {
        this.targetId = e3, this.fe = t2;
      }
    };
    __PRIVATE_WatchTargetChange = class {
      constructor(e3, t2, n2 = ByteString.EMPTY_BYTE_STRING, r4 = null) {
        this.state = e3, this.targetIds = t2, this.resumeToken = n2, this.cause = r4;
      }
    };
    __PRIVATE_TargetState = class {
      constructor() {
        this.ge = 0, /**
        * Keeps track of the document changes since the last raised snapshot.
        *
        * These changes are continuously updated as we receive document updates and
        * always reflect the current set of changes against the last issued snapshot.
        */
        this.pe = __PRIVATE_snapshotChangesMap(), /** See public getters for explanations of these fields. */
        this.ye = ByteString.EMPTY_BYTE_STRING, this.we = false, /**
        * Whether this target state should be included in the next snapshot. We
        * initialize to true so that newly-added targets are included in the next
        * RemoteEvent.
        */
        this.Se = true;
      }
      /**
       * Whether this target has been marked 'current'.
       *
       * 'Current' has special meaning in the RPC protocol: It implies that the
       * Watch backend has sent us all changes up to the point at which the target
       * was added and that the target is consistent with the rest of the watch
       * stream.
       */
      get current() {
        return this.we;
      }
      /** The last resume token sent to us for this target. */
      get resumeToken() {
        return this.ye;
      }
      /** Whether this target has pending target adds or target removes. */
      get be() {
        return 0 !== this.ge;
      }
      /** Whether we have modified any state that should trigger a snapshot. */
      get De() {
        return this.Se;
      }
      /**
       * Applies the resume token to the TargetChange, but only when it has a new
       * value. Empty resumeTokens are discarded.
       */
      Ce(e3) {
        e3.approximateByteSize() > 0 && (this.Se = true, this.ye = e3);
      }
      /**
       * Creates a target change from the current set of changes.
       *
       * To reset the document changes after raising this snapshot, call
       * `clearPendingChanges()`.
       */
      ve() {
        let e3 = __PRIVATE_documentKeySet(), t2 = __PRIVATE_documentKeySet(), n2 = __PRIVATE_documentKeySet();
        return this.pe.forEach((r4, i3) => {
          switch (i3) {
            case 0:
              e3 = e3.add(r4);
              break;
            case 2:
              t2 = t2.add(r4);
              break;
            case 1:
              n2 = n2.add(r4);
              break;
            default:
              fail();
          }
        }), new TargetChange(this.ye, this.we, e3, t2, n2);
      }
      /**
       * Resets the document changes and sets `hasPendingChanges` to false.
       */
      Fe() {
        this.Se = false, this.pe = __PRIVATE_snapshotChangesMap();
      }
      Me(e3, t2) {
        this.Se = true, this.pe = this.pe.insert(e3, t2);
      }
      xe(e3) {
        this.Se = true, this.pe = this.pe.remove(e3);
      }
      Oe() {
        this.ge += 1;
      }
      Ne() {
        this.ge -= 1, __PRIVATE_hardAssert(this.ge >= 0);
      }
      Be() {
        this.Se = true, this.we = true;
      }
    };
    __PRIVATE_WatchChangeAggregator = class {
      constructor(e3) {
        this.Le = e3, /** The internal state of all tracked targets. */
        this.ke = /* @__PURE__ */ new Map(), /** Keeps track of the documents to update since the last raised snapshot. */
        this.qe = __PRIVATE_mutableDocumentMap(), /** A mapping of document keys to their set of target IDs. */
        this.Qe = __PRIVATE_documentTargetMap(), /**
        * A map of targets with existence filter mismatches. These targets are
        * known to be inconsistent and their listens needs to be re-established by
        * RemoteStore.
        */
        this.Ke = new SortedMap(__PRIVATE_primitiveComparator);
      }
      /**
       * Processes and adds the DocumentWatchChange to the current set of changes.
       */
      $e(e3) {
        for (const t2 of e3.Ve)
          e3.me && e3.me.isFoundDocument() ? this.Ue(t2, e3.me) : this.We(t2, e3.key, e3.me);
        for (const t2 of e3.removedTargetIds)
          this.We(t2, e3.key, e3.me);
      }
      /** Processes and adds the WatchTargetChange to the current set of changes. */
      Ge(e3) {
        this.forEachTarget(e3, (t2) => {
          const n2 = this.ze(t2);
          switch (e3.state) {
            case 0:
              this.je(t2) && n2.Ce(e3.resumeToken);
              break;
            case 1:
              n2.Ne(), n2.be || // We have a freshly added target, so we need to reset any state
              // that we had previously. This can happen e.g. when remove and add
              // back a target for existence filter mismatches.
              n2.Fe(), n2.Ce(e3.resumeToken);
              break;
            case 2:
              n2.Ne(), n2.be || this.removeTarget(t2);
              break;
            case 3:
              this.je(t2) && (n2.Be(), n2.Ce(e3.resumeToken));
              break;
            case 4:
              this.je(t2) && // Reset the target and synthesizes removes for all existing
              // documents. The backend will re-add any documents that still
              // match the target before it sends the next global snapshot.
              (this.He(t2), n2.Ce(e3.resumeToken));
              break;
            default:
              fail();
          }
        });
      }
      /**
       * Iterates over all targetIds that the watch change applies to: either the
       * targetIds explicitly listed in the change or the targetIds of all currently
       * active targets.
       */
      forEachTarget(e3, t2) {
        e3.targetIds.length > 0 ? e3.targetIds.forEach(t2) : this.ke.forEach((e4, n2) => {
          this.je(n2) && t2(n2);
        });
      }
      /**
       * Handles existence filters and synthesizes deletes for filter mismatches.
       * Targets that are invalidated by filter mismatches are added to
       * `pendingTargetResets`.
       */
      Je(e3) {
        const t2 = e3.targetId, n2 = e3.fe.count, r4 = this.Ye(t2);
        if (r4) {
          const i3 = r4.target;
          if (__PRIVATE_targetIsDocumentTarget(i3))
            if (0 === n2) {
              const e4 = new DocumentKey(i3.path);
              this.We(t2, e4, MutableDocument.newNoDocument(e4, SnapshotVersion.min()));
            } else
              __PRIVATE_hardAssert(1 === n2);
          else {
            const r5 = this.Ze(t2);
            if (r5 !== n2) {
              const n3 = this.Xe(e3), i4 = n3 ? this.et(n3, e3, r5) : 1;
              if (0 !== i4) {
                this.He(t2);
                const e4 = 2 === i4 ? "TargetPurposeExistenceFilterMismatchBloom" : "TargetPurposeExistenceFilterMismatch";
                this.Ke = this.Ke.insert(t2, e4);
              }
              null == ce || ce.tt(function __PRIVATE_createExistenceFilterMismatchInfoForTestingHooks(e4, t3, n4, r6, i5) {
                var s3, o2, _, a2, u2, c2;
                const l3 = {
                  localCacheCount: e4,
                  existenceFilterCount: t3.count,
                  databaseId: n4.database,
                  projectId: n4.projectId
                }, h = t3.unchangedNames;
                h && (l3.bloomFilter = {
                  applied: 0 === i5,
                  hashCount: null !== (s3 = null == h ? void 0 : h.hashCount) && void 0 !== s3 ? s3 : 0,
                  bitmapLength: null !== (a2 = null === (_ = null === (o2 = null == h ? void 0 : h.bits) || void 0 === o2 ? void 0 : o2.bitmap) || void 0 === _ ? void 0 : _.length) && void 0 !== a2 ? a2 : 0,
                  padding: null !== (c2 = null === (u2 = null == h ? void 0 : h.bits) || void 0 === u2 ? void 0 : u2.padding) && void 0 !== c2 ? c2 : 0,
                  mightContain: (e5) => {
                    var t4;
                    return null !== (t4 = null == r6 ? void 0 : r6.mightContain(e5)) && void 0 !== t4 && t4;
                  }
                });
                return l3;
              }(r5, e3.fe, this.Le.nt(), n3, i4));
            }
          }
        }
      }
      /**
       * Parse the bloom filter from the "unchanged_names" field of an existence
       * filter.
       */
      Xe(e3) {
        const t2 = e3.fe.unchangedNames;
        if (!t2 || !t2.bits)
          return null;
        const { bits: { bitmap: n2 = "", padding: r4 = 0 }, hashCount: i3 = 0 } = t2;
        let s3, o2;
        try {
          s3 = __PRIVATE_normalizeByteString(n2).toUint8Array();
        } catch (e4) {
          if (e4 instanceof __PRIVATE_Base64DecodeError)
            return __PRIVATE_logWarn("Decoding the base64 bloom filter in existence filter failed (" + e4.message + "); ignoring the bloom filter and falling back to full re-query."), null;
          throw e4;
        }
        try {
          o2 = new BloomFilter(s3, r4, i3);
        } catch (e4) {
          return __PRIVATE_logWarn(e4 instanceof __PRIVATE_BloomFilterError ? "BloomFilter error: " : "Applying bloom filter failed: ", e4), null;
        }
        return 0 === o2.Te ? null : o2;
      }
      /**
       * Apply bloom filter to remove the deleted documents, and return the
       * application status.
       */
      et(e3, t2, n2) {
        return t2.fe.count === n2 - this.rt(e3, t2.targetId) ? 0 : 2;
      }
      /**
       * Filter out removed documents based on bloom filter membership result and
       * return number of documents removed.
       */
      rt(e3, t2) {
        const n2 = this.Le.getRemoteKeysForTarget(t2);
        let r4 = 0;
        return n2.forEach((n3) => {
          const i3 = this.Le.nt(), s3 = `projects/${i3.projectId}/databases/${i3.database}/documents/${n3.path.canonicalString()}`;
          e3.mightContain(s3) || (this.We(
            t2,
            n3,
            /*updatedDocument=*/
            null
          ), r4++);
        }), r4;
      }
      /**
       * Converts the currently accumulated state into a remote event at the
       * provided snapshot version. Resets the accumulated changes before returning.
       */
      it(e3) {
        const t2 = /* @__PURE__ */ new Map();
        this.ke.forEach((n3, r5) => {
          const i3 = this.Ye(r5);
          if (i3) {
            if (n3.current && __PRIVATE_targetIsDocumentTarget(i3.target)) {
              const t3 = new DocumentKey(i3.target.path);
              null !== this.qe.get(t3) || this.st(r5, t3) || this.We(r5, t3, MutableDocument.newNoDocument(t3, e3));
            }
            n3.De && (t2.set(r5, n3.ve()), n3.Fe());
          }
        });
        let n2 = __PRIVATE_documentKeySet();
        this.Qe.forEach((e4, t3) => {
          let r5 = true;
          t3.forEachWhile((e5) => {
            const t4 = this.Ye(e5);
            return !t4 || "TargetPurposeLimboResolution" === t4.purpose || (r5 = false, false);
          }), r5 && (n2 = n2.add(e4));
        }), this.qe.forEach((t3, n3) => n3.setReadTime(e3));
        const r4 = new RemoteEvent(e3, t2, this.Ke, this.qe, n2);
        return this.qe = __PRIVATE_mutableDocumentMap(), this.Qe = __PRIVATE_documentTargetMap(), this.Ke = new SortedMap(__PRIVATE_primitiveComparator), r4;
      }
      /**
       * Adds the provided document to the internal list of document updates and
       * its document key to the given target's mapping.
       */
      // Visible for testing.
      Ue(e3, t2) {
        if (!this.je(e3))
          return;
        const n2 = this.st(e3, t2.key) ? 2 : 0;
        this.ze(e3).Me(t2.key, n2), this.qe = this.qe.insert(t2.key, t2), this.Qe = this.Qe.insert(t2.key, this.ot(t2.key).add(e3));
      }
      /**
       * Removes the provided document from the target mapping. If the
       * document no longer matches the target, but the document's state is still
       * known (e.g. we know that the document was deleted or we received the change
       * that caused the filter mismatch), the new document can be provided
       * to update the remote document cache.
       */
      // Visible for testing.
      We(e3, t2, n2) {
        if (!this.je(e3))
          return;
        const r4 = this.ze(e3);
        this.st(e3, t2) ? r4.Me(
          t2,
          1
          /* ChangeType.Removed */
        ) : (
          // The document may have entered and left the target before we raised a
          // snapshot, so we can just ignore the change.
          r4.xe(t2)
        ), this.Qe = this.Qe.insert(t2, this.ot(t2).delete(e3)), n2 && (this.qe = this.qe.insert(t2, n2));
      }
      removeTarget(e3) {
        this.ke.delete(e3);
      }
      /**
       * Returns the current count of documents in the target. This includes both
       * the number of documents that the LocalStore considers to be part of the
       * target as well as any accumulated changes.
       */
      Ze(e3) {
        const t2 = this.ze(e3).ve();
        return this.Le.getRemoteKeysForTarget(e3).size + t2.addedDocuments.size - t2.removedDocuments.size;
      }
      /**
       * Increment the number of acks needed from watch before we can consider the
       * server to be 'in-sync' with the client's active targets.
       */
      Oe(e3) {
        this.ze(e3).Oe();
      }
      ze(e3) {
        let t2 = this.ke.get(e3);
        return t2 || (t2 = new __PRIVATE_TargetState(), this.ke.set(e3, t2)), t2;
      }
      ot(e3) {
        let t2 = this.Qe.get(e3);
        return t2 || (t2 = new SortedSet(__PRIVATE_primitiveComparator), this.Qe = this.Qe.insert(e3, t2)), t2;
      }
      /**
       * Verifies that the user is still interested in this target (by calling
       * `getTargetDataForTarget()`) and that we are not waiting for pending ADDs
       * from watch.
       */
      je(e3) {
        const t2 = null !== this.Ye(e3);
        return t2 || __PRIVATE_logDebug("WatchChangeAggregator", "Detected inactive target", e3), t2;
      }
      /**
       * Returns the TargetData for an active target (i.e. a target that the user
       * is still interested in that has no outstanding target change requests).
       */
      Ye(e3) {
        const t2 = this.ke.get(e3);
        return t2 && t2.be ? null : this.Le._t(e3);
      }
      /**
       * Resets the state of a Watch target to its initial state (e.g. sets
       * 'current' to false, clears the resume token and removes its target mapping
       * from all documents).
       */
      He(e3) {
        this.ke.set(e3, new __PRIVATE_TargetState());
        this.Le.getRemoteKeysForTarget(e3).forEach((t2) => {
          this.We(
            e3,
            t2,
            /*updatedDocument=*/
            null
          );
        });
      }
      /**
       * Returns whether the LocalStore considers the document to be part of the
       * specified target.
       */
      st(e3, t2) {
        return this.Le.getRemoteKeysForTarget(e3).has(t2);
      }
    };
    he = /* @__PURE__ */ (() => {
      const e3 = {
        asc: "ASCENDING",
        desc: "DESCENDING"
      };
      return e3;
    })();
    Pe = /* @__PURE__ */ (() => {
      const e3 = {
        "<": "LESS_THAN",
        "<=": "LESS_THAN_OR_EQUAL",
        ">": "GREATER_THAN",
        ">=": "GREATER_THAN_OR_EQUAL",
        "==": "EQUAL",
        "!=": "NOT_EQUAL",
        "array-contains": "ARRAY_CONTAINS",
        in: "IN",
        "not-in": "NOT_IN",
        "array-contains-any": "ARRAY_CONTAINS_ANY"
      };
      return e3;
    })();
    Ie = /* @__PURE__ */ (() => {
      const e3 = {
        and: "AND",
        or: "OR"
      };
      return e3;
    })();
    JsonProtoSerializer = class {
      constructor(e3, t2) {
        this.databaseId = e3, this.useProto3Json = t2;
      }
    };
    TargetData = class _TargetData {
      constructor(e3, t2, n2, r4, i3 = SnapshotVersion.min(), s3 = SnapshotVersion.min(), o2 = ByteString.EMPTY_BYTE_STRING, _ = null) {
        this.target = e3, this.targetId = t2, this.purpose = n2, this.sequenceNumber = r4, this.snapshotVersion = i3, this.lastLimboFreeSnapshotVersion = s3, this.resumeToken = o2, this.expectedCount = _;
      }
      /** Creates a new target data instance with an updated sequence number. */
      withSequenceNumber(e3) {
        return new _TargetData(this.target, this.targetId, this.purpose, e3, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken, this.expectedCount);
      }
      /**
       * Creates a new target data instance with an updated resume token and
       * snapshot version.
       */
      withResumeToken(e3, t2) {
        return new _TargetData(
          this.target,
          this.targetId,
          this.purpose,
          this.sequenceNumber,
          t2,
          this.lastLimboFreeSnapshotVersion,
          e3,
          /* expectedCount= */
          null
        );
      }
      /**
       * Creates a new target data instance with an updated expected count.
       */
      withExpectedCount(e3) {
        return new _TargetData(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken, e3);
      }
      /**
       * Creates a new target data instance with an updated last limbo free
       * snapshot version number.
       */
      withLastLimboFreeSnapshotVersion(e3) {
        return new _TargetData(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, e3, this.resumeToken, this.expectedCount);
      }
    };
    __PRIVATE_LocalSerializer = class {
      constructor(e3) {
        this.ct = e3;
      }
    };
    __PRIVATE_FirestoreIndexValueWriter = class {
      constructor() {
      }
      // The write methods below short-circuit writing terminators for values
      // containing a (terminating) truncated value.
      // As an example, consider the resulting encoding for:
      // ["bar", [2, "foo"]] -> (STRING, "bar", TERM, ARRAY, NUMBER, 2, STRING, "foo", TERM, TERM, TERM)
      // ["bar", [2, truncated("foo")]] -> (STRING, "bar", TERM, ARRAY, NUMBER, 2, STRING, "foo", TRUNC)
      // ["bar", truncated(["foo"])] -> (STRING, "bar", TERM, ARRAY. STRING, "foo", TERM, TRUNC)
      /** Writes an index value.  */
      Pt(e3, t2) {
        this.It(e3, t2), // Write separator to split index values
        // (see go/firestore-storage-format#encodings).
        t2.Tt();
      }
      It(e3, t2) {
        if ("nullValue" in e3)
          this.Et(t2, 5);
        else if ("booleanValue" in e3)
          this.Et(t2, 10), t2.dt(e3.booleanValue ? 1 : 0);
        else if ("integerValue" in e3)
          this.Et(t2, 15), t2.dt(__PRIVATE_normalizeNumber(e3.integerValue));
        else if ("doubleValue" in e3) {
          const n2 = __PRIVATE_normalizeNumber(e3.doubleValue);
          isNaN(n2) ? this.Et(t2, 13) : (this.Et(t2, 15), __PRIVATE_isNegativeZero(n2) ? (
            // -0.0, 0 and 0.0 are all considered the same
            t2.dt(0)
          ) : t2.dt(n2));
        } else if ("timestampValue" in e3) {
          const n2 = e3.timestampValue;
          this.Et(t2, 20), "string" == typeof n2 ? t2.At(n2) : (t2.At(`${n2.seconds || ""}`), t2.dt(n2.nanos || 0));
        } else if ("stringValue" in e3)
          this.Rt(e3.stringValue, t2), this.Vt(t2);
        else if ("bytesValue" in e3)
          this.Et(t2, 30), t2.ft(__PRIVATE_normalizeByteString(e3.bytesValue)), this.Vt(t2);
        else if ("referenceValue" in e3)
          this.gt(e3.referenceValue, t2);
        else if ("geoPointValue" in e3) {
          const n2 = e3.geoPointValue;
          this.Et(t2, 45), t2.dt(n2.latitude || 0), t2.dt(n2.longitude || 0);
        } else
          "mapValue" in e3 ? __PRIVATE_isMaxValue(e3) ? this.Et(t2, Number.MAX_SAFE_INTEGER) : (this.yt(e3.mapValue, t2), this.Vt(t2)) : "arrayValue" in e3 ? (this.wt(e3.arrayValue, t2), this.Vt(t2)) : fail();
      }
      Rt(e3, t2) {
        this.Et(t2, 25), this.St(e3, t2);
      }
      St(e3, t2) {
        t2.At(e3);
      }
      yt(e3, t2) {
        const n2 = e3.fields || {};
        this.Et(t2, 55);
        for (const e4 of Object.keys(n2))
          this.Rt(e4, t2), this.It(n2[e4], t2);
      }
      wt(e3, t2) {
        const n2 = e3.values || [];
        this.Et(t2, 50);
        for (const e4 of n2)
          this.It(e4, t2);
      }
      gt(e3, t2) {
        this.Et(t2, 37);
        DocumentKey.fromName(e3).path.forEach((e4) => {
          this.Et(t2, 60), this.St(e4, t2);
        });
      }
      Et(e3, t2) {
        e3.dt(t2);
      }
      Vt(e3) {
        e3.dt(2);
      }
    };
    __PRIVATE_FirestoreIndexValueWriter.bt = new __PRIVATE_FirestoreIndexValueWriter();
    __PRIVATE_MemoryIndexManager = class {
      constructor() {
        this._n = new __PRIVATE_MemoryCollectionParentIndex();
      }
      addToCollectionParentIndex(e3, t2) {
        return this._n.add(t2), PersistencePromise.resolve();
      }
      getCollectionParents(e3, t2) {
        return PersistencePromise.resolve(this._n.getEntries(t2));
      }
      addFieldIndex(e3, t2) {
        return PersistencePromise.resolve();
      }
      deleteFieldIndex(e3, t2) {
        return PersistencePromise.resolve();
      }
      deleteAllFieldIndexes(e3) {
        return PersistencePromise.resolve();
      }
      createTargetIndexes(e3, t2) {
        return PersistencePromise.resolve();
      }
      getDocumentsMatchingTarget(e3, t2) {
        return PersistencePromise.resolve(null);
      }
      getIndexType(e3, t2) {
        return PersistencePromise.resolve(
          0
          /* IndexType.NONE */
        );
      }
      getFieldIndexes(e3, t2) {
        return PersistencePromise.resolve([]);
      }
      getNextCollectionGroupToUpdate(e3) {
        return PersistencePromise.resolve(null);
      }
      getMinOffset(e3, t2) {
        return PersistencePromise.resolve(IndexOffset.min());
      }
      getMinOffsetFromCollectionGroup(e3, t2) {
        return PersistencePromise.resolve(IndexOffset.min());
      }
      updateCollectionGroup(e3, t2, n2) {
        return PersistencePromise.resolve();
      }
      updateIndexEntries(e3, t2) {
        return PersistencePromise.resolve();
      }
    };
    __PRIVATE_MemoryCollectionParentIndex = class {
      constructor() {
        this.index = {};
      }
      // Returns false if the entry already existed.
      add(e3) {
        const t2 = e3.lastSegment(), n2 = e3.popLast(), r4 = this.index[t2] || new SortedSet(ResourcePath.comparator), i3 = !r4.has(n2);
        return this.index[t2] = r4.add(n2), i3;
      }
      has(e3) {
        const t2 = e3.lastSegment(), n2 = e3.popLast(), r4 = this.index[t2];
        return r4 && r4.has(n2);
      }
      getEntries(e3) {
        return (this.index[e3] || new SortedSet(ResourcePath.comparator)).toArray();
      }
    };
    Te = new Uint8Array(0);
    LruParams = class _LruParams {
      constructor(e3, t2, n2) {
        this.cacheSizeCollectionThreshold = e3, this.percentileToCollect = t2, this.maximumSequenceNumbersToCollect = n2;
      }
      static withCacheSize(e3) {
        return new _LruParams(e3, _LruParams.DEFAULT_COLLECTION_PERCENTILE, _LruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);
      }
    };
    LruParams.DEFAULT_COLLECTION_PERCENTILE = 10, LruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1e3, LruParams.DEFAULT = new LruParams(41943040, LruParams.DEFAULT_COLLECTION_PERCENTILE, LruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT), LruParams.DISABLED = new LruParams(-1, 0, 0);
    __PRIVATE_TargetIdGenerator = class ___PRIVATE_TargetIdGenerator {
      constructor(e3) {
        this.On = e3;
      }
      next() {
        return this.On += 2, this.On;
      }
      static Nn() {
        return new ___PRIVATE_TargetIdGenerator(0);
      }
      static Bn() {
        return new ___PRIVATE_TargetIdGenerator(-1);
      }
    };
    RemoteDocumentChangeBuffer = class {
      constructor() {
        this.changes = new ObjectMap((e3) => e3.toString(), (e3, t2) => e3.isEqual(t2)), this.changesApplied = false;
      }
      /**
       * Buffers a `RemoteDocumentCache.addEntry()` call.
       *
       * You can only modify documents that have already been retrieved via
       * `getEntry()/getEntries()` (enforced via IndexedDbs `apply()`).
       */
      addEntry(e3) {
        this.assertNotApplied(), this.changes.set(e3.key, e3);
      }
      /**
       * Buffers a `RemoteDocumentCache.removeEntry()` call.
       *
       * You can only remove documents that have already been retrieved via
       * `getEntry()/getEntries()` (enforced via IndexedDbs `apply()`).
       */
      removeEntry(e3, t2) {
        this.assertNotApplied(), this.changes.set(e3, MutableDocument.newInvalidDocument(e3).setReadTime(t2));
      }
      /**
       * Looks up an entry in the cache. The buffered changes will first be checked,
       * and if no buffered change applies, this will forward to
       * `RemoteDocumentCache.getEntry()`.
       *
       * @param transaction - The transaction in which to perform any persistence
       *     operations.
       * @param documentKey - The key of the entry to look up.
       * @returns The cached document or an invalid document if we have nothing
       * cached.
       */
      getEntry(e3, t2) {
        this.assertNotApplied();
        const n2 = this.changes.get(t2);
        return void 0 !== n2 ? PersistencePromise.resolve(n2) : this.getFromCache(e3, t2);
      }
      /**
       * Looks up several entries in the cache, forwarding to
       * `RemoteDocumentCache.getEntry()`.
       *
       * @param transaction - The transaction in which to perform any persistence
       *     operations.
       * @param documentKeys - The keys of the entries to look up.
       * @returns A map of cached documents, indexed by key. If an entry cannot be
       *     found, the corresponding key will be mapped to an invalid document.
       */
      getEntries(e3, t2) {
        return this.getAllFromCache(e3, t2);
      }
      /**
       * Applies buffered changes to the underlying RemoteDocumentCache, using
       * the provided transaction.
       */
      apply(e3) {
        return this.assertNotApplied(), this.changesApplied = true, this.applyChanges(e3);
      }
      /** Helper to assert this.changes is not null  */
      assertNotApplied() {
      }
    };
    OverlayedDocument = class {
      constructor(e3, t2) {
        this.overlayedDocument = e3, this.mutatedFields = t2;
      }
    };
    LocalDocumentsView = class {
      constructor(e3, t2, n2, r4) {
        this.remoteDocumentCache = e3, this.mutationQueue = t2, this.documentOverlayCache = n2, this.indexManager = r4;
      }
      /**
       * Get the local view of the document identified by `key`.
       *
       * @returns Local view of the document or null if we don't have any cached
       * state for it.
       */
      getDocument(e3, t2) {
        let n2 = null;
        return this.documentOverlayCache.getOverlay(e3, t2).next((r4) => (n2 = r4, this.remoteDocumentCache.getEntry(e3, t2))).next((e4) => (null !== n2 && __PRIVATE_mutationApplyToLocalView(n2.mutation, e4, FieldMask.empty(), Timestamp.now()), e4));
      }
      /**
       * Gets the local view of the documents identified by `keys`.
       *
       * If we don't have cached state for a document in `keys`, a NoDocument will
       * be stored for that key in the resulting set.
       */
      getDocuments(e3, t2) {
        return this.remoteDocumentCache.getEntries(e3, t2).next((t3) => this.getLocalViewOfDocuments(e3, t3, __PRIVATE_documentKeySet()).next(() => t3));
      }
      /**
       * Similar to `getDocuments`, but creates the local view from the given
       * `baseDocs` without retrieving documents from the local store.
       *
       * @param transaction - The transaction this operation is scoped to.
       * @param docs - The documents to apply local mutations to get the local views.
       * @param existenceStateChanged - The set of document keys whose existence state
       *   is changed. This is useful to determine if some documents overlay needs
       *   to be recalculated.
       */
      getLocalViewOfDocuments(e3, t2, n2 = __PRIVATE_documentKeySet()) {
        const r4 = __PRIVATE_newOverlayMap();
        return this.populateOverlays(e3, r4, t2).next(() => this.computeViews(e3, t2, r4, n2).next((e4) => {
          let t3 = documentMap();
          return e4.forEach((e5, n3) => {
            t3 = t3.insert(e5, n3.overlayedDocument);
          }), t3;
        }));
      }
      /**
       * Gets the overlayed documents for the given document map, which will include
       * the local view of those documents and a `FieldMask` indicating which fields
       * are mutated locally, `null` if overlay is a Set or Delete mutation.
       */
      getOverlayedDocuments(e3, t2) {
        const n2 = __PRIVATE_newOverlayMap();
        return this.populateOverlays(e3, n2, t2).next(() => this.computeViews(e3, t2, n2, __PRIVATE_documentKeySet()));
      }
      /**
       * Fetches the overlays for {@code docs} and adds them to provided overlay map
       * if the map does not already contain an entry for the given document key.
       */
      populateOverlays(e3, t2, n2) {
        const r4 = [];
        return n2.forEach((e4) => {
          t2.has(e4) || r4.push(e4);
        }), this.documentOverlayCache.getOverlays(e3, r4).next((e4) => {
          e4.forEach((e5, n3) => {
            t2.set(e5, n3);
          });
        });
      }
      /**
       * Computes the local view for the given documents.
       *
       * @param docs - The documents to compute views for. It also has the base
       *   version of the documents.
       * @param overlays - The overlays that need to be applied to the given base
       *   version of the documents.
       * @param existenceStateChanged - A set of documents whose existence states
       *   might have changed. This is used to determine if we need to re-calculate
       *   overlays from mutation queues.
       * @return A map represents the local documents view.
       */
      computeViews(e3, t2, n2, r4) {
        let i3 = __PRIVATE_mutableDocumentMap();
        const s3 = __PRIVATE_newDocumentKeyMap(), o2 = function __PRIVATE_newOverlayedDocumentMap() {
          return __PRIVATE_newDocumentKeyMap();
        }();
        return t2.forEach((e4, t3) => {
          const o3 = n2.get(t3.key);
          r4.has(t3.key) && (void 0 === o3 || o3.mutation instanceof __PRIVATE_PatchMutation) ? i3 = i3.insert(t3.key, t3) : void 0 !== o3 ? (s3.set(t3.key, o3.mutation.getFieldMask()), __PRIVATE_mutationApplyToLocalView(o3.mutation, t3, o3.mutation.getFieldMask(), Timestamp.now())) : (
            // no overlay exists
            // Using EMPTY to indicate there is no overlay for the document.
            s3.set(t3.key, FieldMask.empty())
          );
        }), this.recalculateAndSaveOverlays(e3, i3).next((e4) => (e4.forEach((e5, t3) => s3.set(e5, t3)), t2.forEach((e5, t3) => {
          var n3;
          return o2.set(e5, new OverlayedDocument(t3, null !== (n3 = s3.get(e5)) && void 0 !== n3 ? n3 : null));
        }), o2));
      }
      recalculateAndSaveOverlays(e3, t2) {
        const n2 = __PRIVATE_newDocumentKeyMap();
        let r4 = new SortedMap((e4, t3) => e4 - t3), i3 = __PRIVATE_documentKeySet();
        return this.mutationQueue.getAllMutationBatchesAffectingDocumentKeys(e3, t2).next((e4) => {
          for (const i4 of e4)
            i4.keys().forEach((e5) => {
              const s3 = t2.get(e5);
              if (null === s3)
                return;
              let o2 = n2.get(e5) || FieldMask.empty();
              o2 = i4.applyToLocalView(s3, o2), n2.set(e5, o2);
              const _ = (r4.get(i4.batchId) || __PRIVATE_documentKeySet()).add(e5);
              r4 = r4.insert(i4.batchId, _);
            });
        }).next(() => {
          const s3 = [], o2 = r4.getReverseIterator();
          for (; o2.hasNext(); ) {
            const r5 = o2.getNext(), _ = r5.key, a2 = r5.value, u2 = __PRIVATE_newMutationMap();
            a2.forEach((e4) => {
              if (!i3.has(e4)) {
                const r6 = __PRIVATE_calculateOverlayMutation(t2.get(e4), n2.get(e4));
                null !== r6 && u2.set(e4, r6), i3 = i3.add(e4);
              }
            }), s3.push(this.documentOverlayCache.saveOverlays(e3, _, u2));
          }
          return PersistencePromise.waitFor(s3);
        }).next(() => n2);
      }
      /**
       * Recalculates overlays by reading the documents from remote document cache
       * first, and saves them after they are calculated.
       */
      recalculateAndSaveOverlaysForDocumentKeys(e3, t2) {
        return this.remoteDocumentCache.getEntries(e3, t2).next((t3) => this.recalculateAndSaveOverlays(e3, t3));
      }
      /**
       * Performs a query against the local view of all documents.
       *
       * @param transaction - The persistence transaction.
       * @param query - The query to match documents against.
       * @param offset - Read time and key to start scanning by (exclusive).
       * @param context - A optional tracker to keep a record of important details
       *   during database local query execution.
       */
      getDocumentsMatchingQuery(e3, t2, n2, r4) {
        return function __PRIVATE_isDocumentQuery$1(e4) {
          return DocumentKey.isDocumentKey(e4.path) && null === e4.collectionGroup && 0 === e4.filters.length;
        }(t2) ? this.getDocumentsMatchingDocumentQuery(e3, t2.path) : __PRIVATE_isCollectionGroupQuery(t2) ? this.getDocumentsMatchingCollectionGroupQuery(e3, t2, n2, r4) : this.getDocumentsMatchingCollectionQuery(e3, t2, n2, r4);
      }
      /**
       * Given a collection group, returns the next documents that follow the provided offset, along
       * with an updated batch ID.
       *
       * <p>The documents returned by this method are ordered by remote version from the provided
       * offset. If there are no more remote documents after the provided offset, documents with
       * mutations in order of batch id from the offset are returned. Since all documents in a batch are
       * returned together, the total number of documents returned can exceed {@code count}.
       *
       * @param transaction
       * @param collectionGroup The collection group for the documents.
       * @param offset The offset to index into.
       * @param count The number of documents to return
       * @return A LocalWriteResult with the documents that follow the provided offset and the last processed batch id.
       */
      getNextDocuments(e3, t2, n2, r4) {
        return this.remoteDocumentCache.getAllFromCollectionGroup(e3, t2, n2, r4).next((i3) => {
          const s3 = r4 - i3.size > 0 ? this.documentOverlayCache.getOverlaysForCollectionGroup(e3, t2, n2.largestBatchId, r4 - i3.size) : PersistencePromise.resolve(__PRIVATE_newOverlayMap());
          let o2 = -1, _ = i3;
          return s3.next((t3) => PersistencePromise.forEach(t3, (t4, n3) => (o2 < n3.largestBatchId && (o2 = n3.largestBatchId), i3.get(t4) ? PersistencePromise.resolve() : this.remoteDocumentCache.getEntry(e3, t4).next((e4) => {
            _ = _.insert(t4, e4);
          }))).next(() => this.populateOverlays(e3, t3, i3)).next(() => this.computeViews(e3, _, t3, __PRIVATE_documentKeySet())).next((e4) => ({
            batchId: o2,
            changes: __PRIVATE_convertOverlayedDocumentMapToDocumentMap(e4)
          })));
        });
      }
      getDocumentsMatchingDocumentQuery(e3, t2) {
        return this.getDocument(e3, new DocumentKey(t2)).next((e4) => {
          let t3 = documentMap();
          return e4.isFoundDocument() && (t3 = t3.insert(e4.key, e4)), t3;
        });
      }
      getDocumentsMatchingCollectionGroupQuery(e3, t2, n2, r4) {
        const i3 = t2.collectionGroup;
        let s3 = documentMap();
        return this.indexManager.getCollectionParents(e3, i3).next((o2) => PersistencePromise.forEach(o2, (o3) => {
          const _ = function __PRIVATE_asCollectionQueryAtPath(e4, t3) {
            return new __PRIVATE_QueryImpl(
              t3,
              /*collectionGroup=*/
              null,
              e4.explicitOrderBy.slice(),
              e4.filters.slice(),
              e4.limit,
              e4.limitType,
              e4.startAt,
              e4.endAt
            );
          }(t2, o3.child(i3));
          return this.getDocumentsMatchingCollectionQuery(e3, _, n2, r4).next((e4) => {
            e4.forEach((e5, t3) => {
              s3 = s3.insert(e5, t3);
            });
          });
        }).next(() => s3));
      }
      getDocumentsMatchingCollectionQuery(e3, t2, n2, r4) {
        let i3;
        return this.documentOverlayCache.getOverlaysForCollection(e3, t2.path, n2.largestBatchId).next((s3) => (i3 = s3, this.remoteDocumentCache.getDocumentsMatchingQuery(e3, t2, n2, i3, r4))).next((e4) => {
          i3.forEach((t3, n4) => {
            const r5 = n4.getKey();
            null === e4.get(r5) && (e4 = e4.insert(r5, MutableDocument.newInvalidDocument(r5)));
          });
          let n3 = documentMap();
          return e4.forEach((e5, r5) => {
            const s3 = i3.get(e5);
            void 0 !== s3 && __PRIVATE_mutationApplyToLocalView(s3.mutation, r5, FieldMask.empty(), Timestamp.now()), // Finally, insert the documents that still match the query
            __PRIVATE_queryMatches(t2, r5) && (n3 = n3.insert(e5, r5));
          }), n3;
        });
      }
    };
    __PRIVATE_MemoryBundleCache = class {
      constructor(e3) {
        this.serializer = e3, this.cr = /* @__PURE__ */ new Map(), this.lr = /* @__PURE__ */ new Map();
      }
      getBundleMetadata(e3, t2) {
        return PersistencePromise.resolve(this.cr.get(t2));
      }
      saveBundleMetadata(e3, t2) {
        return this.cr.set(
          t2.id,
          /** Decodes a BundleMetadata proto into a BundleMetadata object. */
          function __PRIVATE_fromBundleMetadata(e4) {
            return {
              id: e4.id,
              version: e4.version,
              createTime: __PRIVATE_fromVersion(e4.createTime)
            };
          }(t2)
        ), PersistencePromise.resolve();
      }
      getNamedQuery(e3, t2) {
        return PersistencePromise.resolve(this.lr.get(t2));
      }
      saveNamedQuery(e3, t2) {
        return this.lr.set(t2.name, function __PRIVATE_fromProtoNamedQuery(e4) {
          return {
            name: e4.name,
            query: __PRIVATE_fromBundledQuery(e4.bundledQuery),
            readTime: __PRIVATE_fromVersion(e4.readTime)
          };
        }(t2)), PersistencePromise.resolve();
      }
    };
    __PRIVATE_MemoryDocumentOverlayCache = class {
      constructor() {
        this.overlays = new SortedMap(DocumentKey.comparator), this.hr = /* @__PURE__ */ new Map();
      }
      getOverlay(e3, t2) {
        return PersistencePromise.resolve(this.overlays.get(t2));
      }
      getOverlays(e3, t2) {
        const n2 = __PRIVATE_newOverlayMap();
        return PersistencePromise.forEach(t2, (t3) => this.getOverlay(e3, t3).next((e4) => {
          null !== e4 && n2.set(t3, e4);
        })).next(() => n2);
      }
      saveOverlays(e3, t2, n2) {
        return n2.forEach((n3, r4) => {
          this.ht(e3, t2, r4);
        }), PersistencePromise.resolve();
      }
      removeOverlaysForBatchId(e3, t2, n2) {
        const r4 = this.hr.get(n2);
        return void 0 !== r4 && (r4.forEach((e4) => this.overlays = this.overlays.remove(e4)), this.hr.delete(n2)), PersistencePromise.resolve();
      }
      getOverlaysForCollection(e3, t2, n2) {
        const r4 = __PRIVATE_newOverlayMap(), i3 = t2.length + 1, s3 = new DocumentKey(t2.child("")), o2 = this.overlays.getIteratorFrom(s3);
        for (; o2.hasNext(); ) {
          const e4 = o2.getNext().value, s4 = e4.getKey();
          if (!t2.isPrefixOf(s4.path))
            break;
          s4.path.length === i3 && (e4.largestBatchId > n2 && r4.set(e4.getKey(), e4));
        }
        return PersistencePromise.resolve(r4);
      }
      getOverlaysForCollectionGroup(e3, t2, n2, r4) {
        let i3 = new SortedMap((e4, t3) => e4 - t3);
        const s3 = this.overlays.getIterator();
        for (; s3.hasNext(); ) {
          const e4 = s3.getNext().value;
          if (e4.getKey().getCollectionGroup() === t2 && e4.largestBatchId > n2) {
            let t3 = i3.get(e4.largestBatchId);
            null === t3 && (t3 = __PRIVATE_newOverlayMap(), i3 = i3.insert(e4.largestBatchId, t3)), t3.set(e4.getKey(), e4);
          }
        }
        const o2 = __PRIVATE_newOverlayMap(), _ = i3.getIterator();
        for (; _.hasNext(); ) {
          if (_.getNext().value.forEach((e4, t3) => o2.set(e4, t3)), o2.size() >= r4)
            break;
        }
        return PersistencePromise.resolve(o2);
      }
      ht(e3, t2, n2) {
        const r4 = this.overlays.get(n2.key);
        if (null !== r4) {
          const e4 = this.hr.get(r4.largestBatchId).delete(n2.key);
          this.hr.set(r4.largestBatchId, e4);
        }
        this.overlays = this.overlays.insert(n2.key, new Overlay(t2, n2));
        let i3 = this.hr.get(t2);
        void 0 === i3 && (i3 = __PRIVATE_documentKeySet(), this.hr.set(t2, i3)), this.hr.set(t2, i3.add(n2.key));
      }
    };
    __PRIVATE_ReferenceSet = class {
      constructor() {
        this.Pr = new SortedSet(__PRIVATE_DocReference.Ir), // A set of outstanding references to a document sorted by target id.
        this.Tr = new SortedSet(__PRIVATE_DocReference.Er);
      }
      /** Returns true if the reference set contains no references. */
      isEmpty() {
        return this.Pr.isEmpty();
      }
      /** Adds a reference to the given document key for the given ID. */
      addReference(e3, t2) {
        const n2 = new __PRIVATE_DocReference(e3, t2);
        this.Pr = this.Pr.add(n2), this.Tr = this.Tr.add(n2);
      }
      /** Add references to the given document keys for the given ID. */
      dr(e3, t2) {
        e3.forEach((e4) => this.addReference(e4, t2));
      }
      /**
       * Removes a reference to the given document key for the given
       * ID.
       */
      removeReference(e3, t2) {
        this.Ar(new __PRIVATE_DocReference(e3, t2));
      }
      Rr(e3, t2) {
        e3.forEach((e4) => this.removeReference(e4, t2));
      }
      /**
       * Clears all references with a given ID. Calls removeRef() for each key
       * removed.
       */
      Vr(e3) {
        const t2 = new DocumentKey(new ResourcePath([])), n2 = new __PRIVATE_DocReference(t2, e3), r4 = new __PRIVATE_DocReference(t2, e3 + 1), i3 = [];
        return this.Tr.forEachInRange([n2, r4], (e4) => {
          this.Ar(e4), i3.push(e4.key);
        }), i3;
      }
      mr() {
        this.Pr.forEach((e3) => this.Ar(e3));
      }
      Ar(e3) {
        this.Pr = this.Pr.delete(e3), this.Tr = this.Tr.delete(e3);
      }
      gr(e3) {
        const t2 = new DocumentKey(new ResourcePath([])), n2 = new __PRIVATE_DocReference(t2, e3), r4 = new __PRIVATE_DocReference(t2, e3 + 1);
        let i3 = __PRIVATE_documentKeySet();
        return this.Tr.forEachInRange([n2, r4], (e4) => {
          i3 = i3.add(e4.key);
        }), i3;
      }
      containsKey(e3) {
        const t2 = new __PRIVATE_DocReference(e3, 0), n2 = this.Pr.firstAfterOrEqual(t2);
        return null !== n2 && e3.isEqual(n2.key);
      }
    };
    __PRIVATE_DocReference = class {
      constructor(e3, t2) {
        this.key = e3, this.pr = t2;
      }
      /** Compare by key then by ID */
      static Ir(e3, t2) {
        return DocumentKey.comparator(e3.key, t2.key) || __PRIVATE_primitiveComparator(e3.pr, t2.pr);
      }
      /** Compare by ID then by key */
      static Er(e3, t2) {
        return __PRIVATE_primitiveComparator(e3.pr, t2.pr) || DocumentKey.comparator(e3.key, t2.key);
      }
    };
    __PRIVATE_MemoryMutationQueue = class {
      constructor(e3, t2) {
        this.indexManager = e3, this.referenceDelegate = t2, /**
        * The set of all mutations that have been sent but not yet been applied to
        * the backend.
        */
        this.mutationQueue = [], /** Next value to use when assigning sequential IDs to each mutation batch. */
        this.yr = 1, /** An ordered mapping between documents and the mutations batch IDs. */
        this.wr = new SortedSet(__PRIVATE_DocReference.Ir);
      }
      checkEmpty(e3) {
        return PersistencePromise.resolve(0 === this.mutationQueue.length);
      }
      addMutationBatch(e3, t2, n2, r4) {
        const i3 = this.yr;
        this.yr++, this.mutationQueue.length > 0 && this.mutationQueue[this.mutationQueue.length - 1];
        const s3 = new MutationBatch(i3, t2, n2, r4);
        this.mutationQueue.push(s3);
        for (const t3 of r4)
          this.wr = this.wr.add(new __PRIVATE_DocReference(t3.key, i3)), this.indexManager.addToCollectionParentIndex(e3, t3.key.path.popLast());
        return PersistencePromise.resolve(s3);
      }
      lookupMutationBatch(e3, t2) {
        return PersistencePromise.resolve(this.Sr(t2));
      }
      getNextMutationBatchAfterBatchId(e3, t2) {
        const n2 = t2 + 1, r4 = this.br(n2), i3 = r4 < 0 ? 0 : r4;
        return PersistencePromise.resolve(this.mutationQueue.length > i3 ? this.mutationQueue[i3] : null);
      }
      getHighestUnacknowledgedBatchId() {
        return PersistencePromise.resolve(0 === this.mutationQueue.length ? -1 : this.yr - 1);
      }
      getAllMutationBatches(e3) {
        return PersistencePromise.resolve(this.mutationQueue.slice());
      }
      getAllMutationBatchesAffectingDocumentKey(e3, t2) {
        const n2 = new __PRIVATE_DocReference(t2, 0), r4 = new __PRIVATE_DocReference(t2, Number.POSITIVE_INFINITY), i3 = [];
        return this.wr.forEachInRange([n2, r4], (e4) => {
          const t3 = this.Sr(e4.pr);
          i3.push(t3);
        }), PersistencePromise.resolve(i3);
      }
      getAllMutationBatchesAffectingDocumentKeys(e3, t2) {
        let n2 = new SortedSet(__PRIVATE_primitiveComparator);
        return t2.forEach((e4) => {
          const t3 = new __PRIVATE_DocReference(e4, 0), r4 = new __PRIVATE_DocReference(e4, Number.POSITIVE_INFINITY);
          this.wr.forEachInRange([t3, r4], (e5) => {
            n2 = n2.add(e5.pr);
          });
        }), PersistencePromise.resolve(this.Dr(n2));
      }
      getAllMutationBatchesAffectingQuery(e3, t2) {
        const n2 = t2.path, r4 = n2.length + 1;
        let i3 = n2;
        DocumentKey.isDocumentKey(i3) || (i3 = i3.child(""));
        const s3 = new __PRIVATE_DocReference(new DocumentKey(i3), 0);
        let o2 = new SortedSet(__PRIVATE_primitiveComparator);
        return this.wr.forEachWhile((e4) => {
          const t3 = e4.key.path;
          return !!n2.isPrefixOf(t3) && // Rows with document keys more than one segment longer than the query
          // path can't be matches. For example, a query on 'rooms' can't match
          // the document /rooms/abc/messages/xyx.
          // TODO(mcg): we'll need a different scanner when we implement
          // ancestor queries.
          (t3.length === r4 && (o2 = o2.add(e4.pr)), true);
        }, s3), PersistencePromise.resolve(this.Dr(o2));
      }
      Dr(e3) {
        const t2 = [];
        return e3.forEach((e4) => {
          const n2 = this.Sr(e4);
          null !== n2 && t2.push(n2);
        }), t2;
      }
      removeMutationBatch(e3, t2) {
        __PRIVATE_hardAssert(0 === this.Cr(t2.batchId, "removed")), this.mutationQueue.shift();
        let n2 = this.wr;
        return PersistencePromise.forEach(t2.mutations, (r4) => {
          const i3 = new __PRIVATE_DocReference(r4.key, t2.batchId);
          return n2 = n2.delete(i3), this.referenceDelegate.markPotentiallyOrphaned(e3, r4.key);
        }).next(() => {
          this.wr = n2;
        });
      }
      Mn(e3) {
      }
      containsKey(e3, t2) {
        const n2 = new __PRIVATE_DocReference(t2, 0), r4 = this.wr.firstAfterOrEqual(n2);
        return PersistencePromise.resolve(t2.isEqual(r4 && r4.key));
      }
      performConsistencyCheck(e3) {
        return this.mutationQueue.length, PersistencePromise.resolve();
      }
      /**
       * Finds the index of the given batchId in the mutation queue and asserts that
       * the resulting index is within the bounds of the queue.
       *
       * @param batchId - The batchId to search for
       * @param action - A description of what the caller is doing, phrased in passive
       * form (e.g. "acknowledged" in a routine that acknowledges batches).
       */
      Cr(e3, t2) {
        return this.br(e3);
      }
      /**
       * Finds the index of the given batchId in the mutation queue. This operation
       * is O(1).
       *
       * @returns The computed index of the batch with the given batchId, based on
       * the state of the queue. Note this index can be negative if the requested
       * batchId has already been remvoed from the queue or past the end of the
       * queue if the batchId is larger than the last added batch.
       */
      br(e3) {
        if (0 === this.mutationQueue.length)
          return 0;
        return e3 - this.mutationQueue[0].batchId;
      }
      /**
       * A version of lookupMutationBatch that doesn't return a promise, this makes
       * other functions that uses this code easier to read and more efficent.
       */
      Sr(e3) {
        const t2 = this.br(e3);
        if (t2 < 0 || t2 >= this.mutationQueue.length)
          return null;
        return this.mutationQueue[t2];
      }
    };
    __PRIVATE_MemoryRemoteDocumentCacheImpl = class {
      /**
       * @param sizer - Used to assess the size of a document. For eager GC, this is
       * expected to just return 0 to avoid unnecessarily doing the work of
       * calculating the size.
       */
      constructor(e3) {
        this.vr = e3, /** Underlying cache of documents and their read times. */
        this.docs = function __PRIVATE_documentEntryMap() {
          return new SortedMap(DocumentKey.comparator);
        }(), /** Size of all cached documents. */
        this.size = 0;
      }
      setIndexManager(e3) {
        this.indexManager = e3;
      }
      /**
       * Adds the supplied entry to the cache and updates the cache size as appropriate.
       *
       * All calls of `addEntry`  are required to go through the RemoteDocumentChangeBuffer
       * returned by `newChangeBuffer()`.
       */
      addEntry(e3, t2) {
        const n2 = t2.key, r4 = this.docs.get(n2), i3 = r4 ? r4.size : 0, s3 = this.vr(t2);
        return this.docs = this.docs.insert(n2, {
          document: t2.mutableCopy(),
          size: s3
        }), this.size += s3 - i3, this.indexManager.addToCollectionParentIndex(e3, n2.path.popLast());
      }
      /**
       * Removes the specified entry from the cache and updates the cache size as appropriate.
       *
       * All calls of `removeEntry` are required to go through the RemoteDocumentChangeBuffer
       * returned by `newChangeBuffer()`.
       */
      removeEntry(e3) {
        const t2 = this.docs.get(e3);
        t2 && (this.docs = this.docs.remove(e3), this.size -= t2.size);
      }
      getEntry(e3, t2) {
        const n2 = this.docs.get(t2);
        return PersistencePromise.resolve(n2 ? n2.document.mutableCopy() : MutableDocument.newInvalidDocument(t2));
      }
      getEntries(e3, t2) {
        let n2 = __PRIVATE_mutableDocumentMap();
        return t2.forEach((e4) => {
          const t3 = this.docs.get(e4);
          n2 = n2.insert(e4, t3 ? t3.document.mutableCopy() : MutableDocument.newInvalidDocument(e4));
        }), PersistencePromise.resolve(n2);
      }
      getDocumentsMatchingQuery(e3, t2, n2, r4) {
        let i3 = __PRIVATE_mutableDocumentMap();
        const s3 = t2.path, o2 = new DocumentKey(s3.child("")), _ = this.docs.getIteratorFrom(o2);
        for (; _.hasNext(); ) {
          const { key: e4, value: { document: o3 } } = _.getNext();
          if (!s3.isPrefixOf(e4.path))
            break;
          e4.path.length > s3.length + 1 || (__PRIVATE_indexOffsetComparator(__PRIVATE_newIndexOffsetFromDocument(o3), n2) <= 0 || (r4.has(o3.key) || __PRIVATE_queryMatches(t2, o3)) && (i3 = i3.insert(o3.key, o3.mutableCopy())));
        }
        return PersistencePromise.resolve(i3);
      }
      getAllFromCollectionGroup(e3, t2, n2, r4) {
        fail();
      }
      Fr(e3, t2) {
        return PersistencePromise.forEach(this.docs, (e4) => t2(e4));
      }
      newChangeBuffer(e3) {
        return new __PRIVATE_MemoryRemoteDocumentChangeBuffer(this);
      }
      getSize(e3) {
        return PersistencePromise.resolve(this.size);
      }
    };
    __PRIVATE_MemoryRemoteDocumentChangeBuffer = class extends RemoteDocumentChangeBuffer {
      constructor(e3) {
        super(), this.ar = e3;
      }
      applyChanges(e3) {
        const t2 = [];
        return this.changes.forEach((n2, r4) => {
          r4.isValidDocument() ? t2.push(this.ar.addEntry(e3, r4)) : this.ar.removeEntry(n2);
        }), PersistencePromise.waitFor(t2);
      }
      getFromCache(e3, t2) {
        return this.ar.getEntry(e3, t2);
      }
      getAllFromCache(e3, t2) {
        return this.ar.getEntries(e3, t2);
      }
    };
    __PRIVATE_MemoryTargetCache = class {
      constructor(e3) {
        this.persistence = e3, /**
        * Maps a target to the data about that target
        */
        this.Mr = new ObjectMap((e4) => __PRIVATE_canonifyTarget(e4), __PRIVATE_targetEquals), /** The last received snapshot version. */
        this.lastRemoteSnapshotVersion = SnapshotVersion.min(), /** The highest numbered target ID encountered. */
        this.highestTargetId = 0, /** The highest sequence number encountered. */
        this.Or = 0, /**
        * A ordered bidirectional mapping between documents and the remote target
        * IDs.
        */
        this.Nr = new __PRIVATE_ReferenceSet(), this.targetCount = 0, this.Br = __PRIVATE_TargetIdGenerator.Nn();
      }
      forEachTarget(e3, t2) {
        return this.Mr.forEach((e4, n2) => t2(n2)), PersistencePromise.resolve();
      }
      getLastRemoteSnapshotVersion(e3) {
        return PersistencePromise.resolve(this.lastRemoteSnapshotVersion);
      }
      getHighestSequenceNumber(e3) {
        return PersistencePromise.resolve(this.Or);
      }
      allocateTargetId(e3) {
        return this.highestTargetId = this.Br.next(), PersistencePromise.resolve(this.highestTargetId);
      }
      setTargetsMetadata(e3, t2, n2) {
        return n2 && (this.lastRemoteSnapshotVersion = n2), t2 > this.Or && (this.Or = t2), PersistencePromise.resolve();
      }
      qn(e3) {
        this.Mr.set(e3.target, e3);
        const t2 = e3.targetId;
        t2 > this.highestTargetId && (this.Br = new __PRIVATE_TargetIdGenerator(t2), this.highestTargetId = t2), e3.sequenceNumber > this.Or && (this.Or = e3.sequenceNumber);
      }
      addTargetData(e3, t2) {
        return this.qn(t2), this.targetCount += 1, PersistencePromise.resolve();
      }
      updateTargetData(e3, t2) {
        return this.qn(t2), PersistencePromise.resolve();
      }
      removeTargetData(e3, t2) {
        return this.Mr.delete(t2.target), this.Nr.Vr(t2.targetId), this.targetCount -= 1, PersistencePromise.resolve();
      }
      removeTargets(e3, t2, n2) {
        let r4 = 0;
        const i3 = [];
        return this.Mr.forEach((s3, o2) => {
          o2.sequenceNumber <= t2 && null === n2.get(o2.targetId) && (this.Mr.delete(s3), i3.push(this.removeMatchingKeysForTargetId(e3, o2.targetId)), r4++);
        }), PersistencePromise.waitFor(i3).next(() => r4);
      }
      getTargetCount(e3) {
        return PersistencePromise.resolve(this.targetCount);
      }
      getTargetData(e3, t2) {
        const n2 = this.Mr.get(t2) || null;
        return PersistencePromise.resolve(n2);
      }
      addMatchingKeys(e3, t2, n2) {
        return this.Nr.dr(t2, n2), PersistencePromise.resolve();
      }
      removeMatchingKeys(e3, t2, n2) {
        this.Nr.Rr(t2, n2);
        const r4 = this.persistence.referenceDelegate, i3 = [];
        return r4 && t2.forEach((t3) => {
          i3.push(r4.markPotentiallyOrphaned(e3, t3));
        }), PersistencePromise.waitFor(i3);
      }
      removeMatchingKeysForTargetId(e3, t2) {
        return this.Nr.Vr(t2), PersistencePromise.resolve();
      }
      getMatchingKeysForTargetId(e3, t2) {
        const n2 = this.Nr.gr(t2);
        return PersistencePromise.resolve(n2);
      }
      containsKey(e3, t2) {
        return PersistencePromise.resolve(this.Nr.containsKey(t2));
      }
    };
    __PRIVATE_MemoryPersistence = class {
      /**
       * The constructor accepts a factory for creating a reference delegate. This
       * allows both the delegate and this instance to have strong references to
       * each other without having nullable fields that would then need to be
       * checked or asserted on every access.
       */
      constructor(e3, t2) {
        this.Lr = {}, this.overlays = {}, this.kr = new __PRIVATE_ListenSequence(0), this.qr = false, this.qr = true, this.referenceDelegate = e3(this), this.Qr = new __PRIVATE_MemoryTargetCache(this);
        this.indexManager = new __PRIVATE_MemoryIndexManager(), this.remoteDocumentCache = function __PRIVATE_newMemoryRemoteDocumentCache(e4) {
          return new __PRIVATE_MemoryRemoteDocumentCacheImpl(e4);
        }((e4) => this.referenceDelegate.Kr(e4)), this.serializer = new __PRIVATE_LocalSerializer(t2), this.$r = new __PRIVATE_MemoryBundleCache(this.serializer);
      }
      start() {
        return Promise.resolve();
      }
      shutdown() {
        return this.qr = false, Promise.resolve();
      }
      get started() {
        return this.qr;
      }
      setDatabaseDeletedListener() {
      }
      setNetworkEnabled() {
      }
      getIndexManager(e3) {
        return this.indexManager;
      }
      getDocumentOverlayCache(e3) {
        let t2 = this.overlays[e3.toKey()];
        return t2 || (t2 = new __PRIVATE_MemoryDocumentOverlayCache(), this.overlays[e3.toKey()] = t2), t2;
      }
      getMutationQueue(e3, t2) {
        let n2 = this.Lr[e3.toKey()];
        return n2 || (n2 = new __PRIVATE_MemoryMutationQueue(t2, this.referenceDelegate), this.Lr[e3.toKey()] = n2), n2;
      }
      getTargetCache() {
        return this.Qr;
      }
      getRemoteDocumentCache() {
        return this.remoteDocumentCache;
      }
      getBundleCache() {
        return this.$r;
      }
      runTransaction(e3, t2, n2) {
        __PRIVATE_logDebug("MemoryPersistence", "Starting transaction:", e3);
        const r4 = new __PRIVATE_MemoryTransaction(this.kr.next());
        return this.referenceDelegate.Ur(), n2(r4).next((e4) => this.referenceDelegate.Wr(r4).next(() => e4)).toPromise().then((e4) => (r4.raiseOnCommittedEvent(), e4));
      }
      Gr(e3, t2) {
        return PersistencePromise.or(Object.values(this.Lr).map((n2) => () => n2.containsKey(e3, t2)));
      }
    };
    __PRIVATE_MemoryTransaction = class extends PersistenceTransaction {
      constructor(e3) {
        super(), this.currentSequenceNumber = e3;
      }
    };
    __PRIVATE_MemoryEagerDelegate = class ___PRIVATE_MemoryEagerDelegate {
      constructor(e3) {
        this.persistence = e3, /** Tracks all documents that are active in Query views. */
        this.zr = new __PRIVATE_ReferenceSet(), /** The list of documents that are potentially GCed after each transaction. */
        this.jr = null;
      }
      static Hr(e3) {
        return new ___PRIVATE_MemoryEagerDelegate(e3);
      }
      get Jr() {
        if (this.jr)
          return this.jr;
        throw fail();
      }
      addReference(e3, t2, n2) {
        return this.zr.addReference(n2, t2), this.Jr.delete(n2.toString()), PersistencePromise.resolve();
      }
      removeReference(e3, t2, n2) {
        return this.zr.removeReference(n2, t2), this.Jr.add(n2.toString()), PersistencePromise.resolve();
      }
      markPotentiallyOrphaned(e3, t2) {
        return this.Jr.add(t2.toString()), PersistencePromise.resolve();
      }
      removeTarget(e3, t2) {
        this.zr.Vr(t2.targetId).forEach((e4) => this.Jr.add(e4.toString()));
        const n2 = this.persistence.getTargetCache();
        return n2.getMatchingKeysForTargetId(e3, t2.targetId).next((e4) => {
          e4.forEach((e5) => this.Jr.add(e5.toString()));
        }).next(() => n2.removeTargetData(e3, t2));
      }
      Ur() {
        this.jr = /* @__PURE__ */ new Set();
      }
      Wr(e3) {
        const t2 = this.persistence.getRemoteDocumentCache().newChangeBuffer();
        return PersistencePromise.forEach(this.Jr, (n2) => {
          const r4 = DocumentKey.fromPath(n2);
          return this.Yr(e3, r4).next((e4) => {
            e4 || t2.removeEntry(r4, SnapshotVersion.min());
          });
        }).next(() => (this.jr = null, t2.apply(e3)));
      }
      updateLimboDocument(e3, t2) {
        return this.Yr(e3, t2).next((e4) => {
          e4 ? this.Jr.delete(t2.toString()) : this.Jr.add(t2.toString());
        });
      }
      Kr(e3) {
        return 0;
      }
      Yr(e3, t2) {
        return PersistencePromise.or([() => PersistencePromise.resolve(this.zr.containsKey(t2)), () => this.persistence.getTargetCache().containsKey(e3, t2), () => this.persistence.Gr(e3, t2)]);
      }
    };
    __PRIVATE_LocalViewChanges = class ___PRIVATE_LocalViewChanges {
      constructor(e3, t2, n2, r4) {
        this.targetId = e3, this.fromCache = t2, this.qi = n2, this.Qi = r4;
      }
      static Ki(e3, t2) {
        let n2 = __PRIVATE_documentKeySet(), r4 = __PRIVATE_documentKeySet();
        for (const e4 of t2.docChanges)
          switch (e4.type) {
            case 0:
              n2 = n2.add(e4.doc.key);
              break;
            case 1:
              r4 = r4.add(e4.doc.key);
          }
        return new ___PRIVATE_LocalViewChanges(e3, t2.fromCache, n2, r4);
      }
    };
    QueryContext = class {
      constructor() {
        this._documentReadCount = 0;
      }
      get documentReadCount() {
        return this._documentReadCount;
      }
      incrementDocumentReadCount(e3) {
        this._documentReadCount += e3;
      }
    };
    __PRIVATE_QueryEngine = class {
      constructor() {
        this.$i = false, this.Ui = false, /**
        * SDK only decides whether it should create index when collection size is
        * larger than this.
        */
        this.Wi = 100, this.Gi = /**
        * This cost represents the evaluation result of
        * (([index, docKey] + [docKey, docContent]) per document in the result set)
        * / ([docKey, docContent] per documents in full collection scan) coming from
        * experiment [enter PR experiment URL here].
        */
        function __PRIVATE_getDefaultRelativeIndexReadCostPerDocument() {
          return isSafari() ? 8 : __PRIVATE_SimpleDb.v(getUA()) > 0 ? 6 : 4;
        }();
      }
      /** Sets the document view to query against. */
      initialize(e3, t2) {
        this.zi = e3, this.indexManager = t2, this.$i = true;
      }
      /** Returns all local documents matching the specified query. */
      getDocumentsMatchingQuery(e3, t2, n2, r4) {
        const i3 = {
          result: null
        };
        return this.ji(e3, t2).next((e4) => {
          i3.result = e4;
        }).next(() => {
          if (!i3.result)
            return this.Hi(e3, t2, r4, n2).next((e4) => {
              i3.result = e4;
            });
        }).next(() => {
          if (i3.result)
            return;
          const n3 = new QueryContext();
          return this.Ji(e3, t2, n3).next((r5) => {
            if (i3.result = r5, this.Ui)
              return this.Yi(e3, t2, n3, r5.size);
          });
        }).next(() => i3.result);
      }
      Yi(e3, t2, n2, r4) {
        return n2.documentReadCount < this.Wi ? (__PRIVATE_getLogLevel() <= LogLevel.DEBUG && __PRIVATE_logDebug("QueryEngine", "SDK will not create cache indexes for query:", __PRIVATE_stringifyQuery(t2), "since it only creates cache indexes for collection contains", "more than or equal to", this.Wi, "documents"), PersistencePromise.resolve()) : (__PRIVATE_getLogLevel() <= LogLevel.DEBUG && __PRIVATE_logDebug("QueryEngine", "Query:", __PRIVATE_stringifyQuery(t2), "scans", n2.documentReadCount, "local documents and returns", r4, "documents as results."), n2.documentReadCount > this.Gi * r4 ? (__PRIVATE_getLogLevel() <= LogLevel.DEBUG && __PRIVATE_logDebug("QueryEngine", "The SDK decides to create cache indexes for query:", __PRIVATE_stringifyQuery(t2), "as using cache indexes may help improve performance."), this.indexManager.createTargetIndexes(e3, __PRIVATE_queryToTarget(t2))) : PersistencePromise.resolve());
      }
      /**
       * Performs an indexed query that evaluates the query based on a collection's
       * persisted index values. Returns `null` if an index is not available.
       */
      ji(e3, t2) {
        if (__PRIVATE_queryMatchesAllDocuments(t2))
          return PersistencePromise.resolve(null);
        let n2 = __PRIVATE_queryToTarget(t2);
        return this.indexManager.getIndexType(e3, n2).next((r4) => 0 === r4 ? null : (null !== t2.limit && 1 === r4 && // We cannot apply a limit for targets that are served using a partial
        // index. If a partial index will be used to serve the target, the
        // query may return a superset of documents that match the target
        // (e.g. if the index doesn't include all the target's filters), or
        // may return the correct set of documents in the wrong order (e.g. if
        // the index doesn't include a segment for one of the orderBys).
        // Therefore, a limit should not be applied in such cases.
        (t2 = __PRIVATE_queryWithLimit(
          t2,
          null,
          "F"
          /* LimitType.First */
        ), n2 = __PRIVATE_queryToTarget(t2)), this.indexManager.getDocumentsMatchingTarget(e3, n2).next((r5) => {
          const i3 = __PRIVATE_documentKeySet(...r5);
          return this.zi.getDocuments(e3, i3).next((r6) => this.indexManager.getMinOffset(e3, n2).next((n3) => {
            const s3 = this.Zi(t2, r6);
            return this.Xi(t2, s3, i3, n3.readTime) ? this.ji(e3, __PRIVATE_queryWithLimit(
              t2,
              null,
              "F"
              /* LimitType.First */
            )) : this.es(e3, s3, t2, n3);
          }));
        })));
      }
      /**
       * Performs a query based on the target's persisted query mapping. Returns
       * `null` if the mapping is not available or cannot be used.
       */
      Hi(e3, t2, n2, r4) {
        return __PRIVATE_queryMatchesAllDocuments(t2) || r4.isEqual(SnapshotVersion.min()) ? PersistencePromise.resolve(null) : this.zi.getDocuments(e3, n2).next((i3) => {
          const s3 = this.Zi(t2, i3);
          return this.Xi(t2, s3, n2, r4) ? PersistencePromise.resolve(null) : (__PRIVATE_getLogLevel() <= LogLevel.DEBUG && __PRIVATE_logDebug("QueryEngine", "Re-using previous result from %s to execute query: %s", r4.toString(), __PRIVATE_stringifyQuery(t2)), this.es(e3, s3, t2, __PRIVATE_newIndexOffsetSuccessorFromReadTime(r4, -1)).next((e4) => e4));
        });
      }
      /** Applies the query filter and sorting to the provided documents.  */
      Zi(e3, t2) {
        let n2 = new SortedSet(__PRIVATE_newQueryComparator(e3));
        return t2.forEach((t3, r4) => {
          __PRIVATE_queryMatches(e3, r4) && (n2 = n2.add(r4));
        }), n2;
      }
      /**
       * Determines if a limit query needs to be refilled from cache, making it
       * ineligible for index-free execution.
       *
       * @param query - The query.
       * @param sortedPreviousResults - The documents that matched the query when it
       * was last synchronized, sorted by the query's comparator.
       * @param remoteKeys - The document keys that matched the query at the last
       * snapshot.
       * @param limboFreeSnapshotVersion - The version of the snapshot when the
       * query was last synchronized.
       */
      Xi(e3, t2, n2, r4) {
        if (null === e3.limit)
          return false;
        if (n2.size !== t2.size)
          return true;
        const i3 = "F" === e3.limitType ? t2.last() : t2.first();
        return !!i3 && (i3.hasPendingWrites || i3.version.compareTo(r4) > 0);
      }
      Ji(e3, t2, n2) {
        return __PRIVATE_getLogLevel() <= LogLevel.DEBUG && __PRIVATE_logDebug("QueryEngine", "Using full collection scan to execute query:", __PRIVATE_stringifyQuery(t2)), this.zi.getDocumentsMatchingQuery(e3, t2, IndexOffset.min(), n2);
      }
      /**
       * Combines the results from an indexed execution with the remaining documents
       * that have not yet been indexed.
       */
      es(e3, t2, n2, r4) {
        return this.zi.getDocumentsMatchingQuery(e3, n2, r4).next((e4) => (
          // Merge with existing results
          (t2.forEach((t3) => {
            e4 = e4.insert(t3.key, t3);
          }), e4)
        ));
      }
    };
    __PRIVATE_LocalStoreImpl = class {
      constructor(e3, t2, n2, r4) {
        this.persistence = e3, this.ts = t2, this.serializer = r4, /**
        * Maps a targetID to data about its target.
        *
        * PORTING NOTE: We are using an immutable data structure on Web to make re-runs
        * of `applyRemoteEvent()` idempotent.
        */
        this.ns = new SortedMap(__PRIVATE_primitiveComparator), /** Maps a target to its targetID. */
        // TODO(wuandy): Evaluate if TargetId can be part of Target.
        this.rs = new ObjectMap((e4) => __PRIVATE_canonifyTarget(e4), __PRIVATE_targetEquals), /**
        * A per collection group index of the last read time processed by
        * `getNewDocumentChanges()`.
        *
        * PORTING NOTE: This is only used for multi-tab synchronization.
        */
        this.ss = /* @__PURE__ */ new Map(), this.os = e3.getRemoteDocumentCache(), this.Qr = e3.getTargetCache(), this.$r = e3.getBundleCache(), this._s(n2);
      }
      _s(e3) {
        this.documentOverlayCache = this.persistence.getDocumentOverlayCache(e3), this.indexManager = this.persistence.getIndexManager(e3), this.mutationQueue = this.persistence.getMutationQueue(e3, this.indexManager), this.localDocuments = new LocalDocumentsView(this.os, this.mutationQueue, this.documentOverlayCache, this.indexManager), this.os.setIndexManager(this.indexManager), this.ts.initialize(this.localDocuments, this.indexManager);
      }
      collectGarbage(e3) {
        return this.persistence.runTransaction("Collect garbage", "readwrite-primary", (t2) => e3.collect(t2, this.ns));
      }
    };
    __PRIVATE_LocalClientState = class {
      constructor() {
        this.activeTargetIds = __PRIVATE_targetIdSet();
      }
      As(e3) {
        this.activeTargetIds = this.activeTargetIds.add(e3);
      }
      Rs(e3) {
        this.activeTargetIds = this.activeTargetIds.delete(e3);
      }
      /**
       * Converts this entry into a JSON-encoded format we can use for WebStorage.
       * Does not encode `clientId` as it is part of the key in WebStorage.
       */
      ds() {
        const e3 = {
          activeTargetIds: this.activeTargetIds.toArray(),
          updateTimeMs: Date.now()
        };
        return JSON.stringify(e3);
      }
    };
    __PRIVATE_MemorySharedClientState = class {
      constructor() {
        this.no = new __PRIVATE_LocalClientState(), this.ro = {}, this.onlineStateHandler = null, this.sequenceNumberHandler = null;
      }
      addPendingMutation(e3) {
      }
      updateMutationState(e3, t2, n2) {
      }
      addLocalQueryTarget(e3) {
        return this.no.As(e3), this.ro[e3] || "not-current";
      }
      updateQueryState(e3, t2, n2) {
        this.ro[e3] = t2;
      }
      removeLocalQueryTarget(e3) {
        this.no.Rs(e3);
      }
      isLocalQueryTarget(e3) {
        return this.no.activeTargetIds.has(e3);
      }
      clearQueryState(e3) {
        delete this.ro[e3];
      }
      getAllActiveQueryTargets() {
        return this.no.activeTargetIds;
      }
      isActiveQueryTarget(e3) {
        return this.no.activeTargetIds.has(e3);
      }
      start() {
        return this.no = new __PRIVATE_LocalClientState(), Promise.resolve();
      }
      handleUserChange(e3, t2, n2) {
      }
      setOnlineState(e3) {
      }
      shutdown() {
      }
      writeSequenceNumber(e3) {
      }
      notifyBundleLoaded(e3) {
      }
    };
    __PRIVATE_NoopConnectivityMonitor = class {
      io(e3) {
      }
      shutdown() {
      }
    };
    __PRIVATE_BrowserConnectivityMonitor = class {
      constructor() {
        this.so = () => this.oo(), this._o = () => this.ao(), this.uo = [], this.co();
      }
      io(e3) {
        this.uo.push(e3);
      }
      shutdown() {
        window.removeEventListener("online", this.so), window.removeEventListener("offline", this._o);
      }
      co() {
        window.addEventListener("online", this.so), window.addEventListener("offline", this._o);
      }
      oo() {
        __PRIVATE_logDebug("ConnectivityMonitor", "Network connectivity changed: AVAILABLE");
        for (const e3 of this.uo)
          e3(
            0
            /* NetworkStatus.AVAILABLE */
          );
      }
      ao() {
        __PRIVATE_logDebug("ConnectivityMonitor", "Network connectivity changed: UNAVAILABLE");
        for (const e3 of this.uo)
          e3(
            1
            /* NetworkStatus.UNAVAILABLE */
          );
      }
      // TODO(chenbrian): Consider passing in window either into this component or
      // here for testing via FakeWindow.
      /** Checks that all used attributes of window are available. */
      static D() {
        return "undefined" != typeof window && void 0 !== window.addEventListener && void 0 !== window.removeEventListener;
      }
    };
    Ae = null;
    Re = {
      BatchGetDocuments: "batchGet",
      Commit: "commit",
      RunQuery: "runQuery",
      RunAggregationQuery: "runAggregationQuery"
    };
    __PRIVATE_StreamBridge = class {
      constructor(e3) {
        this.lo = e3.lo, this.ho = e3.ho;
      }
      Po(e3) {
        this.Io = e3;
      }
      To(e3) {
        this.Eo = e3;
      }
      onMessage(e3) {
        this.Ao = e3;
      }
      close() {
        this.ho();
      }
      send(e3) {
        this.lo(e3);
      }
      Ro() {
        this.Io();
      }
      Vo(e3) {
        this.Eo(e3);
      }
      mo(e3) {
        this.Ao(e3);
      }
    };
    Ve = "WebChannelConnection";
    __PRIVATE_WebChannelConnection = class extends /**
    * Base class for all Rest-based connections to the backend (WebChannel and
    * HTTP).
    */
    class __PRIVATE_RestConnection {
      constructor(e3) {
        this.databaseInfo = e3, this.databaseId = e3.databaseId;
        const t2 = e3.ssl ? "https" : "http", n2 = encodeURIComponent(this.databaseId.projectId), r4 = encodeURIComponent(this.databaseId.database);
        this.fo = t2 + "://" + e3.host, this.po = `projects/${n2}/databases/${r4}`, this.yo = "(default)" === this.databaseId.database ? `project_id=${n2}` : `project_id=${n2}&database_id=${r4}`;
      }
      get wo() {
        return false;
      }
      So(e3, t2, n2, r4, i3) {
        const s3 = __PRIVATE_generateUniqueDebugId(), o2 = this.bo(e3, t2.toUriEncodedString());
        __PRIVATE_logDebug("RestConnection", `Sending RPC '${e3}' ${s3}:`, o2, n2);
        const _ = {
          "google-cloud-resource-prefix": this.po,
          "x-goog-request-params": this.yo
        };
        return this.Do(_, r4, i3), this.Co(e3, o2, _, n2).then((t3) => (__PRIVATE_logDebug("RestConnection", `Received RPC '${e3}' ${s3}: `, t3), t3), (t3) => {
          throw __PRIVATE_logWarn("RestConnection", `RPC '${e3}' ${s3} failed with error: `, t3, "url: ", o2, "request:", n2), t3;
        });
      }
      vo(e3, t2, n2, r4, i3, s3) {
        return this.So(e3, t2, n2, r4, i3);
      }
      /**
       * Modifies the headers for a request, adding any authorization token if
       * present and any additional headers for the request.
       */
      Do(e3, t2, n2) {
        e3["X-Goog-Api-Client"] = // SDK_VERSION is updated to different value at runtime depending on the entry point,
        // so we need to get its value when we need it in a function.
        function __PRIVATE_getGoogApiClientValue() {
          return "gl-js/ fire/" + S2;
        }(), // Content-Type: text/plain will avoid preflight requests which might
        // mess with CORS and redirects by proxies. If we add custom headers
        // we will need to change this code to potentially use the $httpOverwrite
        // parameter supported by ESF to avoid triggering preflight requests.
        e3["Content-Type"] = "text/plain", this.databaseInfo.appId && (e3["X-Firebase-GMPID"] = this.databaseInfo.appId), t2 && t2.headers.forEach((t3, n3) => e3[n3] = t3), n2 && n2.headers.forEach((t3, n3) => e3[n3] = t3);
      }
      bo(e3, t2) {
        const n2 = Re[e3];
        return `${this.fo}/v1/${t2}:${n2}`;
      }
      /**
       * Closes and cleans up any resources associated with the connection. This
       * implementation is a no-op because there are no resources associated
       * with the RestConnection that need to be cleaned up.
       */
      terminate() {
      }
    } {
      constructor(e3) {
        super(e3), this.forceLongPolling = e3.forceLongPolling, this.autoDetectLongPolling = e3.autoDetectLongPolling, this.useFetchStreams = e3.useFetchStreams, this.longPollingOptions = e3.longPollingOptions;
      }
      Co(e3, t2, n2, r4) {
        const i3 = __PRIVATE_generateUniqueDebugId();
        return new Promise((s3, o2) => {
          const _ = new XhrIo();
          _.setWithCredentials(true), _.listenOnce(EventType.COMPLETE, () => {
            try {
              switch (_.getLastErrorCode()) {
                case ErrorCode.NO_ERROR:
                  const t3 = _.getResponseJson();
                  __PRIVATE_logDebug(Ve, `XHR for RPC '${e3}' ${i3} received:`, JSON.stringify(t3)), s3(t3);
                  break;
                case ErrorCode.TIMEOUT:
                  __PRIVATE_logDebug(Ve, `RPC '${e3}' ${i3} timed out`), o2(new FirestoreError(D2.DEADLINE_EXCEEDED, "Request time out"));
                  break;
                case ErrorCode.HTTP_ERROR:
                  const n3 = _.getStatus();
                  if (__PRIVATE_logDebug(Ve, `RPC '${e3}' ${i3} failed with status:`, n3, "response text:", _.getResponseText()), n3 > 0) {
                    let e4 = _.getResponseJson();
                    Array.isArray(e4) && (e4 = e4[0]);
                    const t4 = null == e4 ? void 0 : e4.error;
                    if (t4 && t4.status && t4.message) {
                      const e5 = function __PRIVATE_mapCodeFromHttpResponseErrorStatus(e6) {
                        const t5 = e6.toLowerCase().replace(/_/g, "-");
                        return Object.values(D2).indexOf(t5) >= 0 ? t5 : D2.UNKNOWN;
                      }(t4.status);
                      o2(new FirestoreError(e5, t4.message));
                    } else
                      o2(new FirestoreError(D2.UNKNOWN, "Server responded with status " + _.getStatus()));
                  } else
                    o2(new FirestoreError(D2.UNAVAILABLE, "Connection failed."));
                  break;
                default:
                  fail();
              }
            } finally {
              __PRIVATE_logDebug(Ve, `RPC '${e3}' ${i3} completed.`);
            }
          });
          const a2 = JSON.stringify(r4);
          __PRIVATE_logDebug(Ve, `RPC '${e3}' ${i3} sending request:`, r4), _.send(t2, "POST", a2, n2, 15);
        });
      }
      Fo(e3, t2, n2) {
        const r4 = __PRIVATE_generateUniqueDebugId(), i3 = [this.fo, "/", "google.firestore.v1.Firestore", "/", e3, "/channel"], s3 = createWebChannelTransport(), o2 = getStatEventTarget(), _ = {
          // Required for backend stickiness, routing behavior is based on this
          // parameter.
          httpSessionIdParam: "gsessionid",
          initMessageHeaders: {},
          messageUrlParams: {
            // This param is used to improve routing and project isolation by the
            // backend and must be included in every request.
            database: `projects/${this.databaseId.projectId}/databases/${this.databaseId.database}`
          },
          sendRawJson: true,
          supportsCrossDomainXhr: true,
          internalChannelParams: {
            // Override the default timeout (randomized between 10-20 seconds) since
            // a large write batch on a slow internet connection may take a long
            // time to send to the backend. Rather than have WebChannel impose a
            // tight timeout which could lead to infinite timeouts and retries, we
            // set it very large (5-10 minutes) and rely on the browser's builtin
            // timeouts to kick in if the request isn't working.
            forwardChannelRequestTimeoutMs: 6e5
          },
          forceLongPolling: this.forceLongPolling,
          detectBufferingProxy: this.autoDetectLongPolling
        }, a2 = this.longPollingOptions.timeoutSeconds;
        void 0 !== a2 && (_.longPollingTimeout = Math.round(1e3 * a2)), this.useFetchStreams && (_.useFetchStreams = true), this.Do(_.initMessageHeaders, t2, n2), // Sending the custom headers we just added to request.initMessageHeaders
        // (Authorization, etc.) will trigger the browser to make a CORS preflight
        // request because the XHR will no longer meet the criteria for a "simple"
        // CORS request:
        // https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Simple_requests
        // Therefore to avoid the CORS preflight request (an extra network
        // roundtrip), we use the encodeInitMessageHeaders option to specify that
        // the headers should instead be encoded in the request's POST payload,
        // which is recognized by the webchannel backend.
        _.encodeInitMessageHeaders = true;
        const u2 = i3.join("");
        __PRIVATE_logDebug(Ve, `Creating RPC '${e3}' stream ${r4}: ${u2}`, _);
        const c2 = s3.createWebChannel(u2, _);
        let l3 = false, h = false;
        const P2 = new __PRIVATE_StreamBridge({
          lo: (t3) => {
            h ? __PRIVATE_logDebug(Ve, `Not sending because RPC '${e3}' stream ${r4} is closed:`, t3) : (l3 || (__PRIVATE_logDebug(Ve, `Opening RPC '${e3}' stream ${r4} transport.`), c2.open(), l3 = true), __PRIVATE_logDebug(Ve, `RPC '${e3}' stream ${r4} sending:`, t3), c2.send(t3));
          },
          ho: () => c2.close()
        }), __PRIVATE_unguardedEventListen = (e4, t3, n3) => {
          e4.listen(t3, (e5) => {
            try {
              n3(e5);
            } catch (e6) {
              setTimeout(() => {
                throw e6;
              }, 0);
            }
          });
        };
        return __PRIVATE_unguardedEventListen(c2, WebChannel.EventType.OPEN, () => {
          h || __PRIVATE_logDebug(Ve, `RPC '${e3}' stream ${r4} transport opened.`);
        }), __PRIVATE_unguardedEventListen(c2, WebChannel.EventType.CLOSE, () => {
          h || (h = true, __PRIVATE_logDebug(Ve, `RPC '${e3}' stream ${r4} transport closed`), P2.Vo());
        }), __PRIVATE_unguardedEventListen(c2, WebChannel.EventType.ERROR, (t3) => {
          h || (h = true, __PRIVATE_logWarn(Ve, `RPC '${e3}' stream ${r4} transport errored:`, t3), P2.Vo(new FirestoreError(D2.UNAVAILABLE, "The operation could not be completed")));
        }), __PRIVATE_unguardedEventListen(c2, WebChannel.EventType.MESSAGE, (t3) => {
          var n3;
          if (!h) {
            const i4 = t3.data[0];
            __PRIVATE_hardAssert(!!i4);
            const s4 = i4, o3 = s4.error || (null === (n3 = s4[0]) || void 0 === n3 ? void 0 : n3.error);
            if (o3) {
              __PRIVATE_logDebug(Ve, `RPC '${e3}' stream ${r4} received error:`, o3);
              const t4 = o3.status;
              let n4 = (
                /**
                * Maps an error Code from a GRPC status identifier like 'NOT_FOUND'.
                *
                * @returns The Code equivalent to the given status string or undefined if
                *     there is no match.
                */
                function __PRIVATE_mapCodeFromRpcStatus(e4) {
                  const t5 = ae2[e4];
                  if (void 0 !== t5)
                    return __PRIVATE_mapCodeFromRpcCode(t5);
                }(t4)
              ), i5 = o3.message;
              void 0 === n4 && (n4 = D2.INTERNAL, i5 = "Unknown error status: " + t4 + " with message " + o3.message), // Mark closed so no further events are propagated
              h = true, P2.Vo(new FirestoreError(n4, i5)), c2.close();
            } else
              __PRIVATE_logDebug(Ve, `RPC '${e3}' stream ${r4} received:`, i4), P2.mo(i4);
          }
        }), __PRIVATE_unguardedEventListen(o2, Event2.STAT_EVENT, (t3) => {
          t3.stat === Stat.PROXY ? __PRIVATE_logDebug(Ve, `RPC '${e3}' stream ${r4} detected buffering proxy`) : t3.stat === Stat.NOPROXY && __PRIVATE_logDebug(Ve, `RPC '${e3}' stream ${r4} detected no buffering proxy`);
        }), setTimeout(() => {
          P2.Ro();
        }, 0), P2;
      }
    };
    __PRIVATE_ExponentialBackoff = class {
      constructor(e3, t2, n2 = 1e3, r4 = 1.5, i3 = 6e4) {
        this.oi = e3, this.timerId = t2, this.Mo = n2, this.xo = r4, this.Oo = i3, this.No = 0, this.Bo = null, /** The last backoff attempt, as epoch milliseconds. */
        this.Lo = Date.now(), this.reset();
      }
      /**
       * Resets the backoff delay.
       *
       * The very next backoffAndWait() will have no delay. If it is called again
       * (i.e. due to an error), initialDelayMs (plus jitter) will be used, and
       * subsequent ones will increase according to the backoffFactor.
       */
      reset() {
        this.No = 0;
      }
      /**
       * Resets the backoff delay to the maximum delay (e.g. for use after a
       * RESOURCE_EXHAUSTED error).
       */
      ko() {
        this.No = this.Oo;
      }
      /**
       * Returns a promise that resolves after currentDelayMs, and increases the
       * delay for any subsequent attempts. If there was a pending backoff operation
       * already, it will be canceled.
       */
      qo(e3) {
        this.cancel();
        const t2 = Math.floor(this.No + this.Qo()), n2 = Math.max(0, Date.now() - this.Lo), r4 = Math.max(0, t2 - n2);
        r4 > 0 && __PRIVATE_logDebug("ExponentialBackoff", `Backing off for ${r4} ms (base delay: ${this.No} ms, delay with jitter: ${t2} ms, last attempt: ${n2} ms ago)`), this.Bo = this.oi.enqueueAfterDelay(this.timerId, r4, () => (this.Lo = Date.now(), e3())), // Apply backoff factor to determine next delay and ensure it is within
        // bounds.
        this.No *= this.xo, this.No < this.Mo && (this.No = this.Mo), this.No > this.Oo && (this.No = this.Oo);
      }
      Ko() {
        null !== this.Bo && (this.Bo.skipDelay(), this.Bo = null);
      }
      cancel() {
        null !== this.Bo && (this.Bo.cancel(), this.Bo = null);
      }
      /** Returns a random value in the range [-currentBaseMs/2, currentBaseMs/2] */
      Qo() {
        return (Math.random() - 0.5) * this.No;
      }
    };
    __PRIVATE_PersistentStream = class {
      constructor(e3, t2, n2, r4, i3, s3, o2, _) {
        this.oi = e3, this.$o = n2, this.Uo = r4, this.connection = i3, this.authCredentialsProvider = s3, this.appCheckCredentialsProvider = o2, this.listener = _, this.state = 0, /**
        * A close count that's incremented every time the stream is closed; used by
        * getCloseGuardedDispatcher() to invalidate callbacks that happen after
        * close.
        */
        this.Wo = 0, this.Go = null, this.zo = null, this.stream = null, this.jo = new __PRIVATE_ExponentialBackoff(e3, t2);
      }
      /**
       * Returns true if start() has been called and no error has occurred. True
       * indicates the stream is open or in the process of opening (which
       * encompasses respecting backoff, getting auth tokens, and starting the
       * actual RPC). Use isOpen() to determine if the stream is open and ready for
       * outbound requests.
       */
      Ho() {
        return 1 === this.state || 5 === this.state || this.Jo();
      }
      /**
       * Returns true if the underlying RPC is open (the onOpen() listener has been
       * called) and the stream is ready for outbound requests.
       */
      Jo() {
        return 2 === this.state || 3 === this.state;
      }
      /**
       * Starts the RPC. Only allowed if isStarted() returns false. The stream is
       * not immediately ready for use: onOpen() will be invoked when the RPC is
       * ready for outbound requests, at which point isOpen() will return true.
       *
       * When start returns, isStarted() will return true.
       */
      start() {
        4 !== this.state ? this.auth() : this.Yo();
      }
      /**
       * Stops the RPC. This call is idempotent and allowed regardless of the
       * current isStarted() state.
       *
       * When stop returns, isStarted() and isOpen() will both return false.
       */
      async stop() {
        this.Ho() && await this.close(
          0
          /* PersistentStreamState.Initial */
        );
      }
      /**
       * After an error the stream will usually back off on the next attempt to
       * start it. If the error warrants an immediate restart of the stream, the
       * sender can use this to indicate that the receiver should not back off.
       *
       * Each error will call the onClose() listener. That function can decide to
       * inhibit backoff if required.
       */
      Zo() {
        this.state = 0, this.jo.reset();
      }
      /**
       * Marks this stream as idle. If no further actions are performed on the
       * stream for one minute, the stream will automatically close itself and
       * notify the stream's onClose() handler with Status.OK. The stream will then
       * be in a !isStarted() state, requiring the caller to start the stream again
       * before further use.
       *
       * Only streams that are in state 'Open' can be marked idle, as all other
       * states imply pending network operations.
       */
      Xo() {
        this.Jo() && null === this.Go && (this.Go = this.oi.enqueueAfterDelay(this.$o, 6e4, () => this.e_()));
      }
      /** Sends a message to the underlying stream. */
      t_(e3) {
        this.n_(), this.stream.send(e3);
      }
      /** Called by the idle timer when the stream should close due to inactivity. */
      async e_() {
        if (this.Jo())
          return this.close(
            0
            /* PersistentStreamState.Initial */
          );
      }
      /** Marks the stream as active again. */
      n_() {
        this.Go && (this.Go.cancel(), this.Go = null);
      }
      /** Cancels the health check delayed operation. */
      r_() {
        this.zo && (this.zo.cancel(), this.zo = null);
      }
      /**
       * Closes the stream and cleans up as necessary:
       *
       * * closes the underlying GRPC stream;
       * * calls the onClose handler with the given 'error';
       * * sets internal stream state to 'finalState';
       * * adjusts the backoff timer based on the error
       *
       * A new stream can be opened by calling start().
       *
       * @param finalState - the intended state of the stream after closing.
       * @param error - the error the connection was closed with.
       */
      async close(e3, t2) {
        this.n_(), this.r_(), this.jo.cancel(), // Invalidates any stream-related callbacks (e.g. from auth or the
        // underlying stream), guaranteeing they won't execute.
        this.Wo++, 4 !== e3 ? (
          // If this is an intentional close ensure we don't delay our next connection attempt.
          this.jo.reset()
        ) : t2 && t2.code === D2.RESOURCE_EXHAUSTED ? (
          // Log the error. (Probably either 'quota exceeded' or 'max queue length reached'.)
          (__PRIVATE_logError(t2.toString()), __PRIVATE_logError("Using maximum backoff delay to prevent overloading the backend."), this.jo.ko())
        ) : t2 && t2.code === D2.UNAUTHENTICATED && 3 !== this.state && // "unauthenticated" error means the token was rejected. This should rarely
        // happen since both Auth and AppCheck ensure a sufficient TTL when we
        // request a token. If a user manually resets their system clock this can
        // fail, however. In this case, we should get a Code.UNAUTHENTICATED error
        // before we received the first message and we need to invalidate the token
        // to ensure that we fetch a new token.
        (this.authCredentialsProvider.invalidateToken(), this.appCheckCredentialsProvider.invalidateToken()), // Clean up the underlying stream because we are no longer interested in events.
        null !== this.stream && (this.i_(), this.stream.close(), this.stream = null), // This state must be assigned before calling onClose() to allow the callback to
        // inhibit backoff or otherwise manipulate the state in its non-started state.
        this.state = e3, // Notify the listener that the stream closed.
        await this.listener.To(t2);
      }
      /**
       * Can be overridden to perform additional cleanup before the stream is closed.
       * Calling super.tearDown() is not required.
       */
      i_() {
      }
      auth() {
        this.state = 1;
        const e3 = this.s_(this.Wo), t2 = this.Wo;
        Promise.all([this.authCredentialsProvider.getToken(), this.appCheckCredentialsProvider.getToken()]).then(([e4, n2]) => {
          this.Wo === t2 && // Normally we'd have to schedule the callback on the AsyncQueue.
          // However, the following calls are safe to be called outside the
          // AsyncQueue since they don't chain asynchronous calls
          this.o_(e4, n2);
        }, (t3) => {
          e3(() => {
            const e4 = new FirestoreError(D2.UNKNOWN, "Fetching auth token failed: " + t3.message);
            return this.__(e4);
          });
        });
      }
      o_(e3, t2) {
        const n2 = this.s_(this.Wo);
        this.stream = this.a_(e3, t2), this.stream.Po(() => {
          n2(() => (this.state = 2, this.zo = this.oi.enqueueAfterDelay(this.Uo, 1e4, () => (this.Jo() && (this.state = 3), Promise.resolve())), this.listener.Po()));
        }), this.stream.To((e4) => {
          n2(() => this.__(e4));
        }), this.stream.onMessage((e4) => {
          n2(() => this.onMessage(e4));
        });
      }
      Yo() {
        this.state = 5, this.jo.qo(async () => {
          this.state = 0, this.start();
        });
      }
      // Visible for tests
      __(e3) {
        return __PRIVATE_logDebug("PersistentStream", `close with error: ${e3}`), this.stream = null, this.close(4, e3);
      }
      /**
       * Returns a "dispatcher" function that dispatches operations onto the
       * AsyncQueue but only runs them if closeCount remains unchanged. This allows
       * us to turn auth / stream callbacks into no-ops if the stream is closed /
       * re-opened, etc.
       */
      s_(e3) {
        return (t2) => {
          this.oi.enqueueAndForget(() => this.Wo === e3 ? t2() : (__PRIVATE_logDebug("PersistentStream", "stream callback skipped by getCloseGuardedDispatcher."), Promise.resolve()));
        };
      }
    };
    __PRIVATE_PersistentListenStream = class extends __PRIVATE_PersistentStream {
      constructor(e3, t2, n2, r4, i3, s3) {
        super(e3, "listen_stream_connection_backoff", "listen_stream_idle", "health_check_timeout", t2, n2, r4, s3), this.serializer = i3;
      }
      a_(e3, t2) {
        return this.connection.Fo("Listen", e3, t2);
      }
      onMessage(e3) {
        this.jo.reset();
        const t2 = __PRIVATE_fromWatchChange(this.serializer, e3), n2 = function __PRIVATE_versionFromListenResponse(e4) {
          if (!("targetChange" in e4))
            return SnapshotVersion.min();
          const t3 = e4.targetChange;
          return t3.targetIds && t3.targetIds.length ? SnapshotVersion.min() : t3.readTime ? __PRIVATE_fromVersion(t3.readTime) : SnapshotVersion.min();
        }(e3);
        return this.listener.u_(t2, n2);
      }
      /**
       * Registers interest in the results of the given target. If the target
       * includes a resumeToken it will be included in the request. Results that
       * affect the target will be streamed back as WatchChange messages that
       * reference the targetId.
       */
      c_(e3) {
        const t2 = {};
        t2.database = __PRIVATE_getEncodedDatabaseId(this.serializer), t2.addTarget = function __PRIVATE_toTarget(e4, t3) {
          let n3;
          const r4 = t3.target;
          if (n3 = __PRIVATE_targetIsDocumentTarget(r4) ? {
            documents: __PRIVATE_toDocumentsTarget(e4, r4)
          } : {
            query: __PRIVATE_toQueryTarget(e4, r4).ut
          }, n3.targetId = t3.targetId, t3.resumeToken.approximateByteSize() > 0) {
            n3.resumeToken = __PRIVATE_toBytes(e4, t3.resumeToken);
            const r5 = __PRIVATE_toInt32Proto(e4, t3.expectedCount);
            null !== r5 && (n3.expectedCount = r5);
          } else if (t3.snapshotVersion.compareTo(SnapshotVersion.min()) > 0) {
            n3.readTime = toTimestamp(e4, t3.snapshotVersion.toTimestamp());
            const r5 = __PRIVATE_toInt32Proto(e4, t3.expectedCount);
            null !== r5 && (n3.expectedCount = r5);
          }
          return n3;
        }(this.serializer, e3);
        const n2 = __PRIVATE_toListenRequestLabels(this.serializer, e3);
        n2 && (t2.labels = n2), this.t_(t2);
      }
      /**
       * Unregisters interest in the results of the target associated with the
       * given targetId.
       */
      l_(e3) {
        const t2 = {};
        t2.database = __PRIVATE_getEncodedDatabaseId(this.serializer), t2.removeTarget = e3, this.t_(t2);
      }
    };
    __PRIVATE_PersistentWriteStream = class extends __PRIVATE_PersistentStream {
      constructor(e3, t2, n2, r4, i3, s3) {
        super(e3, "write_stream_connection_backoff", "write_stream_idle", "health_check_timeout", t2, n2, r4, s3), this.serializer = i3, this.h_ = false;
      }
      /**
       * Tracks whether or not a handshake has been successfully exchanged and
       * the stream is ready to accept mutations.
       */
      get P_() {
        return this.h_;
      }
      // Override of PersistentStream.start
      start() {
        this.h_ = false, this.lastStreamToken = void 0, super.start();
      }
      i_() {
        this.h_ && this.I_([]);
      }
      a_(e3, t2) {
        return this.connection.Fo("Write", e3, t2);
      }
      onMessage(e3) {
        if (
          // Always capture the last stream token.
          __PRIVATE_hardAssert(!!e3.streamToken), this.lastStreamToken = e3.streamToken, this.h_
        ) {
          this.jo.reset();
          const t2 = __PRIVATE_fromWriteResults(e3.writeResults, e3.commitTime), n2 = __PRIVATE_fromVersion(e3.commitTime);
          return this.listener.T_(n2, t2);
        }
        return __PRIVATE_hardAssert(!e3.writeResults || 0 === e3.writeResults.length), this.h_ = true, this.listener.E_();
      }
      /**
       * Sends an initial streamToken to the server, performing the handshake
       * required to make the StreamingWrite RPC work. Subsequent
       * calls should wait until onHandshakeComplete was called.
       */
      d_() {
        const e3 = {};
        e3.database = __PRIVATE_getEncodedDatabaseId(this.serializer), this.t_(e3);
      }
      /** Sends a group of mutations to the Firestore backend to apply. */
      I_(e3) {
        const t2 = {
          streamToken: this.lastStreamToken,
          writes: e3.map((e4) => toMutation(this.serializer, e4))
        };
        this.t_(t2);
      }
    };
    __PRIVATE_DatastoreImpl = class extends class Datastore {
    } {
      constructor(e3, t2, n2, r4) {
        super(), this.authCredentials = e3, this.appCheckCredentials = t2, this.connection = n2, this.serializer = r4, this.A_ = false;
      }
      R_() {
        if (this.A_)
          throw new FirestoreError(D2.FAILED_PRECONDITION, "The client has already been terminated.");
      }
      /** Invokes the provided RPC with auth and AppCheck tokens. */
      So(e3, t2, n2, r4) {
        return this.R_(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([i3, s3]) => this.connection.So(e3, __PRIVATE_toResourcePath(t2, n2), r4, i3, s3)).catch((e4) => {
          throw "FirebaseError" === e4.name ? (e4.code === D2.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), e4) : new FirestoreError(D2.UNKNOWN, e4.toString());
        });
      }
      /** Invokes the provided RPC with streamed results with auth and AppCheck tokens. */
      vo(e3, t2, n2, r4, i3) {
        return this.R_(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([s3, o2]) => this.connection.vo(e3, __PRIVATE_toResourcePath(t2, n2), r4, s3, o2, i3)).catch((e4) => {
          throw "FirebaseError" === e4.name ? (e4.code === D2.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), e4) : new FirestoreError(D2.UNKNOWN, e4.toString());
        });
      }
      terminate() {
        this.A_ = true, this.connection.terminate();
      }
    };
    __PRIVATE_OnlineStateTracker = class {
      constructor(e3, t2) {
        this.asyncQueue = e3, this.onlineStateHandler = t2, /** The current OnlineState. */
        this.state = "Unknown", /**
        * A count of consecutive failures to open the stream. If it reaches the
        * maximum defined by MAX_WATCH_STREAM_FAILURES, we'll set the OnlineState to
        * Offline.
        */
        this.m_ = 0, /**
        * A timer that elapses after ONLINE_STATE_TIMEOUT_MS, at which point we
        * transition from OnlineState.Unknown to OnlineState.Offline without waiting
        * for the stream to actually fail (MAX_WATCH_STREAM_FAILURES times).
        */
        this.f_ = null, /**
        * Whether the client should log a warning message if it fails to connect to
        * the backend (initially true, cleared after a successful stream, or if we've
        * logged the message already).
        */
        this.g_ = true;
      }
      /**
       * Called by RemoteStore when a watch stream is started (including on each
       * backoff attempt).
       *
       * If this is the first attempt, it sets the OnlineState to Unknown and starts
       * the onlineStateTimer.
       */
      p_() {
        0 === this.m_ && (this.y_(
          "Unknown"
          /* OnlineState.Unknown */
        ), this.f_ = this.asyncQueue.enqueueAfterDelay("online_state_timeout", 1e4, () => (this.f_ = null, this.w_("Backend didn't respond within 10 seconds."), this.y_(
          "Offline"
          /* OnlineState.Offline */
        ), Promise.resolve())));
      }
      /**
       * Updates our OnlineState as appropriate after the watch stream reports a
       * failure. The first failure moves us to the 'Unknown' state. We then may
       * allow multiple failures (based on MAX_WATCH_STREAM_FAILURES) before we
       * actually transition to the 'Offline' state.
       */
      S_(e3) {
        "Online" === this.state ? this.y_(
          "Unknown"
          /* OnlineState.Unknown */
        ) : (this.m_++, this.m_ >= 1 && (this.b_(), this.w_(`Connection failed 1 times. Most recent error: ${e3.toString()}`), this.y_(
          "Offline"
          /* OnlineState.Offline */
        )));
      }
      /**
       * Explicitly sets the OnlineState to the specified state.
       *
       * Note that this resets our timers / failure counters, etc. used by our
       * Offline heuristics, so must not be used in place of
       * handleWatchStreamStart() and handleWatchStreamFailure().
       */
      set(e3) {
        this.b_(), this.m_ = 0, "Online" === e3 && // We've connected to watch at least once. Don't warn the developer
        // about being offline going forward.
        (this.g_ = false), this.y_(e3);
      }
      y_(e3) {
        e3 !== this.state && (this.state = e3, this.onlineStateHandler(e3));
      }
      w_(e3) {
        const t2 = `Could not reach Cloud Firestore backend. ${e3}
This typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`;
        this.g_ ? (__PRIVATE_logError(t2), this.g_ = false) : __PRIVATE_logDebug("OnlineStateTracker", t2);
      }
      b_() {
        null !== this.f_ && (this.f_.cancel(), this.f_ = null);
      }
    };
    __PRIVATE_RemoteStoreImpl = class {
      constructor(e3, t2, n2, r4, i3) {
        this.localStore = e3, this.datastore = t2, this.asyncQueue = n2, this.remoteSyncer = {}, /**
        * A list of up to MAX_PENDING_WRITES writes that we have fetched from the
        * LocalStore via fillWritePipeline() and have or will send to the write
        * stream.
        *
        * Whenever writePipeline.length > 0 the RemoteStore will attempt to start or
        * restart the write stream. When the stream is established the writes in the
        * pipeline will be sent in order.
        *
        * Writes remain in writePipeline until they are acknowledged by the backend
        * and thus will automatically be re-sent if the stream is interrupted /
        * restarted before they're acknowledged.
        *
        * Write responses from the backend are linked to their originating request
        * purely based on order, and so we can just shift() writes from the front of
        * the writePipeline as we receive responses.
        */
        this.D_ = [], /**
        * A mapping of watched targets that the client cares about tracking and the
        * user has explicitly called a 'listen' for this target.
        *
        * These targets may or may not have been sent to or acknowledged by the
        * server. On re-establishing the listen stream, these targets should be sent
        * to the server. The targets removed with unlistens are removed eagerly
        * without waiting for confirmation from the listen stream.
        */
        this.C_ = /* @__PURE__ */ new Map(), /**
        * A set of reasons for why the RemoteStore may be offline. If empty, the
        * RemoteStore may start its network connections.
        */
        this.v_ = /* @__PURE__ */ new Set(), /**
        * Event handlers that get called when the network is disabled or enabled.
        *
        * PORTING NOTE: These functions are used on the Web client to create the
        * underlying streams (to support tree-shakeable streams). On Android and iOS,
        * the streams are created during construction of RemoteStore.
        */
        this.F_ = [], this.M_ = i3, this.M_.io((e4) => {
          n2.enqueueAndForget(async () => {
            __PRIVATE_canUseNetwork(this) && (__PRIVATE_logDebug("RemoteStore", "Restarting streams for network reachability change."), await async function __PRIVATE_restartNetwork(e5) {
              const t3 = __PRIVATE_debugCast(e5);
              t3.v_.add(
                4
                /* OfflineCause.ConnectivityChange */
              ), await __PRIVATE_disableNetworkInternal(t3), t3.x_.set(
                "Unknown"
                /* OnlineState.Unknown */
              ), t3.v_.delete(
                4
                /* OfflineCause.ConnectivityChange */
              ), await __PRIVATE_enableNetworkInternal(t3);
            }(this));
          });
        }), this.x_ = new __PRIVATE_OnlineStateTracker(n2, r4);
      }
    };
    DelayedOperation = class _DelayedOperation {
      constructor(e3, t2, n2, r4, i3) {
        this.asyncQueue = e3, this.timerId = t2, this.targetTimeMs = n2, this.op = r4, this.removalCallback = i3, this.deferred = new __PRIVATE_Deferred(), this.then = this.deferred.promise.then.bind(this.deferred.promise), // It's normal for the deferred promise to be canceled (due to cancellation)
        // and so we attach a dummy catch callback to avoid
        // 'UnhandledPromiseRejectionWarning' log spam.
        this.deferred.promise.catch((e4) => {
        });
      }
      get promise() {
        return this.deferred.promise;
      }
      /**
       * Creates and returns a DelayedOperation that has been scheduled to be
       * executed on the provided asyncQueue after the provided delayMs.
       *
       * @param asyncQueue - The queue to schedule the operation on.
       * @param id - A Timer ID identifying the type of operation this is.
       * @param delayMs - The delay (ms) before the operation should be scheduled.
       * @param op - The operation to run.
       * @param removalCallback - A callback to be called synchronously once the
       *   operation is executed or canceled, notifying the AsyncQueue to remove it
       *   from its delayedOperations list.
       *   PORTING NOTE: This exists to prevent making removeDelayedOperation() and
       *   the DelayedOperation class public.
       */
      static createAndSchedule(e3, t2, n2, r4, i3) {
        const s3 = Date.now() + n2, o2 = new _DelayedOperation(e3, t2, s3, r4, i3);
        return o2.start(n2), o2;
      }
      /**
       * Starts the timer. This is called immediately after construction by
       * createAndSchedule().
       */
      start(e3) {
        this.timerHandle = setTimeout(() => this.handleDelayElapsed(), e3);
      }
      /**
       * Queues the operation to run immediately (if it hasn't already been run or
       * canceled).
       */
      skipDelay() {
        return this.handleDelayElapsed();
      }
      /**
       * Cancels the operation if it hasn't already been executed or canceled. The
       * promise will be rejected.
       *
       * As long as the operation has not yet been run, calling cancel() provides a
       * guarantee that the operation will not be run.
       */
      cancel(e3) {
        null !== this.timerHandle && (this.clearTimeout(), this.deferred.reject(new FirestoreError(D2.CANCELLED, "Operation cancelled" + (e3 ? ": " + e3 : ""))));
      }
      handleDelayElapsed() {
        this.asyncQueue.enqueueAndForget(() => null !== this.timerHandle ? (this.clearTimeout(), this.op().then((e3) => this.deferred.resolve(e3))) : Promise.resolve());
      }
      clearTimeout() {
        null !== this.timerHandle && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null);
      }
    };
    DocumentSet = class _DocumentSet {
      /** The default ordering is by key if the comparator is omitted */
      constructor(e3) {
        this.comparator = e3 ? (t2, n2) => e3(t2, n2) || DocumentKey.comparator(t2.key, n2.key) : (e4, t2) => DocumentKey.comparator(e4.key, t2.key), this.keyedMap = documentMap(), this.sortedSet = new SortedMap(this.comparator);
      }
      /**
       * Returns an empty copy of the existing DocumentSet, using the same
       * comparator.
       */
      static emptySet(e3) {
        return new _DocumentSet(e3.comparator);
      }
      has(e3) {
        return null != this.keyedMap.get(e3);
      }
      get(e3) {
        return this.keyedMap.get(e3);
      }
      first() {
        return this.sortedSet.minKey();
      }
      last() {
        return this.sortedSet.maxKey();
      }
      isEmpty() {
        return this.sortedSet.isEmpty();
      }
      /**
       * Returns the index of the provided key in the document set, or -1 if the
       * document key is not present in the set;
       */
      indexOf(e3) {
        const t2 = this.keyedMap.get(e3);
        return t2 ? this.sortedSet.indexOf(t2) : -1;
      }
      get size() {
        return this.sortedSet.size;
      }
      /** Iterates documents in order defined by "comparator" */
      forEach(e3) {
        this.sortedSet.inorderTraversal((t2, n2) => (e3(t2), false));
      }
      /** Inserts or updates a document with the same key */
      add(e3) {
        const t2 = this.delete(e3.key);
        return t2.copy(t2.keyedMap.insert(e3.key, e3), t2.sortedSet.insert(e3, null));
      }
      /** Deletes a document with a given key */
      delete(e3) {
        const t2 = this.get(e3);
        return t2 ? this.copy(this.keyedMap.remove(e3), this.sortedSet.remove(t2)) : this;
      }
      isEqual(e3) {
        if (!(e3 instanceof _DocumentSet))
          return false;
        if (this.size !== e3.size)
          return false;
        const t2 = this.sortedSet.getIterator(), n2 = e3.sortedSet.getIterator();
        for (; t2.hasNext(); ) {
          const e4 = t2.getNext().key, r4 = n2.getNext().key;
          if (!e4.isEqual(r4))
            return false;
        }
        return true;
      }
      toString() {
        const e3 = [];
        return this.forEach((t2) => {
          e3.push(t2.toString());
        }), 0 === e3.length ? "DocumentSet ()" : "DocumentSet (\n  " + e3.join("  \n") + "\n)";
      }
      copy(e3, t2) {
        const n2 = new _DocumentSet();
        return n2.comparator = this.comparator, n2.keyedMap = e3, n2.sortedSet = t2, n2;
      }
    };
    __PRIVATE_DocumentChangeSet = class {
      constructor() {
        this.L_ = new SortedMap(DocumentKey.comparator);
      }
      track(e3) {
        const t2 = e3.doc.key, n2 = this.L_.get(t2);
        n2 ? (
          // Merge the new change with the existing change.
          0 !== e3.type && 3 === n2.type ? this.L_ = this.L_.insert(t2, e3) : 3 === e3.type && 1 !== n2.type ? this.L_ = this.L_.insert(t2, {
            type: n2.type,
            doc: e3.doc
          }) : 2 === e3.type && 2 === n2.type ? this.L_ = this.L_.insert(t2, {
            type: 2,
            doc: e3.doc
          }) : 2 === e3.type && 0 === n2.type ? this.L_ = this.L_.insert(t2, {
            type: 0,
            doc: e3.doc
          }) : 1 === e3.type && 0 === n2.type ? this.L_ = this.L_.remove(t2) : 1 === e3.type && 2 === n2.type ? this.L_ = this.L_.insert(t2, {
            type: 1,
            doc: n2.doc
          }) : 0 === e3.type && 1 === n2.type ? this.L_ = this.L_.insert(t2, {
            type: 2,
            doc: e3.doc
          }) : (
            // This includes these cases, which don't make sense:
            // Added->Added
            // Removed->Removed
            // Modified->Added
            // Removed->Modified
            // Metadata->Added
            // Removed->Metadata
            fail()
          )
        ) : this.L_ = this.L_.insert(t2, e3);
      }
      k_() {
        const e3 = [];
        return this.L_.inorderTraversal((t2, n2) => {
          e3.push(n2);
        }), e3;
      }
    };
    ViewSnapshot = class _ViewSnapshot {
      constructor(e3, t2, n2, r4, i3, s3, o2, _, a2) {
        this.query = e3, this.docs = t2, this.oldDocs = n2, this.docChanges = r4, this.mutatedKeys = i3, this.fromCache = s3, this.syncStateChanged = o2, this.excludesMetadataChanges = _, this.hasCachedResults = a2;
      }
      /** Returns a view snapshot as if all documents in the snapshot were added. */
      static fromInitialDocuments(e3, t2, n2, r4, i3) {
        const s3 = [];
        return t2.forEach((e4) => {
          s3.push({
            type: 0,
            doc: e4
          });
        }), new _ViewSnapshot(
          e3,
          t2,
          DocumentSet.emptySet(t2),
          s3,
          n2,
          r4,
          /* syncStateChanged= */
          true,
          /* excludesMetadataChanges= */
          false,
          i3
        );
      }
      get hasPendingWrites() {
        return !this.mutatedKeys.isEmpty();
      }
      isEqual(e3) {
        if (!(this.fromCache === e3.fromCache && this.hasCachedResults === e3.hasCachedResults && this.syncStateChanged === e3.syncStateChanged && this.mutatedKeys.isEqual(e3.mutatedKeys) && __PRIVATE_queryEquals(this.query, e3.query) && this.docs.isEqual(e3.docs) && this.oldDocs.isEqual(e3.oldDocs)))
          return false;
        const t2 = this.docChanges, n2 = e3.docChanges;
        if (t2.length !== n2.length)
          return false;
        for (let e4 = 0; e4 < t2.length; e4++)
          if (t2[e4].type !== n2[e4].type || !t2[e4].doc.isEqual(n2[e4].doc))
            return false;
        return true;
      }
    };
    __PRIVATE_QueryListenersInfo = class {
      constructor() {
        this.q_ = void 0, this.Q_ = [];
      }
    };
    __PRIVATE_EventManagerImpl = class {
      constructor() {
        this.queries = new ObjectMap((e3) => __PRIVATE_canonifyQuery(e3), __PRIVATE_queryEquals), this.onlineState = "Unknown", this.K_ = /* @__PURE__ */ new Set();
      }
    };
    __PRIVATE_QueryListener = class {
      constructor(e3, t2, n2) {
        this.query = e3, this.G_ = t2, /**
        * Initial snapshots (e.g. from cache) may not be propagated to the wrapped
        * observer. This flag is set to true once we've actually raised an event.
        */
        this.z_ = false, this.j_ = null, this.onlineState = "Unknown", this.options = n2 || {};
      }
      /**
       * Applies the new ViewSnapshot to this listener, raising a user-facing event
       * if applicable (depending on what changed, whether the user has opted into
       * metadata-only changes, etc.). Returns true if a user-facing event was
       * indeed raised.
       */
      W_(e3) {
        if (!this.options.includeMetadataChanges) {
          const t3 = [];
          for (const n2 of e3.docChanges)
            3 !== n2.type && t3.push(n2);
          e3 = new ViewSnapshot(
            e3.query,
            e3.docs,
            e3.oldDocs,
            t3,
            e3.mutatedKeys,
            e3.fromCache,
            e3.syncStateChanged,
            /* excludesMetadataChanges= */
            true,
            e3.hasCachedResults
          );
        }
        let t2 = false;
        return this.z_ ? this.H_(e3) && (this.G_.next(e3), t2 = true) : this.J_(e3, this.onlineState) && (this.Y_(e3), t2 = true), this.j_ = e3, t2;
      }
      onError(e3) {
        this.G_.error(e3);
      }
      /** Returns whether a snapshot was raised. */
      U_(e3) {
        this.onlineState = e3;
        let t2 = false;
        return this.j_ && !this.z_ && this.J_(this.j_, e3) && (this.Y_(this.j_), t2 = true), t2;
      }
      J_(e3, t2) {
        if (!e3.fromCache)
          return true;
        const n2 = "Offline" !== t2;
        return (!this.options.Z_ || !n2) && (!e3.docs.isEmpty() || e3.hasCachedResults || "Offline" === t2);
      }
      H_(e3) {
        if (e3.docChanges.length > 0)
          return true;
        const t2 = this.j_ && this.j_.hasPendingWrites !== e3.hasPendingWrites;
        return !(!e3.syncStateChanged && !t2) && true === this.options.includeMetadataChanges;
      }
      Y_(e3) {
        e3 = ViewSnapshot.fromInitialDocuments(e3.query, e3.docs, e3.mutatedKeys, e3.fromCache, e3.hasCachedResults), this.z_ = true, this.G_.next(e3);
      }
    };
    __PRIVATE_AddedLimboDocument = class {
      constructor(e3) {
        this.key = e3;
      }
    };
    __PRIVATE_RemovedLimboDocument = class {
      constructor(e3) {
        this.key = e3;
      }
    };
    __PRIVATE_View = class {
      constructor(e3, t2) {
        this.query = e3, this.oa = t2, this._a = null, this.hasCachedResults = false, /**
        * A flag whether the view is current with the backend. A view is considered
        * current after it has seen the current flag from the backend and did not
        * lose consistency within the watch stream (e.g. because of an existence
        * filter mismatch).
        */
        this.current = false, /** Documents in the view but not in the remote target */
        this.aa = __PRIVATE_documentKeySet(), /** Document Keys that have local changes */
        this.mutatedKeys = __PRIVATE_documentKeySet(), this.ua = __PRIVATE_newQueryComparator(e3), this.ca = new DocumentSet(this.ua);
      }
      /**
       * The set of remote documents that the server has told us belongs to the target associated with
       * this view.
       */
      get la() {
        return this.oa;
      }
      /**
       * Iterates over a set of doc changes, applies the query limit, and computes
       * what the new results should be, what the changes were, and whether we may
       * need to go back to the local cache for more results. Does not make any
       * changes to the view.
       * @param docChanges - The doc changes to apply to this view.
       * @param previousChanges - If this is being called with a refill, then start
       *        with this set of docs and changes instead of the current view.
       * @returns a new set of docs, changes, and refill flag.
       */
      ha(e3, t2) {
        const n2 = t2 ? t2.Pa : new __PRIVATE_DocumentChangeSet(), r4 = t2 ? t2.ca : this.ca;
        let i3 = t2 ? t2.mutatedKeys : this.mutatedKeys, s3 = r4, o2 = false;
        const _ = "F" === this.query.limitType && r4.size === this.query.limit ? r4.last() : null, a2 = "L" === this.query.limitType && r4.size === this.query.limit ? r4.first() : null;
        if (e3.inorderTraversal((e4, t3) => {
          const u2 = r4.get(e4), c2 = __PRIVATE_queryMatches(this.query, t3) ? t3 : null, l3 = !!u2 && this.mutatedKeys.has(u2.key), h = !!c2 && (c2.hasLocalMutations || // We only consider committed mutations for documents that were
          // mutated during the lifetime of the view.
          this.mutatedKeys.has(c2.key) && c2.hasCommittedMutations);
          let P2 = false;
          if (u2 && c2) {
            u2.data.isEqual(c2.data) ? l3 !== h && (n2.track({
              type: 3,
              doc: c2
            }), P2 = true) : this.Ia(u2, c2) || (n2.track({
              type: 2,
              doc: c2
            }), P2 = true, (_ && this.ua(c2, _) > 0 || a2 && this.ua(c2, a2) < 0) && // This doc moved from inside the limit to outside the limit.
            // That means there may be some other doc in the local cache
            // that should be included instead.
            (o2 = true));
          } else
            !u2 && c2 ? (n2.track({
              type: 0,
              doc: c2
            }), P2 = true) : u2 && !c2 && (n2.track({
              type: 1,
              doc: u2
            }), P2 = true, (_ || a2) && // A doc was removed from a full limit query. We'll need to
            // requery from the local cache to see if we know about some other
            // doc that should be in the results.
            (o2 = true));
          P2 && (c2 ? (s3 = s3.add(c2), i3 = h ? i3.add(e4) : i3.delete(e4)) : (s3 = s3.delete(e4), i3 = i3.delete(e4)));
        }), null !== this.query.limit)
          for (; s3.size > this.query.limit; ) {
            const e4 = "F" === this.query.limitType ? s3.last() : s3.first();
            s3 = s3.delete(e4.key), i3 = i3.delete(e4.key), n2.track({
              type: 1,
              doc: e4
            });
          }
        return {
          ca: s3,
          Pa: n2,
          Xi: o2,
          mutatedKeys: i3
        };
      }
      Ia(e3, t2) {
        return e3.hasLocalMutations && t2.hasCommittedMutations && !t2.hasLocalMutations;
      }
      /**
       * Updates the view with the given ViewDocumentChanges and optionally updates
       * limbo docs and sync state from the provided target change.
       * @param docChanges - The set of changes to make to the view's docs.
       * @param limboResolutionEnabled - Whether to update limbo documents based on
       *        this change.
       * @param targetChange - A target change to apply for computing limbo docs and
       *        sync state.
       * @param targetIsPendingReset - Whether the target is pending to reset due to
       *        existence filter mismatch. If not explicitly specified, it is treated
       *        equivalently to `false`.
       * @returns A new ViewChange with the given docs, changes, and sync state.
       */
      // PORTING NOTE: The iOS/Android clients always compute limbo document changes.
      applyChanges(e3, t2, n2, r4) {
        const i3 = this.ca;
        this.ca = e3.ca, this.mutatedKeys = e3.mutatedKeys;
        const s3 = e3.Pa.k_();
        s3.sort((e4, t3) => function __PRIVATE_compareChangeType(e5, t4) {
          const order = (e6) => {
            switch (e6) {
              case 0:
                return 1;
              case 2:
              case 3:
                return 2;
              case 1:
                return 0;
              default:
                return fail();
            }
          };
          return order(e5) - order(t4);
        }(e4.type, t3.type) || this.ua(e4.doc, t3.doc)), this.Ta(n2), r4 = null != r4 && r4;
        const o2 = t2 && !r4 ? this.Ea() : [], _ = 0 === this.aa.size && this.current && !r4 ? 1 : 0, a2 = _ !== this._a;
        if (this._a = _, 0 !== s3.length || a2) {
          return {
            snapshot: new ViewSnapshot(
              this.query,
              e3.ca,
              i3,
              s3,
              e3.mutatedKeys,
              0 === _,
              a2,
              /* excludesMetadataChanges= */
              false,
              !!n2 && n2.resumeToken.approximateByteSize() > 0
            ),
            da: o2
          };
        }
        return {
          da: o2
        };
      }
      /**
       * Applies an OnlineState change to the view, potentially generating a
       * ViewChange if the view's syncState changes as a result.
       */
      U_(e3) {
        return this.current && "Offline" === e3 ? (
          // If we're offline, set `current` to false and then call applyChanges()
          // to refresh our syncState and generate a ViewChange as appropriate. We
          // are guaranteed to get a new TargetChange that sets `current` back to
          // true once the client is back online.
          (this.current = false, this.applyChanges(
            {
              ca: this.ca,
              Pa: new __PRIVATE_DocumentChangeSet(),
              mutatedKeys: this.mutatedKeys,
              Xi: false
            },
            /* limboResolutionEnabled= */
            false
          ))
        ) : {
          da: []
        };
      }
      /**
       * Returns whether the doc for the given key should be in limbo.
       */
      Aa(e3) {
        return !this.oa.has(e3) && // The local store doesn't think it's a result, so it shouldn't be in limbo.
        (!!this.ca.has(e3) && !this.ca.get(e3).hasLocalMutations);
      }
      /**
       * Updates syncedDocuments, current, and limbo docs based on the given change.
       * Returns the list of changes to which docs are in limbo.
       */
      Ta(e3) {
        e3 && (e3.addedDocuments.forEach((e4) => this.oa = this.oa.add(e4)), e3.modifiedDocuments.forEach((e4) => {
        }), e3.removedDocuments.forEach((e4) => this.oa = this.oa.delete(e4)), this.current = e3.current);
      }
      Ea() {
        if (!this.current)
          return [];
        const e3 = this.aa;
        this.aa = __PRIVATE_documentKeySet(), this.ca.forEach((e4) => {
          this.Aa(e4.key) && (this.aa = this.aa.add(e4.key));
        });
        const t2 = [];
        return e3.forEach((e4) => {
          this.aa.has(e4) || t2.push(new __PRIVATE_RemovedLimboDocument(e4));
        }), this.aa.forEach((n2) => {
          e3.has(n2) || t2.push(new __PRIVATE_AddedLimboDocument(n2));
        }), t2;
      }
      /**
       * Update the in-memory state of the current view with the state read from
       * persistence.
       *
       * We update the query view whenever a client's primary status changes:
       * - When a client transitions from primary to secondary, it can miss
       *   LocalStorage updates and its query views may temporarily not be
       *   synchronized with the state on disk.
       * - For secondary to primary transitions, the client needs to update the list
       *   of `syncedDocuments` since secondary clients update their query views
       *   based purely on synthesized RemoteEvents.
       *
       * @param queryResult.documents - The documents that match the query according
       * to the LocalStore.
       * @param queryResult.remoteKeys - The keys of the documents that match the
       * query according to the backend.
       *
       * @returns The ViewChange that resulted from this synchronization.
       */
      // PORTING NOTE: Multi-tab only.
      Ra(e3) {
        this.oa = e3.hs, this.aa = __PRIVATE_documentKeySet();
        const t2 = this.ha(e3.documents);
        return this.applyChanges(
          t2,
          /* limboResolutionEnabled= */
          true
        );
      }
      /**
       * Returns a view snapshot as if this query was just listened to. Contains
       * a document add for every existing document and the `fromCache` and
       * `hasPendingWrites` status of the already established view.
       */
      // PORTING NOTE: Multi-tab only.
      Va() {
        return ViewSnapshot.fromInitialDocuments(this.query, this.ca, this.mutatedKeys, 0 === this._a, this.hasCachedResults);
      }
    };
    __PRIVATE_QueryView = class {
      constructor(e3, t2, n2) {
        this.query = e3, this.targetId = t2, this.view = n2;
      }
    };
    LimboResolution = class {
      constructor(e3) {
        this.key = e3, /**
        * Set to true once we've received a document. This is used in
        * getRemoteKeysForTarget() and ultimately used by WatchChangeAggregator to
        * decide whether it needs to manufacture a delete event for the target once
        * the target is CURRENT.
        */
        this.ma = false;
      }
    };
    __PRIVATE_SyncEngineImpl = class {
      constructor(e3, t2, n2, r4, i3, s3) {
        this.localStore = e3, this.remoteStore = t2, this.eventManager = n2, this.sharedClientState = r4, this.currentUser = i3, this.maxConcurrentLimboResolutions = s3, this.fa = {}, this.ga = new ObjectMap((e4) => __PRIVATE_canonifyQuery(e4), __PRIVATE_queryEquals), this.pa = /* @__PURE__ */ new Map(), /**
        * The keys of documents that are in limbo for which we haven't yet started a
        * limbo resolution query. The strings in this set are the result of calling
        * `key.path.canonicalString()` where `key` is a `DocumentKey` object.
        *
        * The `Set` type was chosen because it provides efficient lookup and removal
        * of arbitrary elements and it also maintains insertion order, providing the
        * desired queue-like FIFO semantics.
        */
        this.ya = /* @__PURE__ */ new Set(), /**
        * Keeps track of the target ID for each document that is in limbo with an
        * active target.
        */
        this.wa = new SortedMap(DocumentKey.comparator), /**
        * Keeps track of the information about an active limbo resolution for each
        * active target ID that was started for the purpose of limbo resolution.
        */
        this.Sa = /* @__PURE__ */ new Map(), this.ba = new __PRIVATE_ReferenceSet(), /** Stores user completion handlers, indexed by User and BatchId. */
        this.Da = {}, /** Stores user callbacks waiting for all pending writes to be acknowledged. */
        this.Ca = /* @__PURE__ */ new Map(), this.va = __PRIVATE_TargetIdGenerator.Bn(), this.onlineState = "Unknown", // The primary state is set to `true` or `false` immediately after Firestore
        // startup. In the interim, a client should only be considered primary if
        // `isPrimary` is true.
        this.Fa = void 0;
      }
      get isPrimaryClient() {
        return true === this.Fa;
      }
    };
    MemoryOfflineComponentProvider = class {
      constructor() {
        this.synchronizeTabs = false;
      }
      async initialize(e3) {
        this.serializer = __PRIVATE_newSerializer(e3.databaseInfo.databaseId), this.sharedClientState = this.createSharedClientState(e3), this.persistence = this.createPersistence(e3), await this.persistence.start(), this.localStore = this.createLocalStore(e3), this.gcScheduler = this.createGarbageCollectionScheduler(e3, this.localStore), this.indexBackfillerScheduler = this.createIndexBackfillerScheduler(e3, this.localStore);
      }
      createGarbageCollectionScheduler(e3, t2) {
        return null;
      }
      createIndexBackfillerScheduler(e3, t2) {
        return null;
      }
      createLocalStore(e3) {
        return __PRIVATE_newLocalStore(this.persistence, new __PRIVATE_QueryEngine(), e3.initialUser, this.serializer);
      }
      createPersistence(e3) {
        return new __PRIVATE_MemoryPersistence(__PRIVATE_MemoryEagerDelegate.Hr, this.serializer);
      }
      createSharedClientState(e3) {
        return new __PRIVATE_MemorySharedClientState();
      }
      async terminate() {
        var e3, t2;
        null === (e3 = this.gcScheduler) || void 0 === e3 || e3.stop(), null === (t2 = this.indexBackfillerScheduler) || void 0 === t2 || t2.stop(), this.sharedClientState.shutdown(), await this.persistence.shutdown();
      }
    };
    OnlineComponentProvider = class {
      async initialize(e3, t2) {
        this.localStore || (this.localStore = e3.localStore, this.sharedClientState = e3.sharedClientState, this.datastore = this.createDatastore(t2), this.remoteStore = this.createRemoteStore(t2), this.eventManager = this.createEventManager(t2), this.syncEngine = this.createSyncEngine(
          t2,
          /* startAsPrimary=*/
          !e3.synchronizeTabs
        ), this.sharedClientState.onlineStateHandler = (e4) => __PRIVATE_syncEngineApplyOnlineStateChange(
          this.syncEngine,
          e4,
          1
          /* OnlineStateSource.SharedClientState */
        ), this.remoteStore.remoteSyncer.handleCredentialChange = __PRIVATE_syncEngineHandleCredentialChange.bind(null, this.syncEngine), await __PRIVATE_remoteStoreApplyPrimaryState(this.remoteStore, this.syncEngine.isPrimaryClient));
      }
      createEventManager(e3) {
        return function __PRIVATE_newEventManager() {
          return new __PRIVATE_EventManagerImpl();
        }();
      }
      createDatastore(e3) {
        const t2 = __PRIVATE_newSerializer(e3.databaseInfo.databaseId), n2 = function __PRIVATE_newConnection(e4) {
          return new __PRIVATE_WebChannelConnection(e4);
        }(e3.databaseInfo);
        return function __PRIVATE_newDatastore(e4, t3, n3, r4) {
          return new __PRIVATE_DatastoreImpl(e4, t3, n3, r4);
        }(e3.authCredentials, e3.appCheckCredentials, n2, t2);
      }
      createRemoteStore(e3) {
        return function __PRIVATE_newRemoteStore(e4, t2, n2, r4, i3) {
          return new __PRIVATE_RemoteStoreImpl(e4, t2, n2, r4, i3);
        }(this.localStore, this.datastore, e3.asyncQueue, (e4) => __PRIVATE_syncEngineApplyOnlineStateChange(
          this.syncEngine,
          e4,
          0
          /* OnlineStateSource.RemoteStore */
        ), function __PRIVATE_newConnectivityMonitor() {
          return __PRIVATE_BrowserConnectivityMonitor.D() ? new __PRIVATE_BrowserConnectivityMonitor() : new __PRIVATE_NoopConnectivityMonitor();
        }());
      }
      createSyncEngine(e3, t2) {
        return function __PRIVATE_newSyncEngine(e4, t3, n2, r4, i3, s3, o2) {
          const _ = new __PRIVATE_SyncEngineImpl(e4, t3, n2, r4, i3, s3);
          return o2 && (_.Fa = true), _;
        }(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, e3.initialUser, e3.maxConcurrentLimboResolutions, t2);
      }
      async terminate() {
        var e3;
        await async function __PRIVATE_remoteStoreShutdown(e4) {
          const t2 = __PRIVATE_debugCast(e4);
          __PRIVATE_logDebug("RemoteStore", "RemoteStore shutting down."), t2.v_.add(
            5
            /* OfflineCause.Shutdown */
          ), await __PRIVATE_disableNetworkInternal(t2), t2.M_.shutdown(), // Set the OnlineState to Unknown (rather than Offline) to avoid potentially
          // triggering spurious listener events with cached data, etc.
          t2.x_.set(
            "Unknown"
            /* OnlineState.Unknown */
          );
        }(this.remoteStore), null === (e3 = this.datastore) || void 0 === e3 || e3.terminate();
      }
    };
    __PRIVATE_AsyncObserver = class {
      constructor(e3) {
        this.observer = e3, /**
        * When set to true, will not raise future events. Necessary to deal with
        * async detachment of listener.
        */
        this.muted = false;
      }
      next(e3) {
        this.observer.next && this.Ba(this.observer.next, e3);
      }
      error(e3) {
        this.observer.error ? this.Ba(this.observer.error, e3) : __PRIVATE_logError("Uncaught Error in snapshot listener:", e3.toString());
      }
      La() {
        this.muted = true;
      }
      Ba(e3, t2) {
        this.muted || setTimeout(() => {
          this.muted || e3(t2);
        }, 0);
      }
    };
    FirestoreClient = class {
      constructor(e3, t2, n2, r4) {
        this.authCredentials = e3, this.appCheckCredentials = t2, this.asyncQueue = n2, this.databaseInfo = r4, this.user = User.UNAUTHENTICATED, this.clientId = __PRIVATE_AutoId.newId(), this.authCredentialListener = () => Promise.resolve(), this.appCheckCredentialListener = () => Promise.resolve(), this.authCredentials.start(n2, async (e4) => {
          __PRIVATE_logDebug("FirestoreClient", "Received user=", e4.uid), await this.authCredentialListener(e4), this.user = e4;
        }), this.appCheckCredentials.start(n2, (e4) => (__PRIVATE_logDebug("FirestoreClient", "Received new app check token=", e4), this.appCheckCredentialListener(e4, this.user)));
      }
      get configuration() {
        return {
          asyncQueue: this.asyncQueue,
          databaseInfo: this.databaseInfo,
          clientId: this.clientId,
          authCredentials: this.authCredentials,
          appCheckCredentials: this.appCheckCredentials,
          initialUser: this.user,
          maxConcurrentLimboResolutions: 100
        };
      }
      setCredentialChangeListener(e3) {
        this.authCredentialListener = e3;
      }
      setAppCheckTokenChangeListener(e3) {
        this.appCheckCredentialListener = e3;
      }
      /**
       * Checks that the client has not been terminated. Ensures that other methods on //
       * this class cannot be called after the client is terminated. //
       */
      verifyNotTerminated() {
        if (this.asyncQueue.isShuttingDown)
          throw new FirestoreError(D2.FAILED_PRECONDITION, "The client has already been terminated.");
      }
      terminate() {
        this.asyncQueue.enterRestrictedMode();
        const e3 = new __PRIVATE_Deferred();
        return this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => {
          try {
            this._onlineComponents && await this._onlineComponents.terminate(), this._offlineComponents && await this._offlineComponents.terminate(), // The credentials provider must be terminated after shutting down the
            // RemoteStore as it will prevent the RemoteStore from retrieving auth
            // tokens.
            this.authCredentials.shutdown(), this.appCheckCredentials.shutdown(), e3.resolve();
          } catch (t2) {
            const n2 = __PRIVATE_wrapInUserErrorIfRecoverable(t2, "Failed to shutdown persistence");
            e3.reject(n2);
          }
        }), e3.promise;
      }
    };
    me = /* @__PURE__ */ new Map();
    FirestoreSettingsImpl = class {
      constructor(e3) {
        var t2, n2;
        if (void 0 === e3.host) {
          if (void 0 !== e3.ssl)
            throw new FirestoreError(D2.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set");
          this.host = "firestore.googleapis.com", this.ssl = true;
        } else
          this.host = e3.host, this.ssl = null === (t2 = e3.ssl) || void 0 === t2 || t2;
        if (this.credentials = e3.credentials, this.ignoreUndefinedProperties = !!e3.ignoreUndefinedProperties, this.localCache = e3.localCache, void 0 === e3.cacheSizeBytes)
          this.cacheSizeBytes = 41943040;
        else {
          if (-1 !== e3.cacheSizeBytes && e3.cacheSizeBytes < 1048576)
            throw new FirestoreError(D2.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
          this.cacheSizeBytes = e3.cacheSizeBytes;
        }
        __PRIVATE_validateIsNotUsedTogether("experimentalForceLongPolling", e3.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", e3.experimentalAutoDetectLongPolling), this.experimentalForceLongPolling = !!e3.experimentalForceLongPolling, this.experimentalForceLongPolling ? this.experimentalAutoDetectLongPolling = false : void 0 === e3.experimentalAutoDetectLongPolling ? this.experimentalAutoDetectLongPolling = true : (
          // For backwards compatibility, coerce the value to boolean even though
          // the TypeScript compiler has narrowed the type to boolean already.
          // noinspection PointlessBooleanExpressionJS
          this.experimentalAutoDetectLongPolling = !!e3.experimentalAutoDetectLongPolling
        ), this.experimentalLongPollingOptions = __PRIVATE_cloneLongPollingOptions(null !== (n2 = e3.experimentalLongPollingOptions) && void 0 !== n2 ? n2 : {}), function __PRIVATE_validateLongPollingOptions(e4) {
          if (void 0 !== e4.timeoutSeconds) {
            if (isNaN(e4.timeoutSeconds))
              throw new FirestoreError(D2.INVALID_ARGUMENT, `invalid long polling timeout: ${e4.timeoutSeconds} (must not be NaN)`);
            if (e4.timeoutSeconds < 5)
              throw new FirestoreError(D2.INVALID_ARGUMENT, `invalid long polling timeout: ${e4.timeoutSeconds} (minimum allowed value is 5)`);
            if (e4.timeoutSeconds > 30)
              throw new FirestoreError(D2.INVALID_ARGUMENT, `invalid long polling timeout: ${e4.timeoutSeconds} (maximum allowed value is 30)`);
          }
        }(this.experimentalLongPollingOptions), this.useFetchStreams = !!e3.useFetchStreams;
      }
      isEqual(e3) {
        return this.host === e3.host && this.ssl === e3.ssl && this.credentials === e3.credentials && this.cacheSizeBytes === e3.cacheSizeBytes && this.experimentalForceLongPolling === e3.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === e3.experimentalAutoDetectLongPolling && function __PRIVATE_longPollingOptionsEqual(e4, t2) {
          return e4.timeoutSeconds === t2.timeoutSeconds;
        }(this.experimentalLongPollingOptions, e3.experimentalLongPollingOptions) && this.ignoreUndefinedProperties === e3.ignoreUndefinedProperties && this.useFetchStreams === e3.useFetchStreams;
      }
    };
    Firestore$1 = class {
      /** @hideconstructor */
      constructor(e3, t2, n2, r4) {
        this._authCredentials = e3, this._appCheckCredentials = t2, this._databaseId = n2, this._app = r4, /**
        * Whether it's a Firestore or Firestore Lite instance.
        */
        this.type = "firestore-lite", this._persistenceKey = "(lite)", this._settings = new FirestoreSettingsImpl({}), this._settingsFrozen = false;
      }
      /**
       * The {@link @firebase/app#FirebaseApp} associated with this `Firestore` service
       * instance.
       */
      get app() {
        if (!this._app)
          throw new FirestoreError(D2.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
        return this._app;
      }
      get _initialized() {
        return this._settingsFrozen;
      }
      get _terminated() {
        return void 0 !== this._terminateTask;
      }
      _setSettings(e3) {
        if (this._settingsFrozen)
          throw new FirestoreError(D2.FAILED_PRECONDITION, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");
        this._settings = new FirestoreSettingsImpl(e3), void 0 !== e3.credentials && (this._authCredentials = function __PRIVATE_makeAuthCredentialsProvider(e4) {
          if (!e4)
            return new __PRIVATE_EmptyAuthCredentialsProvider();
          switch (e4.type) {
            case "firstParty":
              return new __PRIVATE_FirstPartyAuthCredentialsProvider(e4.sessionIndex || "0", e4.iamToken || null, e4.authTokenFactory || null);
            case "provider":
              return e4.client;
            default:
              throw new FirestoreError(D2.INVALID_ARGUMENT, "makeAuthCredentialsProvider failed due to invalid credential type");
          }
        }(e3.credentials));
      }
      _getSettings() {
        return this._settings;
      }
      _freezeSettings() {
        return this._settingsFrozen = true, this._settings;
      }
      _delete() {
        return this._terminateTask || (this._terminateTask = this._terminate()), this._terminateTask;
      }
      /** Returns a JSON-serializable representation of this `Firestore` instance. */
      toJSON() {
        return {
          app: this._app,
          databaseId: this._databaseId,
          settings: this._settings
        };
      }
      /**
       * Terminates all components used by this client. Subclasses can override
       * this method to clean up their own dependencies, but must also call this
       * method.
       *
       * Only ever called once.
       */
      _terminate() {
        return function __PRIVATE_removeComponents(e3) {
          const t2 = me.get(e3);
          t2 && (__PRIVATE_logDebug("ComponentProvider", "Removing Datastore"), me.delete(e3), t2.terminate());
        }(this), Promise.resolve();
      }
    };
    Query = class _Query {
      // This is the lite version of the Query class in the main SDK.
      /** @hideconstructor protected */
      constructor(e3, t2, n2) {
        this.converter = t2, this._query = n2, /** The type of this Firestore reference. */
        this.type = "query", this.firestore = e3;
      }
      withConverter(e3) {
        return new _Query(this.firestore, e3, this._query);
      }
    };
    DocumentReference = class _DocumentReference {
      /** @hideconstructor */
      constructor(e3, t2, n2) {
        this.converter = t2, this._key = n2, /** The type of this Firestore reference. */
        this.type = "document", this.firestore = e3;
      }
      get _path() {
        return this._key.path;
      }
      /**
       * The document's identifier within its collection.
       */
      get id() {
        return this._key.path.lastSegment();
      }
      /**
       * A string representing the path of the referenced document (relative
       * to the root of the database).
       */
      get path() {
        return this._key.path.canonicalString();
      }
      /**
       * The collection this `DocumentReference` belongs to.
       */
      get parent() {
        return new CollectionReference(this.firestore, this.converter, this._key.path.popLast());
      }
      withConverter(e3) {
        return new _DocumentReference(this.firestore, e3, this._key);
      }
    };
    CollectionReference = class _CollectionReference extends Query {
      /** @hideconstructor */
      constructor(e3, t2, n2) {
        super(e3, t2, __PRIVATE_newQueryForPath(n2)), this._path = n2, /** The type of this Firestore reference. */
        this.type = "collection";
      }
      /** The collection's identifier. */
      get id() {
        return this._query.path.lastSegment();
      }
      /**
       * A string representing the path of the referenced collection (relative
       * to the root of the database).
       */
      get path() {
        return this._query.path.canonicalString();
      }
      /**
       * A reference to the containing `DocumentReference` if this is a
       * subcollection. If this isn't a subcollection, the reference is null.
       */
      get parent() {
        const e3 = this._path.popLast();
        return e3.isEmpty() ? null : new DocumentReference(
          this.firestore,
          /* converter= */
          null,
          new DocumentKey(e3)
        );
      }
      withConverter(e3) {
        return new _CollectionReference(this.firestore, e3, this._path);
      }
    };
    __PRIVATE_AsyncQueueImpl = class {
      constructor() {
        this.Xa = Promise.resolve(), // A list of retryable operations. Retryable operations are run in order and
        // retried with backoff.
        this.eu = [], // Is this AsyncQueue being shut down? Once it is set to true, it will not
        // be changed again.
        this.tu = false, // Operations scheduled to be queued in the future. Operations are
        // automatically removed after they are run or canceled.
        this.nu = [], // visible for testing
        this.ru = null, // Flag set while there's an outstanding AsyncQueue operation, used for
        // assertion sanity-checks.
        this.iu = false, // Enabled during shutdown on Safari to prevent future access to IndexedDB.
        this.su = false, // List of TimerIds to fast-forward delays for.
        this.ou = [], // Backoff timer used to schedule retries for retryable operations
        this.jo = new __PRIVATE_ExponentialBackoff(
          this,
          "async_queue_retry"
          /* TimerId.AsyncQueueRetry */
        ), // Visibility handler that triggers an immediate retry of all retryable
        // operations. Meant to speed up recovery when we regain file system access
        // after page comes into foreground.
        this._u = () => {
          const e4 = getDocument();
          e4 && __PRIVATE_logDebug("AsyncQueue", "Visibility state changed to " + e4.visibilityState), this.jo.Ko();
        };
        const e3 = getDocument();
        e3 && "function" == typeof e3.addEventListener && e3.addEventListener("visibilitychange", this._u);
      }
      get isShuttingDown() {
        return this.tu;
      }
      /**
       * Adds a new operation to the queue without waiting for it to complete (i.e.
       * we ignore the Promise result).
       */
      enqueueAndForget(e3) {
        this.enqueue(e3);
      }
      enqueueAndForgetEvenWhileRestricted(e3) {
        this.au(), // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this.uu(e3);
      }
      enterRestrictedMode(e3) {
        if (!this.tu) {
          this.tu = true, this.su = e3 || false;
          const t2 = getDocument();
          t2 && "function" == typeof t2.removeEventListener && t2.removeEventListener("visibilitychange", this._u);
        }
      }
      enqueue(e3) {
        if (this.au(), this.tu)
          return new Promise(() => {
          });
        const t2 = new __PRIVATE_Deferred();
        return this.uu(() => this.tu && this.su ? Promise.resolve() : (e3().then(t2.resolve, t2.reject), t2.promise)).then(() => t2.promise);
      }
      enqueueRetryable(e3) {
        this.enqueueAndForget(() => (this.eu.push(e3), this.cu()));
      }
      /**
       * Runs the next operation from the retryable queue. If the operation fails,
       * reschedules with backoff.
       */
      async cu() {
        if (0 !== this.eu.length) {
          try {
            await this.eu[0](), this.eu.shift(), this.jo.reset();
          } catch (e3) {
            if (!__PRIVATE_isIndexedDbTransactionError(e3))
              throw e3;
            __PRIVATE_logDebug("AsyncQueue", "Operation failed with retryable error: " + e3);
          }
          this.eu.length > 0 && // If there are additional operations, we re-schedule `retryNextOp()`.
          // This is necessary to run retryable operations that failed during
          // their initial attempt since we don't know whether they are already
          // enqueued. If, for example, `op1`, `op2`, `op3` are enqueued and `op1`
          // needs to  be re-run, we will run `op1`, `op1`, `op2` using the
          // already enqueued calls to `retryNextOp()`. `op3()` will then run in the
          // call scheduled here.
          // Since `backoffAndRun()` cancels an existing backoff and schedules a
          // new backoff on every call, there is only ever a single additional
          // operation in the queue.
          this.jo.qo(() => this.cu());
        }
      }
      uu(e3) {
        const t2 = this.Xa.then(() => (this.iu = true, e3().catch((e4) => {
          this.ru = e4, this.iu = false;
          const t3 = (
            /**
            * Chrome includes Error.message in Error.stack. Other browsers do not.
            * This returns expected output of message + stack when available.
            * @param error - Error or FirestoreError
            */
            function __PRIVATE_getMessageOrStack(e5) {
              let t4 = e5.message || "";
              e5.stack && (t4 = e5.stack.includes(e5.message) ? e5.stack : e5.message + "\n" + e5.stack);
              return t4;
            }(e4)
          );
          throw __PRIVATE_logError("INTERNAL UNHANDLED ERROR: ", t3), e4;
        }).then((e4) => (this.iu = false, e4))));
        return this.Xa = t2, t2;
      }
      enqueueAfterDelay(e3, t2, n2) {
        this.au(), // Fast-forward delays for timerIds that have been overriden.
        this.ou.indexOf(e3) > -1 && (t2 = 0);
        const r4 = DelayedOperation.createAndSchedule(this, e3, t2, n2, (e4) => this.lu(e4));
        return this.nu.push(r4), r4;
      }
      au() {
        this.ru && fail();
      }
      verifyOperationInProgress() {
      }
      /**
       * Waits until all currently queued tasks are finished executing. Delayed
       * operations are not run.
       */
      async hu() {
        let e3;
        do {
          e3 = this.Xa, await e3;
        } while (e3 !== this.Xa);
      }
      /**
       * For Tests: Determine if a delayed operation with a particular TimerId
       * exists.
       */
      Pu(e3) {
        for (const t2 of this.nu)
          if (t2.timerId === e3)
            return true;
        return false;
      }
      /**
       * For Tests: Runs some or all delayed operations early.
       *
       * @param lastTimerId - Delayed operations up to and including this TimerId
       * will be drained. Pass TimerId.All to run all delayed operations.
       * @returns a Promise that resolves once all operations have been run.
       */
      Iu(e3) {
        return this.hu().then(() => {
          this.nu.sort((e4, t2) => e4.targetTimeMs - t2.targetTimeMs);
          for (const t2 of this.nu)
            if (t2.skipDelay(), "all" !== e3 && t2.timerId === e3)
              break;
          return this.hu();
        });
      }
      /**
       * For Tests: Skip all subsequent delays for a timer id.
       */
      Tu(e3) {
        this.ou.push(e3);
      }
      /** Called once a DelayedOperation is run or canceled. */
      lu(e3) {
        const t2 = this.nu.indexOf(e3);
        this.nu.splice(t2, 1);
      }
    };
    Firestore = class extends Firestore$1 {
      /** @hideconstructor */
      constructor(e3, t2, n2, r4) {
        super(e3, t2, n2, r4), /**
        * Whether it's a {@link Firestore} or Firestore Lite instance.
        */
        this.type = "firestore", this._queue = function __PRIVATE_newAsyncQueue() {
          return new __PRIVATE_AsyncQueueImpl();
        }(), this._persistenceKey = (null == r4 ? void 0 : r4.name) || "[DEFAULT]";
      }
      _terminate() {
        return this._firestoreClient || // The client must be initialized to ensure that all subsequent API
        // usage throws an exception.
        __PRIVATE_configureFirestore(this), this._firestoreClient.terminate();
      }
    };
    Bytes = class _Bytes {
      /** @hideconstructor */
      constructor(e3) {
        this._byteString = e3;
      }
      /**
       * Creates a new `Bytes` object from the given Base64 string, converting it to
       * bytes.
       *
       * @param base64 - The Base64 string used to create the `Bytes` object.
       */
      static fromBase64String(e3) {
        try {
          return new _Bytes(ByteString.fromBase64String(e3));
        } catch (e4) {
          throw new FirestoreError(D2.INVALID_ARGUMENT, "Failed to construct data from Base64 string: " + e4);
        }
      }
      /**
       * Creates a new `Bytes` object from the given Uint8Array.
       *
       * @param array - The Uint8Array used to create the `Bytes` object.
       */
      static fromUint8Array(e3) {
        return new _Bytes(ByteString.fromUint8Array(e3));
      }
      /**
       * Returns the underlying bytes as a Base64-encoded string.
       *
       * @returns The Base64-encoded string created from the `Bytes` object.
       */
      toBase64() {
        return this._byteString.toBase64();
      }
      /**
       * Returns the underlying bytes in a new `Uint8Array`.
       *
       * @returns The Uint8Array created from the `Bytes` object.
       */
      toUint8Array() {
        return this._byteString.toUint8Array();
      }
      /**
       * Returns a string representation of the `Bytes` object.
       *
       * @returns A string representation of the `Bytes` object.
       */
      toString() {
        return "Bytes(base64: " + this.toBase64() + ")";
      }
      /**
       * Returns true if this `Bytes` object is equal to the provided one.
       *
       * @param other - The `Bytes` object to compare against.
       * @returns true if this `Bytes` object is equal to the provided one.
       */
      isEqual(e3) {
        return this._byteString.isEqual(e3._byteString);
      }
    };
    FieldPath = class {
      /**
       * Creates a `FieldPath` from the provided field names. If more than one field
       * name is provided, the path will point to a nested field in a document.
       *
       * @param fieldNames - A list of field names.
       */
      constructor(...e3) {
        for (let t2 = 0; t2 < e3.length; ++t2)
          if (0 === e3[t2].length)
            throw new FirestoreError(D2.INVALID_ARGUMENT, "Invalid field name at argument $(i + 1). Field names must not be empty.");
        this._internalPath = new FieldPath$1(e3);
      }
      /**
       * Returns true if this `FieldPath` is equal to the provided one.
       *
       * @param other - The `FieldPath` to compare against.
       * @returns true if this `FieldPath` is equal to the provided one.
       */
      isEqual(e3) {
        return this._internalPath.isEqual(e3._internalPath);
      }
    };
    FieldValue = class {
      /**
       * @param _methodName - The public API endpoint that returns this class.
       * @hideconstructor
       */
      constructor(e3) {
        this._methodName = e3;
      }
    };
    GeoPoint = class {
      /**
       * Creates a new immutable `GeoPoint` object with the provided latitude and
       * longitude values.
       * @param latitude - The latitude as number between -90 and 90.
       * @param longitude - The longitude as number between -180 and 180.
       */
      constructor(e3, t2) {
        if (!isFinite(e3) || e3 < -90 || e3 > 90)
          throw new FirestoreError(D2.INVALID_ARGUMENT, "Latitude must be a number between -90 and 90, but was: " + e3);
        if (!isFinite(t2) || t2 < -180 || t2 > 180)
          throw new FirestoreError(D2.INVALID_ARGUMENT, "Longitude must be a number between -180 and 180, but was: " + t2);
        this._lat = e3, this._long = t2;
      }
      /**
       * The latitude of this `GeoPoint` instance.
       */
      get latitude() {
        return this._lat;
      }
      /**
       * The longitude of this `GeoPoint` instance.
       */
      get longitude() {
        return this._long;
      }
      /**
       * Returns true if this `GeoPoint` is equal to the provided one.
       *
       * @param other - The `GeoPoint` to compare against.
       * @returns true if this `GeoPoint` is equal to the provided one.
       */
      isEqual(e3) {
        return this._lat === e3._lat && this._long === e3._long;
      }
      /** Returns a JSON-serializable representation of this GeoPoint. */
      toJSON() {
        return {
          latitude: this._lat,
          longitude: this._long
        };
      }
      /**
       * Actually private to JS consumers of our API, so this function is prefixed
       * with an underscore.
       */
      _compareTo(e3) {
        return __PRIVATE_primitiveComparator(this._lat, e3._lat) || __PRIVATE_primitiveComparator(this._long, e3._long);
      }
    };
    ge = /^__.*__$/;
    ParsedSetData = class {
      constructor(e3, t2, n2) {
        this.data = e3, this.fieldMask = t2, this.fieldTransforms = n2;
      }
      toMutation(e3, t2) {
        return null !== this.fieldMask ? new __PRIVATE_PatchMutation(e3, this.data, this.fieldMask, t2, this.fieldTransforms) : new __PRIVATE_SetMutation(e3, this.data, t2, this.fieldTransforms);
      }
    };
    __PRIVATE_ParseContextImpl = class ___PRIVATE_ParseContextImpl {
      /**
       * Initializes a ParseContext with the given source and path.
       *
       * @param settings - The settings for the parser.
       * @param databaseId - The database ID of the Firestore instance.
       * @param serializer - The serializer to use to generate the Value proto.
       * @param ignoreUndefinedProperties - Whether to ignore undefined properties
       * rather than throw.
       * @param fieldTransforms - A mutable list of field transforms encountered
       * while parsing the data.
       * @param fieldMask - A mutable list of field paths encountered while parsing
       * the data.
       *
       * TODO(b/34871131): We don't support array paths right now, so path can be
       * null to indicate the context represents any location within an array (in
       * which case certain features will not work and errors will be somewhat
       * compromised).
       */
      constructor(e3, t2, n2, r4, i3, s3) {
        this.settings = e3, this.databaseId = t2, this.serializer = n2, this.ignoreUndefinedProperties = r4, // Minor hack: If fieldTransforms is undefined, we assume this is an
        // external call and we need to validate the entire path.
        void 0 === i3 && this.Eu(), this.fieldTransforms = i3 || [], this.fieldMask = s3 || [];
      }
      get path() {
        return this.settings.path;
      }
      get du() {
        return this.settings.du;
      }
      /** Returns a new context with the specified settings overwritten. */
      Au(e3) {
        return new ___PRIVATE_ParseContextImpl(Object.assign(Object.assign({}, this.settings), e3), this.databaseId, this.serializer, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);
      }
      Ru(e3) {
        var t2;
        const n2 = null === (t2 = this.path) || void 0 === t2 ? void 0 : t2.child(e3), r4 = this.Au({
          path: n2,
          Vu: false
        });
        return r4.mu(e3), r4;
      }
      fu(e3) {
        var t2;
        const n2 = null === (t2 = this.path) || void 0 === t2 ? void 0 : t2.child(e3), r4 = this.Au({
          path: n2,
          Vu: false
        });
        return r4.Eu(), r4;
      }
      gu(e3) {
        return this.Au({
          path: void 0,
          Vu: true
        });
      }
      pu(e3) {
        return __PRIVATE_createError(e3, this.settings.methodName, this.settings.yu || false, this.path, this.settings.wu);
      }
      /** Returns 'true' if 'fieldPath' was traversed when creating this context. */
      contains(e3) {
        return void 0 !== this.fieldMask.find((t2) => e3.isPrefixOf(t2)) || void 0 !== this.fieldTransforms.find((t2) => e3.isPrefixOf(t2.field));
      }
      Eu() {
        if (this.path)
          for (let e3 = 0; e3 < this.path.length; e3++)
            this.mu(this.path.get(e3));
      }
      mu(e3) {
        if (0 === e3.length)
          throw this.pu("Document fields must not be empty");
        if (__PRIVATE_isWrite(this.du) && ge.test(e3))
          throw this.pu('Document fields cannot begin and end with "__"');
      }
    };
    __PRIVATE_UserDataReader = class {
      constructor(e3, t2, n2) {
        this.databaseId = e3, this.ignoreUndefinedProperties = t2, this.serializer = n2 || __PRIVATE_newSerializer(e3);
      }
      /** Creates a new top-level parse context. */
      Su(e3, t2, n2, r4 = false) {
        return new __PRIVATE_ParseContextImpl({
          du: e3,
          methodName: t2,
          wu: n2,
          path: FieldPath$1.emptyPath(),
          Vu: false,
          yu: r4
        }, this.databaseId, this.serializer, this.ignoreUndefinedProperties);
      }
    };
    pe = new RegExp("[~\\*/\\[\\]]");
    DocumentSnapshot$1 = class {
      // Note: This class is stripped down version of the DocumentSnapshot in
      // the legacy SDK. The changes are:
      // - No support for SnapshotMetadata.
      // - No support for SnapshotOptions.
      /** @hideconstructor protected */
      constructor(e3, t2, n2, r4, i3) {
        this._firestore = e3, this._userDataWriter = t2, this._key = n2, this._document = r4, this._converter = i3;
      }
      /** Property of the `DocumentSnapshot` that provides the document's ID. */
      get id() {
        return this._key.path.lastSegment();
      }
      /**
       * The `DocumentReference` for the document included in the `DocumentSnapshot`.
       */
      get ref() {
        return new DocumentReference(this._firestore, this._converter, this._key);
      }
      /**
       * Signals whether or not the document at the snapshot's location exists.
       *
       * @returns true if the document exists.
       */
      exists() {
        return null !== this._document;
      }
      /**
       * Retrieves all fields in the document as an `Object`. Returns `undefined` if
       * the document doesn't exist.
       *
       * @returns An `Object` containing all fields in the document or `undefined`
       * if the document doesn't exist.
       */
      data() {
        if (this._document) {
          if (this._converter) {
            const e3 = new QueryDocumentSnapshot$1(
              this._firestore,
              this._userDataWriter,
              this._key,
              this._document,
              /* converter= */
              null
            );
            return this._converter.fromFirestore(e3);
          }
          return this._userDataWriter.convertValue(this._document.data.value);
        }
      }
      /**
       * Retrieves the field specified by `fieldPath`. Returns `undefined` if the
       * document or field doesn't exist.
       *
       * @param fieldPath - The path (for example 'foo' or 'foo.bar') to a specific
       * field.
       * @returns The data at the specified field location or undefined if no such
       * field exists in the document.
       */
      // We are using `any` here to avoid an explicit cast by our users.
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      get(e3) {
        if (this._document) {
          const t2 = this._document.data.field(__PRIVATE_fieldPathFromArgument("DocumentSnapshot.get", e3));
          if (null !== t2)
            return this._userDataWriter.convertValue(t2);
        }
      }
    };
    QueryDocumentSnapshot$1 = class extends DocumentSnapshot$1 {
      /**
       * Retrieves all fields in the document as an `Object`.
       *
       * @override
       * @returns An `Object` containing all fields in the document.
       */
      data() {
        return super.data();
      }
    };
    AbstractUserDataWriter = class {
      convertValue(e3, t2 = "none") {
        switch (__PRIVATE_typeOrder(e3)) {
          case 0:
            return null;
          case 1:
            return e3.booleanValue;
          case 2:
            return __PRIVATE_normalizeNumber(e3.integerValue || e3.doubleValue);
          case 3:
            return this.convertTimestamp(e3.timestampValue);
          case 4:
            return this.convertServerTimestamp(e3, t2);
          case 5:
            return e3.stringValue;
          case 6:
            return this.convertBytes(__PRIVATE_normalizeByteString(e3.bytesValue));
          case 7:
            return this.convertReference(e3.referenceValue);
          case 8:
            return this.convertGeoPoint(e3.geoPointValue);
          case 9:
            return this.convertArray(e3.arrayValue, t2);
          case 10:
            return this.convertObject(e3.mapValue, t2);
          default:
            throw fail();
        }
      }
      convertObject(e3, t2) {
        return this.convertObjectMap(e3.fields, t2);
      }
      /**
       * @internal
       */
      convertObjectMap(e3, t2 = "none") {
        const n2 = {};
        return forEach(e3, (e4, r4) => {
          n2[e4] = this.convertValue(r4, t2);
        }), n2;
      }
      convertGeoPoint(e3) {
        return new GeoPoint(__PRIVATE_normalizeNumber(e3.latitude), __PRIVATE_normalizeNumber(e3.longitude));
      }
      convertArray(e3, t2) {
        return (e3.values || []).map((e4) => this.convertValue(e4, t2));
      }
      convertServerTimestamp(e3, t2) {
        switch (t2) {
          case "previous":
            const n2 = __PRIVATE_getPreviousValue(e3);
            return null == n2 ? null : this.convertValue(n2, t2);
          case "estimate":
            return this.convertTimestamp(__PRIVATE_getLocalWriteTime(e3));
          default:
            return null;
        }
      }
      convertTimestamp(e3) {
        const t2 = __PRIVATE_normalizeTimestamp(e3);
        return new Timestamp(t2.seconds, t2.nanos);
      }
      convertDocumentKey(e3, t2) {
        const n2 = ResourcePath.fromString(e3);
        __PRIVATE_hardAssert(__PRIVATE_isValidResourceName(n2));
        const r4 = new DatabaseId(n2.get(1), n2.get(3)), i3 = new DocumentKey(n2.popFirst(5));
        return r4.isEqual(t2) || // TODO(b/64130202): Somehow support foreign references.
        __PRIVATE_logError(`Document ${i3} contains a document reference within a different database (${r4.projectId}/${r4.database}) which is not supported. It will be treated as a reference in the current database (${t2.projectId}/${t2.database}) instead.`), i3;
      }
    };
    SnapshotMetadata = class {
      /** @hideconstructor */
      constructor(e3, t2) {
        this.hasPendingWrites = e3, this.fromCache = t2;
      }
      /**
       * Returns true if this `SnapshotMetadata` is equal to the provided one.
       *
       * @param other - The `SnapshotMetadata` to compare against.
       * @returns true if this `SnapshotMetadata` is equal to the provided one.
       */
      isEqual(e3) {
        return this.hasPendingWrites === e3.hasPendingWrites && this.fromCache === e3.fromCache;
      }
    };
    DocumentSnapshot = class extends DocumentSnapshot$1 {
      /** @hideconstructor protected */
      constructor(e3, t2, n2, r4, i3, s3) {
        super(e3, t2, n2, r4, s3), this._firestore = e3, this._firestoreImpl = e3, this.metadata = i3;
      }
      /**
       * Returns whether or not the data exists. True if the document exists.
       */
      exists() {
        return super.exists();
      }
      /**
       * Retrieves all fields in the document as an `Object`. Returns `undefined` if
       * the document doesn't exist.
       *
       * By default, `serverTimestamp()` values that have not yet been
       * set to their final value will be returned as `null`. You can override
       * this by passing an options object.
       *
       * @param options - An options object to configure how data is retrieved from
       * the snapshot (for example the desired behavior for server timestamps that
       * have not yet been set to their final value).
       * @returns An `Object` containing all fields in the document or `undefined` if
       * the document doesn't exist.
       */
      data(e3 = {}) {
        if (this._document) {
          if (this._converter) {
            const t2 = new QueryDocumentSnapshot(
              this._firestore,
              this._userDataWriter,
              this._key,
              this._document,
              this.metadata,
              /* converter= */
              null
            );
            return this._converter.fromFirestore(t2, e3);
          }
          return this._userDataWriter.convertValue(this._document.data.value, e3.serverTimestamps);
        }
      }
      /**
       * Retrieves the field specified by `fieldPath`. Returns `undefined` if the
       * document or field doesn't exist.
       *
       * By default, a `serverTimestamp()` that has not yet been set to
       * its final value will be returned as `null`. You can override this by
       * passing an options object.
       *
       * @param fieldPath - The path (for example 'foo' or 'foo.bar') to a specific
       * field.
       * @param options - An options object to configure how the field is retrieved
       * from the snapshot (for example the desired behavior for server timestamps
       * that have not yet been set to their final value).
       * @returns The data at the specified field location or undefined if no such
       * field exists in the document.
       */
      // We are using `any` here to avoid an explicit cast by our users.
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      get(e3, t2 = {}) {
        if (this._document) {
          const n2 = this._document.data.field(__PRIVATE_fieldPathFromArgument("DocumentSnapshot.get", e3));
          if (null !== n2)
            return this._userDataWriter.convertValue(n2, t2.serverTimestamps);
        }
      }
    };
    QueryDocumentSnapshot = class extends DocumentSnapshot {
      /**
       * Retrieves all fields in the document as an `Object`.
       *
       * By default, `serverTimestamp()` values that have not yet been
       * set to their final value will be returned as `null`. You can override
       * this by passing an options object.
       *
       * @override
       * @param options - An options object to configure how data is retrieved from
       * the snapshot (for example the desired behavior for server timestamps that
       * have not yet been set to their final value).
       * @returns An `Object` containing all fields in the document.
       */
      data(e3 = {}) {
        return super.data(e3);
      }
    };
    QuerySnapshot = class {
      /** @hideconstructor */
      constructor(e3, t2, n2, r4) {
        this._firestore = e3, this._userDataWriter = t2, this._snapshot = r4, this.metadata = new SnapshotMetadata(r4.hasPendingWrites, r4.fromCache), this.query = n2;
      }
      /** An array of all the documents in the `QuerySnapshot`. */
      get docs() {
        const e3 = [];
        return this.forEach((t2) => e3.push(t2)), e3;
      }
      /** The number of documents in the `QuerySnapshot`. */
      get size() {
        return this._snapshot.docs.size;
      }
      /** True if there are no documents in the `QuerySnapshot`. */
      get empty() {
        return 0 === this.size;
      }
      /**
       * Enumerates all of the documents in the `QuerySnapshot`.
       *
       * @param callback - A callback to be called with a `QueryDocumentSnapshot` for
       * each document in the snapshot.
       * @param thisArg - The `this` binding for the callback.
       */
      forEach(e3, t2) {
        this._snapshot.docs.forEach((n2) => {
          e3.call(t2, new QueryDocumentSnapshot(this._firestore, this._userDataWriter, n2.key, n2, new SnapshotMetadata(this._snapshot.mutatedKeys.has(n2.key), this._snapshot.fromCache), this.query.converter));
        });
      }
      /**
       * Returns an array of the documents changes since the last snapshot. If this
       * is the first snapshot, all documents will be in the list as 'added'
       * changes.
       *
       * @param options - `SnapshotListenOptions` that control whether metadata-only
       * changes (i.e. only `DocumentSnapshot.metadata` changed) should trigger
       * snapshot events.
       */
      docChanges(e3 = {}) {
        const t2 = !!e3.includeMetadataChanges;
        if (t2 && this._snapshot.excludesMetadataChanges)
          throw new FirestoreError(D2.INVALID_ARGUMENT, "To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().");
        return this._cachedChanges && this._cachedChangesIncludeMetadataChanges === t2 || (this._cachedChanges = /** Calculates the array of `DocumentChange`s for a given `ViewSnapshot`. */
        function __PRIVATE_changesFromSnapshot(e4, t3) {
          if (e4._snapshot.oldDocs.isEmpty()) {
            let t4 = 0;
            return e4._snapshot.docChanges.map((n2) => {
              const r4 = new QueryDocumentSnapshot(e4._firestore, e4._userDataWriter, n2.doc.key, n2.doc, new SnapshotMetadata(e4._snapshot.mutatedKeys.has(n2.doc.key), e4._snapshot.fromCache), e4.query.converter);
              return n2.doc, {
                type: "added",
                doc: r4,
                oldIndex: -1,
                newIndex: t4++
              };
            });
          }
          {
            let n2 = e4._snapshot.oldDocs;
            return e4._snapshot.docChanges.filter((e5) => t3 || 3 !== e5.type).map((t4) => {
              const r4 = new QueryDocumentSnapshot(e4._firestore, e4._userDataWriter, t4.doc.key, t4.doc, new SnapshotMetadata(e4._snapshot.mutatedKeys.has(t4.doc.key), e4._snapshot.fromCache), e4.query.converter);
              let i3 = -1, s3 = -1;
              return 0 !== t4.type && (i3 = n2.indexOf(t4.doc.key), n2 = n2.delete(t4.doc.key)), 1 !== t4.type && (n2 = n2.add(t4.doc), s3 = n2.indexOf(t4.doc.key)), {
                type: __PRIVATE_resultChangeType(t4.type),
                doc: r4,
                oldIndex: i3,
                newIndex: s3
              };
            });
          }
        }(this, t2), this._cachedChangesIncludeMetadataChanges = t2), this._cachedChanges;
      }
    };
    __PRIVATE_ExpUserDataWriter = class extends AbstractUserDataWriter {
      constructor(e3) {
        super(), this.firestore = e3;
      }
      convertBytes(e3) {
        return new Bytes(e3);
      }
      convertReference(e3) {
        const t2 = this.convertDocumentKey(e3, this.firestore._databaseId);
        return new DocumentReference(
          this.firestore,
          /* converter= */
          null,
          t2
        );
      }
    };
    !function __PRIVATE_registerFirestore(e3, t2 = true) {
      !function __PRIVATE_setSDKVersion(e4) {
        S2 = e4;
      }(SDK_VERSION), _registerComponent(new Component("firestore", (e4, { instanceIdentifier: n2, options: r4 }) => {
        const i3 = e4.getProvider("app").getImmediate(), s3 = new Firestore(new __PRIVATE_FirebaseAuthCredentialsProvider(e4.getProvider("auth-internal")), new __PRIVATE_FirebaseAppCheckTokenProvider(e4.getProvider("app-check-internal")), function __PRIVATE_databaseIdFromApp(e5, t3) {
          if (!Object.prototype.hasOwnProperty.apply(e5.options, ["projectId"]))
            throw new FirestoreError(D2.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
          return new DatabaseId(e5.options.projectId, t3);
        }(i3, n2), i3);
        return r4 = Object.assign({
          useFetchStreams: t2
        }, r4), s3._setSettings(r4), s3;
      }, "PUBLIC").setMultipleInstances(true)), registerVersion(w2, "4.4.3", e3), // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation
      registerVersion(w2, "4.4.3", "esm2017");
    }();
  }
});
var init_index_esm2 = __esm({
  "node_modules/firebase/firestore/dist/esm/index.esm.js"() {
    init_index_esm20176();
  }
});
var firebaseConfig;
var app;
var db2;
var createProject;
var getProjects;
var deleteProject;
var init_index7 = __esm({
  ".svelte-kit/output/server/chunks/index7.js"() {
    init_index_esm();
    init_index_esm2();
    firebaseConfig = {
      apiKey: "AIzaSyBN3ItcUbNwvwNTUrhDNyVfdOnwbu1hU9o",
      authDomain: "ria-busana.firebaseapp.com",
      projectId: "ria-busana",
      storageBucket: "ria-busana.appspot.com",
      messagingSenderId: "1053993262752",
      appId: "1:1053993262752:web:e0f64d268e25eff00133c5",
      useEmulator: false
    };
    app = void 0;
    if (!app) {
      app = initializeApp(firebaseConfig);
      if (firebaseConfig.useEmulator) {
        db2 = getFirestore(app);
        connectFirestoreEmulator(db2, "127.0.0.1", 8080);
      } else {
        db2 = getFirestore(app);
      }
    }
    createProject = async (name5) => {
      await setDoc(doc(db2, "projects", name5), {});
    };
    getProjects = async () => {
      const docs = await getDocs(collection(db2, "projects"));
      const data2 = [];
      docs.forEach((doc2) => {
        data2.push(doc2.id);
      });
      console.log("FETCHING PROJECTS...", data2);
      return data2;
    };
    deleteProject = async (project) => {
      await deleteDoc(doc(db2, "projects", project));
    };
  }
});
function redirect(status, location2) {
  if (isNaN(status) || status < 300 || status > 308) {
    throw new Error("Invalid status code");
  }
  throw new Redirect(status, location2.toString());
}
function json(data2, init2) {
  const body2 = JSON.stringify(data2);
  const headers2 = new Headers(init2?.headers);
  if (!headers2.has("content-length")) {
    headers2.set("content-length", encoder.encode(body2).byteLength.toString());
  }
  if (!headers2.has("content-type")) {
    headers2.set("content-type", "application/json");
  }
  return new Response(body2, {
    ...init2,
    headers: headers2
  });
}
function text(body2, init2) {
  const headers2 = new Headers(init2?.headers);
  if (!headers2.has("content-length")) {
    const encoded = encoder.encode(body2);
    headers2.set("content-length", encoded.byteLength.toString());
    return new Response(encoded, {
      ...init2,
      headers: headers2
    });
  }
  return new Response(body2, {
    ...init2,
    headers: headers2
  });
}
function fail2(status, data2) {
  return new ActionFailure(status, data2);
}
var HttpError;
var Redirect;
var SvelteKitError;
var ActionFailure;
var encoder;
var init_chunks = __esm({
  ".svelte-kit/output/server/chunks/index.js"() {
    HttpError = class {
      /**
       * @param {number} status
       * @param {{message: string} extends App.Error ? (App.Error | string | undefined) : App.Error} body
       */
      constructor(status, body2) {
        this.status = status;
        if (typeof body2 === "string") {
          this.body = { message: body2 };
        } else if (body2) {
          this.body = body2;
        } else {
          this.body = { message: `Error: ${status}` };
        }
      }
      toString() {
        return JSON.stringify(this.body);
      }
    };
    Redirect = class {
      /**
       * @param {300 | 301 | 302 | 303 | 304 | 305 | 306 | 307 | 308} status
       * @param {string} location
       */
      constructor(status, location2) {
        this.status = status;
        this.location = location2;
      }
    };
    SvelteKitError = class extends Error {
      /**
       * @param {number} status
       * @param {string} text
       * @param {string} message
       */
      constructor(status, text2, message) {
        super(message);
        this.status = status;
        this.text = text2;
      }
    };
    ActionFailure = class {
      /**
       * @param {number} status
       * @param {T} data
       */
      constructor(status, data2) {
        this.status = status;
        this.data = data2;
      }
    };
    encoder = new TextEncoder();
  }
});
var hooks_server_exports = {};
__export(hooks_server_exports, {
  handle: () => handle
});
var handle;
var init_hooks_server = __esm({
  ".svelte-kit/output/server/chunks/hooks.server.js"() {
    init_index7();
    init_chunks();
    handle = async ({ event, resolve: resolve2 }) => {
      console.log("SUSAH");
      const isSessionPresent = event.cookies.get("session");
      const isLoginPage = event.url.pathname === "/";
      if (!isSessionPresent && !isLoginPage)
        throw redirect(303, "/");
      if (isLoginPage)
        event.locals.isLogin = true;
      const projectPage = event.params.project;
      const isMethodGET = event.request.method === "GET";
      if (isMethodGET) {
        if (projectPage || isSessionPresent) {
          event.locals.projects = await getProjects();
        }
        if (isLoginPage && isSessionPresent) {
          const firstProject = event.locals.projects && event.locals.projects[0];
          throw redirect(303, `/${firstProject}/identitas-proyek`);
        }
      }
      return resolve2(event);
    };
  }
});
function resolve(base2, path) {
  if (path[0] === "/" && path[1] === "/")
    return path;
  let url = new URL(base2, internal);
  url = new URL(path, url);
  return url.protocol === internal.protocol ? url.pathname + url.search + url.hash : url.href;
}
function normalize_path(path, trailing_slash) {
  if (path === "/" || trailing_slash === "ignore")
    return path;
  if (trailing_slash === "never") {
    return path.endsWith("/") ? path.slice(0, -1) : path;
  } else if (trailing_slash === "always" && !path.endsWith("/")) {
    return path + "/";
  }
  return path;
}
function decode_pathname(pathname) {
  return pathname.split("%25").map(decodeURI).join("%25");
}
function decode_params(params) {
  for (const key2 in params) {
    params[key2] = decodeURIComponent(params[key2]);
  }
  return params;
}
function make_trackable(url, callback, search_params_callback) {
  const tracked = new URL(url);
  Object.defineProperty(tracked, "searchParams", {
    value: new Proxy(tracked.searchParams, {
      get(obj, key2) {
        if (key2 === "get" || key2 === "getAll" || key2 === "has") {
          return (param) => {
            search_params_callback(param);
            return obj[key2](param);
          };
        }
        callback();
        const value = Reflect.get(obj, key2);
        return typeof value === "function" ? value.bind(obj) : value;
      }
    }),
    enumerable: true,
    configurable: true
  });
  for (const property of tracked_url_properties) {
    Object.defineProperty(tracked, property, {
      get() {
        callback();
        return url[property];
      },
      enumerable: true,
      configurable: true
    });
  }
  {
    tracked[Symbol.for("nodejs.util.inspect.custom")] = (depth, opts, inspect) => {
      return inspect(url, opts);
    };
  }
  {
    disable_hash(tracked);
  }
  return tracked;
}
function disable_hash(url) {
  allow_nodejs_console_log(url);
  Object.defineProperty(url, "hash", {
    get() {
      throw new Error(
        "Cannot access event.url.hash. Consider using `$page.url.hash` inside a component instead"
      );
    }
  });
}
function disable_search(url) {
  allow_nodejs_console_log(url);
  for (const property of ["search", "searchParams"]) {
    Object.defineProperty(url, property, {
      get() {
        throw new Error(`Cannot access url.${property} on a page with prerendering enabled`);
      }
    });
  }
}
function allow_nodejs_console_log(url) {
  {
    url[Symbol.for("nodejs.util.inspect.custom")] = (depth, opts, inspect) => {
      return inspect(new URL(url), opts);
    };
  }
}
function has_data_suffix(pathname) {
  return pathname.endsWith(DATA_SUFFIX) || pathname.endsWith(HTML_DATA_SUFFIX);
}
function add_data_suffix(pathname) {
  if (pathname.endsWith(".html"))
    return pathname.replace(/\.html$/, HTML_DATA_SUFFIX);
  return pathname.replace(/\/$/, "") + DATA_SUFFIX;
}
function strip_data_suffix(pathname) {
  if (pathname.endsWith(HTML_DATA_SUFFIX)) {
    return pathname.slice(0, -HTML_DATA_SUFFIX.length) + ".html";
  }
  return pathname.slice(0, -DATA_SUFFIX.length);
}
function validator(expected) {
  function validate2(module, file) {
    if (!module)
      return;
    for (const key2 in module) {
      if (key2[0] === "_" || expected.has(key2))
        continue;
      const values = [...expected.values()];
      const hint = hint_for_supported_files(key2, file?.slice(file.lastIndexOf("."))) ?? `valid exports are ${values.join(", ")}, or anything with a '_' prefix`;
      throw new Error(`Invalid export '${key2}'${file ? ` in ${file}` : ""} (${hint})`);
    }
  }
  return validate2;
}
function hint_for_supported_files(key2, ext = ".js") {
  const supported_files = [];
  if (valid_layout_exports.has(key2)) {
    supported_files.push(`+layout${ext}`);
  }
  if (valid_page_exports.has(key2)) {
    supported_files.push(`+page${ext}`);
  }
  if (valid_layout_server_exports.has(key2)) {
    supported_files.push(`+layout.server${ext}`);
  }
  if (valid_page_server_exports.has(key2)) {
    supported_files.push(`+page.server${ext}`);
  }
  if (valid_server_exports.has(key2)) {
    supported_files.push(`+server${ext}`);
  }
  if (supported_files.length > 0) {
    return `'${key2}' is a valid export in ${supported_files.slice(0, -1).join(", ")}${supported_files.length > 1 ? " or " : ""}${supported_files.at(-1)}`;
  }
}
var internal;
var tracked_url_properties;
var DATA_SUFFIX;
var HTML_DATA_SUFFIX;
var valid_layout_exports;
var valid_page_exports;
var valid_layout_server_exports;
var valid_page_server_exports;
var valid_server_exports;
var validate_layout_exports;
var validate_page_exports;
var validate_layout_server_exports;
var validate_page_server_exports;
var validate_server_exports;
var init_exports = __esm({
  ".svelte-kit/output/server/chunks/exports.js"() {
    internal = new URL("sveltekit-internal://");
    tracked_url_properties = /** @type {const} */
    [
      "href",
      "pathname",
      "search",
      "toString",
      "toJSON"
    ];
    DATA_SUFFIX = "/__data.json";
    HTML_DATA_SUFFIX = ".html__data.json";
    valid_layout_exports = /* @__PURE__ */ new Set([
      "load",
      "prerender",
      "csr",
      "ssr",
      "trailingSlash",
      "config"
    ]);
    valid_page_exports = /* @__PURE__ */ new Set([...valid_layout_exports, "entries"]);
    valid_layout_server_exports = /* @__PURE__ */ new Set([...valid_layout_exports]);
    valid_page_server_exports = /* @__PURE__ */ new Set([...valid_layout_server_exports, "actions", "entries"]);
    valid_server_exports = /* @__PURE__ */ new Set([
      "GET",
      "POST",
      "PATCH",
      "PUT",
      "DELETE",
      "OPTIONS",
      "HEAD",
      "fallback",
      "prerender",
      "trailingSlash",
      "config",
      "entries"
    ]);
    validate_layout_exports = validator(valid_layout_exports);
    validate_page_exports = validator(valid_page_exports);
    validate_layout_server_exports = validator(valid_layout_server_exports);
    validate_page_server_exports = validator(valid_page_server_exports);
    validate_server_exports = validator(valid_server_exports);
  }
});
function is_primitive(thing) {
  return Object(thing) !== thing;
}
function is_plain_object(thing) {
  const proto = Object.getPrototypeOf(thing);
  return proto === Object.prototype || proto === null || Object.getOwnPropertyNames(proto).sort().join("\0") === object_proto_names;
}
function get_type(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
function get_escaped_char(char) {
  switch (char) {
    case '"':
      return '\\"';
    case "<":
      return "\\u003C";
    case "\\":
      return "\\\\";
    case "\n":
      return "\\n";
    case "\r":
      return "\\r";
    case "	":
      return "\\t";
    case "\b":
      return "\\b";
    case "\f":
      return "\\f";
    case "\u2028":
      return "\\u2028";
    case "\u2029":
      return "\\u2029";
    default:
      return char < " " ? `\\u${char.charCodeAt(0).toString(16).padStart(4, "0")}` : "";
  }
}
function stringify_string(str) {
  let result = "";
  let last_pos = 0;
  const len = str.length;
  for (let i3 = 0; i3 < len; i3 += 1) {
    const char = str[i3];
    const replacement = get_escaped_char(char);
    if (replacement) {
      result += str.slice(last_pos, i3) + replacement;
      last_pos = i3 + 1;
    }
  }
  return `"${last_pos === 0 ? str : result + str.slice(last_pos)}"`;
}
var escaped;
var DevalueError;
var object_proto_names;
var init_utils = __esm({
  "node_modules/devalue/src/utils.js"() {
    escaped = {
      "<": "\\u003C",
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    DevalueError = class extends Error {
      /**
       * @param {string} message
       * @param {string[]} keys
       */
      constructor(message, keys) {
        super(message);
        this.name = "DevalueError";
        this.path = keys.join("");
      }
    };
    object_proto_names = /* @__PURE__ */ Object.getOwnPropertyNames(
      Object.prototype
    ).sort().join("\0");
  }
});
function uneval(value, replacer) {
  const counts = /* @__PURE__ */ new Map();
  const keys = [];
  const custom2 = /* @__PURE__ */ new Map();
  function walk(thing) {
    if (typeof thing === "function") {
      throw new DevalueError(`Cannot stringify a function`, keys);
    }
    if (!is_primitive(thing)) {
      if (counts.has(thing)) {
        counts.set(thing, counts.get(thing) + 1);
        return;
      }
      counts.set(thing, 1);
      if (replacer) {
        const str2 = replacer(thing);
        if (typeof str2 === "string") {
          custom2.set(thing, str2);
          return;
        }
      }
      const type = get_type(thing);
      switch (type) {
        case "Number":
        case "BigInt":
        case "String":
        case "Boolean":
        case "Date":
        case "RegExp":
          return;
        case "Array":
          thing.forEach((value2, i3) => {
            keys.push(`[${i3}]`);
            walk(value2);
            keys.pop();
          });
          break;
        case "Set":
          Array.from(thing).forEach(walk);
          break;
        case "Map":
          for (const [key2, value2] of thing) {
            keys.push(
              `.get(${is_primitive(key2) ? stringify_primitive(key2) : "..."})`
            );
            walk(value2);
            keys.pop();
          }
          break;
        default:
          if (!is_plain_object(thing)) {
            throw new DevalueError(
              `Cannot stringify arbitrary non-POJOs`,
              keys
            );
          }
          if (Object.getOwnPropertySymbols(thing).length > 0) {
            throw new DevalueError(
              `Cannot stringify POJOs with symbolic keys`,
              keys
            );
          }
          for (const key2 in thing) {
            keys.push(`.${key2}`);
            walk(thing[key2]);
            keys.pop();
          }
      }
    }
  }
  walk(value);
  const names = /* @__PURE__ */ new Map();
  Array.from(counts).filter((entry) => entry[1] > 1).sort((a2, b2) => b2[1] - a2[1]).forEach((entry, i3) => {
    names.set(entry[0], get_name(i3));
  });
  function stringify2(thing) {
    if (names.has(thing)) {
      return names.get(thing);
    }
    if (is_primitive(thing)) {
      return stringify_primitive(thing);
    }
    if (custom2.has(thing)) {
      return custom2.get(thing);
    }
    const type = get_type(thing);
    switch (type) {
      case "Number":
      case "String":
      case "Boolean":
        return `Object(${stringify2(thing.valueOf())})`;
      case "RegExp":
        return `new RegExp(${stringify_string(thing.source)}, "${thing.flags}")`;
      case "Date":
        return `new Date(${thing.getTime()})`;
      case "Array":
        const members = (
          /** @type {any[]} */
          thing.map(
            (v3, i3) => i3 in thing ? stringify2(v3) : ""
          )
        );
        const tail = thing.length === 0 || thing.length - 1 in thing ? "" : ",";
        return `[${members.join(",")}${tail}]`;
      case "Set":
      case "Map":
        return `new ${type}([${Array.from(thing).map(stringify2).join(",")}])`;
      default:
        const obj = `{${Object.keys(thing).map((key2) => `${safe_key(key2)}:${stringify2(thing[key2])}`).join(",")}}`;
        const proto = Object.getPrototypeOf(thing);
        if (proto === null) {
          return Object.keys(thing).length > 0 ? `Object.assign(Object.create(null),${obj})` : `Object.create(null)`;
        }
        return obj;
    }
  }
  const str = stringify2(value);
  if (names.size) {
    const params = [];
    const statements = [];
    const values = [];
    names.forEach((name5, thing) => {
      params.push(name5);
      if (custom2.has(thing)) {
        values.push(
          /** @type {string} */
          custom2.get(thing)
        );
        return;
      }
      if (is_primitive(thing)) {
        values.push(stringify_primitive(thing));
        return;
      }
      const type = get_type(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          values.push(`Object(${stringify2(thing.valueOf())})`);
          break;
        case "RegExp":
          values.push(thing.toString());
          break;
        case "Date":
          values.push(`new Date(${thing.getTime()})`);
          break;
        case "Array":
          values.push(`Array(${thing.length})`);
          thing.forEach((v3, i3) => {
            statements.push(`${name5}[${i3}]=${stringify2(v3)}`);
          });
          break;
        case "Set":
          values.push(`new Set`);
          statements.push(
            `${name5}.${Array.from(thing).map((v3) => `add(${stringify2(v3)})`).join(".")}`
          );
          break;
        case "Map":
          values.push(`new Map`);
          statements.push(
            `${name5}.${Array.from(thing).map(([k2, v3]) => `set(${stringify2(k2)}, ${stringify2(v3)})`).join(".")}`
          );
          break;
        default:
          values.push(
            Object.getPrototypeOf(thing) === null ? "Object.create(null)" : "{}"
          );
          Object.keys(thing).forEach((key2) => {
            statements.push(
              `${name5}${safe_prop(key2)}=${stringify2(thing[key2])}`
            );
          });
      }
    });
    statements.push(`return ${str}`);
    return `(function(${params.join(",")}){${statements.join(
      ";"
    )}}(${values.join(",")}))`;
  } else {
    return str;
  }
}
function get_name(num) {
  let name5 = "";
  do {
    name5 = chars[num % chars.length] + name5;
    num = ~~(num / chars.length) - 1;
  } while (num >= 0);
  return reserved.test(name5) ? `${name5}0` : name5;
}
function escape_unsafe_char(c2) {
  return escaped[c2] || c2;
}
function escape_unsafe_chars(str) {
  return str.replace(unsafe_chars, escape_unsafe_char);
}
function safe_key(key2) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key2) ? key2 : escape_unsafe_chars(JSON.stringify(key2));
}
function safe_prop(key2) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key2) ? `.${key2}` : `[${escape_unsafe_chars(JSON.stringify(key2))}]`;
}
function stringify_primitive(thing) {
  if (typeof thing === "string")
    return stringify_string(thing);
  if (thing === void 0)
    return "void 0";
  if (thing === 0 && 1 / thing < 0)
    return "-0";
  const str = String(thing);
  if (typeof thing === "number")
    return str.replace(/^(-)?0\./, "$1.");
  if (typeof thing === "bigint")
    return thing + "n";
  return str;
}
var chars;
var unsafe_chars;
var reserved;
var init_uneval = __esm({
  "node_modules/devalue/src/uneval.js"() {
    init_utils();
    chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";
    unsafe_chars = /[<\b\f\n\r\t\0\u2028\u2029]/g;
    reserved = /^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;
  }
});
var UNDEFINED;
var HOLE;
var NAN;
var POSITIVE_INFINITY;
var NEGATIVE_INFINITY;
var NEGATIVE_ZERO;
var init_constants = __esm({
  "node_modules/devalue/src/constants.js"() {
    UNDEFINED = -1;
    HOLE = -2;
    NAN = -3;
    POSITIVE_INFINITY = -4;
    NEGATIVE_INFINITY = -5;
    NEGATIVE_ZERO = -6;
  }
});
function parse(serialized, revivers) {
  return unflatten(JSON.parse(serialized), revivers);
}
function unflatten(parsed, revivers) {
  if (typeof parsed === "number")
    return hydrate(parsed, true);
  if (!Array.isArray(parsed) || parsed.length === 0) {
    throw new Error("Invalid input");
  }
  const values = (
    /** @type {any[]} */
    parsed
  );
  const hydrated = Array(values.length);
  function hydrate(index15, standalone = false) {
    if (index15 === UNDEFINED)
      return void 0;
    if (index15 === NAN)
      return NaN;
    if (index15 === POSITIVE_INFINITY)
      return Infinity;
    if (index15 === NEGATIVE_INFINITY)
      return -Infinity;
    if (index15 === NEGATIVE_ZERO)
      return -0;
    if (standalone)
      throw new Error(`Invalid input`);
    if (index15 in hydrated)
      return hydrated[index15];
    const value = values[index15];
    if (!value || typeof value !== "object") {
      hydrated[index15] = value;
    } else if (Array.isArray(value)) {
      if (typeof value[0] === "string") {
        const type = value[0];
        const reviver = revivers?.[type];
        if (reviver) {
          return hydrated[index15] = reviver(hydrate(value[1]));
        }
        switch (type) {
          case "Date":
            hydrated[index15] = new Date(value[1]);
            break;
          case "Set":
            const set = /* @__PURE__ */ new Set();
            hydrated[index15] = set;
            for (let i3 = 1; i3 < value.length; i3 += 1) {
              set.add(hydrate(value[i3]));
            }
            break;
          case "Map":
            const map = /* @__PURE__ */ new Map();
            hydrated[index15] = map;
            for (let i3 = 1; i3 < value.length; i3 += 2) {
              map.set(hydrate(value[i3]), hydrate(value[i3 + 1]));
            }
            break;
          case "RegExp":
            hydrated[index15] = new RegExp(value[1], value[2]);
            break;
          case "Object":
            hydrated[index15] = Object(value[1]);
            break;
          case "BigInt":
            hydrated[index15] = BigInt(value[1]);
            break;
          case "null":
            const obj = /* @__PURE__ */ Object.create(null);
            hydrated[index15] = obj;
            for (let i3 = 1; i3 < value.length; i3 += 2) {
              obj[value[i3]] = hydrate(value[i3 + 1]);
            }
            break;
          default:
            throw new Error(`Unknown type ${type}`);
        }
      } else {
        const array2 = new Array(value.length);
        hydrated[index15] = array2;
        for (let i3 = 0; i3 < value.length; i3 += 1) {
          const n2 = value[i3];
          if (n2 === HOLE)
            continue;
          array2[i3] = hydrate(n2);
        }
      }
    } else {
      const object = {};
      hydrated[index15] = object;
      for (const key2 in value) {
        const n2 = value[key2];
        object[key2] = hydrate(n2);
      }
    }
    return hydrated[index15];
  }
  return hydrate(0);
}
var init_parse = __esm({
  "node_modules/devalue/src/parse.js"() {
    init_constants();
  }
});
function stringify(value, reducers) {
  const stringified = [];
  const indexes = /* @__PURE__ */ new Map();
  const custom2 = [];
  for (const key2 in reducers) {
    custom2.push({ key: key2, fn: reducers[key2] });
  }
  const keys = [];
  let p3 = 0;
  function flatten(thing) {
    if (typeof thing === "function") {
      throw new DevalueError(`Cannot stringify a function`, keys);
    }
    if (indexes.has(thing))
      return indexes.get(thing);
    if (thing === void 0)
      return UNDEFINED;
    if (Number.isNaN(thing))
      return NAN;
    if (thing === Infinity)
      return POSITIVE_INFINITY;
    if (thing === -Infinity)
      return NEGATIVE_INFINITY;
    if (thing === 0 && 1 / thing < 0)
      return NEGATIVE_ZERO;
    const index16 = p3++;
    indexes.set(thing, index16);
    for (const { key: key2, fn } of custom2) {
      const value2 = fn(thing);
      if (value2) {
        stringified[index16] = `["${key2}",${flatten(value2)}]`;
        return index16;
      }
    }
    let str = "";
    if (is_primitive(thing)) {
      str = stringify_primitive2(thing);
    } else {
      const type = get_type(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          str = `["Object",${stringify_primitive2(thing)}]`;
          break;
        case "BigInt":
          str = `["BigInt",${thing}]`;
          break;
        case "Date":
          str = `["Date","${thing.toISOString()}"]`;
          break;
        case "RegExp":
          const { source, flags } = thing;
          str = flags ? `["RegExp",${stringify_string(source)},"${flags}"]` : `["RegExp",${stringify_string(source)}]`;
          break;
        case "Array":
          str = "[";
          for (let i3 = 0; i3 < thing.length; i3 += 1) {
            if (i3 > 0)
              str += ",";
            if (i3 in thing) {
              keys.push(`[${i3}]`);
              str += flatten(thing[i3]);
              keys.pop();
            } else {
              str += HOLE;
            }
          }
          str += "]";
          break;
        case "Set":
          str = '["Set"';
          for (const value2 of thing) {
            str += `,${flatten(value2)}`;
          }
          str += "]";
          break;
        case "Map":
          str = '["Map"';
          for (const [key2, value2] of thing) {
            keys.push(
              `.get(${is_primitive(key2) ? stringify_primitive2(key2) : "..."})`
            );
            str += `,${flatten(key2)},${flatten(value2)}`;
          }
          str += "]";
          break;
        default:
          if (!is_plain_object(thing)) {
            throw new DevalueError(
              `Cannot stringify arbitrary non-POJOs`,
              keys
            );
          }
          if (Object.getOwnPropertySymbols(thing).length > 0) {
            throw new DevalueError(
              `Cannot stringify POJOs with symbolic keys`,
              keys
            );
          }
          if (Object.getPrototypeOf(thing) === null) {
            str = '["null"';
            for (const key2 in thing) {
              keys.push(`.${key2}`);
              str += `,${stringify_string(key2)},${flatten(thing[key2])}`;
              keys.pop();
            }
            str += "]";
          } else {
            str = "{";
            let started = false;
            for (const key2 in thing) {
              if (started)
                str += ",";
              started = true;
              keys.push(`.${key2}`);
              str += `${stringify_string(key2)}:${flatten(thing[key2])}`;
              keys.pop();
            }
            str += "}";
          }
      }
    }
    stringified[index16] = str;
    return index16;
  }
  const index15 = flatten(value);
  if (index15 < 0)
    return `${index15}`;
  return `[${stringified.join(",")}]`;
}
function stringify_primitive2(thing) {
  const type = typeof thing;
  if (type === "string")
    return stringify_string(thing);
  if (thing instanceof String)
    return stringify_string(thing.toString());
  if (thing === void 0)
    return UNDEFINED.toString();
  if (thing === 0 && 1 / thing < 0)
    return NEGATIVE_ZERO.toString();
  if (type === "bigint")
    return `["BigInt","${thing}"]`;
  return String(thing);
}
var init_stringify = __esm({
  "node_modules/devalue/src/stringify.js"() {
    init_utils();
    init_constants();
  }
});
var init_devalue = __esm({
  "node_modules/devalue/index.js"() {
    init_uneval();
    init_parse();
    init_stringify();
  }
});
function readable(value, start) {
  return {
    subscribe: writable(value, start).subscribe
  };
}
function writable(value, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i3 = 0; i3 < subscriber_queue.length; i3 += 2) {
            subscriber_queue[i3][0](subscriber_queue[i3 + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set, update2) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}
function derived(stores, fn, initial_value) {
  const single = !Array.isArray(stores);
  const stores_array = single ? [stores] : stores;
  if (!stores_array.every(Boolean)) {
    throw new Error("derived() expects stores as input, got a falsy value");
  }
  const auto = fn.length < 2;
  return readable(initial_value, (set, update2) => {
    let started = false;
    const values = [];
    let pending = 0;
    let cleanup = noop;
    const sync = () => {
      if (pending) {
        return;
      }
      cleanup();
      const result = fn(single ? values[0] : values, set, update2);
      if (auto) {
        set(result);
      } else {
        cleanup = is_function(result) ? result : noop;
      }
    };
    const unsubscribers = stores_array.map(
      (store, i3) => subscribe(
        store,
        (value) => {
          values[i3] = value;
          pending &= ~(1 << i3);
          if (started) {
            sync();
          }
        },
        () => {
          pending |= 1 << i3;
        }
      )
    );
    started = true;
    sync();
    return function stop() {
      run_all(unsubscribers);
      cleanup();
      started = false;
    };
  });
}
function readonly(store) {
  return {
    subscribe: store.subscribe.bind(store)
  };
}
var subscriber_queue;
var init_index2 = __esm({
  ".svelte-kit/output/server/chunks/index2.js"() {
    init_lifecycle();
    subscriber_queue = [];
  }
});
var require_cookie = __commonJS({
  "node_modules/cookie/index.js"(exports) {
    "use strict";
    exports.parse = parse3;
    exports.serialize = serialize2;
    var __toString = Object.prototype.toString;
    var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
    function parse3(str, options2) {
      if (typeof str !== "string") {
        throw new TypeError("argument str must be a string");
      }
      var obj = {};
      var opt = options2 || {};
      var dec = opt.decode || decode;
      var index15 = 0;
      while (index15 < str.length) {
        var eqIdx = str.indexOf("=", index15);
        if (eqIdx === -1) {
          break;
        }
        var endIdx = str.indexOf(";", index15);
        if (endIdx === -1) {
          endIdx = str.length;
        } else if (endIdx < eqIdx) {
          index15 = str.lastIndexOf(";", eqIdx - 1) + 1;
          continue;
        }
        var key2 = str.slice(index15, eqIdx).trim();
        if (void 0 === obj[key2]) {
          var val = str.slice(eqIdx + 1, endIdx).trim();
          if (val.charCodeAt(0) === 34) {
            val = val.slice(1, -1);
          }
          obj[key2] = tryDecode(val, dec);
        }
        index15 = endIdx + 1;
      }
      return obj;
    }
    function serialize2(name5, val, options2) {
      var opt = options2 || {};
      var enc = opt.encode || encode2;
      if (typeof enc !== "function") {
        throw new TypeError("option encode is invalid");
      }
      if (!fieldContentRegExp.test(name5)) {
        throw new TypeError("argument name is invalid");
      }
      var value = enc(val);
      if (value && !fieldContentRegExp.test(value)) {
        throw new TypeError("argument val is invalid");
      }
      var str = name5 + "=" + value;
      if (null != opt.maxAge) {
        var maxAge = opt.maxAge - 0;
        if (isNaN(maxAge) || !isFinite(maxAge)) {
          throw new TypeError("option maxAge is invalid");
        }
        str += "; Max-Age=" + Math.floor(maxAge);
      }
      if (opt.domain) {
        if (!fieldContentRegExp.test(opt.domain)) {
          throw new TypeError("option domain is invalid");
        }
        str += "; Domain=" + opt.domain;
      }
      if (opt.path) {
        if (!fieldContentRegExp.test(opt.path)) {
          throw new TypeError("option path is invalid");
        }
        str += "; Path=" + opt.path;
      }
      if (opt.expires) {
        var expires = opt.expires;
        if (!isDate(expires) || isNaN(expires.valueOf())) {
          throw new TypeError("option expires is invalid");
        }
        str += "; Expires=" + expires.toUTCString();
      }
      if (opt.httpOnly) {
        str += "; HttpOnly";
      }
      if (opt.secure) {
        str += "; Secure";
      }
      if (opt.partitioned) {
        str += "; Partitioned";
      }
      if (opt.priority) {
        var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
        switch (priority) {
          case "low":
            str += "; Priority=Low";
            break;
          case "medium":
            str += "; Priority=Medium";
            break;
          case "high":
            str += "; Priority=High";
            break;
          default:
            throw new TypeError("option priority is invalid");
        }
      }
      if (opt.sameSite) {
        var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
        switch (sameSite) {
          case true:
            str += "; SameSite=Strict";
            break;
          case "lax":
            str += "; SameSite=Lax";
            break;
          case "strict":
            str += "; SameSite=Strict";
            break;
          case "none":
            str += "; SameSite=None";
            break;
          default:
            throw new TypeError("option sameSite is invalid");
        }
      }
      return str;
    }
    function decode(str) {
      return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
    }
    function encode2(val) {
      return encodeURIComponent(val);
    }
    function isDate(val) {
      return __toString.call(val) === "[object Date]" || val instanceof Date;
    }
    function tryDecode(str, decode2) {
      try {
        return decode2(str);
      } catch (e3) {
        return str;
      }
    }
  }
});
var require_set_cookie = __commonJS({
  "node_modules/set-cookie-parser/lib/set-cookie.js"(exports, module) {
    "use strict";
    var defaultParseOptions = {
      decodeValues: true,
      map: false,
      silent: false
    };
    function isNonEmptyString(str) {
      return typeof str === "string" && !!str.trim();
    }
    function parseString2(setCookieValue, options2) {
      var parts = setCookieValue.split(";").filter(isNonEmptyString);
      var nameValuePairStr = parts.shift();
      var parsed = parseNameValuePair(nameValuePairStr);
      var name5 = parsed.name;
      var value = parsed.value;
      options2 = options2 ? Object.assign({}, defaultParseOptions, options2) : defaultParseOptions;
      try {
        value = options2.decodeValues ? decodeURIComponent(value) : value;
      } catch (e3) {
        console.error(
          "set-cookie-parser encountered an error while decoding a cookie with value '" + value + "'. Set options.decodeValues to false to disable this feature.",
          e3
        );
      }
      var cookie = {
        name: name5,
        value
      };
      parts.forEach(function(part) {
        var sides2 = part.split("=");
        var key2 = sides2.shift().trimLeft().toLowerCase();
        var value2 = sides2.join("=");
        if (key2 === "expires") {
          cookie.expires = new Date(value2);
        } else if (key2 === "max-age") {
          cookie.maxAge = parseInt(value2, 10);
        } else if (key2 === "secure") {
          cookie.secure = true;
        } else if (key2 === "httponly") {
          cookie.httpOnly = true;
        } else if (key2 === "samesite") {
          cookie.sameSite = value2;
        } else {
          cookie[key2] = value2;
        }
      });
      return cookie;
    }
    function parseNameValuePair(nameValuePairStr) {
      var name5 = "";
      var value = "";
      var nameValueArr = nameValuePairStr.split("=");
      if (nameValueArr.length > 1) {
        name5 = nameValueArr.shift();
        value = nameValueArr.join("=");
      } else {
        value = nameValuePairStr;
      }
      return { name: name5, value };
    }
    function parse3(input, options2) {
      options2 = options2 ? Object.assign({}, defaultParseOptions, options2) : defaultParseOptions;
      if (!input) {
        if (!options2.map) {
          return [];
        } else {
          return {};
        }
      }
      if (input.headers) {
        if (typeof input.headers.getSetCookie === "function") {
          input = input.headers.getSetCookie();
        } else if (input.headers["set-cookie"]) {
          input = input.headers["set-cookie"];
        } else {
          var sch = input.headers[Object.keys(input.headers).find(function(key2) {
            return key2.toLowerCase() === "set-cookie";
          })];
          if (!sch && input.headers.cookie && !options2.silent) {
            console.warn(
              "Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning."
            );
          }
          input = sch;
        }
      }
      if (!Array.isArray(input)) {
        input = [input];
      }
      options2 = options2 ? Object.assign({}, defaultParseOptions, options2) : defaultParseOptions;
      if (!options2.map) {
        return input.filter(isNonEmptyString).map(function(str) {
          return parseString2(str, options2);
        });
      } else {
        var cookies = {};
        return input.filter(isNonEmptyString).reduce(function(cookies2, str) {
          var cookie = parseString2(str, options2);
          cookies2[cookie.name] = cookie;
          return cookies2;
        }, cookies);
      }
    }
    function splitCookiesString2(cookiesString) {
      if (Array.isArray(cookiesString)) {
        return cookiesString;
      }
      if (typeof cookiesString !== "string") {
        return [];
      }
      var cookiesStrings = [];
      var pos = 0;
      var start;
      var ch;
      var lastComma;
      var nextStart;
      var cookiesSeparatorFound;
      function skipWhitespace() {
        while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
          pos += 1;
        }
        return pos < cookiesString.length;
      }
      function notSpecialChar() {
        ch = cookiesString.charAt(pos);
        return ch !== "=" && ch !== ";" && ch !== ",";
      }
      while (pos < cookiesString.length) {
        start = pos;
        cookiesSeparatorFound = false;
        while (skipWhitespace()) {
          ch = cookiesString.charAt(pos);
          if (ch === ",") {
            lastComma = pos;
            pos += 1;
            skipWhitespace();
            nextStart = pos;
            while (pos < cookiesString.length && notSpecialChar()) {
              pos += 1;
            }
            if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
              cookiesSeparatorFound = true;
              pos = nextStart;
              cookiesStrings.push(cookiesString.substring(start, lastComma));
              start = pos;
            } else {
              pos = lastComma + 1;
            }
          } else {
            pos += 1;
          }
        }
        if (!cookiesSeparatorFound || pos >= cookiesString.length) {
          cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
        }
      }
      return cookiesStrings;
    }
    module.exports = parse3;
    module.exports.parse = parse3;
    module.exports.parseString = parseString2;
    module.exports.splitCookiesString = splitCookiesString2;
  }
});
var layout_server_ts_exports = {};
__export(layout_server_ts_exports, {
  load: () => load
});
var load;
var init_layout_server_ts = __esm({
  ".svelte-kit/output/server/entries/pages/_layout.server.ts.js"() {
    init_chunks();
    load = async ({ locals }) => {
      if (locals.isLogin)
        return;
      return { projects: locals.projects };
    };
  }
});
function withoutTransition(action) {
  if (typeof document === "undefined")
    return;
  clearTimeout(timeoutAction);
  clearTimeout(timeoutEnable);
  const style = document.createElement("style");
  const css4 = document.createTextNode(`* {
     -webkit-transition: none !important;
     -moz-transition: none !important;
     -o-transition: none !important;
     -ms-transition: none !important;
     transition: none !important;
  }`);
  style.appendChild(css4);
  const disable = () => document.head.appendChild(style);
  const enable = () => document.head.removeChild(style);
  if (typeof window.getComputedStyle !== "undefined") {
    disable();
    action();
    window.getComputedStyle(style).opacity;
    enable();
    return;
  }
  if (typeof window.requestAnimationFrame !== "undefined") {
    disable();
    action();
    window.requestAnimationFrame(enable);
    return;
  }
  disable();
  timeoutAction = window.setTimeout(() => {
    action();
    timeoutEnable = window.setTimeout(enable, 120);
  }, 120);
}
function createUserPrefersMode() {
  const defaultValue2 = "system";
  const storage = isBrowser ? localStorage : noopStorage;
  const initialValue = storage.getItem(localStorageKey);
  let value = isValidMode(initialValue) ? initialValue : defaultValue2;
  const { subscribe: subscribe2, set: _set } = writable(value, () => {
    if (!isBrowser)
      return;
    const handler = (e3) => {
      if (e3.key !== localStorageKey)
        return;
      const newValue = e3.newValue;
      if (isValidMode(newValue)) {
        _set(value = newValue);
      } else {
        _set(value = defaultValue2);
      }
    };
    addEventListener("storage", handler);
    return () => removeEventListener("storage", handler);
  });
  function set(v3) {
    _set(value = v3);
    storage.setItem(localStorageKey, value);
  }
  return {
    subscribe: subscribe2,
    set
  };
}
function createSystemMode() {
  const defaultValue2 = void 0;
  let track = true;
  const { subscribe: subscribe2, set } = writable(defaultValue2, () => {
    if (!isBrowser)
      return;
    const handler = (e3) => {
      if (!track)
        return;
      set(e3.matches ? "light" : "dark");
    };
    const mediaQueryState = window.matchMedia("(prefers-color-scheme: light)");
    mediaQueryState.addEventListener("change", handler);
    return () => mediaQueryState.removeEventListener("change", handler);
  });
  function query() {
    if (!isBrowser)
      return;
    const mediaQueryState = window.matchMedia("(prefers-color-scheme: light)");
    set(mediaQueryState.matches ? "light" : "dark");
  }
  function tracking(active) {
    track = active;
  }
  return {
    subscribe: subscribe2,
    query,
    tracking
  };
}
function createDerivedMode() {
  const { subscribe: subscribe2 } = derived([userPrefersMode, systemPrefersMode, themeColors], ([$userPrefersMode, $systemPrefersMode, $themeColors]) => {
    if (!isBrowser)
      return void 0;
    const derivedMode2 = $userPrefersMode === "system" ? $systemPrefersMode : $userPrefersMode;
    withoutTransition(() => {
      const htmlEl = document.documentElement;
      const themeColorEl = document.querySelector('meta[name="theme-color"]');
      if (derivedMode2 === "light") {
        htmlEl.classList.remove("dark");
        htmlEl.style.colorScheme = "light";
        if (themeColorEl && $themeColors) {
          themeColorEl.setAttribute("content", $themeColors.light);
        }
      } else {
        htmlEl.classList.add("dark");
        htmlEl.style.colorScheme = "dark";
        if (themeColorEl && $themeColors) {
          themeColorEl.setAttribute("content", $themeColors.dark);
        }
      }
    });
    return derivedMode2;
  });
  return {
    subscribe: subscribe2
  };
}
function isValidMode(value) {
  if (typeof value !== "string")
    return false;
  return modes.includes(value);
}
var timeoutAction;
var timeoutEnable;
var noopStorage;
var isBrowser;
var modes;
var localStorageKey;
var userPrefersMode;
var systemPrefersMode;
var themeColors;
var derivedMode;
var init_stores = __esm({
  ".svelte-kit/output/server/chunks/stores.js"() {
    init_index2();
    noopStorage = {
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getItem: (_key) => null,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      setItem: (_key, _value) => {
      }
    };
    isBrowser = typeof document !== "undefined";
    modes = ["dark", "light", "system"];
    localStorageKey = "mode-watcher-mode";
    userPrefersMode = createUserPrefersMode();
    systemPrefersMode = createSystemMode();
    themeColors = writable(void 0);
    derivedMode = createDerivedMode();
  }
});
function get(key2, parse3 = JSON.parse) {
  try {
    return parse3(sessionStorage[key2]);
  } catch {
  }
}
function invalidateAll() {
  {
    throw new Error("Cannot call invalidateAll() on the server");
  }
}
async function applyAction(result) {
  {
    throw new Error("Cannot call applyAction(...) on the server");
  }
}
var SNAPSHOT_KEY;
var SCROLL_KEY;
var init_client = __esm({
  ".svelte-kit/output/server/chunks/client.js"() {
    init_exports();
    init_devalue();
    SNAPSHOT_KEY = "sveltekit:snapshot";
    SCROLL_KEY = "sveltekit:scroll";
    get(SCROLL_KEY) ?? {};
    get(SNAPSHOT_KEY) ?? {};
  }
});
var layout_svelte_exports = {};
__export(layout_svelte_exports, {
  default: () => Layout
});
function setInitialMode(defaultMode, themeColors2) {
  const rootEl = document.documentElement;
  const mode = localStorage.getItem("mode-watcher-mode") || defaultMode;
  const light = mode === "light" || mode === "system" && window.matchMedia("(prefers-color-scheme: light)").matches;
  rootEl.classList[light ? "remove" : "add"]("dark");
  rootEl.style.colorScheme = light ? "light" : "dark";
  if (themeColors2) {
    const themeMetaEl = document.querySelector('meta[name="theme-color"]');
    if (themeMetaEl) {
      themeMetaEl.setAttribute("content", mode === "light" ? themeColors2.light : themeColors2.dark);
    }
  }
  localStorage.setItem("mode-watcher-mode", mode);
}
var Mode_watcher;
var css$1;
var ProgressBar;
var Tailwind_indicator;
var css;
var Layout;
var init_layout_svelte = __esm({
  ".svelte-kit/output/server/entries/pages/_layout.svelte.js"() {
    init_ssr();
    init_stores();
    init_client();
    Mode_watcher = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { track = true } = $$props;
      let { defaultMode = "system" } = $$props;
      let { themeColors: themeColors$1 = void 0 } = $$props;
      themeColors.set(themeColors$1);
      const args = `"${defaultMode}"${themeColors$1 ? `, ${JSON.stringify(themeColors$1)}` : ""}`;
      if ($$props.track === void 0 && $$bindings.track && track !== void 0)
        $$bindings.track(track);
      if ($$props.defaultMode === void 0 && $$bindings.defaultMode && defaultMode !== void 0)
        $$bindings.defaultMode(defaultMode);
      if ($$props.themeColors === void 0 && $$bindings.themeColors && themeColors$1 !== void 0)
        $$bindings.themeColors(themeColors$1);
      return `${$$result.head += `<!-- HEAD_svelte-cpyj77_START -->${themeColors$1 ? `   <meta name="theme-color"${add_attribute("content", themeColors$1.dark, 0)}>` : ``}<!-- HTML_TAG_START -->${`<script nonce="%sveltekit.nonce%">(` + setInitialMode.toString() + `)(` + args + `);<\/script>`}<!-- HTML_TAG_END --><!-- HEAD_svelte-cpyj77_END -->`, ""}`;
    });
    css$1 = {
      code: ".svelte-progress-bar.svelte-1rjlpd{position:fixed;top:0;left:0;height:3px;transition:width 0.21s ease-in-out}.svelte-progress-bar-hiding.svelte-1rjlpd{transition:top 0.8s ease;top:-8px}.svelte-progress-bar-leader.svelte-1rjlpd{position:absolute;top:0;right:0;height:5px;width:100px;transform:rotate(2.5deg) translate(0px, -4px);box-shadow:0 0 8px}",
      map: null
    };
    ProgressBar = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      const getIncrement = (n2) => {
        if (n2 >= 0 && n2 < 0.2)
          return 0.1;
        else if (n2 >= 0.2 && n2 < 0.5)
          return 0.04;
        else if (n2 >= 0.5 && n2 < 0.8)
          return 0.02;
        else if (n2 >= 0.8 && n2 < 0.99)
          return 5e-3;
        return 0;
      };
      let running = false;
      let updater = null;
      let completed = false;
      let width = 0;
      let { id: id2 = void 0 } = $$props;
      let { busy = false } = $$props;
      let { color = "currentColor" } = $$props;
      let { class: textColorClass = "" } = $$props;
      let { zIndex = 1 } = $$props;
      let { minimum: defaultMinimum = 0.08 } = $$props;
      let { maximum = 0.994 } = $$props;
      let { settleTime: defaultSettleTime = 700 } = $$props;
      let { intervalTime = 700 } = $$props;
      let { stepSizes = [0, 5e-3, 0.01, 0.02] } = $$props;
      const reset2 = (minimum = defaultMinimum) => {
        width = minimum;
        running = true;
      };
      const animate = () => {
        if (updater) {
          clearInterval(updater);
        }
        running = true;
        updater = setInterval(
          () => {
            const randomStep = stepSizes[Math.floor(Math.random() * stepSizes.length)] ?? 0;
            const step = getIncrement(width) + randomStep;
            if (width < maximum) {
              width = width + step;
            }
            if (width > maximum) {
              width = maximum;
              stop();
            }
          },
          intervalTime
        );
      };
      const start = (minimum) => {
        reset2(minimum);
        animate();
      };
      const stop = () => {
        if (updater) {
          clearInterval(updater);
        }
      };
      const complete = (settleTime = defaultSettleTime) => {
        if (updater)
          clearInterval(updater);
        if (!running)
          return;
        width = 1;
        running = false;
        setTimeout(
          () => {
            completed = true;
            setTimeout(
              () => {
                completed = false;
                width = 0;
              },
              settleTime
            );
          },
          settleTime
        );
      };
      const setWidthRatio = (widthRatio) => {
        stop();
        width = widthRatio;
        completed = false;
        running = true;
      };
      const getState2 = () => {
        return {
          width,
          running,
          completed,
          color,
          defaultMinimum,
          maximum,
          defaultSettleTime,
          intervalTime,
          stepSizes
        };
      };
      let barStyle;
      let leaderColorStyle;
      let { displayThresholdMs = 150 } = $$props;
      let { noNavigationProgress = false } = $$props;
      if ($$props.id === void 0 && $$bindings.id && id2 !== void 0)
        $$bindings.id(id2);
      if ($$props.busy === void 0 && $$bindings.busy && busy !== void 0)
        $$bindings.busy(busy);
      if ($$props.color === void 0 && $$bindings.color && color !== void 0)
        $$bindings.color(color);
      if ($$props.class === void 0 && $$bindings.class && textColorClass !== void 0)
        $$bindings.class(textColorClass);
      if ($$props.zIndex === void 0 && $$bindings.zIndex && zIndex !== void 0)
        $$bindings.zIndex(zIndex);
      if ($$props.minimum === void 0 && $$bindings.minimum && defaultMinimum !== void 0)
        $$bindings.minimum(defaultMinimum);
      if ($$props.maximum === void 0 && $$bindings.maximum && maximum !== void 0)
        $$bindings.maximum(maximum);
      if ($$props.settleTime === void 0 && $$bindings.settleTime && defaultSettleTime !== void 0)
        $$bindings.settleTime(defaultSettleTime);
      if ($$props.intervalTime === void 0 && $$bindings.intervalTime && intervalTime !== void 0)
        $$bindings.intervalTime(intervalTime);
      if ($$props.stepSizes === void 0 && $$bindings.stepSizes && stepSizes !== void 0)
        $$bindings.stepSizes(stepSizes);
      if ($$props.reset === void 0 && $$bindings.reset && reset2 !== void 0)
        $$bindings.reset(reset2);
      if ($$props.animate === void 0 && $$bindings.animate && animate !== void 0)
        $$bindings.animate(animate);
      if ($$props.start === void 0 && $$bindings.start && start !== void 0)
        $$bindings.start(start);
      if ($$props.stop === void 0 && $$bindings.stop && stop !== void 0)
        $$bindings.stop(stop);
      if ($$props.complete === void 0 && $$bindings.complete && complete !== void 0)
        $$bindings.complete(complete);
      if ($$props.setWidthRatio === void 0 && $$bindings.setWidthRatio && setWidthRatio !== void 0)
        $$bindings.setWidthRatio(setWidthRatio);
      if ($$props.getState === void 0 && $$bindings.getState && getState2 !== void 0)
        $$bindings.getState(getState2);
      if ($$props.displayThresholdMs === void 0 && $$bindings.displayThresholdMs && displayThresholdMs !== void 0)
        $$bindings.displayThresholdMs(displayThresholdMs);
      if ($$props.noNavigationProgress === void 0 && $$bindings.noNavigationProgress && noNavigationProgress !== void 0)
        $$bindings.noNavigationProgress(noNavigationProgress);
      $$result.css.add(css$1);
      running = busy;
      barStyle = (color ? `background-color: ${color};` : "") + (width && width * 100 ? `width: ${width * 100}%;` : "") + `z-index: ${zIndex};`;
      leaderColorStyle = (color ? `background-color: ${color}; color: ${color};` : "") + `z-index: ${zIndex + 1};`;
      return `  ${running || width > 0 ? `<output${add_attribute("id", id2, 0)} role="progressbar"${add_attribute("aria-valuenow", width, 0)}${add_attribute("aria-valuemin", 0, 0)}${add_attribute("aria-valuemax", 1, 0)} class="${[
        "svelte-progress-bar " + escape(textColorClass, true) + " svelte-1rjlpd",
        (running ? "running" : "") + " " + (completed ? "svelte-progress-bar-hiding" : "")
      ].join(" ").trim()}"${add_attribute("style", barStyle, 0)}>${running ? `<div class="svelte-progress-bar-leader svelte-1rjlpd"${add_attribute("style", leaderColorStyle, 0)}></div>` : ``}</output>` : ``}`;
    });
    Tailwind_indicator = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `${true ? `<div class="fixed bottom-1 right-1 z-50 flex h-6 w-6 items-center justify-center rounded-full bg-gray-800 p-3 font-mono text-xs text-white" data-svelte-h="svelte-e37xxc"><div class="block sm:hidden">xs</div> <div class="hidden sm:block md:hidden lg:hidden xl:hidden 2xl:hidden">sm</div> <div class="hidden md:block lg:hidden xl:hidden 2xl:hidden">md</div> <div class="hidden lg:block xl:hidden 2xl:hidden">lg</div> <div class="hidden xl:block 2xl:hidden">xl</div> <div class="hidden 2xl:block">2xl</div></div>` : ``}`;
    });
    css = {
      code: "body{font-family:'Inter Variable'}",
      map: null
    };
    Layout = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      $$result.css.add(css);
      return `${$$result.head += `<!-- HEAD_svelte-ennwre_START -->${$$result.title = `<title>Ria Busana</title>`, ""}<meta name="description" content="Ria Busana Konstruksi"><!-- HEAD_svelte-ennwre_END -->`, ""} ${validate_component(ProgressBar, "ProgressBar").$$render($$result, { class: "text-blue-500", zIndex: 99 }, {}, {})} ${slots.default ? slots.default({}) : ``} ${validate_component(Mode_watcher, "ModeWatcher").$$render($$result, {}, {}, {})} ${validate_component(Tailwind_indicator, "TailwindIndicator").$$render($$result, {}, {}, {})}`;
    });
  }
});
var __exports = {};
__export(__exports, {
  component: () => component,
  fonts: () => fonts,
  imports: () => imports,
  index: () => index,
  server: () => layout_server_ts_exports,
  server_id: () => server_id,
  stylesheets: () => stylesheets
});
var index;
var component_cache;
var component;
var server_id;
var imports;
var stylesheets;
var fonts;
var init__ = __esm({
  ".svelte-kit/output/server/nodes/0.js"() {
    init_layout_server_ts();
    index = 0;
    component = async () => component_cache ??= (await Promise.resolve().then(() => (init_layout_svelte(), layout_svelte_exports))).default;
    server_id = "src/routes/+layout.server.ts";
    imports = ["_app/immutable/nodes/0.CvBs-dte.js", "_app/immutable/chunks/scheduler.Cglc-E-6.js", "_app/immutable/chunks/index.9iPnfnGV.js", "_app/immutable/chunks/mode.BQ9atwLW.js", "_app/immutable/chunks/index.C4PciY-_.js", "_app/immutable/chunks/entry.BIRdqJCX.js"];
    stylesheets = ["_app/immutable/assets/0.KKyKOcgj.css"];
    fonts = ["_app/immutable/assets/inter-cyrillic-ext-wght-normal.DIEz8p5i.woff2", "_app/immutable/assets/inter-cyrillic-wght-normal.BmJJXa8e.woff2", "_app/immutable/assets/inter-greek-ext-wght-normal.D5AYLNiq.woff2", "_app/immutable/assets/inter-greek-wght-normal.DyIDNIyN.woff2", "_app/immutable/assets/inter-vietnamese-wght-normal._GQuwPVU.woff2", "_app/immutable/assets/inter-latin-ext-wght-normal.CN1pIXkb.woff2", "_app/immutable/assets/inter-latin-wght-normal.BgVq2Tq4.woff2"];
  }
});
var getStores;
var page;
var navigating;
var init_stores2 = __esm({
  ".svelte-kit/output/server/chunks/stores2.js"() {
    init_lifecycle();
    init_client();
    getStores = () => {
      const stores = getContext("__svelte__");
      return {
        /** @type {typeof page} */
        page: {
          subscribe: stores.page.subscribe
        },
        /** @type {typeof navigating} */
        navigating: {
          subscribe: stores.navigating.subscribe
        },
        /** @type {typeof updated} */
        updated: stores.updated
      };
    };
    page = {
      subscribe(fn) {
        const store = getStores().page;
        return store.subscribe(fn);
      }
    };
    navigating = {
      subscribe(fn) {
        const store = getStores().navigating;
        return store.subscribe(fn);
      }
    };
  }
});
var error_svelte_exports = {};
__export(error_svelte_exports, {
  default: () => Error2
});
var Error2;
var init_error_svelte = __esm({
  ".svelte-kit/output/server/entries/fallbacks/error.svelte.js"() {
    init_lifecycle();
    init_ssr();
    init_stores2();
    Error2 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $page, $$unsubscribe_page;
      $$unsubscribe_page = subscribe(page, (value) => $page = value);
      $$unsubscribe_page();
      return `<h1>${escape($page.status)}</h1> <p>${escape($page.error?.message)}</p>`;
    });
  }
});
var __exports2 = {};
__export(__exports2, {
  component: () => component2,
  fonts: () => fonts2,
  imports: () => imports2,
  index: () => index2,
  stylesheets: () => stylesheets2
});
var index2;
var component_cache2;
var component2;
var imports2;
var stylesheets2;
var fonts2;
var init__2 = __esm({
  ".svelte-kit/output/server/nodes/1.js"() {
    index2 = 1;
    component2 = async () => component_cache2 ??= (await Promise.resolve().then(() => (init_error_svelte(), error_svelte_exports))).default;
    imports2 = ["_app/immutable/nodes/1.Dsw6JE4C.js", "_app/immutable/chunks/scheduler.Cglc-E-6.js", "_app/immutable/chunks/index.9iPnfnGV.js", "_app/immutable/chunks/stores.-qfiZ27n.js", "_app/immutable/chunks/entry.BIRdqJCX.js", "_app/immutable/chunks/index.C4PciY-_.js"];
    stylesheets2 = [];
    fonts2 = [];
  }
});
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function tick() {
  schedule_update();
  return resolved_promise;
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component15 = dirty_components[flushidx];
        flushidx++;
        set_current_component(component15);
        update(component15.$$);
      }
    } catch (e3) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e3;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i3 = 0; i3 < render_callbacks.length; i3 += 1) {
      const callback = render_callbacks[i3];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
var dirty_components;
var binding_callbacks;
var render_callbacks;
var flush_callbacks;
var resolved_promise;
var update_scheduled;
var seen_callbacks;
var flushidx;
var init_scheduler = __esm({
  ".svelte-kit/output/server/chunks/scheduler.js"() {
    init_lifecycle();
    dirty_components = [];
    binding_callbacks = [];
    render_callbacks = [];
    flush_callbacks = [];
    resolved_promise = /* @__PURE__ */ Promise.resolve();
    update_scheduled = false;
    seen_callbacks = /* @__PURE__ */ new Set();
    flushidx = 0;
  }
});
function clone(obj) {
  let result = obj;
  var type = {}.toString.call(obj).slice(8, -1);
  if (type == "Set") {
    return new Set([...obj].map((value) => clone(value)));
  }
  if (type == "Map") {
    return new Map([...obj].map((kv) => [clone(kv[0]), clone(kv[1])]));
  }
  if (type == "Date") {
    return new Date(obj.getTime());
  }
  if (type == "RegExp") {
    return RegExp(obj.source, getRegExpFlags(obj));
  }
  if (type == "Array" || type == "Object") {
    result = Array.isArray(obj) ? [] : {};
    for (var key2 in obj) {
      result[key2] = clone(obj[key2]);
    }
  }
  return result;
}
function getRegExpFlags(regExp) {
  if (typeof regExp.source.flags == "string") {
    return regExp.source.flags;
  } else {
    var flags = [];
    regExp.global && flags.push("g");
    regExp.ignoreCase && flags.push("i");
    regExp.multiline && flags.push("m");
    regExp.sticky && flags.push("y");
    regExp.unicode && flags.push("u");
    return flags.join("");
  }
}
var collectionClone;
var init_just_clone = __esm({
  "node_modules/just-clone/index.mjs"() {
    collectionClone = clone;
  }
});
var isObject2;
var merge;
var defaultOptions;
var init_esm = __esm({
  "node_modules/ts-deepmerge/esm/index.js"() {
    isObject2 = (obj) => {
      if (typeof obj === "object" && obj !== null) {
        if (typeof Object.getPrototypeOf === "function") {
          const prototype = Object.getPrototypeOf(obj);
          return prototype === Object.prototype || prototype === null;
        }
        return Object.prototype.toString.call(obj) === "[object Object]";
      }
      return false;
    };
    merge = (...objects) => objects.reduce((result, current) => {
      if (Array.isArray(current)) {
        throw new TypeError("Arguments provided to ts-deepmerge must be objects, not arrays.");
      }
      Object.keys(current).forEach((key2) => {
        if (["__proto__", "constructor", "prototype"].includes(key2)) {
          return;
        }
        if (Array.isArray(result[key2]) && Array.isArray(current[key2])) {
          result[key2] = merge.options.mergeArrays ? merge.options.uniqueArrayItems ? Array.from(new Set(result[key2].concat(current[key2]))) : [...result[key2], ...current[key2]] : current[key2];
        } else if (isObject2(result[key2]) && isObject2(current[key2])) {
          result[key2] = merge(result[key2], current[key2]);
        } else {
          result[key2] = current[key2] === void 0 ? merge.options.allowUndefinedOverrides ? current[key2] : result[key2] : current[key2];
        }
      });
      return result;
    }, {});
    defaultOptions = {
      allowUndefinedOverrides: true,
      mergeArrays: true,
      uniqueArrayItems: true
    };
    merge.options = defaultOptions;
    merge.withOptions = (options2, ...objects) => {
      merge.options = Object.assign(Object.assign({}, defaultOptions), options2);
      const result = merge(...objects);
      merge.options = defaultOptions;
      return result;
    };
  }
});
function addErrorMessage(res, key2, errorMessage, refs) {
  if (!refs?.errorMessages)
    return;
  if (errorMessage) {
    res.errorMessage = {
      ...res.errorMessage,
      [key2]: errorMessage
    };
  }
}
function setResponseValueAndErrors(res, key2, value, errorMessage, refs) {
  res[key2] = value;
  addErrorMessage(res, key2, errorMessage, refs);
}
var init_errorMessages = __esm({
  "node_modules/zod-to-json-schema/dist/esm/errorMessages.js"() {
  }
});
var defaultOptions2;
var getDefaultOptions;
var init_Options = __esm({
  "node_modules/zod-to-json-schema/dist/esm/Options.js"() {
    defaultOptions2 = {
      name: void 0,
      $refStrategy: "root",
      basePath: ["#"],
      effectStrategy: "input",
      pipeStrategy: "all",
      dateStrategy: "string",
      mapStrategy: "entries",
      definitionPath: "definitions",
      target: "jsonSchema7",
      strictUnions: false,
      definitions: {},
      errorMessages: false,
      markdownDescription: false,
      patternStrategy: "escape",
      emailStrategy: "format:email"
    };
    getDefaultOptions = (options2) => typeof options2 === "string" ? {
      ...defaultOptions2,
      name: options2
    } : {
      ...defaultOptions2,
      ...options2
    };
  }
});
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
      // then global default map
    ].filter((x4) => !!x4)
  });
  ctx.common.issues.push(issue);
}
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
function isValidIP(ip, version3) {
  if ((version3 === "v4" || !version3) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version3 === "v6" || !version3) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key2 in schema.shape) {
      const fieldSchema = schema.shape[key2];
      newShape[key2] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
function mergeValues(a2, b2) {
  const aType = getParsedType(a2);
  const bType = getParsedType(b2);
  if (a2 === b2) {
    return { valid: true, data: a2 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b2);
    const sharedKeys = util.objectKeys(a2).filter((key2) => bKeys.indexOf(key2) !== -1);
    const newObj = { ...a2, ...b2 };
    for (const key2 of sharedKeys) {
      const sharedValue = mergeValues(a2[key2], b2[key2]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key2] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a2.length !== b2.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index15 = 0; index15 < a2.length; index15++) {
      const itemA = a2[index15];
      const itemB = b2[index15];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a2 === +b2) {
    return { valid: true, data: a2 };
  } else {
    return { valid: false };
  }
}
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var util;
var objectUtil;
var ZodParsedType;
var getParsedType;
var ZodIssueCode;
var quotelessJson;
var ZodError;
var errorMap;
var overrideErrorMap;
var makeIssue;
var EMPTY_PATH;
var ParseStatus;
var INVALID;
var DIRTY;
var OK;
var isAborted;
var isDirty;
var isValid;
var isAsync;
var errorUtil;
var ParseInputLazyPath;
var handleResult;
var ZodType;
var cuidRegex;
var cuid2Regex;
var ulidRegex;
var uuidRegex;
var emailRegex;
var _emojiRegex;
var emojiRegex;
var ipv4Regex;
var ipv6Regex;
var datetimeRegex;
var ZodString;
var ZodNumber;
var ZodBigInt;
var ZodBoolean;
var ZodDate;
var ZodSymbol;
var ZodUndefined;
var ZodNull;
var ZodAny;
var ZodUnknown;
var ZodNever;
var ZodVoid;
var ZodArray;
var ZodObject;
var ZodUnion;
var getDiscriminator;
var ZodDiscriminatedUnion;
var ZodIntersection;
var ZodTuple;
var ZodRecord;
var ZodMap;
var ZodSet;
var ZodFunction;
var ZodLazy;
var ZodLiteral;
var ZodEnum;
var ZodNativeEnum;
var ZodPromise;
var ZodEffects;
var ZodOptional;
var ZodNullable;
var ZodDefault;
var ZodCatch;
var ZodNaN;
var BRAND;
var ZodBranded;
var ZodPipeline;
var ZodReadonly;
var custom;
var late;
var ZodFirstPartyTypeKind;
var instanceOfType;
var stringType;
var numberType;
var nanType;
var bigIntType;
var booleanType;
var dateType;
var symbolType;
var undefinedType;
var nullType;
var anyType;
var unknownType;
var neverType;
var voidType;
var arrayType;
var objectType;
var strictObjectType;
var unionType;
var discriminatedUnionType;
var intersectionType;
var tupleType;
var recordType;
var mapType;
var setType;
var functionType;
var lazyType;
var literalType;
var enumType;
var nativeEnumType;
var promiseType;
var effectsType;
var optionalType;
var nullableType;
var preprocessType;
var pipelineType;
var ostring;
var onumber;
var oboolean;
var coerce;
var NEVER;
var z2;
var init_lib = __esm({
  "node_modules/zod/lib/index.mjs"() {
    (function(util2) {
      util2.assertEqual = (val) => val;
      function assertIs(_arg) {
      }
      util2.assertIs = assertIs;
      function assertNever(_x) {
        throw new Error();
      }
      util2.assertNever = assertNever;
      util2.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
          obj[item] = item;
        }
        return obj;
      };
      util2.getValidEnumValues = (obj) => {
        const validKeys = util2.objectKeys(obj).filter((k2) => typeof obj[obj[k2]] !== "number");
        const filtered = {};
        for (const k2 of validKeys) {
          filtered[k2] = obj[k2];
        }
        return util2.objectValues(filtered);
      };
      util2.objectValues = (obj) => {
        return util2.objectKeys(obj).map(function(e3) {
          return obj[e3];
        });
      };
      util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
        const keys = [];
        for (const key2 in object) {
          if (Object.prototype.hasOwnProperty.call(object, key2)) {
            keys.push(key2);
          }
        }
        return keys;
      };
      util2.find = (arr, checker) => {
        for (const item of arr) {
          if (checker(item))
            return item;
        }
        return void 0;
      };
      util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
      function joinValues(array2, separator = " | ") {
        return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
      }
      util2.joinValues = joinValues;
      util2.jsonStringifyReplacer = (_, value) => {
        if (typeof value === "bigint") {
          return value.toString();
        }
        return value;
      };
    })(util || (util = {}));
    (function(objectUtil2) {
      objectUtil2.mergeShapes = (first, second) => {
        return {
          ...first,
          ...second
          // second overwrites first
        };
      };
    })(objectUtil || (objectUtil = {}));
    ZodParsedType = util.arrayToEnum([
      "string",
      "nan",
      "number",
      "integer",
      "float",
      "boolean",
      "date",
      "bigint",
      "symbol",
      "function",
      "undefined",
      "null",
      "array",
      "object",
      "unknown",
      "promise",
      "void",
      "never",
      "map",
      "set"
    ]);
    getParsedType = (data2) => {
      const t2 = typeof data2;
      switch (t2) {
        case "undefined":
          return ZodParsedType.undefined;
        case "string":
          return ZodParsedType.string;
        case "number":
          return isNaN(data2) ? ZodParsedType.nan : ZodParsedType.number;
        case "boolean":
          return ZodParsedType.boolean;
        case "function":
          return ZodParsedType.function;
        case "bigint":
          return ZodParsedType.bigint;
        case "symbol":
          return ZodParsedType.symbol;
        case "object":
          if (Array.isArray(data2)) {
            return ZodParsedType.array;
          }
          if (data2 === null) {
            return ZodParsedType.null;
          }
          if (data2.then && typeof data2.then === "function" && data2.catch && typeof data2.catch === "function") {
            return ZodParsedType.promise;
          }
          if (typeof Map !== "undefined" && data2 instanceof Map) {
            return ZodParsedType.map;
          }
          if (typeof Set !== "undefined" && data2 instanceof Set) {
            return ZodParsedType.set;
          }
          if (typeof Date !== "undefined" && data2 instanceof Date) {
            return ZodParsedType.date;
          }
          return ZodParsedType.object;
        default:
          return ZodParsedType.unknown;
      }
    };
    ZodIssueCode = util.arrayToEnum([
      "invalid_type",
      "invalid_literal",
      "custom",
      "invalid_union",
      "invalid_union_discriminator",
      "invalid_enum_value",
      "unrecognized_keys",
      "invalid_arguments",
      "invalid_return_type",
      "invalid_date",
      "invalid_string",
      "too_small",
      "too_big",
      "invalid_intersection_types",
      "not_multiple_of",
      "not_finite"
    ]);
    quotelessJson = (obj) => {
      const json2 = JSON.stringify(obj, null, 2);
      return json2.replace(/"([^"]+)":/g, "$1:");
    };
    ZodError = class extends Error {
      constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
          this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
          this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(this, actualProto);
        } else {
          this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
      }
      get errors() {
        return this.issues;
      }
      format(_mapper) {
        const mapper = _mapper || function(issue) {
          return issue.message;
        };
        const fieldErrors = { _errors: [] };
        const processError = (error) => {
          for (const issue of error.issues) {
            if (issue.code === "invalid_union") {
              issue.unionErrors.map(processError);
            } else if (issue.code === "invalid_return_type") {
              processError(issue.returnTypeError);
            } else if (issue.code === "invalid_arguments") {
              processError(issue.argumentsError);
            } else if (issue.path.length === 0) {
              fieldErrors._errors.push(mapper(issue));
            } else {
              let curr = fieldErrors;
              let i3 = 0;
              while (i3 < issue.path.length) {
                const el = issue.path[i3];
                const terminal = i3 === issue.path.length - 1;
                if (!terminal) {
                  curr[el] = curr[el] || { _errors: [] };
                } else {
                  curr[el] = curr[el] || { _errors: [] };
                  curr[el]._errors.push(mapper(issue));
                }
                curr = curr[el];
                i3++;
              }
            }
          }
        };
        processError(this);
        return fieldErrors;
      }
      toString() {
        return this.message;
      }
      get message() {
        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
      }
      get isEmpty() {
        return this.issues.length === 0;
      }
      flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
          if (sub.path.length > 0) {
            fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
            fieldErrors[sub.path[0]].push(mapper(sub));
          } else {
            formErrors.push(mapper(sub));
          }
        }
        return { formErrors, fieldErrors };
      }
      get formErrors() {
        return this.flatten();
      }
    };
    ZodError.create = (issues) => {
      const error = new ZodError(issues);
      return error;
    };
    errorMap = (issue, _ctx) => {
      let message;
      switch (issue.code) {
        case ZodIssueCode.invalid_type:
          if (issue.received === ZodParsedType.undefined) {
            message = "Required";
          } else {
            message = `Expected ${issue.expected}, received ${issue.received}`;
          }
          break;
        case ZodIssueCode.invalid_literal:
          message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
          break;
        case ZodIssueCode.unrecognized_keys:
          message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
          break;
        case ZodIssueCode.invalid_union:
          message = `Invalid input`;
          break;
        case ZodIssueCode.invalid_union_discriminator:
          message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
          break;
        case ZodIssueCode.invalid_enum_value:
          message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
          break;
        case ZodIssueCode.invalid_arguments:
          message = `Invalid function arguments`;
          break;
        case ZodIssueCode.invalid_return_type:
          message = `Invalid function return type`;
          break;
        case ZodIssueCode.invalid_date:
          message = `Invalid date`;
          break;
        case ZodIssueCode.invalid_string:
          if (typeof issue.validation === "object") {
            if ("includes" in issue.validation) {
              message = `Invalid input: must include "${issue.validation.includes}"`;
              if (typeof issue.validation.position === "number") {
                message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
              }
            } else if ("startsWith" in issue.validation) {
              message = `Invalid input: must start with "${issue.validation.startsWith}"`;
            } else if ("endsWith" in issue.validation) {
              message = `Invalid input: must end with "${issue.validation.endsWith}"`;
            } else {
              util.assertNever(issue.validation);
            }
          } else if (issue.validation !== "regex") {
            message = `Invalid ${issue.validation}`;
          } else {
            message = "Invalid";
          }
          break;
        case ZodIssueCode.too_small:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
          else
            message = "Invalid input";
          break;
        case ZodIssueCode.too_big:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "bigint")
            message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
          else
            message = "Invalid input";
          break;
        case ZodIssueCode.custom:
          message = `Invalid input`;
          break;
        case ZodIssueCode.invalid_intersection_types:
          message = `Intersection results could not be merged`;
          break;
        case ZodIssueCode.not_multiple_of:
          message = `Number must be a multiple of ${issue.multipleOf}`;
          break;
        case ZodIssueCode.not_finite:
          message = "Number must be finite";
          break;
        default:
          message = _ctx.defaultError;
          util.assertNever(issue);
      }
      return { message };
    };
    overrideErrorMap = errorMap;
    makeIssue = (params) => {
      const { data: data2, path, errorMaps, issueData } = params;
      const fullPath = [...path, ...issueData.path || []];
      const fullIssue = {
        ...issueData,
        path: fullPath
      };
      let errorMessage = "";
      const maps = errorMaps.filter((m) => !!m).slice().reverse();
      for (const map of maps) {
        errorMessage = map(fullIssue, { data: data2, defaultError: errorMessage }).message;
      }
      return {
        ...issueData,
        path: fullPath,
        message: issueData.message || errorMessage
      };
    };
    EMPTY_PATH = [];
    ParseStatus = class _ParseStatus {
      constructor() {
        this.value = "valid";
      }
      dirty() {
        if (this.value === "valid")
          this.value = "dirty";
      }
      abort() {
        if (this.value !== "aborted")
          this.value = "aborted";
      }
      static mergeArray(status, results) {
        const arrayValue = [];
        for (const s3 of results) {
          if (s3.status === "aborted")
            return INVALID;
          if (s3.status === "dirty")
            status.dirty();
          arrayValue.push(s3.value);
        }
        return { status: status.value, value: arrayValue };
      }
      static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
          syncPairs.push({
            key: await pair.key,
            value: await pair.value
          });
        }
        return _ParseStatus.mergeObjectSync(status, syncPairs);
      }
      static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
          const { key: key2, value } = pair;
          if (key2.status === "aborted")
            return INVALID;
          if (value.status === "aborted")
            return INVALID;
          if (key2.status === "dirty")
            status.dirty();
          if (value.status === "dirty")
            status.dirty();
          if (key2.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
            finalObject[key2.value] = value.value;
          }
        }
        return { status: status.value, value: finalObject };
      }
    };
    INVALID = Object.freeze({
      status: "aborted"
    });
    DIRTY = (value) => ({ status: "dirty", value });
    OK = (value) => ({ status: "valid", value });
    isAborted = (x4) => x4.status === "aborted";
    isDirty = (x4) => x4.status === "dirty";
    isValid = (x4) => x4.status === "valid";
    isAsync = (x4) => typeof Promise !== "undefined" && x4 instanceof Promise;
    (function(errorUtil2) {
      errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
      errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
    })(errorUtil || (errorUtil = {}));
    ParseInputLazyPath = class {
      constructor(parent, value, path, key2) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key2;
      }
      get path() {
        if (!this._cachedPath.length) {
          if (this._key instanceof Array) {
            this._cachedPath.push(...this._path, ...this._key);
          } else {
            this._cachedPath.push(...this._path, this._key);
          }
        }
        return this._cachedPath;
      }
    };
    handleResult = (ctx, result) => {
      if (isValid(result)) {
        return { success: true, data: result.value };
      } else {
        if (!ctx.common.issues.length) {
          throw new Error("Validation failed but no issues detected.");
        }
        return {
          success: false,
          get error() {
            if (this._error)
              return this._error;
            const error = new ZodError(ctx.common.issues);
            this._error = error;
            return this._error;
          }
        };
      }
    };
    ZodType = class {
      constructor(def) {
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
      }
      get description() {
        return this._def.description;
      }
      _getType(input) {
        return getParsedType(input.data);
      }
      _getOrReturnCtx(input, ctx) {
        return ctx || {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        };
      }
      _processInputParams(input) {
        return {
          status: new ParseStatus(),
          ctx: {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
          }
        };
      }
      _parseSync(input) {
        const result = this._parse(input);
        if (isAsync(result)) {
          throw new Error("Synchronous parse encountered promise.");
        }
        return result;
      }
      _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
      }
      parse(data2, params) {
        const result = this.safeParse(data2, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      safeParse(data2, params) {
        var _a2;
        const ctx = {
          common: {
            issues: [],
            async: (_a2 = params === null || params === void 0 ? void 0 : params.async) !== null && _a2 !== void 0 ? _a2 : false,
            contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
          },
          path: (params === null || params === void 0 ? void 0 : params.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data: data2,
          parsedType: getParsedType(data2)
        };
        const result = this._parseSync({ data: data2, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
      }
      async parseAsync(data2, params) {
        const result = await this.safeParseAsync(data2, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      async safeParseAsync(data2, params) {
        const ctx = {
          common: {
            issues: [],
            contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
            async: true
          },
          path: (params === null || params === void 0 ? void 0 : params.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data: data2,
          parsedType: getParsedType(data2)
        };
        const maybeAsyncResult = this._parse({ data: data2, path: ctx.path, parent: ctx });
        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
      }
      refine(check, message) {
        const getIssueProperties = (val) => {
          if (typeof message === "string" || typeof message === "undefined") {
            return { message };
          } else if (typeof message === "function") {
            return message(val);
          } else {
            return message;
          }
        };
        return this._refinement((val, ctx) => {
          const result = check(val);
          const setError = () => ctx.addIssue({
            code: ZodIssueCode.custom,
            ...getIssueProperties(val)
          });
          if (typeof Promise !== "undefined" && result instanceof Promise) {
            return result.then((data2) => {
              if (!data2) {
                setError();
                return false;
              } else {
                return true;
              }
            });
          }
          if (!result) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      refinement(check, refinementData) {
        return this._refinement((val, ctx) => {
          if (!check(val)) {
            ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
            return false;
          } else {
            return true;
          }
        });
      }
      _refinement(refinement) {
        return new ZodEffects({
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "refinement", refinement }
        });
      }
      superRefine(refinement) {
        return this._refinement(refinement);
      }
      optional() {
        return ZodOptional.create(this, this._def);
      }
      nullable() {
        return ZodNullable.create(this, this._def);
      }
      nullish() {
        return this.nullable().optional();
      }
      array() {
        return ZodArray.create(this, this._def);
      }
      promise() {
        return ZodPromise.create(this, this._def);
      }
      or(option) {
        return ZodUnion.create([this, option], this._def);
      }
      and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
      }
      transform(transform) {
        return new ZodEffects({
          ...processCreateParams(this._def),
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "transform", transform }
        });
      }
      default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
          ...processCreateParams(this._def),
          innerType: this,
          defaultValue: defaultValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodDefault
        });
      }
      brand() {
        return new ZodBranded({
          typeName: ZodFirstPartyTypeKind.ZodBranded,
          type: this,
          ...processCreateParams(this._def)
        });
      }
      catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch({
          ...processCreateParams(this._def),
          innerType: this,
          catchValue: catchValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodCatch
        });
      }
      describe(description) {
        const This = this.constructor;
        return new This({
          ...this._def,
          description
        });
      }
      pipe(target) {
        return ZodPipeline.create(this, target);
      }
      readonly() {
        return ZodReadonly.create(this);
      }
      isOptional() {
        return this.safeParse(void 0).success;
      }
      isNullable() {
        return this.safeParse(null).success;
      }
    };
    cuidRegex = /^c[^\s-]{8,}$/i;
    cuid2Regex = /^[a-z][a-z0-9]*$/;
    ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
    uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
    emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
    _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
    ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
    ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
    datetimeRegex = (args) => {
      if (args.precision) {
        if (args.offset) {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        } else {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
        }
      } else if (args.precision === 0) {
        if (args.offset) {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        } else {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
        }
      } else {
        if (args.offset) {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        } else {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
        }
      }
    };
    ZodString = class _ZodString extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.string) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(
            ctx2,
            {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.string,
              received: ctx2.parsedType
            }
            //
          );
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.length < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.length > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "length") {
            const tooBig = input.data.length > check.value;
            const tooSmall = input.data.length < check.value;
            if (tooBig || tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              if (tooBig) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  maximum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              } else if (tooSmall) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  minimum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              }
              status.dirty();
            }
          } else if (check.kind === "email") {
            if (!emailRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "email",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "emoji") {
            if (!emojiRegex) {
              emojiRegex = new RegExp(_emojiRegex, "u");
            }
            if (!emojiRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "emoji",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "uuid") {
            if (!uuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "uuid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid") {
            if (!cuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cuid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid2") {
            if (!cuid2Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cuid2",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ulid") {
            if (!ulidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "ulid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "url") {
            try {
              new URL(input.data);
            } catch (_a2) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "url",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "regex") {
            check.regex.lastIndex = 0;
            const testResult = check.regex.test(input.data);
            if (!testResult) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "regex",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "trim") {
            input.data = input.data.trim();
          } else if (check.kind === "includes") {
            if (!input.data.includes(check.value, check.position)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { includes: check.value, position: check.position },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "toLowerCase") {
            input.data = input.data.toLowerCase();
          } else if (check.kind === "toUpperCase") {
            input.data = input.data.toUpperCase();
          } else if (check.kind === "startsWith") {
            if (!input.data.startsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { startsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "endsWith") {
            if (!input.data.endsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { endsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "datetime") {
            const regex = datetimeRegex(check);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "datetime",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ip") {
            if (!isValidIP(input.data, check.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "ip",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      _regex(regex, validation, message) {
        return this.refinement((data2) => regex.test(data2), {
          validation,
          code: ZodIssueCode.invalid_string,
          ...errorUtil.errToObj(message)
        });
      }
      _addCheck(check) {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      email(message) {
        return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
      }
      url(message) {
        return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
      }
      emoji(message) {
        return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
      }
      uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
      }
      cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
      }
      cuid2(message) {
        return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
      }
      ulid(message) {
        return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
      }
      ip(options2) {
        return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options2) });
      }
      datetime(options2) {
        var _a2;
        if (typeof options2 === "string") {
          return this._addCheck({
            kind: "datetime",
            precision: null,
            offset: false,
            message: options2
          });
        }
        return this._addCheck({
          kind: "datetime",
          precision: typeof (options2 === null || options2 === void 0 ? void 0 : options2.precision) === "undefined" ? null : options2 === null || options2 === void 0 ? void 0 : options2.precision,
          offset: (_a2 = options2 === null || options2 === void 0 ? void 0 : options2.offset) !== null && _a2 !== void 0 ? _a2 : false,
          ...errorUtil.errToObj(options2 === null || options2 === void 0 ? void 0 : options2.message)
        });
      }
      regex(regex, message) {
        return this._addCheck({
          kind: "regex",
          regex,
          ...errorUtil.errToObj(message)
        });
      }
      includes(value, options2) {
        return this._addCheck({
          kind: "includes",
          value,
          position: options2 === null || options2 === void 0 ? void 0 : options2.position,
          ...errorUtil.errToObj(options2 === null || options2 === void 0 ? void 0 : options2.message)
        });
      }
      startsWith(value, message) {
        return this._addCheck({
          kind: "startsWith",
          value,
          ...errorUtil.errToObj(message)
        });
      }
      endsWith(value, message) {
        return this._addCheck({
          kind: "endsWith",
          value,
          ...errorUtil.errToObj(message)
        });
      }
      min(minLength, message) {
        return this._addCheck({
          kind: "min",
          value: minLength,
          ...errorUtil.errToObj(message)
        });
      }
      max(maxLength, message) {
        return this._addCheck({
          kind: "max",
          value: maxLength,
          ...errorUtil.errToObj(message)
        });
      }
      length(len, message) {
        return this._addCheck({
          kind: "length",
          value: len,
          ...errorUtil.errToObj(message)
        });
      }
      /**
       * @deprecated Use z.string().min(1) instead.
       * @see {@link ZodString.min}
       */
      nonempty(message) {
        return this.min(1, errorUtil.errToObj(message));
      }
      trim() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "trim" }]
        });
      }
      toLowerCase() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toLowerCase" }]
        });
      }
      toUpperCase() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toUpperCase" }]
        });
      }
      get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
      }
      get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
      }
      get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
      }
      get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
      }
      get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
      }
      get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
      }
      get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
      }
      get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
      }
      get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
      }
      get minLength() {
        let min2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min2 === null || ch.value > min2)
              min2 = ch.value;
          }
        }
        return min2;
      }
      get maxLength() {
        let max2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max2 === null || ch.value < max2)
              max2 = ch.value;
          }
        }
        return max2;
      }
    };
    ZodString.create = (params) => {
      var _a2;
      return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: (_a2 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a2 !== void 0 ? _a2 : false,
        ...processCreateParams(params)
      });
    };
    ZodNumber = class _ZodNumber extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.number) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.number,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        let ctx = void 0;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "int") {
            if (!util.isInteger(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: "integer",
                received: "float",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (floatSafeRemainder(input.data, check.value) !== 0) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "finite") {
            if (!Number.isFinite(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_finite,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new _ZodNumber({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new _ZodNumber({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      int(message) {
        return this._addCheck({
          kind: "int",
          message: errorUtil.toString(message)
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil.toString(message)
        });
      }
      finite(message) {
        return this._addCheck({
          kind: "finite",
          message: errorUtil.toString(message)
        });
      }
      safe(message) {
        return this._addCheck({
          kind: "min",
          inclusive: true,
          value: Number.MIN_SAFE_INTEGER,
          message: errorUtil.toString(message)
        })._addCheck({
          kind: "max",
          inclusive: true,
          value: Number.MAX_SAFE_INTEGER,
          message: errorUtil.toString(message)
        });
      }
      get minValue() {
        let min2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min2 === null || ch.value > min2)
              min2 = ch.value;
          }
        }
        return min2;
      }
      get maxValue() {
        let max2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max2 === null || ch.value < max2)
              max2 = ch.value;
          }
        }
        return max2;
      }
      get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
      }
      get isFinite() {
        let max2 = null, min2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
            return true;
          } else if (ch.kind === "min") {
            if (min2 === null || ch.value > min2)
              min2 = ch.value;
          } else if (ch.kind === "max") {
            if (max2 === null || ch.value < max2)
              max2 = ch.value;
          }
        }
        return Number.isFinite(min2) && Number.isFinite(max2);
      }
    };
    ZodNumber.create = (params) => {
      return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params)
      });
    };
    ZodBigInt = class _ZodBigInt extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = BigInt(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.bigint) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.bigint,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        let ctx = void 0;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                type: "bigint",
                minimum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                type: "bigint",
                maximum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (input.data % check.value !== BigInt(0)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new _ZodBigInt({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new _ZodBigInt({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil.toString(message)
        });
      }
      get minValue() {
        let min2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min2 === null || ch.value > min2)
              min2 = ch.value;
          }
        }
        return min2;
      }
      get maxValue() {
        let max2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max2 === null || ch.value < max2)
              max2 = ch.value;
          }
        }
        return max2;
      }
    };
    ZodBigInt.create = (params) => {
      var _a2;
      return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: (_a2 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a2 !== void 0 ? _a2 : false,
        ...processCreateParams(params)
      });
    };
    ZodBoolean = class extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.boolean) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.boolean,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodBoolean.create = (params) => {
      return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params)
      });
    };
    ZodDate = class _ZodDate extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.date) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.date,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        if (isNaN(input.data.getTime())) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_date
          });
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.getTime() < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                message: check.message,
                inclusive: true,
                exact: false,
                minimum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.getTime() > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                message: check.message,
                inclusive: true,
                exact: false,
                maximum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return {
          status: status.value,
          value: new Date(input.data.getTime())
        };
      }
      _addCheck(check) {
        return new _ZodDate({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      min(minDate, message) {
        return this._addCheck({
          kind: "min",
          value: minDate.getTime(),
          message: errorUtil.toString(message)
        });
      }
      max(maxDate, message) {
        return this._addCheck({
          kind: "max",
          value: maxDate.getTime(),
          message: errorUtil.toString(message)
        });
      }
      get minDate() {
        let min2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min2 === null || ch.value > min2)
              min2 = ch.value;
          }
        }
        return min2 != null ? new Date(min2) : null;
      }
      get maxDate() {
        let max2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max2 === null || ch.value < max2)
              max2 = ch.value;
          }
        }
        return max2 != null ? new Date(max2) : null;
      }
    };
    ZodDate.create = (params) => {
      return new ZodDate({
        checks: [],
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params)
      });
    };
    ZodSymbol = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.symbol) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.symbol,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodSymbol.create = (params) => {
      return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params)
      });
    };
    ZodUndefined = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.undefined,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodUndefined.create = (params) => {
      return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params)
      });
    };
    ZodNull = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.null) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.null,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodNull.create = (params) => {
      return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params)
      });
    };
    ZodAny = class extends ZodType {
      constructor() {
        super(...arguments);
        this._any = true;
      }
      _parse(input) {
        return OK(input.data);
      }
    };
    ZodAny.create = (params) => {
      return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params)
      });
    };
    ZodUnknown = class extends ZodType {
      constructor() {
        super(...arguments);
        this._unknown = true;
      }
      _parse(input) {
        return OK(input.data);
      }
    };
    ZodUnknown.create = (params) => {
      return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params)
      });
    };
    ZodNever = class extends ZodType {
      _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.never,
          received: ctx.parsedType
        });
        return INVALID;
      }
    };
    ZodNever.create = (params) => {
      return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params)
      });
    };
    ZodVoid = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.void,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodVoid.create = (params) => {
      return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params)
      });
    };
    ZodArray = class _ZodArray extends ZodType {
      _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.array,
            received: ctx.parsedType
          });
          return INVALID;
        }
        if (def.exactLength !== null) {
          const tooBig = ctx.data.length > def.exactLength.value;
          const tooSmall = ctx.data.length < def.exactLength.value;
          if (tooBig || tooSmall) {
            addIssueToContext(ctx, {
              code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
              minimum: tooSmall ? def.exactLength.value : void 0,
              maximum: tooBig ? def.exactLength.value : void 0,
              type: "array",
              inclusive: true,
              exact: true,
              message: def.exactLength.message
            });
            status.dirty();
          }
        }
        if (def.minLength !== null) {
          if (ctx.data.length < def.minLength.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: def.minLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.minLength.message
            });
            status.dirty();
          }
        }
        if (def.maxLength !== null) {
          if (ctx.data.length > def.maxLength.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: def.maxLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.maxLength.message
            });
            status.dirty();
          }
        }
        if (ctx.common.async) {
          return Promise.all([...ctx.data].map((item, i3) => {
            return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i3));
          })).then((result2) => {
            return ParseStatus.mergeArray(status, result2);
          });
        }
        const result = [...ctx.data].map((item, i3) => {
          return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i3));
        });
        return ParseStatus.mergeArray(status, result);
      }
      get element() {
        return this._def.type;
      }
      min(minLength, message) {
        return new _ZodArray({
          ...this._def,
          minLength: { value: minLength, message: errorUtil.toString(message) }
        });
      }
      max(maxLength, message) {
        return new _ZodArray({
          ...this._def,
          maxLength: { value: maxLength, message: errorUtil.toString(message) }
        });
      }
      length(len, message) {
        return new _ZodArray({
          ...this._def,
          exactLength: { value: len, message: errorUtil.toString(message) }
        });
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    ZodArray.create = (schema, params) => {
      return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params)
      });
    };
    ZodObject = class _ZodObject extends ZodType {
      constructor() {
        super(...arguments);
        this._cached = null;
        this.nonstrict = this.passthrough;
        this.augment = this.extend;
      }
      _getCached() {
        if (this._cached !== null)
          return this._cached;
        const shape = this._def.shape();
        const keys = util.objectKeys(shape);
        return this._cached = { shape, keys };
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.object) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
          for (const key2 in ctx.data) {
            if (!shapeKeys.includes(key2)) {
              extraKeys.push(key2);
            }
          }
        }
        const pairs = [];
        for (const key2 of shapeKeys) {
          const keyValidator = shape[key2];
          const value = ctx.data[key2];
          pairs.push({
            key: { status: "valid", value: key2 },
            value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key2)),
            alwaysSet: key2 in ctx.data
          });
        }
        if (this._def.catchall instanceof ZodNever) {
          const unknownKeys = this._def.unknownKeys;
          if (unknownKeys === "passthrough") {
            for (const key2 of extraKeys) {
              pairs.push({
                key: { status: "valid", value: key2 },
                value: { status: "valid", value: ctx.data[key2] }
              });
            }
          } else if (unknownKeys === "strict") {
            if (extraKeys.length > 0) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.unrecognized_keys,
                keys: extraKeys
              });
              status.dirty();
            }
          } else if (unknownKeys === "strip")
            ;
          else {
            throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
          }
        } else {
          const catchall = this._def.catchall;
          for (const key2 of extraKeys) {
            const value = ctx.data[key2];
            pairs.push({
              key: { status: "valid", value: key2 },
              value: catchall._parse(
                new ParseInputLazyPath(ctx, value, ctx.path, key2)
                //, ctx.child(key), value, getParsedType(value)
              ),
              alwaysSet: key2 in ctx.data
            });
          }
        }
        if (ctx.common.async) {
          return Promise.resolve().then(async () => {
            const syncPairs = [];
            for (const pair of pairs) {
              const key2 = await pair.key;
              syncPairs.push({
                key: key2,
                value: await pair.value,
                alwaysSet: pair.alwaysSet
              });
            }
            return syncPairs;
          }).then((syncPairs) => {
            return ParseStatus.mergeObjectSync(status, syncPairs);
          });
        } else {
          return ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get shape() {
        return this._def.shape();
      }
      strict(message) {
        errorUtil.errToObj;
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strict",
          ...message !== void 0 ? {
            errorMap: (issue, ctx) => {
              var _a2, _b2, _c, _d;
              const defaultError = (_c = (_b2 = (_a2 = this._def).errorMap) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
              if (issue.code === "unrecognized_keys")
                return {
                  message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
                };
              return {
                message: defaultError
              };
            }
          } : {}
        });
      }
      strip() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strip"
        });
      }
      passthrough() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "passthrough"
        });
      }
      // const AugmentFactory =
      //   <Def extends ZodObjectDef>(def: Def) =>
      //   <Augmentation extends ZodRawShape>(
      //     augmentation: Augmentation
      //   ): ZodObject<
      //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
      //     Def["unknownKeys"],
      //     Def["catchall"]
      //   > => {
      //     return new ZodObject({
      //       ...def,
      //       shape: () => ({
      //         ...def.shape(),
      //         ...augmentation,
      //       }),
      //     }) as any;
      //   };
      extend(augmentation) {
        return new _ZodObject({
          ...this._def,
          shape: () => ({
            ...this._def.shape(),
            ...augmentation
          })
        });
      }
      /**
       * Prior to zod@1.0.12 there was a bug in the
       * inferred type of merged objects. Please
       * upgrade if you are experiencing issues.
       */
      merge(merging) {
        const merged = new _ZodObject({
          unknownKeys: merging._def.unknownKeys,
          catchall: merging._def.catchall,
          shape: () => ({
            ...this._def.shape(),
            ...merging._def.shape()
          }),
          typeName: ZodFirstPartyTypeKind.ZodObject
        });
        return merged;
      }
      // merge<
      //   Incoming extends AnyZodObject,
      //   Augmentation extends Incoming["shape"],
      //   NewOutput extends {
      //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
      //       ? Augmentation[k]["_output"]
      //       : k extends keyof Output
      //       ? Output[k]
      //       : never;
      //   },
      //   NewInput extends {
      //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
      //       ? Augmentation[k]["_input"]
      //       : k extends keyof Input
      //       ? Input[k]
      //       : never;
      //   }
      // >(
      //   merging: Incoming
      // ): ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"],
      //   NewOutput,
      //   NewInput
      // > {
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      setKey(key2, schema) {
        return this.augment({ [key2]: schema });
      }
      // merge<Incoming extends AnyZodObject>(
      //   merging: Incoming
      // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
      // ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"]
      // > {
      //   // const mergedShape = objectUtil.mergeShapes(
      //   //   this._def.shape(),
      //   //   merging._def.shape()
      //   // );
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      catchall(index15) {
        return new _ZodObject({
          ...this._def,
          catchall: index15
        });
      }
      pick(mask) {
        const shape = {};
        util.objectKeys(mask).forEach((key2) => {
          if (mask[key2] && this.shape[key2]) {
            shape[key2] = this.shape[key2];
          }
        });
        return new _ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      omit(mask) {
        const shape = {};
        util.objectKeys(this.shape).forEach((key2) => {
          if (!mask[key2]) {
            shape[key2] = this.shape[key2];
          }
        });
        return new _ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      /**
       * @deprecated
       */
      deepPartial() {
        return deepPartialify(this);
      }
      partial(mask) {
        const newShape = {};
        util.objectKeys(this.shape).forEach((key2) => {
          const fieldSchema = this.shape[key2];
          if (mask && !mask[key2]) {
            newShape[key2] = fieldSchema;
          } else {
            newShape[key2] = fieldSchema.optional();
          }
        });
        return new _ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      required(mask) {
        const newShape = {};
        util.objectKeys(this.shape).forEach((key2) => {
          if (mask && !mask[key2]) {
            newShape[key2] = this.shape[key2];
          } else {
            const fieldSchema = this.shape[key2];
            let newField = fieldSchema;
            while (newField instanceof ZodOptional) {
              newField = newField._def.innerType;
            }
            newShape[key2] = newField;
          }
        });
        return new _ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      keyof() {
        return createZodEnum(util.objectKeys(this.shape));
      }
    };
    ZodObject.create = (shape, params) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.strictCreate = (shape, params) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.lazycreate = (shape, params) => {
      return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodUnion = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options2 = this._def.options;
        function handleResults(results) {
          for (const result of results) {
            if (result.result.status === "valid") {
              return result.result;
            }
          }
          for (const result of results) {
            if (result.result.status === "dirty") {
              ctx.common.issues.push(...result.ctx.common.issues);
              return result.result;
            }
          }
          const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union,
            unionErrors
          });
          return INVALID;
        }
        if (ctx.common.async) {
          return Promise.all(options2.map(async (option) => {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            return {
              result: await option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: childCtx
              }),
              ctx: childCtx
            };
          })).then(handleResults);
        } else {
          let dirty = void 0;
          const issues = [];
          for (const option of options2) {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            const result = option._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            });
            if (result.status === "valid") {
              return result;
            } else if (result.status === "dirty" && !dirty) {
              dirty = { result, ctx: childCtx };
            }
            if (childCtx.common.issues.length) {
              issues.push(childCtx.common.issues);
            }
          }
          if (dirty) {
            ctx.common.issues.push(...dirty.ctx.common.issues);
            return dirty.result;
          }
          const unionErrors = issues.map((issues2) => new ZodError(issues2));
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union,
            unionErrors
          });
          return INVALID;
        }
      }
      get options() {
        return this._def.options;
      }
    };
    ZodUnion.create = (types, params) => {
      return new ZodUnion({
        options: types,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params)
      });
    };
    getDiscriminator = (type) => {
      if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
      } else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
      } else if (type instanceof ZodLiteral) {
        return [type.value];
      } else if (type instanceof ZodEnum) {
        return type.options;
      } else if (type instanceof ZodNativeEnum) {
        return Object.keys(type.enum);
      } else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
      } else if (type instanceof ZodUndefined) {
        return [void 0];
      } else if (type instanceof ZodNull) {
        return [null];
      } else {
        return null;
      }
    };
    ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [discriminator]
          });
          return INVALID;
        }
        if (ctx.common.async) {
          return option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        } else {
          return option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        }
      }
      get discriminator() {
        return this._def.discriminator;
      }
      get options() {
        return this._def.options;
      }
      get optionsMap() {
        return this._def.optionsMap;
      }
      /**
       * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
       * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
       * have a different value for each object in the union.
       * @param discriminator the name of the discriminator property
       * @param types an array of object schemas
       * @param params
       */
      static create(discriminator, options2, params) {
        const optionsMap = /* @__PURE__ */ new Map();
        for (const type of options2) {
          const discriminatorValues = getDiscriminator(type.shape[discriminator]);
          if (!discriminatorValues) {
            throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
          }
          for (const value of discriminatorValues) {
            if (optionsMap.has(value)) {
              throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
            }
            optionsMap.set(value, type);
          }
        }
        return new _ZodDiscriminatedUnion({
          typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
          discriminator,
          options: options2,
          optionsMap,
          ...processCreateParams(params)
        });
      }
    };
    ZodIntersection = class extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
          if (isAborted(parsedLeft) || isAborted(parsedRight)) {
            return INVALID;
          }
          const merged = mergeValues(parsedLeft.value, parsedRight.value);
          if (!merged.valid) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_intersection_types
            });
            return INVALID;
          }
          if (isDirty(parsedLeft) || isDirty(parsedRight)) {
            status.dirty();
          }
          return { status: status.value, value: merged.data };
        };
        if (ctx.common.async) {
          return Promise.all([
            this._def.left._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }),
            this._def.right._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            })
          ]).then(([left, right]) => handleParsed(left, right));
        } else {
          return handleParsed(this._def.left._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }), this._def.right._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }));
        }
      }
    };
    ZodIntersection.create = (left, right, params) => {
      return new ZodIntersection({
        left,
        right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params)
      });
    };
    ZodTuple = class _ZodTuple extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.array,
            received: ctx.parsedType
          });
          return INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          return INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          status.dirty();
        }
        const items = [...ctx.data].map((item, itemIndex) => {
          const schema = this._def.items[itemIndex] || this._def.rest;
          if (!schema)
            return null;
          return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        }).filter((x4) => !!x4);
        if (ctx.common.async) {
          return Promise.all(items).then((results) => {
            return ParseStatus.mergeArray(status, results);
          });
        } else {
          return ParseStatus.mergeArray(status, items);
        }
      }
      get items() {
        return this._def.items;
      }
      rest(rest) {
        return new _ZodTuple({
          ...this._def,
          rest
        });
      }
    };
    ZodTuple.create = (schemas, params) => {
      if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
      }
      return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params)
      });
    };
    ZodRecord = class _ZodRecord extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key2 in ctx.data) {
          pairs.push({
            key: keyType._parse(new ParseInputLazyPath(ctx, key2, ctx.path, key2)),
            value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key2], ctx.path, key2))
          });
        }
        if (ctx.common.async) {
          return ParseStatus.mergeObjectAsync(status, pairs);
        } else {
          return ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get element() {
        return this._def.valueType;
      }
      static create(first, second, third) {
        if (second instanceof ZodType) {
          return new _ZodRecord({
            keyType: first,
            valueType: second,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(third)
          });
        }
        return new _ZodRecord({
          keyType: ZodString.create(),
          valueType: first,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(second)
        });
      }
    };
    ZodMap = class extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.map) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.map,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key2, value], index15) => {
          return {
            key: keyType._parse(new ParseInputLazyPath(ctx, key2, ctx.path, [index15, "key"])),
            value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index15, "value"]))
          };
        });
        if (ctx.common.async) {
          const finalMap = /* @__PURE__ */ new Map();
          return Promise.resolve().then(async () => {
            for (const pair of pairs) {
              const key2 = await pair.key;
              const value = await pair.value;
              if (key2.status === "aborted" || value.status === "aborted") {
                return INVALID;
              }
              if (key2.status === "dirty" || value.status === "dirty") {
                status.dirty();
              }
              finalMap.set(key2.value, value.value);
            }
            return { status: status.value, value: finalMap };
          });
        } else {
          const finalMap = /* @__PURE__ */ new Map();
          for (const pair of pairs) {
            const key2 = pair.key;
            const value = pair.value;
            if (key2.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key2.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key2.value, value.value);
          }
          return { status: status.value, value: finalMap };
        }
      }
    };
    ZodMap.create = (keyType, valueType, params) => {
      return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params)
      });
    };
    ZodSet = class _ZodSet extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.set) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.set,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
          if (ctx.data.size < def.minSize.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: def.minSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.minSize.message
            });
            status.dirty();
          }
        }
        if (def.maxSize !== null) {
          if (ctx.data.size > def.maxSize.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: def.maxSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.maxSize.message
            });
            status.dirty();
          }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements2) {
          const parsedSet = /* @__PURE__ */ new Set();
          for (const element of elements2) {
            if (element.status === "aborted")
              return INVALID;
            if (element.status === "dirty")
              status.dirty();
            parsedSet.add(element.value);
          }
          return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx.data.values()].map((item, i3) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i3)));
        if (ctx.common.async) {
          return Promise.all(elements).then((elements2) => finalizeSet(elements2));
        } else {
          return finalizeSet(elements);
        }
      }
      min(minSize, message) {
        return new _ZodSet({
          ...this._def,
          minSize: { value: minSize, message: errorUtil.toString(message) }
        });
      }
      max(maxSize, message) {
        return new _ZodSet({
          ...this._def,
          maxSize: { value: maxSize, message: errorUtil.toString(message) }
        });
      }
      size(size3, message) {
        return this.min(size3, message).max(size3, message);
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    ZodSet.create = (valueType, params) => {
      return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params)
      });
    };
    ZodFunction = class _ZodFunction extends ZodType {
      constructor() {
        super(...arguments);
        this.validate = this.implement;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.function) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.function,
            received: ctx.parsedType
          });
          return INVALID;
        }
        function makeArgsIssue(args, error) {
          return makeIssue({
            data: args,
            path: ctx.path,
            errorMaps: [
              ctx.common.contextualErrorMap,
              ctx.schemaErrorMap,
              getErrorMap(),
              errorMap
            ].filter((x4) => !!x4),
            issueData: {
              code: ZodIssueCode.invalid_arguments,
              argumentsError: error
            }
          });
        }
        function makeReturnsIssue(returns, error) {
          return makeIssue({
            data: returns,
            path: ctx.path,
            errorMaps: [
              ctx.common.contextualErrorMap,
              ctx.schemaErrorMap,
              getErrorMap(),
              errorMap
            ].filter((x4) => !!x4),
            issueData: {
              code: ZodIssueCode.invalid_return_type,
              returnTypeError: error
            }
          });
        }
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
          const me2 = this;
          return OK(async function(...args) {
            const error = new ZodError([]);
            const parsedArgs = await me2._def.args.parseAsync(args, params).catch((e3) => {
              error.addIssue(makeArgsIssue(args, e3));
              throw error;
            });
            const result = await Reflect.apply(fn, this, parsedArgs);
            const parsedReturns = await me2._def.returns._def.type.parseAsync(result, params).catch((e3) => {
              error.addIssue(makeReturnsIssue(result, e3));
              throw error;
            });
            return parsedReturns;
          });
        } else {
          const me2 = this;
          return OK(function(...args) {
            const parsedArgs = me2._def.args.safeParse(args, params);
            if (!parsedArgs.success) {
              throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
            }
            const result = Reflect.apply(fn, this, parsedArgs.data);
            const parsedReturns = me2._def.returns.safeParse(result, params);
            if (!parsedReturns.success) {
              throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
            }
            return parsedReturns.data;
          });
        }
      }
      parameters() {
        return this._def.args;
      }
      returnType() {
        return this._def.returns;
      }
      args(...items) {
        return new _ZodFunction({
          ...this._def,
          args: ZodTuple.create(items).rest(ZodUnknown.create())
        });
      }
      returns(returnType) {
        return new _ZodFunction({
          ...this._def,
          returns: returnType
        });
      }
      implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      static create(args, returns, params) {
        return new _ZodFunction({
          args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
          returns: returns || ZodUnknown.create(),
          typeName: ZodFirstPartyTypeKind.ZodFunction,
          ...processCreateParams(params)
        });
      }
    };
    ZodLazy = class extends ZodType {
      get schema() {
        return this._def.getter();
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
      }
    };
    ZodLazy.create = (getter, params) => {
      return new ZodLazy({
        getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params)
      });
    };
    ZodLiteral = class extends ZodType {
      _parse(input) {
        if (input.data !== this._def.value) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_literal,
            expected: this._def.value
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
      get value() {
        return this._def.value;
      }
    };
    ZodLiteral.create = (value, params) => {
      return new ZodLiteral({
        value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params)
      });
    };
    ZodEnum = class _ZodEnum extends ZodType {
      _parse(input) {
        if (typeof input.data !== "string") {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx, {
            expected: util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode.invalid_type
          });
          return INVALID;
        }
        if (this._def.values.indexOf(input.data) === -1) {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK(input.data);
      }
      get options() {
        return this._def.values;
      }
      get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      extract(values) {
        return _ZodEnum.create(values);
      }
      exclude(values) {
        return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
      }
    };
    ZodEnum.create = createZodEnum;
    ZodNativeEnum = class extends ZodType {
      _parse(input) {
        const nativeEnumValues = util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx, {
            expected: util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode.invalid_type
          });
          return INVALID;
        }
        if (nativeEnumValues.indexOf(input.data) === -1) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK(input.data);
      }
      get enum() {
        return this._def.values;
      }
    };
    ZodNativeEnum.create = (values, params) => {
      return new ZodNativeEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params)
      });
    };
    ZodPromise = class extends ZodType {
      unwrap() {
        return this._def.type;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.promise,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
        return OK(promisified.then((data2) => {
          return this._def.type.parseAsync(data2, {
            path: ctx.path,
            errorMap: ctx.common.contextualErrorMap
          });
        }));
      }
    };
    ZodPromise.create = (schema, params) => {
      return new ZodPromise({
        type: schema,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params)
      });
    };
    ZodEffects = class extends ZodType {
      innerType() {
        return this._def.schema;
      }
      sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect2 = this._def.effect || null;
        const checkCtx = {
          addIssue: (arg) => {
            addIssueToContext(ctx, arg);
            if (arg.fatal) {
              status.abort();
            } else {
              status.dirty();
            }
          },
          get path() {
            return ctx.path;
          }
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect2.type === "preprocess") {
          const processed = effect2.transform(ctx.data, checkCtx);
          if (ctx.common.issues.length) {
            return {
              status: "dirty",
              value: ctx.data
            };
          }
          if (ctx.common.async) {
            return Promise.resolve(processed).then((processed2) => {
              return this._def.schema._parseAsync({
                data: processed2,
                path: ctx.path,
                parent: ctx
              });
            });
          } else {
            return this._def.schema._parseSync({
              data: processed,
              path: ctx.path,
              parent: ctx
            });
          }
        }
        if (effect2.type === "refinement") {
          const executeRefinement = (acc) => {
            const result = effect2.refinement(acc, checkCtx);
            if (ctx.common.async) {
              return Promise.resolve(result);
            }
            if (result instanceof Promise) {
              throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
            }
            return acc;
          };
          if (ctx.common.async === false) {
            const inner = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            executeRefinement(inner.value);
            return { status: status.value, value: inner.value };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
              if (inner.status === "aborted")
                return INVALID;
              if (inner.status === "dirty")
                status.dirty();
              return executeRefinement(inner.value).then(() => {
                return { status: status.value, value: inner.value };
              });
            });
          }
        }
        if (effect2.type === "transform") {
          if (ctx.common.async === false) {
            const base2 = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (!isValid(base2))
              return base2;
            const result = effect2.transform(base2.value, checkCtx);
            if (result instanceof Promise) {
              throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
            }
            return { status: status.value, value: result };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base2) => {
              if (!isValid(base2))
                return base2;
              return Promise.resolve(effect2.transform(base2.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
            });
          }
        }
        util.assertNever(effect2);
      }
    };
    ZodEffects.create = (schema, effect2, params) => {
      return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: effect2,
        ...processCreateParams(params)
      });
    };
    ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
      return new ZodEffects({
        schema,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params)
      });
    };
    ZodOptional = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.undefined) {
          return OK(void 0);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodOptional.create = (type, params) => {
      return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params)
      });
    };
    ZodNullable = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.null) {
          return OK(null);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodNullable.create = (type, params) => {
      return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params)
      });
    };
    ZodDefault = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data2 = ctx.data;
        if (ctx.parsedType === ZodParsedType.undefined) {
          data2 = this._def.defaultValue();
        }
        return this._def.innerType._parse({
          data: data2,
          path: ctx.path,
          parent: ctx
        });
      }
      removeDefault() {
        return this._def.innerType;
      }
    };
    ZodDefault.create = (type, params) => {
      return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function" ? params.default : () => params.default,
        ...processCreateParams(params)
      });
    };
    ZodCatch = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const newCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          }
        };
        const result = this._def.innerType._parse({
          data: newCtx.data,
          path: newCtx.path,
          parent: {
            ...newCtx
          }
        });
        if (isAsync(result)) {
          return result.then((result2) => {
            return {
              status: "valid",
              value: result2.status === "valid" ? result2.value : this._def.catchValue({
                get error() {
                  return new ZodError(newCtx.common.issues);
                },
                input: newCtx.data
              })
            };
          });
        } else {
          return {
            status: "valid",
            value: result.status === "valid" ? result.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        }
      }
      removeCatch() {
        return this._def.innerType;
      }
    };
    ZodCatch.create = (type, params) => {
      return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
        ...processCreateParams(params)
      });
    };
    ZodNaN = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.nan) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.nan,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
    };
    ZodNaN.create = (params) => {
      return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params)
      });
    };
    BRAND = Symbol("zod_brand");
    ZodBranded = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data2 = ctx.data;
        return this._def.type._parse({
          data: data2,
          path: ctx.path,
          parent: ctx
        });
      }
      unwrap() {
        return this._def.type;
      }
    };
    ZodPipeline = class _ZodPipeline extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
          const handleAsync = async () => {
            const inResult = await this._def.in._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inResult.status === "aborted")
              return INVALID;
            if (inResult.status === "dirty") {
              status.dirty();
              return DIRTY(inResult.value);
            } else {
              return this._def.out._parseAsync({
                data: inResult.value,
                path: ctx.path,
                parent: ctx
              });
            }
          };
          return handleAsync();
        } else {
          const inResult = this._def.in._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return {
              status: "dirty",
              value: inResult.value
            };
          } else {
            return this._def.out._parseSync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        }
      }
      static create(a2, b2) {
        return new _ZodPipeline({
          in: a2,
          out: b2,
          typeName: ZodFirstPartyTypeKind.ZodPipeline
        });
      }
    };
    ZodReadonly = class extends ZodType {
      _parse(input) {
        const result = this._def.innerType._parse(input);
        if (isValid(result)) {
          result.value = Object.freeze(result.value);
        }
        return result;
      }
    };
    ZodReadonly.create = (type, params) => {
      return new ZodReadonly({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodReadonly,
        ...processCreateParams(params)
      });
    };
    custom = (check, params = {}, fatal) => {
      if (check)
        return ZodAny.create().superRefine((data2, ctx) => {
          var _a2, _b2;
          if (!check(data2)) {
            const p3 = typeof params === "function" ? params(data2) : typeof params === "string" ? { message: params } : params;
            const _fatal = (_b2 = (_a2 = p3.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b2 !== void 0 ? _b2 : true;
            const p22 = typeof p3 === "string" ? { message: p3 } : p3;
            ctx.addIssue({ code: "custom", ...p22, fatal: _fatal });
          }
        });
      return ZodAny.create();
    };
    late = {
      object: ZodObject.lazycreate
    };
    (function(ZodFirstPartyTypeKind2) {
      ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
      ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
      ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
      ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
      ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
      ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
      ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
      ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
      ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
      ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
      ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
      ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
      ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
      ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
      ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
      ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
      ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
      ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
      ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
      ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
      ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
      ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
      ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
      ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
      ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
      ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
      ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
      ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
      ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
      ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
      ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
      ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
      ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
      ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
      ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
      ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
    })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
    instanceOfType = (cls, params = {
      message: `Input not instance of ${cls.name}`
    }) => custom((data2) => data2 instanceof cls, params);
    stringType = ZodString.create;
    numberType = ZodNumber.create;
    nanType = ZodNaN.create;
    bigIntType = ZodBigInt.create;
    booleanType = ZodBoolean.create;
    dateType = ZodDate.create;
    symbolType = ZodSymbol.create;
    undefinedType = ZodUndefined.create;
    nullType = ZodNull.create;
    anyType = ZodAny.create;
    unknownType = ZodUnknown.create;
    neverType = ZodNever.create;
    voidType = ZodVoid.create;
    arrayType = ZodArray.create;
    objectType = ZodObject.create;
    strictObjectType = ZodObject.strictCreate;
    unionType = ZodUnion.create;
    discriminatedUnionType = ZodDiscriminatedUnion.create;
    intersectionType = ZodIntersection.create;
    tupleType = ZodTuple.create;
    recordType = ZodRecord.create;
    mapType = ZodMap.create;
    setType = ZodSet.create;
    functionType = ZodFunction.create;
    lazyType = ZodLazy.create;
    literalType = ZodLiteral.create;
    enumType = ZodEnum.create;
    nativeEnumType = ZodNativeEnum.create;
    promiseType = ZodPromise.create;
    effectsType = ZodEffects.create;
    optionalType = ZodOptional.create;
    nullableType = ZodNullable.create;
    preprocessType = ZodEffects.createWithPreprocess;
    pipelineType = ZodPipeline.create;
    ostring = () => stringType().optional();
    onumber = () => numberType().optional();
    oboolean = () => booleanType().optional();
    coerce = {
      string: (arg) => ZodString.create({ ...arg, coerce: true }),
      number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
      boolean: (arg) => ZodBoolean.create({
        ...arg,
        coerce: true
      }),
      bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
      date: (arg) => ZodDate.create({ ...arg, coerce: true })
    };
    NEVER = INVALID;
    z2 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      defaultErrorMap: errorMap,
      setErrorMap,
      getErrorMap,
      makeIssue,
      EMPTY_PATH,
      addIssueToContext,
      ParseStatus,
      INVALID,
      DIRTY,
      OK,
      isAborted,
      isDirty,
      isValid,
      isAsync,
      get util() {
        return util;
      },
      get objectUtil() {
        return objectUtil;
      },
      ZodParsedType,
      getParsedType,
      ZodType,
      ZodString,
      ZodNumber,
      ZodBigInt,
      ZodBoolean,
      ZodDate,
      ZodSymbol,
      ZodUndefined,
      ZodNull,
      ZodAny,
      ZodUnknown,
      ZodNever,
      ZodVoid,
      ZodArray,
      ZodObject,
      ZodUnion,
      ZodDiscriminatedUnion,
      ZodIntersection,
      ZodTuple,
      ZodRecord,
      ZodMap,
      ZodSet,
      ZodFunction,
      ZodLazy,
      ZodLiteral,
      ZodEnum,
      ZodNativeEnum,
      ZodPromise,
      ZodEffects,
      ZodTransformer: ZodEffects,
      ZodOptional,
      ZodNullable,
      ZodDefault,
      ZodCatch,
      ZodNaN,
      BRAND,
      ZodBranded,
      ZodPipeline,
      ZodReadonly,
      custom,
      Schema: ZodType,
      ZodSchema: ZodType,
      late,
      get ZodFirstPartyTypeKind() {
        return ZodFirstPartyTypeKind;
      },
      coerce,
      any: anyType,
      array: arrayType,
      bigint: bigIntType,
      boolean: booleanType,
      date: dateType,
      discriminatedUnion: discriminatedUnionType,
      effect: effectsType,
      "enum": enumType,
      "function": functionType,
      "instanceof": instanceOfType,
      intersection: intersectionType,
      lazy: lazyType,
      literal: literalType,
      map: mapType,
      nan: nanType,
      nativeEnum: nativeEnumType,
      never: neverType,
      "null": nullType,
      nullable: nullableType,
      number: numberType,
      object: objectType,
      oboolean,
      onumber,
      optional: optionalType,
      ostring,
      pipeline: pipelineType,
      preprocess: preprocessType,
      promise: promiseType,
      record: recordType,
      set: setType,
      strictObject: strictObjectType,
      string: stringType,
      symbol: symbolType,
      transformer: effectsType,
      tuple: tupleType,
      "undefined": undefinedType,
      union: unionType,
      unknown: unknownType,
      "void": voidType,
      NEVER,
      ZodIssueCode,
      quotelessJson,
      ZodError
    });
  }
});
function parseAnyDef() {
  return {};
}
var init_any = __esm({
  "node_modules/zod-to-json-schema/dist/esm/parsers/any.js"() {
  }
});
function parseArrayDef(def, refs) {
  const res = {
    type: "array"
  };
  if (def.type?._def?.typeName !== ZodFirstPartyTypeKind.ZodAny) {
    res.items = parseDef(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
  }
  if (def.minLength) {
    setResponseValueAndErrors(res, "minItems", def.minLength.value, def.minLength.message, refs);
  }
  if (def.maxLength) {
    setResponseValueAndErrors(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
  }
  if (def.exactLength) {
    setResponseValueAndErrors(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
    setResponseValueAndErrors(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
  }
  return res;
}
var init_array = __esm({
  "node_modules/zod-to-json-schema/dist/esm/parsers/array.js"() {
    init_lib();
    init_errorMessages();
    init_parseDef();
  }
});
function parseBigintDef(def, refs) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}
var init_bigint = __esm({
  "node_modules/zod-to-json-schema/dist/esm/parsers/bigint.js"() {
    init_errorMessages();
  }
});
function parseBooleanDef() {
  return {
    type: "boolean"
  };
}
var init_boolean = __esm({
  "node_modules/zod-to-json-schema/dist/esm/parsers/boolean.js"() {
  }
});
function parseBrandedDef(_def, refs) {
  return parseDef(_def.type._def, refs);
}
var init_branded = __esm({
  "node_modules/zod-to-json-schema/dist/esm/parsers/branded.js"() {
    init_parseDef();
  }
});
var parseCatchDef;
var init_catch = __esm({
  "node_modules/zod-to-json-schema/dist/esm/parsers/catch.js"() {
    init_parseDef();
    parseCatchDef = (def, refs) => {
      return parseDef(def.innerType._def, refs);
    };
  }
});
function parseDateDef(def, refs) {
  if (refs.dateStrategy == "integer") {
    return integerDateParser(def, refs);
  } else {
    return {
      type: "string",
      format: "date-time"
    };
  }
}
var integerDateParser;
var init_date = __esm({
  "node_modules/zod-to-json-schema/dist/esm/parsers/date.js"() {
    init_errorMessages();
    integerDateParser = (def, refs) => {
      const res = {
        type: "integer",
        format: "unix-time"
      };
      for (const check of def.checks) {
        switch (check.kind) {
          case "min":
            if (refs.target === "jsonSchema7") {
              setResponseValueAndErrors(
                res,
                "minimum",
                check.value,
                // This is in milliseconds
                check.message,
                refs
              );
            }
            break;
          case "max":
            if (refs.target === "jsonSchema7") {
              setResponseValueAndErrors(
                res,
                "maximum",
                check.value,
                // This is in milliseconds
                check.message,
                refs
              );
            }
            break;
        }
      }
      return res;
    };
  }
});
function parseDefaultDef(_def, refs) {
  return {
    ...parseDef(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}
var init_default = __esm({
  "node_modules/zod-to-json-schema/dist/esm/parsers/default.js"() {
    init_parseDef();
  }
});
function parseEffectsDef(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs) : {};
}
var init_effects = __esm({
  "node_modules/zod-to-json-schema/dist/esm/parsers/effects.js"() {
    init_parseDef();
  }
});
function parseEnumDef(def) {
  return {
    type: "string",
    enum: def.values
  };
}
var init_enum = __esm({
  "node_modules/zod-to-json-schema/dist/esm/parsers/enum.js"() {
  }
});
function parseIntersectionDef(def, refs) {
  const allOf = [
    parseDef(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    }),
    parseDef(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"]
    })
  ].filter((x4) => !!x4);
  let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : void 0;
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType(schema)) {
      mergedAllOf.push(...schema.allOf);
      if (schema.unevaluatedProperties === void 0) {
        unevaluatedProperties = void 0;
      }
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      } else {
        unevaluatedProperties = void 0;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? {
    allOf: mergedAllOf,
    ...unevaluatedProperties
  } : void 0;
}
var isJsonSchema7AllOfType;
var init_intersection = __esm({
  "node_modules/zod-to-json-schema/dist/esm/parsers/intersection.js"() {
    init_parseDef();
    isJsonSchema7AllOfType = (type) => {
      if ("type" in type && type.type === "string")
        return false;
      return "allOf" in type;
    };
  }
});
function parseLiteralDef(def, refs) {
  const parsedType = typeof def.value;
  if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  if (refs.target === "openApi3") {
    return {
      type: parsedType === "bigint" ? "integer" : parsedType,
      enum: [def.value]
    };
  }
  return {
    type: parsedType === "bigint" ? "integer" : parsedType,
    const: def.value
  };
}
var init_literal = __esm({
  "node_modules/zod-to-json-schema/dist/esm/parsers/literal.js"() {
  }
});
function parseStringDef(def, refs) {
  const res = {
    type: "string"
  };
  function processPattern(value) {
    return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(value) : value;
  }
  if (def.checks) {
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          break;
        case "max":
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat(res, "email", check.message, refs);
              break;
            case "format:idn-email":
              addFormat(res, "idn-email", check.message, refs);
              break;
            case "pattern:zod":
              addPattern(res, zodPatterns.email, check.message, refs);
              break;
          }
          break;
        case "url":
          addFormat(res, "uri", check.message, refs);
          break;
        case "uuid":
          addFormat(res, "uuid", check.message, refs);
          break;
        case "regex":
          addPattern(res, check.regex.source, check.message, refs);
          break;
        case "cuid":
          addPattern(res, zodPatterns.cuid, check.message, refs);
          break;
        case "cuid2":
          addPattern(res, zodPatterns.cuid2, check.message, refs);
          break;
        case "startsWith":
          addPattern(res, "^" + processPattern(check.value), check.message, refs);
          break;
        case "endsWith":
          addPattern(res, processPattern(check.value) + "$", check.message, refs);
          break;
        case "datetime":
          addFormat(res, "date-time", check.message, refs);
          break;
        case "length":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "includes": {
          addPattern(res, processPattern(check.value), check.message, refs);
          break;
        }
        case "ip": {
          if (check.version !== "v6") {
            addFormat(res, "ipv4", check.message, refs);
          }
          if (check.version !== "v4") {
            addFormat(res, "ipv6", check.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern(res, zodPatterns.emoji, check.message, refs);
          break;
        case "ulid": {
          addPattern(res, zodPatterns.ulid, check.message, refs);
          break;
        }
        case "toLowerCase":
        case "toUpperCase":
        case "trim":
          break;
        default:
          /* @__PURE__ */ ((_) => {
          })(check);
      }
    }
  }
  return res;
}
var zodPatterns;
var escapeNonAlphaNumeric;
var addFormat;
var addPattern;
var init_string = __esm({
  "node_modules/zod-to-json-schema/dist/esm/parsers/string.js"() {
    init_errorMessages();
    zodPatterns = {
      /**
       * `c` was changed to `[cC]` to replicate /i flag
       */
      cuid: "^[cC][^\\s-]{8,}$",
      cuid2: "^[a-z][a-z0-9]*$",
      ulid: "^[0-9A-HJKMNP-TV-Z]{26}$",
      /**
       * `a-z` was added to replicate /i flag
       */
      email: "^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_+-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$",
      emoji: "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
      /**
       * Unused
       */
      uuid: "^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$",
      /**
       * Unused
       */
      ipv4: "^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$",
      /**
       * Unused
       */
      ipv6: "^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$"
    };
    escapeNonAlphaNumeric = (value) => Array.from(value).map((c2) => /[a-zA-Z0-9]/.test(c2) ? c2 : `\\${c2}`).join("");
    addFormat = (schema, value, message, refs) => {
      if (schema.format || schema.anyOf?.some((x4) => x4.format)) {
        if (!schema.anyOf) {
          schema.anyOf = [];
        }
        if (schema.format) {
          schema.anyOf.push({
            format: schema.format,
            ...schema.errorMessage && refs.errorMessages && {
              errorMessage: { format: schema.errorMessage.format }
            }
          });
          delete schema.format;
          if (schema.errorMessage) {
            delete schema.errorMessage.format;
            if (Object.keys(schema.errorMessage).length === 0) {
              delete schema.errorMessage;
            }
          }
        }
        schema.anyOf.push({
          format: value,
          ...message && refs.errorMessages && { errorMessage: { format: message } }
        });
      } else {
        setResponseValueAndErrors(schema, "format", value, message, refs);
      }
    };
    addPattern = (schema, value, message, refs) => {
      if (schema.pattern || schema.allOf?.some((x4) => x4.pattern)) {
        if (!schema.allOf) {
          schema.allOf = [];
        }
        if (schema.pattern) {
          schema.allOf.push({
            pattern: schema.pattern,
            ...schema.errorMessage && refs.errorMessages && {
              errorMessage: { pattern: schema.errorMessage.pattern }
            }
          });
          delete schema.pattern;
          if (schema.errorMessage) {
            delete schema.errorMessage.pattern;
            if (Object.keys(schema.errorMessage).length === 0) {
              delete schema.errorMessage;
            }
          }
        }
        schema.allOf.push({
          pattern: value,
          ...message && refs.errorMessages && { errorMessage: { pattern: message } }
        });
      } else {
        setResponseValueAndErrors(schema, "pattern", value, message, refs);
      }
    };
  }
});
function parseRecordDef(def, refs) {
  if (refs.target === "openApi3" && def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      type: "object",
      required: def.keyType._def.values,
      properties: def.keyType._def.values.reduce((acc, key2) => ({
        ...acc,
        [key2]: parseDef(def.valueType._def, {
          ...refs,
          currentPath: [...refs.currentPath, "properties", key2]
        }) ?? {}
      }), {}),
      additionalProperties: false
    };
  }
  const schema = {
    type: "object",
    additionalProperties: parseDef(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? {}
  };
  if (refs.target === "openApi3") {
    return schema;
  }
  if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.checks?.length) {
    const keyType = Object.entries(parseStringDef(def.keyType._def, refs)).reduce((acc, [key2, value]) => key2 === "type" ? acc : { ...acc, [key2]: value }, {});
    return {
      ...schema,
      propertyNames: keyType
    };
  } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      ...schema,
      propertyNames: {
        enum: def.keyType._def.values
      }
    };
  }
  return schema;
}
var init_record = __esm({
  "node_modules/zod-to-json-schema/dist/esm/parsers/record.js"() {
    init_lib();
    init_parseDef();
    init_string();
  }
});
function parseMapDef(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef(def, refs);
  }
  const keys = parseDef(def.keyType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "0"]
  }) || {};
  const values = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "1"]
  }) || {};
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}
var init_map = __esm({
  "node_modules/zod-to-json-schema/dist/esm/parsers/map.js"() {
    init_parseDef();
    init_record();
  }
});
function parseNativeEnumDef(def) {
  const object = def.values;
  const actualKeys = Object.keys(def.values).filter((key2) => {
    return typeof object[object[key2]] !== "number";
  });
  const actualValues = actualKeys.map((key2) => object[key2]);
  const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}
var init_nativeEnum = __esm({
  "node_modules/zod-to-json-schema/dist/esm/parsers/nativeEnum.js"() {
  }
});
function parseNeverDef() {
  return {
    not: {}
  };
}
var init_never = __esm({
  "node_modules/zod-to-json-schema/dist/esm/parsers/never.js"() {
  }
});
function parseNullDef(refs) {
  return refs.target === "openApi3" ? {
    enum: ["null"],
    nullable: true
  } : {
    type: "null"
  };
}
var init_null = __esm({
  "node_modules/zod-to-json-schema/dist/esm/parsers/null.js"() {
  }
});
function parseUnionDef(def, refs) {
  if (refs.target === "openApi3")
    return asAnyOf(def, refs);
  const options2 = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options2.every((x4) => x4._def.typeName in primitiveMappings && (!x4._def.checks || !x4._def.checks.length))) {
    const types = options2.reduce((types2, x4) => {
      const type = primitiveMappings[x4._def.typeName];
      return type && !types2.includes(type) ? [...types2, type] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options2.every((x4) => x4._def.typeName === "ZodLiteral" && !x4.description)) {
    const types = options2.reduce((acc, x4) => {
      const type = typeof x4._def.value;
      switch (type) {
        case "string":
        case "number":
        case "boolean":
          return [...acc, type];
        case "bigint":
          return [...acc, "integer"];
        case "object":
          if (x4._def.value === null)
            return [...acc, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return acc;
      }
    }, []);
    if (types.length === options2.length) {
      const uniqueTypes = types.filter((x4, i3, a2) => a2.indexOf(x4) === i3);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options2.reduce((acc, x4) => {
          return acc.includes(x4._def.value) ? acc : [...acc, x4._def.value];
        }, [])
      };
    }
  } else if (options2.every((x4) => x4._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options2.reduce((acc, x4) => [
        ...acc,
        ...x4._def.values.filter((x5) => !acc.includes(x5))
      ], [])
    };
  }
  return asAnyOf(def, refs);
}
var primitiveMappings;
var asAnyOf;
var init_union = __esm({
  "node_modules/zod-to-json-schema/dist/esm/parsers/union.js"() {
    init_parseDef();
    primitiveMappings = {
      ZodString: "string",
      ZodNumber: "number",
      ZodBigInt: "integer",
      ZodBoolean: "boolean",
      ZodNull: "null"
    };
    asAnyOf = (def, refs) => {
      const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x4, i3) => parseDef(x4._def, {
        ...refs,
        currentPath: [...refs.currentPath, "anyOf", `${i3}`]
      })).filter((x4) => !!x4 && (!refs.strictUnions || typeof x4 === "object" && Object.keys(x4).length > 0));
      return anyOf.length ? { anyOf } : void 0;
    };
  }
});
function parseNullableDef(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    if (refs.target === "openApi3") {
      return {
        type: primitiveMappings[def.innerType._def.typeName],
        nullable: true
      };
    }
    return {
      type: [
        primitiveMappings[def.innerType._def.typeName],
        "null"
      ]
    };
  }
  if (refs.target === "openApi3") {
    const base3 = parseDef(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath]
    });
    if (base3 && "$ref" in base3)
      return { allOf: [base3], nullable: true };
    return base3 && { ...base3, nullable: true };
  }
  const base2 = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"]
  });
  return base2 && { anyOf: [base2, { type: "null" }] };
}
var init_nullable = __esm({
  "node_modules/zod-to-json-schema/dist/esm/parsers/nullable.js"() {
    init_parseDef();
    init_union();
  }
});
function parseNumberDef(def, refs) {
  const res = {
    type: "number"
  };
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "int":
        res.type = "integer";
        addErrorMessage(res, "type", check.message, refs);
        break;
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}
var init_number = __esm({
  "node_modules/zod-to-json-schema/dist/esm/parsers/number.js"() {
    init_errorMessages();
  }
});
function parseObjectDef(def, refs) {
  const result = {
    type: "object",
    ...Object.entries(def.shape()).reduce((acc, [propName, propDef]) => {
      if (propDef === void 0 || propDef._def === void 0)
        return acc;
      const parsedDef = parseDef(propDef._def, {
        ...refs,
        currentPath: [...refs.currentPath, "properties", propName],
        propertyPath: [...refs.currentPath, "properties", propName]
      });
      if (parsedDef === void 0)
        return acc;
      return {
        properties: { ...acc.properties, [propName]: parsedDef },
        required: propDef.isOptional() ? acc.required : [...acc.required, propName]
      };
    }, { properties: {}, required: [] }),
    additionalProperties: def.catchall._def.typeName === "ZodNever" ? def.unknownKeys === "passthrough" : parseDef(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? true
  };
  if (!result.required.length)
    delete result.required;
  return result;
}
var init_object = __esm({
  "node_modules/zod-to-json-schema/dist/esm/parsers/object.js"() {
    init_parseDef();
  }
});
var parseOptionalDef;
var init_optional = __esm({
  "node_modules/zod-to-json-schema/dist/esm/parsers/optional.js"() {
    init_parseDef();
    parseOptionalDef = (def, refs) => {
      if (refs.currentPath.toString() === refs.propertyPath?.toString()) {
        return parseDef(def.innerType._def, refs);
      }
      const innerSchema = parseDef(def.innerType._def, {
        ...refs,
        currentPath: [...refs.currentPath, "anyOf", "1"]
      });
      return innerSchema ? {
        anyOf: [
          {
            not: {}
          },
          innerSchema
        ]
      } : {};
    };
  }
});
var parsePipelineDef;
var init_pipeline = __esm({
  "node_modules/zod-to-json-schema/dist/esm/parsers/pipeline.js"() {
    init_parseDef();
    parsePipelineDef = (def, refs) => {
      if (refs.pipeStrategy === "input") {
        return parseDef(def.in._def, refs);
      } else if (refs.pipeStrategy === "output") {
        return parseDef(def.out._def, refs);
      }
      const a2 = parseDef(def.in._def, {
        ...refs,
        currentPath: [...refs.currentPath, "allOf", "0"]
      });
      const b2 = parseDef(def.out._def, {
        ...refs,
        currentPath: [...refs.currentPath, "allOf", a2 ? "1" : "0"]
      });
      return {
        allOf: [a2, b2].filter((x4) => x4 !== void 0)
      };
    };
  }
});
function parsePromiseDef(def, refs) {
  return parseDef(def.type._def, refs);
}
var init_promise = __esm({
  "node_modules/zod-to-json-schema/dist/esm/parsers/promise.js"() {
    init_parseDef();
  }
});
function parseSetDef(def, refs) {
  const items = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    setResponseValueAndErrors(schema, "minItems", def.minSize.value, def.minSize.message, refs);
  }
  if (def.maxSize) {
    setResponseValueAndErrors(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
  }
  return schema;
}
var init_set = __esm({
  "node_modules/zod-to-json-schema/dist/esm/parsers/set.js"() {
    init_errorMessages();
    init_parseDef();
  }
});
function parseTupleDef(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map((x4, i3) => parseDef(x4._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i3}`]
      })).reduce((acc, x4) => x4 === void 0 ? acc : [...acc, x4], []),
      additionalItems: parseDef(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"]
      })
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map((x4, i3) => parseDef(x4._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i3}`]
      })).reduce((acc, x4) => x4 === void 0 ? acc : [...acc, x4], [])
    };
  }
}
var init_tuple = __esm({
  "node_modules/zod-to-json-schema/dist/esm/parsers/tuple.js"() {
    init_parseDef();
  }
});
function parseUndefinedDef() {
  return {
    not: {}
  };
}
var init_undefined = __esm({
  "node_modules/zod-to-json-schema/dist/esm/parsers/undefined.js"() {
  }
});
function parseUnknownDef() {
  return {};
}
var init_unknown = __esm({
  "node_modules/zod-to-json-schema/dist/esm/parsers/unknown.js"() {
  }
});
var parseReadonlyDef;
var init_readonly = __esm({
  "node_modules/zod-to-json-schema/dist/esm/parsers/readonly.js"() {
    init_parseDef();
    parseReadonlyDef = (def, refs) => {
      return parseDef(def.innerType._def, refs);
    };
  }
});
function parseDef(def, refs, forceResolution = false) {
  const seenItem = refs.seen.get(def);
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref(seenItem, refs);
    if (seenSchema !== void 0) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchema = selectParser(def, def.typeName, refs);
  if (jsonSchema) {
    addMeta(def, refs, jsonSchema);
  }
  newItem.jsonSchema = jsonSchema;
  return jsonSchema;
}
var get$ref;
var getRelativePath;
var selectParser;
var addMeta;
var init_parseDef = __esm({
  "node_modules/zod-to-json-schema/dist/esm/parseDef.js"() {
    init_lib();
    init_any();
    init_array();
    init_bigint();
    init_boolean();
    init_branded();
    init_catch();
    init_date();
    init_default();
    init_effects();
    init_enum();
    init_intersection();
    init_literal();
    init_map();
    init_nativeEnum();
    init_never();
    init_null();
    init_nullable();
    init_number();
    init_object();
    init_optional();
    init_pipeline();
    init_promise();
    init_record();
    init_set();
    init_string();
    init_tuple();
    init_undefined();
    init_union();
    init_unknown();
    init_readonly();
    get$ref = (item, refs) => {
      switch (refs.$refStrategy) {
        case "root":
          return { $ref: item.path.join("/") };
        case "relative":
          return { $ref: getRelativePath(refs.currentPath, item.path) };
        case "none":
        case "seen": {
          if (item.path.length < refs.currentPath.length && item.path.every((value, index15) => refs.currentPath[index15] === value)) {
            console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
            return {};
          }
          return refs.$refStrategy === "seen" ? {} : void 0;
        }
      }
    };
    getRelativePath = (pathA, pathB) => {
      let i3 = 0;
      for (; i3 < pathA.length && i3 < pathB.length; i3++) {
        if (pathA[i3] !== pathB[i3])
          break;
      }
      return [(pathA.length - i3).toString(), ...pathB.slice(i3)].join("/");
    };
    selectParser = (def, typeName, refs) => {
      switch (typeName) {
        case ZodFirstPartyTypeKind.ZodString:
          return parseStringDef(def, refs);
        case ZodFirstPartyTypeKind.ZodNumber:
          return parseNumberDef(def, refs);
        case ZodFirstPartyTypeKind.ZodObject:
          return parseObjectDef(def, refs);
        case ZodFirstPartyTypeKind.ZodBigInt:
          return parseBigintDef(def, refs);
        case ZodFirstPartyTypeKind.ZodBoolean:
          return parseBooleanDef();
        case ZodFirstPartyTypeKind.ZodDate:
          return parseDateDef(def, refs);
        case ZodFirstPartyTypeKind.ZodUndefined:
          return parseUndefinedDef();
        case ZodFirstPartyTypeKind.ZodNull:
          return parseNullDef(refs);
        case ZodFirstPartyTypeKind.ZodArray:
          return parseArrayDef(def, refs);
        case ZodFirstPartyTypeKind.ZodUnion:
        case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
          return parseUnionDef(def, refs);
        case ZodFirstPartyTypeKind.ZodIntersection:
          return parseIntersectionDef(def, refs);
        case ZodFirstPartyTypeKind.ZodTuple:
          return parseTupleDef(def, refs);
        case ZodFirstPartyTypeKind.ZodRecord:
          return parseRecordDef(def, refs);
        case ZodFirstPartyTypeKind.ZodLiteral:
          return parseLiteralDef(def, refs);
        case ZodFirstPartyTypeKind.ZodEnum:
          return parseEnumDef(def);
        case ZodFirstPartyTypeKind.ZodNativeEnum:
          return parseNativeEnumDef(def);
        case ZodFirstPartyTypeKind.ZodNullable:
          return parseNullableDef(def, refs);
        case ZodFirstPartyTypeKind.ZodOptional:
          return parseOptionalDef(def, refs);
        case ZodFirstPartyTypeKind.ZodMap:
          return parseMapDef(def, refs);
        case ZodFirstPartyTypeKind.ZodSet:
          return parseSetDef(def, refs);
        case ZodFirstPartyTypeKind.ZodLazy:
          return parseDef(def.getter()._def, refs);
        case ZodFirstPartyTypeKind.ZodPromise:
          return parsePromiseDef(def, refs);
        case ZodFirstPartyTypeKind.ZodNaN:
        case ZodFirstPartyTypeKind.ZodNever:
          return parseNeverDef();
        case ZodFirstPartyTypeKind.ZodEffects:
          return parseEffectsDef(def, refs);
        case ZodFirstPartyTypeKind.ZodAny:
          return parseAnyDef();
        case ZodFirstPartyTypeKind.ZodUnknown:
          return parseUnknownDef();
        case ZodFirstPartyTypeKind.ZodDefault:
          return parseDefaultDef(def, refs);
        case ZodFirstPartyTypeKind.ZodBranded:
          return parseBrandedDef(def, refs);
        case ZodFirstPartyTypeKind.ZodReadonly:
          return parseReadonlyDef(def, refs);
        case ZodFirstPartyTypeKind.ZodCatch:
          return parseCatchDef(def, refs);
        case ZodFirstPartyTypeKind.ZodPipeline:
          return parsePipelineDef(def, refs);
        case ZodFirstPartyTypeKind.ZodFunction:
        case ZodFirstPartyTypeKind.ZodVoid:
        case ZodFirstPartyTypeKind.ZodSymbol:
          return void 0;
        default:
          return /* @__PURE__ */ ((_) => void 0)(typeName);
      }
    };
    addMeta = (def, refs, jsonSchema) => {
      if (def.description) {
        jsonSchema.description = def.description;
        if (refs.markdownDescription) {
          jsonSchema.markdownDescription = def.description;
        }
      }
      return jsonSchema;
    };
  }
});
var getRefs;
var init_Refs = __esm({
  "node_modules/zod-to-json-schema/dist/esm/Refs.js"() {
    init_Options();
    getRefs = (options2) => {
      const _options = getDefaultOptions(options2);
      const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
      return {
        ..._options,
        currentPath,
        propertyPath: void 0,
        seen: new Map(Object.entries(_options.definitions).map(([name5, def]) => [
          def._def,
          {
            def: def._def,
            path: [..._options.basePath, _options.definitionPath, name5],
            // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
            jsonSchema: void 0
          }
        ]))
      };
    };
  }
});
var zodToJsonSchema;
var init_zodToJsonSchema = __esm({
  "node_modules/zod-to-json-schema/dist/esm/zodToJsonSchema.js"() {
    init_parseDef();
    init_Refs();
    zodToJsonSchema = (schema, options2) => {
      const refs = getRefs(options2);
      const definitions = typeof options2 === "object" && options2.definitions ? Object.entries(options2.definitions).reduce((acc, [name6, schema2]) => ({
        ...acc,
        [name6]: parseDef(schema2._def, {
          ...refs,
          currentPath: [...refs.basePath, refs.definitionPath, name6]
        }, true) ?? {}
      }), {}) : void 0;
      const name5 = typeof options2 === "string" ? options2 : options2?.name;
      const main = parseDef(schema._def, name5 === void 0 ? refs : {
        ...refs,
        currentPath: [...refs.basePath, refs.definitionPath, name5]
      }, false) ?? {};
      const combined = name5 === void 0 ? definitions ? {
        ...main,
        [refs.definitionPath]: definitions
      } : main : {
        $ref: [
          ...refs.$refStrategy === "relative" ? [] : refs.basePath,
          refs.definitionPath,
          name5
        ].join("/"),
        [refs.definitionPath]: {
          ...definitions,
          [name5]: main
        }
      };
      if (refs.target === "jsonSchema7") {
        combined.$schema = "http://json-schema.org/draft-07/schema#";
      } else if (refs.target === "jsonSchema2019-09") {
        combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
      }
      return combined;
    };
  }
});
var init_esm2 = __esm({
  "node_modules/zod-to-json-schema/dist/esm/index.js"() {
    init_errorMessages();
    init_Options();
    init_parseDef();
    init_any();
    init_array();
    init_bigint();
    init_boolean();
    init_branded();
    init_catch();
    init_date();
    init_default();
    init_effects();
    init_enum();
    init_intersection();
    init_literal();
    init_map();
    init_nativeEnum();
    init_never();
    init_null();
    init_nullable();
    init_number();
    init_object();
    init_optional();
    init_pipeline();
    init_promise();
    init_readonly();
    init_record();
    init_set();
    init_string();
    init_tuple();
    init_undefined();
    init_union();
    init_unknown();
    init_Refs();
    init_zodToJsonSchema();
    init_zodToJsonSchema();
  }
});
var require_memoize = __commonJS({
  "node_modules/memoize-weak/lib/memoize.js"(exports, module) {
    function isPrimitive(value) {
      return typeof value !== "object" && typeof value !== "function" || value === null;
    }
    function MapTree() {
      this.childBranches = /* @__PURE__ */ new WeakMap();
      this.primitiveKeys = /* @__PURE__ */ new Map();
      this.hasValue = false;
      this.value = void 0;
    }
    MapTree.prototype.has = function has2(key2) {
      var keyObject = isPrimitive(key2) ? this.primitiveKeys.get(key2) : key2;
      return keyObject ? this.childBranches.has(keyObject) : false;
    };
    MapTree.prototype.get = function get2(key2) {
      var keyObject = isPrimitive(key2) ? this.primitiveKeys.get(key2) : key2;
      return keyObject ? this.childBranches.get(keyObject) : void 0;
    };
    MapTree.prototype.resolveBranch = function resolveBranch(key2) {
      if (this.has(key2)) {
        return this.get(key2);
      }
      var newBranch = new MapTree();
      var keyObject = this.createKey(key2);
      this.childBranches.set(keyObject, newBranch);
      return newBranch;
    };
    MapTree.prototype.setValue = function setValue(value) {
      this.hasValue = true;
      return this.value = value;
    };
    MapTree.prototype.createKey = function createKey(key2) {
      if (isPrimitive(key2)) {
        var keyObject = {};
        this.primitiveKeys.set(key2, keyObject);
        return keyObject;
      }
      return key2;
    };
    MapTree.prototype.clear = function clear() {
      if (arguments.length === 0) {
        this.childBranches = /* @__PURE__ */ new WeakMap();
        this.primitiveKeys.clear();
        this.hasValue = false;
        this.value = void 0;
      } else if (arguments.length === 1) {
        var key2 = arguments[0];
        if (isPrimitive(key2)) {
          var keyObject = this.primitiveKeys.get(key2);
          if (keyObject) {
            this.childBranches.delete(keyObject);
            this.primitiveKeys.delete(key2);
          }
        } else {
          this.childBranches.delete(key2);
        }
      } else {
        var childKey = arguments[0];
        if (this.has(childKey)) {
          var childBranch = this.get(childKey);
          childBranch.clear.apply(childBranch, Array.prototype.slice.call(arguments, 1));
        }
      }
    };
    module.exports = function memoize2(fn) {
      var argsTree = new MapTree();
      function memoized() {
        var args = Array.prototype.slice.call(arguments);
        var argNode = args.reduce(function getBranch(parentBranch, arg) {
          return parentBranch.resolveBranch(arg);
        }, argsTree);
        if (argNode.hasValue) {
          return argNode.value;
        }
        var value = fn.apply(null, args);
        return argNode.setValue(value);
      }
      memoized.clear = argsTree.clear.bind(argsTree);
      return memoized;
    };
  }
});
var require_memoize_weak = __commonJS({
  "node_modules/memoize-weak/index.js"(exports, module) {
    module.exports = require_memoize();
  }
});
function setPath(parent, key2, value) {
  parent[key2] = value;
  return "skip";
}
function isInvalidPath(originalPath, pathData) {
  return pathData.value !== void 0 && typeof pathData.value !== "object" && pathData.path.length < originalPath.length;
}
function pathExists(obj, path, options2 = {}) {
  if (!options2.modifier) {
    options2.modifier = (pathData) => isInvalidPath(path, pathData) ? void 0 : pathData.value;
  }
  const exists = traversePath(obj, path, options2.modifier);
  if (!exists)
    return void 0;
  if (options2.value === void 0)
    return exists;
  return options2.value(exists.value) ? exists : void 0;
}
function traversePath(obj, realPath, modifier) {
  if (!realPath.length)
    return void 0;
  const path = [realPath[0]];
  let parent = obj;
  while (path.length < realPath.length) {
    const key22 = path[path.length - 1];
    const value = modifier ? modifier({
      parent,
      key: String(key22),
      value: parent[key22],
      path: path.map((p3) => String(p3)),
      isLeaf: false,
      set: (v3) => setPath(parent, key22, v3)
    }) : parent[key22];
    if (value === void 0)
      return void 0;
    else
      parent = value;
    path.push(realPath[path.length]);
  }
  if (!parent)
    return void 0;
  const key2 = realPath[realPath.length - 1];
  return {
    parent,
    key: String(key2),
    value: parent[key2],
    path: realPath.map((p3) => String(p3)),
    isLeaf: true,
    set: (v3) => setPath(parent, key2, v3)
  };
}
function traversePaths(parent, modifier, path = []) {
  for (const key2 in parent) {
    const value = parent[key2];
    const isLeaf = value === null || typeof value !== "object";
    const pathData = {
      parent,
      key: key2,
      value,
      path: path.concat([key2]),
      // path.map(String).concat([key])
      isLeaf,
      set: (v3) => setPath(parent, key2, v3)
    };
    const status = modifier(pathData);
    if (status === "abort")
      return status;
    else if (status === "skip")
      continue;
    else if (!isLeaf) {
      const status2 = traversePaths(value, modifier, pathData.path);
      if (status2 === "abort")
        return status2;
    }
  }
}
function eqSet(xs, ys) {
  return xs === ys || xs.size === ys.size && [...xs].every((x4) => ys.has(x4));
}
function comparePaths(newObj, oldObj) {
  const diffPaths = /* @__PURE__ */ new Map();
  function checkPath(data2, compareTo) {
    const exists = compareTo ? traversePath(compareTo, data2.path) : void 0;
    function addDiff() {
      diffPaths.set(data2.path.join(" "), data2.path);
      return "skip";
    }
    if (data2.isLeaf) {
      if (!exists) {
        addDiff();
      } else if (data2.value !== exists.value) {
        addDiff();
      }
    } else if (exists) {
      if ((data2.value instanceof Date || exists.value instanceof Date) && (!!data2.value != !!exists.value || data2.value.getTime() != exists.value.getTime())) {
        return addDiff();
      } else if ((data2.value instanceof Set || exists.value instanceof Set) && (!!data2.value != !!exists.value || !eqSet(data2.value, exists.value))) {
        return addDiff();
      } else if ((data2.value instanceof File || exists.value instanceof File) && (!!data2.value != !!exists.value || data2.value !== exists.value)) {
        return addDiff();
      }
    }
  }
  traversePaths(newObj, (data2) => checkPath(data2, oldObj));
  traversePaths(oldObj, (data2) => checkPath(data2, newObj));
  return Array.from(diffPaths.values());
}
function setPaths(obj, paths, value) {
  const isFunction2 = typeof value === "function";
  for (const path of paths) {
    const leaf = traversePath(obj, path, ({ parent, key: key2, value: value2 }) => {
      if (value2 === void 0 || typeof value2 !== "object") {
        parent[key2] = {};
      }
      return parent[key2];
    });
    if (leaf)
      leaf.parent[leaf.key] = isFunction2 ? value(path, leaf) : value;
  }
}
function splitPath(path) {
  return path.toString().split(/[[\].]+/).filter((p3) => p3);
}
function mergePath(path) {
  return path.reduce((acc, next2) => {
    const key2 = String(next2);
    if (typeof next2 === "number" || /^\d+$/.test(key2))
      acc += `[${key2}]`;
    else if (!acc)
      acc += key2;
    else
      acc += `.${key2}`;
    return acc;
  }, "");
}
function clone$1(data2) {
  return data2 && typeof data2 === "object" ? collectionClone(data2) : data2;
}
function assertSchema(schema, path) {
  if (typeof schema === "boolean") {
    throw new SchemaError("Schema property cannot be defined as boolean.", path);
  }
}
function schemaInfo(schema, isOptional, path) {
  assertSchema(schema, path);
  if (schema.allOf && schema.allOf.length) {
    return {
      ...merge.withOptions({ allowUndefinedOverrides: false }, ...schema.allOf.map((s3) => schemaInfo(s3, false, []))),
      schema
    };
  }
  const types = schemaTypes(schema, path);
  const array2 = schema.items && types.includes("array") ? (Array.isArray(schema.items) ? schema.items : [schema.items]).filter((s3) => typeof s3 !== "boolean") : void 0;
  const properties = schema.properties && types.includes("object") ? Object.fromEntries(Object.entries(schema.properties).filter(([, value]) => typeof value !== "boolean")) : void 0;
  const union = unionInfo(schema)?.filter((u2) => u2.type !== "null" && u2.const !== null);
  return {
    types: types.filter((s3) => s3 !== "null"),
    isOptional,
    isNullable: types.includes("null"),
    schema,
    union: union?.length ? union : void 0,
    array: array2,
    properties,
    required: schema.required
  };
}
function schemaTypes(schema, path) {
  assertSchema(schema, path);
  let types = schema.const === null ? ["null"] : [];
  if (schema.type) {
    types = Array.isArray(schema.type) ? schema.type : [schema.type];
  }
  if (schema.anyOf) {
    types = schema.anyOf.flatMap((s3) => schemaTypes(s3, path));
  }
  if (types.includes("array") && schema.uniqueItems) {
    const i3 = types.findIndex((t2) => t2 != "array");
    types[i3] = "set";
  } else if (schema.format && conversionFormatTypes.includes(schema.format)) {
    types.unshift(schema.format);
    if (schema.format == "unix-time") {
      const i3 = types.findIndex((t2) => t2 == "integer");
      types.splice(i3, 1);
    }
  }
  if (schema.const && schema.const !== null && typeof schema.const !== "function") {
    types.push(typeof schema.const);
  }
  return Array.from(new Set(types));
}
function unionInfo(schema) {
  if (!schema.anyOf || !schema.anyOf.length)
    return void 0;
  return schema.anyOf.filter((s3) => typeof s3 !== "boolean");
}
function defaultValues(schema, isOptional = false, path = []) {
  return _defaultValues(schema, isOptional, path);
}
function _defaultValues(schema, isOptional, path) {
  if (!schema) {
    throw new SchemaError("Schema was undefined", path);
  }
  const info = schemaInfo(schema, isOptional, path);
  if (!info)
    return void 0;
  let objectDefaults = void 0;
  if ("default" in schema) {
    if (info.types.includes("object") && schema.default && typeof schema.default == "object" && !Array.isArray(schema.default)) {
      objectDefaults = schema.default;
    } else {
      if (info.types.length > 1) {
        if (info.types.includes("unix-time") && (info.types.includes("integer") || info.types.includes("number")))
          throw new SchemaError("Cannot resolve a default value with a union that includes a date and a number/integer.", path);
      }
      const [type] = info.types;
      return formatDefaultValue(type, schema.default);
    }
  }
  let _multiType;
  const isMultiTypeUnion = () => {
    if (!info.union || info.union.length < 2)
      return false;
    if (info.union.some((i3) => i3.enum))
      return true;
    if (!_multiType) {
      _multiType = new Set(info.types.map((i3) => {
        return ["integer", "unix-time"].includes(i3) ? "number" : i3;
      }));
    }
    return _multiType.size > 1;
  };
  let output = {};
  if (!objectDefaults && info.union) {
    const singleDefault = info.union.filter((s3) => typeof s3 !== "boolean" && s3.default !== void 0);
    if (singleDefault.length == 1) {
      return _defaultValues(singleDefault[0], isOptional, path);
    } else if (singleDefault.length > 1) {
      throw new SchemaError("Only one default value can exist in a union, or set a default value for the whole union.", path);
    } else {
      if (info.isNullable)
        return null;
      if (info.isOptional)
        return void 0;
      if (isMultiTypeUnion()) {
        throw new SchemaError("Multi-type unions must have a default value, or exactly one of the union types must have.", path);
      }
      if (info.union.length && info.types[0] == "object") {
        output = info.union.length > 1 ? merge.withOptions({ allowUndefinedOverrides: true }, ...info.union.map((s3) => _defaultValues(s3, isOptional, path))) : _defaultValues(info.union[0], isOptional, path);
      }
    }
  }
  if (!objectDefaults) {
    if (info.isNullable)
      return null;
    if (info.isOptional)
      return void 0;
  }
  if (info.properties) {
    for (const [key2, value] of Object.entries(info.properties)) {
      assertSchema(value, [...path, key2]);
      const def = objectDefaults && objectDefaults[key2] !== void 0 ? objectDefaults[key2] : _defaultValues(value, !info.required?.includes(key2), [...path, key2]);
      output[key2] = def;
    }
    return output;
  } else if (objectDefaults) {
    return objectDefaults;
  }
  if (schema.enum) {
    return schema.enum[0];
  }
  if (isMultiTypeUnion()) {
    throw new SchemaError("Default values cannot have more than one type.", path);
  } else if (info.types.length == 0) {
    return void 0;
  }
  const [formatType] = info.types;
  return defaultValue(formatType, schema.enum);
}
function formatDefaultValue(type, value) {
  switch (type) {
    case "set":
      return Array.isArray(value) ? new Set(value) : value;
    case "Date":
    case "date":
    case "unix-time":
      if (typeof value === "string" || typeof value === "number")
        return new Date(value);
      break;
    case "bigint":
      if (typeof value === "string" || typeof value === "number")
        return BigInt(value);
      break;
    case "symbol":
      if (typeof value === "string" || typeof value === "number")
        return Symbol(value);
      break;
  }
  return value;
}
function defaultValue(type, enumType2) {
  switch (type) {
    case "string":
      return enumType2 && enumType2.length > 0 ? enumType2[0] : "";
    case "number":
    case "integer":
      return enumType2 && enumType2.length > 0 ? enumType2[0] : 0;
    case "boolean":
      return false;
    case "array":
      return [];
    case "object":
      return {};
    case "null":
      return null;
    case "Date":
    case "date":
    case "unix-time":
      return void 0;
    case "bigint":
      return BigInt(0);
    case "set":
      return /* @__PURE__ */ new Set();
    case "symbol":
      return Symbol();
    case "undefined":
    case "any":
      return void 0;
    default:
      throw new SchemaError("Schema type or format not supported, requires explicit default value: " + type);
  }
}
function defaultTypes(schema, path = []) {
  return _defaultTypes(schema, false, path);
}
function _defaultTypes(schema, isOptional, path) {
  if (!schema) {
    throw new SchemaError("Schema was undefined", path);
  }
  const info = schemaInfo(schema, isOptional, path);
  const output = {
    __types: info.types
  };
  if (info.schema.items && typeof info.schema.items == "object" && !Array.isArray(info.schema.items)) {
    output.__items = _defaultTypes(info.schema.items, info.isOptional, path);
  }
  if (info.properties) {
    for (const [key2, value] of Object.entries(info.properties)) {
      assertSchema(value, [...path, key2]);
      output[key2] = _defaultTypes(info.properties[key2], !info.required?.includes(key2), [
        ...path,
        key2
      ]);
    }
  }
  if (info.isNullable && !output.__types.includes("null")) {
    output.__types.push("null");
  }
  if (info.isOptional && !output.__types.includes("undefined")) {
    output.__types.push("undefined");
  }
  return output;
}
function mapErrors(errors, shape) {
  const output = {};
  function addFormLevelError(error) {
    if (!("_errors" in output))
      output._errors = [];
    if (!Array.isArray(output._errors)) {
      if (typeof output._errors === "string")
        output._errors = [output._errors];
      else
        throw new SuperFormError("Form-level error was not an array.");
    }
    output._errors.push(error.message);
  }
  for (const error of errors) {
    if (!error.path || error.path.length == 1 && !error.path[0]) {
      addFormLevelError(error);
      continue;
    }
    const isLastIndexNumeric = /^\d$/.test(String(error.path[error.path.length - 1]));
    const objectError = !isLastIndexNumeric && pathExists(shape, error.path.filter((p3) => /\D/.test(String(p3))))?.value;
    const leaf = traversePath(output, error.path, ({ value, parent: parent2, key: key22 }) => {
      if (value === void 0)
        parent2[key22] = {};
      return parent2[key22];
    });
    if (!leaf) {
      addFormLevelError(error);
      continue;
    }
    const { parent, key: key2 } = leaf;
    if (objectError) {
      if (!(key2 in parent))
        parent[key2] = {};
      if (!("_errors" in parent[key2]))
        parent[key2]._errors = [error.message];
      else
        parent[key2]._errors.push(error.message);
    } else {
      if (!(key2 in parent))
        parent[key2] = [error.message];
      else
        parent[key2].push(error.message);
    }
  }
  return output;
}
function updateErrors(New, Previous, force) {
  if (force)
    return New;
  traversePaths(Previous, (errors) => {
    if (!Array.isArray(errors.value))
      return;
    errors.set(void 0);
  });
  traversePaths(New, (error) => {
    if (!Array.isArray(error.value) && error.value !== void 0)
      return;
    setPaths(Previous, [error.path], error.value);
  });
  return Previous;
}
function flattenErrors(errors) {
  return _flattenErrors(errors, []);
}
function _flattenErrors(errors, path) {
  const entries = Object.entries(errors);
  return entries.filter(([, value]) => value !== void 0).flatMap(([key2, messages]) => {
    if (Array.isArray(messages) && messages.length > 0) {
      const currPath = path.concat([key2]);
      return { path: mergePath(currPath), messages };
    } else {
      return _flattenErrors(errors[key2], path.concat([key2]));
    }
  });
}
function mergeDefaults(parsedData, defaults6) {
  if (!parsedData)
    return clone$1(defaults6);
  return merge.withOptions({ mergeArrays: false }, defaults6, parsedData);
}
function replaceInvalidDefaults(Data, Defaults, _schema, Errors, preprocessed) {
  const defaultType = _schema.additionalProperties && typeof _schema.additionalProperties == "object" ? { __types: schemaInfo(_schema.additionalProperties, false, []).types } : void 0;
  const Types = defaultTypes(_schema);
  function Types_correctValue(dataValue, defValue, type) {
    const types = type.__types;
    if (!types.length || types.every((t2) => t2 == "undefined" || t2 == "null" || t2 == "any")) {
      return dataValue;
    } else if (types.length == 1 && types[0] == "array" && !type.__items) {
      return dataValue;
    }
    const dateTypes = ["unix-time", "Date", "date"];
    for (const schemaType of types) {
      const defaultTypeValue = defaultValue(schemaType, void 0);
      const sameType = typeof dataValue === typeof defaultTypeValue || dateTypes.includes(schemaType) && dataValue instanceof Date;
      const sameExistance = sameType && dataValue === null === (defaultTypeValue === null);
      if (sameType && sameExistance) {
        return dataValue;
      } else if (type.__items) {
        return Types_correctValue(dataValue, defValue, type.__items);
      }
    }
    if (defValue === void 0 && types.includes("null")) {
      return null;
    }
    return defValue;
  }
  function Data_traverse() {
    traversePaths(Defaults, Defaults_traverseAndReplace);
    Errors_traverseAndReplace();
    return Data;
  }
  function Data_setValue(currentPath, newValue) {
    setPaths(Data, [currentPath], newValue);
  }
  function Errors_traverseAndReplace() {
    for (const error of Errors) {
      if (!error.path)
        continue;
      Defaults_traverseAndReplace({
        path: error.path,
        value: pathExists(Defaults, error.path)?.value
      });
    }
  }
  function Defaults_traverseAndReplace(defaultPath) {
    const currentPath = defaultPath.path;
    if (!currentPath || !currentPath[0])
      return;
    if (typeof currentPath[0] === "string" && preprocessed?.includes(currentPath[0]))
      return;
    const dataPath = pathExists(Data, currentPath);
    if (!dataPath && defaultPath.value !== void 0 || dataPath && dataPath.value === void 0) {
      Data_setValue(currentPath, defaultPath.value);
    } else if (dataPath) {
      const defValue = defaultPath.value;
      const dataValue = dataPath.value;
      if (defValue !== void 0 && typeof dataValue === typeof defValue && dataValue === null === (defValue === null)) {
        return;
      }
      const typePath = currentPath.filter((p3) => /\D/.test(String(p3)));
      const pathTypes = traversePath(Types, typePath, (path) => {
        return "__items" in path.value ? path.value.__items : path.value;
      });
      if (!pathTypes) {
        throw new SchemaError("No types found for defaults", currentPath);
      }
      const fieldType = pathTypes.value ?? defaultType;
      if (!fieldType) {
        throw new SchemaError("No default value specified for field (can be undefined, but must be explicit)", currentPath);
      }
      Data_setValue(currentPath, Types_correctValue(dataValue, defValue, fieldType));
    }
  }
  {
    return Data_traverse();
  }
}
function cancelFlash(options2) {
  if (!options2.flashMessage || !browser2)
    return;
  if (!shouldSyncFlash(options2))
    return;
  document.cookie = `flash=; Max-Age=0; Path=${options2.flashMessage.cookiePath ?? "/"};`;
}
function shouldSyncFlash(options2) {
  if (!options2.flashMessage || !browser2)
    return false;
  return options2.syncFlashMessage;
}
function deserialize(result) {
  const parsed = JSON.parse(result);
  if (parsed.data) {
    parsed.data = parse(parsed.data);
  }
  return parsed;
}
function clone2(element) {
  return (
    /** @type {T} */
    HTMLElement.prototype.cloneNode.call(element)
  );
}
function enhance(form_element, submit = () => {
}) {
  const fallback_callback = async ({
    action,
    result,
    reset: reset2 = true,
    invalidateAll: shouldInvalidateAll = true
  }) => {
    if (result.type === "success") {
      if (reset2) {
        HTMLFormElement.prototype.reset.call(form_element);
      }
      if (shouldInvalidateAll) {
        await invalidateAll();
      }
    }
    if (location.origin + location.pathname === action.origin + action.pathname || result.type === "redirect" || result.type === "error") {
      applyAction();
    }
  };
  async function handle_submit(event) {
    const method = event.submitter?.hasAttribute("formmethod") ? (
      /** @type {HTMLButtonElement | HTMLInputElement} */
      event.submitter.formMethod
    ) : clone2(form_element).method;
    if (method !== "post")
      return;
    event.preventDefault();
    const action = new URL(
      // We can't do submitter.formAction directly because that property is always set
      event.submitter?.hasAttribute("formaction") ? (
        /** @type {HTMLButtonElement | HTMLInputElement} */
        event.submitter.formAction
      ) : clone2(form_element).action
    );
    const form_data = new FormData(form_element);
    const submitter_name = event.submitter?.getAttribute("name");
    if (submitter_name) {
      form_data.append(submitter_name, event.submitter?.getAttribute("value") ?? "");
    }
    const controller = new AbortController();
    let cancelled = false;
    const cancel = () => cancelled = true;
    const callback = await submit({
      action,
      cancel,
      controller,
      formData: form_data,
      formElement: form_element,
      submitter: event.submitter
    }) ?? fallback_callback;
    if (cancelled)
      return;
    let result;
    try {
      const response = await fetch(action, {
        method: "POST",
        headers: {
          accept: "application/json",
          "x-sveltekit-action": "true"
        },
        cache: "no-store",
        body: form_data,
        signal: controller.signal
      });
      result = deserialize(await response.text());
      if (result.type === "error")
        result.status = response.status;
    } catch (error) {
      if (
        /** @type {any} */
        error?.name === "AbortError"
      )
        return;
      result = { type: "error", error };
    }
    callback({
      action,
      formData: form_data,
      formElement: form_element,
      update: (opts) => fallback_callback({
        action,
        result,
        reset: opts?.reset,
        invalidateAll: opts?.invalidateAll
      }),
      // @ts-expect-error generic constraints stuff we don't care about
      result
    });
  }
  HTMLFormElement.prototype.addEventListener.call(form_element, "submit", handle_submit);
  return {
    destroy() {
      HTMLFormElement.prototype.removeEventListener.call(form_element, "submit", handle_submit);
    }
  };
}
async function updateCustomValidity(validityEl, errors) {
  if ("setCustomValidity" in validityEl) {
    validityEl.setCustomValidity("");
  }
  if (noCustomValidityDataAttribute in validityEl.dataset)
    return;
  setCustomValidity(validityEl, errors);
}
function setCustomValidityForm(formElement, errors) {
  for (const el of formElement.querySelectorAll("input,select,textarea,button")) {
    if (noCustomValidityDataAttribute in el.dataset) {
      continue;
    }
    const error = traversePath(errors, splitPath(el.name));
    setCustomValidity(el, error?.value);
    if (error?.value)
      return;
  }
}
function setCustomValidity(el, errors) {
  const message = errors && errors.length ? errors.join("\n") : "";
  el.setCustomValidity(message);
  if (message)
    el.reportValidity();
}
function inputInfo(el) {
  const immediate = !!el && (el instanceof HTMLSelectElement || el instanceof HTMLInputElement && immediateInputTypes.includes(el.type));
  const multiple = !!el && el instanceof HTMLSelectElement && el.multiple;
  const file = !!el && el instanceof HTMLInputElement && el.type == "file";
  return { immediate, multiple, file };
}
function Form(formElement, timers, options2) {
  let state = FetchStatus.Idle;
  let delayedTimeout, timeoutTimeout;
  const Timers = activeTimers;
  function Timers_start() {
    Timers_clear();
    Timers_setState(state != FetchStatus.Delayed ? FetchStatus.Submitting : FetchStatus.Delayed);
    delayedTimeout = window.setTimeout(() => {
      if (delayedTimeout && state == FetchStatus.Submitting)
        Timers_setState(FetchStatus.Delayed);
    }, options2.delayMs);
    timeoutTimeout = window.setTimeout(() => {
      if (timeoutTimeout && state == FetchStatus.Delayed)
        Timers_setState(FetchStatus.Timeout);
    }, options2.timeoutMs);
    Timers.add(Timers_clear);
  }
  function Timers_clear() {
    clearTimeout(delayedTimeout);
    clearTimeout(timeoutTimeout);
    delayedTimeout = timeoutTimeout = 0;
    Timers.delete(Timers_clear);
    Timers_setState(FetchStatus.Idle);
  }
  function Timers_clearAll() {
    Timers.forEach((t2) => t2());
    Timers.clear();
  }
  function Timers_setState(s3) {
    state = s3;
    timers.submitting.set(state >= FetchStatus.Submitting);
    timers.delayed.set(state >= FetchStatus.Delayed);
    timers.timeout.set(state >= FetchStatus.Timeout);
  }
  const ErrorTextEvents = formElement;
  function ErrorTextEvents__selectText(e3) {
    const target = e3.target;
    if (options2.selectErrorText)
      target.select();
  }
  function ErrorTextEvents_addErrorTextListeners() {
    if (!options2.selectErrorText)
      return;
    ErrorTextEvents.querySelectorAll("input").forEach((el) => {
      el.addEventListener("invalid", ErrorTextEvents__selectText);
    });
  }
  function ErrorTextEvents_removeErrorTextListeners() {
    if (!options2.selectErrorText)
      return;
    ErrorTextEvents.querySelectorAll("input").forEach((el) => el.removeEventListener("invalid", ErrorTextEvents__selectText));
  }
  const Form2 = formElement;
  {
    ErrorTextEvents_addErrorTextListeners();
    const completed = (opts) => {
      if (!opts.clearAll)
        Timers_clear();
      else
        Timers_clearAll();
      if (!opts.cancelled)
        setTimeout(() => scrollToFirstError(Form2, options2), 1);
    };
    onDestroy(() => {
      ErrorTextEvents_removeErrorTextListeners();
      completed({ cancelled: true });
    });
    return {
      submitting() {
        Timers_start();
      },
      completed,
      scrollToFirstError() {
        setTimeout(() => scrollToFirstError(Form2, options2), 1);
      },
      isSubmitting: () => state === FetchStatus.Submitting || state === FetchStatus.Delayed
    };
  }
}
function updateProxyField(obj, path, updater) {
  const output = traversePath(obj, path, ({ parent, key: key2, value }) => {
    if (value === void 0)
      parent[key2] = /\D/.test(key2) ? {} : [];
    return parent[key2];
  });
  if (output) {
    const newValue = updater(output.value);
    output.parent[output.key] = newValue;
  }
  return obj;
}
function superFieldProxy(superForm2, path, baseOptions) {
  const form = superForm2.form;
  const path2 = splitPath(path);
  const proxy = derived(form, ($form) => {
    const data2 = traversePath($form, path2);
    return data2?.value;
  });
  return {
    subscribe(...params) {
      const unsub = proxy.subscribe(...params);
      return () => unsub();
    },
    update(upd, options2) {
      form.update((data2) => updateProxyField(data2, path2, upd), options2 ?? baseOptions);
    },
    set(value, options2) {
      form.update((data2) => updateProxyField(data2, path2, () => value), options2 ?? baseOptions);
    }
  };
}
function isSuperForm(form, options2) {
  const isSuperForm2 = "form" in form;
  if (!isSuperForm2 && options2?.taint !== void 0) {
    throw new SuperFormError("If options.taint is set, the whole superForm object must be used as a proxy.");
  }
  return isSuperForm2;
}
function fieldProxy(form, path, options2) {
  const path2 = splitPath(path);
  if (isSuperForm(form, options2)) {
    return superFieldProxy(form, path, options2);
  }
  const proxy = derived(form, ($form) => {
    const data2 = traversePath($form, path2);
    return data2?.value;
  });
  return {
    subscribe(...params) {
      const unsub = proxy.subscribe(...params);
      return () => unsub();
    },
    update(upd) {
      form.update((data2) => updateProxyField(data2, path2, upd));
    },
    set(value) {
      form.update((data2) => updateProxyField(data2, path2, () => value));
    }
  };
}
function superForm(form, formOptions) {
  let initialForm;
  let options2 = formOptions ?? {};
  let initialValidator = void 0;
  {
    if (options2.legacy ?? LEGACY_MODE) {
      if (options2.resetForm === void 0)
        options2.resetForm = false;
      if (options2.taintedMessage === void 0)
        options2.taintedMessage = true;
    }
    if (STORYBOOK_MODE) {
      if (options2.applyAction === void 0)
        options2.applyAction = false;
    }
    initialValidator = options2.validators;
    options2 = {
      ...defaultFormOptions,
      ...options2
    };
    if (options2.SPA && options2.validators === void 0) {
      console.warn("No validators set for superForm in SPA mode. Add a validation adapter to the validators option, or set it to false to disable this warning.");
    }
    if (!form) {
      throw new SuperFormError("No form data sent to superForm. Make sure the output from superValidate is used (usually data.form) and that it's not null or undefined. Alternatively, an object with default values for the form can also be used, but then constraints won't be available.");
    }
    if (Context_isValidationObject(form) === false) {
      form = {
        id: options2.id ?? "",
        valid: false,
        posted: false,
        errors: {},
        data: form
      };
    }
    form = form;
    const _initialFormId = options2.id ?? form.id;
    const _currentPage = get_store_value(page) ?? (STORYBOOK_MODE ? {} : void 0);
    if (!initialForms.has(form)) {
      initialForms.set(form, form);
    }
    initialForm = initialForms.get(form);
    if (typeof initialForm.valid !== "boolean") {
      throw new SuperFormError("A non-validation object was passed to superForm. It should be an object of type SuperValidated, usually returned from superValidate.");
    }
    if (_currentPage.form && typeof _currentPage.form === "object") {
      const postedData = _currentPage.form;
      for (const postedForm of Context_findValidationForms(postedData).reverse()) {
        if (postedForm.id == _initialFormId && !initialForms.has(postedForm)) {
          initialForms.set(postedData, postedData);
          const pageDataForm = form;
          form = postedForm;
          form.constraints = pageDataForm.constraints;
          form.shape = pageDataForm.shape;
          if (form.valid && options2.resetForm && (options2.resetForm === true || options2.resetForm())) {
            form = clone$1(pageDataForm);
            form.message = clone$1(postedForm.message);
          }
          break;
        }
      }
    } else {
      form = clone$1(initialForm);
    }
    onDestroy(() => {
      Unsubscriptions_unsubscribe();
      NextChange_clear();
      for (const events of Object.values(formEvents)) {
        events.length = 0;
      }
      formIds.get(_currentPage)?.delete(_initialFormId);
    });
    if (options2.dataType !== "json") {
      const checkForNestedData = (key2, value) => {
        if (!value || typeof value !== "object")
          return;
        if (Array.isArray(value)) {
          if (value.length > 0)
            checkForNestedData(key2, value[0]);
        } else if (!(value instanceof Date) && !(value instanceof File) && !browser2) {
          throw new SuperFormError(`Object found in form field "${key2}". Set the dataType option to "json" and add use:enhance to use nested data structures. More information: https://superforms.rocks/concepts/nested-data`);
        }
      };
      for (const [key2, value] of Object.entries(form.data)) {
        checkForNestedData(key2, value);
      }
    }
  }
  const __data = {
    formId: form.id,
    form: clone$1(form.data),
    constraints: form.constraints ?? {},
    posted: form.posted,
    errors: clone$1(form.errors),
    message: clone$1(form.message),
    tainted: void 0,
    valid: form.valid,
    submitting: false,
    shape: form.shape
  };
  const Data = __data;
  const FormId = writable(options2.id ?? form.id);
  function Context_findValidationForms(data2) {
    const forms = Object.values(data2).filter((v3) => Context_isValidationObject(v3) !== false);
    return forms;
  }
  function Context_isValidationObject(object) {
    if (!object || typeof object !== "object")
      return false;
    if (!("valid" in object && "errors" in object && typeof object.valid === "boolean")) {
      return false;
    }
    return "id" in object && typeof object.id === "string" ? object.id : false;
  }
  const _formData = writable(form.data);
  const Form$1 = {
    subscribe: _formData.subscribe,
    set: (value, options22 = {}) => {
      const newData = clone$1(value);
      Tainted_update(newData, options22.taint ?? true);
      return _formData.set(newData);
    },
    update: (updater, options22 = {}) => {
      return _formData.update((value) => {
        const newData = updater(value);
        Tainted_update(newData, options22.taint ?? true);
        return newData;
      });
    }
  };
  async function Form_validate(opts = {}) {
    const dataToValidate = opts.formData ?? Data.form;
    let errors = {};
    let status;
    const validator2 = opts.adapter ?? options2.validators;
    if (typeof validator2 == "object") {
      if (validator2 != initialValidator && !("jsonSchema" in validator2)) {
        throw new SuperFormError('Client validation adapter found in options.validators. A full adapter must be used when changing validators dynamically, for example "zod" instead of "zodClient".');
      }
      status = await /* @__PURE__ */ validator2.validate(dataToValidate);
      if (!status.success) {
        errors = mapErrors(status.issues, validator2.shape ?? Data.shape ?? {});
      } else if (opts.recheckValidData !== false) {
        return Form_validate({ ...opts, recheckValidData: false });
      }
    } else {
      status = { success: true, data: {} };
    }
    const data2 = { ...Data.form, ...dataToValidate, ...status.success ? status.data : {} };
    return {
      valid: status.success,
      posted: false,
      errors,
      data: data2,
      constraints: Data.constraints,
      message: void 0,
      id: Data.formId,
      shape: Data.shape
    };
  }
  function Form__changeEvent(event) {
    if (!options2.onChange || !event.paths.length || event.type == "blur")
      return;
    let changeEvent;
    const paths = event.paths.map(mergePath);
    if (event.type && event.paths.length == 1 && event.formElement && event.target instanceof Element) {
      changeEvent = {
        path: paths[0],
        paths,
        formElement: event.formElement,
        target: event.target,
        set(path, value, options22) {
          fieldProxy({ form: Form$1 }, path, options22).set(value);
        },
        get(path) {
          return get_store_value(fieldProxy(Form$1, path));
        }
      };
    } else {
      changeEvent = {
        paths,
        target: void 0,
        set(path, value, options22) {
          fieldProxy({ form: Form$1 }, path, options22).set(value);
        },
        get(path) {
          return get_store_value(fieldProxy(Form$1, path));
        }
      };
    }
    options2.onChange(changeEvent);
  }
  async function Form_clientValidation(event, force = false, adapter) {
    if (event) {
      if (options2.validators == "clear") {
        Errors.update(($errors) => {
          setPaths($errors, event.paths, void 0);
          return $errors;
        });
      }
      setTimeout(() => Form__changeEvent(event));
    }
    if (!event || !options2.validators || options2.validators == "clear")
      return;
    if (!force) {
      if (options2.validationMethod == "onsubmit" || options2.validationMethod == "submit-only") {
        return;
      }
      if (options2.validationMethod == "onblur" && event.type == "input")
        return;
      if (options2.validationMethod == "oninput" && event.type == "blur")
        return;
    }
    const result = await Form_validate({ adapter });
    if (result.valid && (event.immediate || event.type != "input")) {
      Form$1.set(result.data, { taint: "ignore" });
    }
    await tick();
    Form__displayNewErrors(result.errors, event, force);
    return result;
  }
  async function Form__displayNewErrors(errors, event, force) {
    const { type, immediate, multiple, paths } = event;
    const previous = Data.errors;
    const output = {};
    const validity = /* @__PURE__ */ new Map();
    const formElement = event.formElement ?? EnhancedForm;
    if (options2.customValidity && formElement) {
      for (const path of event.paths) {
        const name5 = CSS.escape(mergePath(path));
        const el = formElement.querySelector(`[name="${name5}"]`);
        if (el) {
          const message = "validationMessage" in el ? String(el.validationMessage) : "";
          validity.set(path.join(), { el, message });
          updateCustomValidity(el, void 0);
        }
      }
    }
    traversePaths(errors, (error) => {
      if (!Array.isArray(error.value))
        return;
      let joinedPath = error.path.join(".");
      if (joinedPath.endsWith("._errors")) {
        joinedPath = joinedPath.substring(0, -8);
      }
      function addError() {
        setPaths(output, [error.path], error.value);
        if (options2.customValidity && isEventError && validity.has(joinedPath)) {
          const { el, message } = validity.get(joinedPath);
          if (message != error.value) {
            updateCustomValidity(el, error.value);
            validity.clear();
          }
        }
      }
      if (force)
        return addError();
      const isEventError = error.value && paths.map((path) => path.join(".")).some((path) => path.startsWith(joinedPath));
      if (isEventError && options2.validationMethod == "oninput")
        return addError();
      if (immediate && !multiple && isEventError)
        return addError();
      if (multiple) {
        const errorPath = pathExists(get_store_value(Errors), error.path.slice(0, -1));
        if (errorPath?.value && typeof errorPath?.value == "object") {
          for (const errors2 of Object.values(errorPath.value)) {
            if (Array.isArray(errors2)) {
              return addError();
            }
          }
        }
      }
      const previousError = pathExists(previous, error.path);
      if (previousError && previousError.key in previousError.parent) {
        return addError();
      }
      const lastPath = error.path[error.path.length - 1];
      const isObjectError = lastPath == "_errors";
      if (isObjectError) {
        if (options2.validationMethod == "oninput" || type == "blur" && Tainted_hasBeenTainted(mergePath(error.path.slice(0, -1)))) {
          return addError();
        }
      } else {
        if (type == "blur" && isEventError) {
          return addError();
        }
      }
    });
    Errors.set(output);
  }
  function Form_set(data2, options22 = {}) {
    if (options22.keepFiles) {
      traversePaths(Data.form, (info) => {
        if (info.value instanceof File || browser2) {
          const dataPath = pathExists(data2, info.path);
          if (!dataPath || !(dataPath.key in dataPath.parent)) {
            setPaths(data2, [info.path], info.value);
          }
        }
      });
    }
    return Form$1.set(data2, options22);
  }
  function Form_shouldReset(validForm, successActionResult) {
    return validForm && successActionResult && options2.resetForm && (options2.resetForm === true || options2.resetForm());
  }
  async function Form_updateFromValidation(form2, successResult) {
    if (form2.valid && successResult && Form_shouldReset(form2.valid, successResult)) {
      Form_reset({ message: form2.message, posted: true });
    } else {
      rebind({
        form: form2,
        untaint: successResult,
        keepFiles: true,
        // Check if the form data should be used for updating, or if the invalidateAll load function should be used:
        skipFormData: options2.invalidateAll == "force"
      });
    }
    if (formEvents.onUpdated.length) {
      await tick();
    }
    for (const event of formEvents.onUpdated) {
      event({ form: form2 });
    }
  }
  function Form_reset(opts = {}) {
    if (opts.newState)
      initialForm.data = { ...initialForm.data, ...opts.newState };
    const resetData = clone$1(initialForm);
    resetData.data = { ...resetData.data, ...opts.data };
    if (opts.id !== void 0)
      resetData.id = opts.id;
    rebind({
      form: resetData,
      untaint: true,
      message: opts.message,
      keepFiles: false,
      posted: opts.posted
    });
  }
  async function Form_updateFromActionResult(result) {
    if (result.type == "error") {
      throw new SuperFormError(`ActionResult of type "${result.type}" cannot be passed to update function.`);
    }
    if (result.type == "redirect") {
      if (Form_shouldReset(true, true))
        Form_reset({ posted: true });
      return;
    }
    if (typeof result.data !== "object") {
      throw new SuperFormError("Non-object validation data returned from ActionResult.");
    }
    const forms = Context_findValidationForms(result.data);
    if (!forms.length) {
      throw new SuperFormError("No form data returned from ActionResult. Make sure you return { form } in the form actions.");
    }
    for (const newForm of forms) {
      if (newForm.id !== Data.formId)
        continue;
      await Form_updateFromValidation(newForm, result.status >= 200 && result.status < 300);
    }
  }
  const Message = writable(__data.message);
  const Constraints = writable(__data.constraints);
  const Posted = writable(__data.posted);
  const Shape = writable(__data.shape);
  const _errors = writable(form.errors);
  const Errors = {
    subscribe: _errors.subscribe,
    set(value, options22) {
      return _errors.set(updateErrors(value, Data.errors, options22?.force));
    },
    update(updater, options22) {
      return _errors.update((value) => {
        return updateErrors(updater(value), Data.errors, options22?.force);
      });
    },
    /**
     * To work with client-side validation, errors cannot be deleted but must
     * be set to undefined, to know where they existed before (tainted+error check in oninput)
     */
    clear: () => void 0
  };
  let NextChange = null;
  function NextChange_setHtmlEvent(event) {
    NextChange = event;
    setTimeout(() => {
      Form_clientValidation(NextChange);
    }, 0);
  }
  function NextChange_additionalEventInformation(event, immediate, multiple, formElement, target) {
    if (NextChange === null) {
      NextChange = { paths: [] };
    }
    NextChange.type = event;
    NextChange.immediate = immediate;
    NextChange.multiple = multiple;
    NextChange.formElement = formElement;
    NextChange.target = target;
  }
  function NextChange_paths() {
    return NextChange?.paths ?? [];
  }
  function NextChange_clear() {
    NextChange = null;
  }
  const Tainted = {
    state: writable(),
    message: options2.taintedMessage,
    clean: clone$1(form.data)
    // Important to clone form.data, so it's not comparing the same object,
  };
  function Tainted_enable() {
    options2.taintedMessage = Tainted.message;
  }
  function Tainted_currentState() {
    return Tainted.state;
  }
  function Tainted_hasBeenTainted(path) {
    if (!Data.tainted)
      return false;
    if (!path)
      return !!Data.tainted;
    const field = pathExists(Data.tainted, splitPath(path));
    return !!field && field.key in field.parent;
  }
  function Tainted_isTainted(path) {
    if (typeof path === "boolean")
      return path;
    if (typeof path === "object")
      return Tainted__isObjectTainted(path);
    if (!Data.tainted)
      return false;
    if (!path)
      return Tainted__isObjectTainted(Data.tainted);
    const field = pathExists(Data.tainted, splitPath(path));
    return Tainted__isObjectTainted(field?.value);
  }
  function Tainted__isObjectTainted(obj) {
    if (!obj)
      return false;
    if (typeof obj === "object") {
      for (const obj2 of Object.values(obj)) {
        if (Tainted__isObjectTainted(obj2))
          return true;
      }
    }
    return obj === true;
  }
  function Tainted_update(newData, taintOptions) {
    if (taintOptions == "ignore")
      return;
    const paths = comparePaths(newData, Data.form);
    if (paths.length) {
      if (taintOptions == "untaint-all" || taintOptions == "untaint-form") {
        Tainted.state.set(void 0);
      } else {
        Tainted.state.update((tainted) => {
          if (!tainted)
            tainted = {};
          setPaths(tainted, paths, (path, data2) => {
            const currentValue = traversePath(newData, path);
            const cleanPath = traversePath(Tainted.clean, path);
            return currentValue && cleanPath && currentValue.value === cleanPath.value ? void 0 : taintOptions === true ? true : taintOptions === "untaint" ? void 0 : data2.value;
          });
          return tainted;
        });
      }
    }
    NextChange_setHtmlEvent({ paths });
  }
  function Tainted_set(tainted, newClean) {
    Tainted.state.set(tainted);
    if (newClean)
      Tainted.clean = newClean;
  }
  const Submitting = writable(false);
  const Delayed = writable(false);
  const Timeout = writable(false);
  const Unsubscriptions = [
    // eslint-disable-next-line dci-lint/private-role-access
    Tainted.state.subscribe((tainted) => __data.tainted = clone$1(tainted)),
    // eslint-disable-next-line dci-lint/private-role-access
    Form$1.subscribe((form2) => __data.form = clone$1(form2)),
    // eslint-disable-next-line dci-lint/private-role-access
    Errors.subscribe((errors) => __data.errors = clone$1(errors)),
    FormId.subscribe((id2) => __data.formId = id2),
    Constraints.subscribe((constraints2) => __data.constraints = constraints2),
    Posted.subscribe((posted) => __data.posted = posted),
    Message.subscribe((message) => __data.message = message),
    Submitting.subscribe((submitting) => __data.submitting = submitting),
    Shape.subscribe((shape) => __data.shape = shape)
  ];
  function Unsubscriptions_unsubscribe() {
    Unsubscriptions.forEach((unsub) => unsub());
  }
  const AllErrors = derived(Errors, ($errors) => $errors ? flattenErrors($errors) : []);
  let EnhancedForm;
  options2.taintedMessage = void 0;
  function rebind(opts) {
    const form2 = opts.form;
    const message = opts.message ?? form2.message;
    if (opts.untaint) {
      Tainted_set(typeof opts.untaint === "boolean" ? void 0 : opts.untaint, form2.data);
    }
    if (opts.skipFormData !== true) {
      Form_set(form2.data, {
        taint: "ignore",
        keepFiles: opts.keepFiles
      });
    }
    Message.set(message);
    Errors.set(form2.errors);
    FormId.set(form2.id);
    Posted.set(opts.posted ?? form2.posted);
    if (form2.constraints)
      Constraints.set(form2.constraints);
    if (form2.shape)
      Shape.set(form2.shape);
    __data.valid = form2.valid;
    if (options2.flashMessage && shouldSyncFlash(options2)) {
      const flash = options2.flashMessage.module.getFlash(page);
      if (message && get_store_value(flash) === void 0) {
        flash.set(message);
      }
    }
  }
  const formEvents = {
    onSubmit: options2.onSubmit ? [options2.onSubmit] : [],
    onResult: options2.onResult ? [options2.onResult] : [],
    onUpdate: options2.onUpdate ? [options2.onUpdate] : [],
    onUpdated: options2.onUpdated ? [options2.onUpdated] : [],
    onError: options2.onError ? [options2.onError] : []
  };
  return {
    form: Form$1,
    formId: FormId,
    errors: Errors,
    message: Message,
    constraints: Constraints,
    tainted: Tainted_currentState(),
    submitting: readonly(Submitting),
    delayed: readonly(Delayed),
    timeout: readonly(Timeout),
    options: options2,
    capture() {
      return {
        valid: Data.valid,
        posted: Data.posted,
        errors: Data.errors,
        data: Data.form,
        constraints: Data.constraints,
        message: Data.message,
        id: Data.formId,
        tainted: Data.tainted,
        shape: Data.shape
      };
    },
    restore: (snapshot) => {
      rebind({ form: snapshot, untaint: snapshot.tainted ?? true });
    },
    async validate(path, opts = {}) {
      if (!options2.validators) {
        throw new SuperFormError("options.validators must be set to use the validate method.");
      }
      if (opts.update === void 0)
        opts.update = true;
      if (opts.taint === void 0)
        opts.taint = false;
      if (typeof opts.errors == "string")
        opts.errors = [opts.errors];
      let data2;
      const splittedPath = splitPath(path);
      if ("value" in opts) {
        if (opts.update === true || opts.update === "value") {
          Form$1.update(($form) => {
            setPaths($form, [splittedPath], opts.value);
            return $form;
          }, { taint: opts.taint });
          data2 = Data.form;
        } else {
          data2 = clone$1(Data.form);
          setPaths(data2, [splittedPath], opts.value);
        }
      } else {
        data2 = Data.form;
      }
      const result = await Form_validate({ formData: data2 });
      const error = pathExists(result.errors, splittedPath);
      if (error && error.value && opts.errors) {
        error.value = opts.errors;
      }
      if (opts.update === true || opts.update == "errors") {
        Errors.update(($errors) => {
          setPaths($errors, [splittedPath], error?.value);
          return $errors;
        });
      }
      return error?.value;
    },
    async validateForm(opts = {}) {
      if (!options2.validators && !opts.schema) {
        throw new SuperFormError("options.validators or the schema option must be set to use the validateForm method.");
      }
      const result = opts.update ? await Form_clientValidation({ paths: [] }, true, opts.schema) : Form_validate({ adapter: opts.schema });
      if (opts.update && EnhancedForm) {
        setTimeout(() => {
          if (EnhancedForm)
            scrollToFirstError(EnhancedForm, {
              ...options2,
              scrollToError: opts.focusOnError === false ? "off" : options2.scrollToError
            });
        }, 1);
      }
      return result || Form_validate({ adapter: opts.schema });
    },
    allErrors: AllErrors,
    posted: Posted,
    reset(options22) {
      return Form_reset({
        message: options22?.keepMessage ? Data.message : void 0,
        data: options22?.data,
        id: options22?.id,
        newState: options22?.newState
      });
    },
    submit(submitter) {
      const form2 = EnhancedForm ? EnhancedForm : submitter && submitter instanceof HTMLElement ? submitter.closest("form") : void 0;
      if (!form2) {
        throw new SuperFormError("use:enhance must be added to the form to use submit, or pass a HTMLElement inside the form (or the form itself) as an argument.");
      }
      const isSubmitButton = submitter && (submitter instanceof HTMLButtonElement && submitter.type == "submit" || submitter instanceof HTMLInputElement && ["submit", "image"].includes(submitter.type));
      form2.requestSubmit(isSubmitButton ? submitter : void 0);
    },
    isTainted: Tainted_isTainted,
    ///// Custom use:enhance ////////////////////////////////////////
    // @DCI-context
    enhance(FormElement, events) {
      EnhancedForm = FormElement;
      if (events) {
        if (events.onError) {
          if (options2.onError === "apply") {
            throw new SuperFormError('options.onError is set to "apply", cannot add any onError events.');
          } else if (events.onError === "apply") {
            throw new SuperFormError('Cannot add "apply" as onError event in use:enhance.');
          }
          formEvents.onError.push(events.onError);
        }
        if (events.onResult)
          formEvents.onResult.push(events.onResult);
        if (events.onSubmit)
          formEvents.onSubmit.push(events.onSubmit);
        if (events.onUpdate)
          formEvents.onUpdate.push(events.onUpdate);
        if (events.onUpdated)
          formEvents.onUpdated.push(events.onUpdated);
      }
      Tainted_enable();
      let lastInputChange;
      async function onInput(e3) {
        const info = inputInfo(e3.target);
        if (info.immediate && !info.file)
          await new Promise((r4) => setTimeout(r4, 0));
        lastInputChange = NextChange_paths();
        NextChange_additionalEventInformation("input", info.immediate, info.multiple, FormElement, e3.target ?? void 0);
      }
      async function onBlur(e3) {
        if (Data.submitting)
          return;
        if (!lastInputChange || NextChange_paths() != lastInputChange) {
          return;
        }
        const info = inputInfo(e3.target);
        if (info.immediate && !info.file)
          await new Promise((r4) => setTimeout(r4, 0));
        Form_clientValidation({
          paths: lastInputChange,
          immediate: info.multiple,
          multiple: info.multiple,
          type: "blur",
          formElement: FormElement,
          target: e3.target ?? void 0
        });
        lastInputChange = void 0;
      }
      FormElement.addEventListener("focusout", onBlur);
      FormElement.addEventListener("input", onInput);
      onDestroy(() => {
        FormElement.removeEventListener("focusout", onBlur);
        FormElement.removeEventListener("input", onInput);
        EnhancedForm = void 0;
      });
      const htmlForm = Form(FormElement, { submitting: Submitting, delayed: Delayed, timeout: Timeout }, options2);
      let currentRequest;
      return enhance(FormElement, async (submitParams) => {
        let jsonData = void 0;
        let validationAdapter = options2.validators;
        const submit = {
          ...submitParams,
          jsonData(data2) {
            if (options2.dataType !== "json") {
              throw new SuperFormError("options.dataType must be set to 'json' to use jsonData.");
            }
            jsonData = data2;
          },
          validators(adapter) {
            validationAdapter = adapter;
          }
        };
        const _submitCancel = submit.cancel;
        let cancelled = false;
        function clientValidationResult(validation) {
          const validationResult = { ...validation, posted: true };
          const status = validationResult.valid ? 200 : (typeof options2.SPA === "boolean" ? void 0 : options2.SPA?.failStatus) ?? 400;
          const data2 = { form: validationResult };
          const result = validationResult.valid ? { type: "success", status, data: data2 } : { type: "failure", status, data: data2 };
          setTimeout(() => validationResponse({ result }), 0);
        }
        function cancel(opts = {
          resetTimers: true
        }) {
          cancelled = true;
          if (opts.resetTimers && htmlForm.isSubmitting()) {
            htmlForm.completed({ cancelled });
          }
          return _submitCancel();
        }
        submit.cancel = cancel;
        if (htmlForm.isSubmitting() && options2.multipleSubmits == "prevent") {
          cancel({ resetTimers: false });
        } else {
          if (htmlForm.isSubmitting() && options2.multipleSubmits == "abort") {
            if (currentRequest)
              currentRequest.abort();
          }
          htmlForm.submitting();
          currentRequest = submit.controller;
          for (const event of formEvents.onSubmit) {
            await event(submit);
          }
        }
        if (cancelled && options2.flashMessage)
          cancelFlash(options2);
        if (!cancelled) {
          const noValidate = !options2.SPA && (FormElement.noValidate || (submit.submitter instanceof HTMLButtonElement || submit.submitter instanceof HTMLInputElement) && submit.submitter.formNoValidate);
          let validation = void 0;
          const validateForm = async () => {
            return await Form_validate({ adapter: validationAdapter });
          };
          if (!noValidate) {
            validation = await validateForm();
            if (!validation.valid) {
              cancel({ resetTimers: false });
              clientValidationResult(validation);
            }
          }
          if (!cancelled) {
            switch (options2.clearOnSubmit) {
              case "errors-and-message":
                Errors.clear();
                Message.set(void 0);
                break;
              case "errors":
                Errors.clear();
                break;
              case "message":
                Message.set(void 0);
                break;
            }
            if (options2.flashMessage && (options2.clearOnSubmit == "errors-and-message" || options2.clearOnSubmit == "message") && shouldSyncFlash(options2)) {
              options2.flashMessage.module.getFlash(page).set(void 0);
            }
            const submitData = "formData" in submit ? submit.formData : submit.data;
            lastInputChange = void 0;
            if (options2.SPA) {
              if (!validation)
                validation = await validateForm();
              cancel({ resetTimers: false });
              clientValidationResult(validation);
            } else if (options2.dataType === "json") {
              if (!validation)
                validation = await validateForm();
              const postData = clone$1(jsonData ?? validation.data);
              traversePaths(postData, (data2) => {
                if (data2.value instanceof File) {
                  const key2 = "__superform_file_" + mergePath(data2.path);
                  submitData.append(key2, data2.value);
                  return data2.set(void 0);
                } else if (Array.isArray(data2.value) && data2.value.length && data2.value.every((v3) => v3 instanceof File)) {
                  const key2 = "__superform_files_" + mergePath(data2.path);
                  for (const file of data2.value) {
                    submitData.append(key2, file);
                  }
                  return data2.set(void 0);
                }
              });
              Object.keys(postData).forEach((key2) => {
                if (typeof submitData.get(key2) === "string") {
                  submitData.delete(key2);
                }
              });
              const chunks = chunkSubstr(stringify(postData), options2.jsonChunkSize ?? 5e5);
              for (const chunk of chunks) {
                submitData.append("__superform_json", chunk);
              }
            }
            if (!options2.SPA && !submitData.has("__superform_id")) {
              const id2 = Data.formId;
              if (id2 !== void 0)
                submitData.set("__superform_id", id2);
            }
          }
        }
        function chunkSubstr(str, size3) {
          const numChunks = Math.ceil(str.length / size3);
          const chunks = new Array(numChunks);
          for (let i3 = 0, o2 = 0; i3 < numChunks; ++i3, o2 += size3) {
            chunks[i3] = str.substring(o2, o2 + size3);
          }
          return chunks;
        }
        async function validationResponse(event) {
          let cancelled2 = false;
          currentRequest = null;
          let result = event.result.type ? event.result : {
            type: "error",
            status: 500,
            error: event.result
          };
          const cancel2 = () => cancelled2 = true;
          const data2 = {
            result,
            formEl: FormElement,
            formElement: FormElement,
            cancel: cancel2
          };
          const unsubCheckforNav = STORYBOOK_MODE ? () => {
          } : navigating.subscribe(($nav) => {
            if (!$nav || $nav.from?.route.id === $nav.to?.route.id)
              return;
            cancel2();
          });
          for (const event2 of formEvents.onResult) {
            await event2(data2);
          }
          result = data2.result;
          if (!cancelled2) {
            if ((result.type === "success" || result.type == "failure") && result.data) {
              const forms = Context_findValidationForms(result.data);
              if (!forms.length) {
                throw new SuperFormError("No form data returned from ActionResult. Make sure you return { form } in the form actions.");
              }
              for (const newForm of forms) {
                if (newForm.id !== Data.formId)
                  continue;
                const data22 = {
                  form: newForm,
                  formEl: FormElement,
                  formElement: FormElement,
                  cancel: () => cancelled2 = true
                };
                for (const event2 of formEvents.onUpdate) {
                  await event2(data22);
                }
                if (!cancelled2) {
                  if (options2.customValidity) {
                    setCustomValidityForm(FormElement, data22.form.errors);
                  }
                  if (Form_shouldReset(data22.form.valid, result.type == "success")) {
                    data22.formElement.querySelectorAll('input[type="file"]').forEach((e3) => e3.value = "");
                  }
                }
              }
            }
            if (!cancelled2) {
              if (result.type !== "error") {
                if (result.type === "success" && options2.invalidateAll) {
                  await invalidateAll();
                }
                if (options2.applyAction) {
                  await applyAction();
                } else {
                  await Form_updateFromActionResult(result);
                }
              } else {
                if (options2.applyAction) {
                  if (options2.onError == "apply") {
                    await applyAction();
                  } else {
                    ({
                      type: "failure",
                      status: Math.floor(result.status || 500),
                      data: result
                    });
                    await applyAction();
                  }
                }
                if (options2.onError !== "apply") {
                  const data22 = { result, message: Message };
                  for (const onErrorEvent of formEvents.onError) {
                    if (onErrorEvent !== "apply" && (onErrorEvent != defaultOnError || !options2.flashMessage?.onError)) {
                      await onErrorEvent(data22);
                    }
                  }
                }
              }
              if (options2.flashMessage) {
                if (result.type == "error" && options2.flashMessage.onError) {
                  await options2.flashMessage.onError({
                    result,
                    flashMessage: options2.flashMessage.module.getFlash(page)
                  });
                }
              }
            }
          }
          if (cancelled2 && options2.flashMessage) {
            cancelFlash(options2);
          }
          if (cancelled2 || result.type != "redirect") {
            htmlForm.completed({ cancelled: cancelled2 });
          } else if (STORYBOOK_MODE) {
            htmlForm.completed({ cancelled: cancelled2, clearAll: true });
          } else {
            const unsub = navigating.subscribe(($nav) => {
              if ($nav)
                return;
              setTimeout(() => {
                try {
                  if (unsub)
                    unsub();
                } catch {
                }
              });
              if (htmlForm.isSubmitting()) {
                htmlForm.completed({ cancelled: cancelled2, clearAll: true });
              }
            });
          }
          unsubCheckforNav();
        }
        return validationResponse;
      });
    }
  };
}
function schemaShape(schema, path = []) {
  const output = _schemaShape(schema, path);
  if (!output)
    throw new SchemaError("No shape could be created for schema.", path);
  return output;
}
function _schemaShape(schema, path) {
  assertSchema(schema, path);
  const info = schemaInfo(schema, false, path);
  if (info.array || info.union) {
    const arr = info.array || [];
    const union = info.union || [];
    return arr.concat(union).reduce((shape, next2) => {
      const nextShape = _schemaShape(next2, path);
      if (nextShape)
        shape = { ...shape ?? {}, ...nextShape };
      return shape;
    }, arr.length ? {} : void 0);
  }
  if (info.properties) {
    const output = {};
    for (const [key2, prop] of Object.entries(info.properties)) {
      const shape = _schemaShape(prop, [...path, key2]);
      if (shape)
        output[key2] = shape;
    }
    return output;
  }
  return info.types.includes("array") || info.types.includes("object") ? {} : void 0;
}
function constraints(schema) {
  return _constraints(schemaInfo(schema, false, []), []);
}
function merge2(constraints2) {
  let output = {};
  for (const constraint2 of constraints2) {
    if (!constraint2)
      continue;
    output = { ...output, ...constraint2 };
  }
  return output;
}
function _constraints(info, path) {
  if (!info)
    return void 0;
  if (info.union) {
    const infos = info.union.map((s3) => schemaInfo(s3, info.isOptional, path));
    const merged = infos.map((i3) => _constraints(i3, path));
    const output = merge2(merged);
    if (output && (info.isNullable || info.isOptional || infos.some((i3) => i3?.isNullable || i3?.isOptional))) {
      delete output.required;
    }
    return output && Object.values(output).length ? output : void 0;
  }
  if (info.array) {
    if (info.array.length == 1) {
      return _constraints(schemaInfo(info.array[0], info.isOptional, path), path);
    }
    return merge2(info.array.map((i3) => _constraints(schemaInfo(i3, info.isOptional, path), path)));
  }
  if (info.properties) {
    const output = {};
    for (const [key2, prop] of Object.entries(info.properties)) {
      const propInfo = schemaInfo(prop, !info.required?.includes(key2) || prop.default !== void 0, [key2]);
      const propConstraint = _constraints(propInfo, [...path, key2]);
      if (typeof propConstraint === "object" && Object.values(propConstraint).length > 0) {
        output[key2] = propConstraint;
      }
    }
    return output;
  }
  return constraint(info);
}
function constraint(info) {
  const output = {};
  const schema = info.schema;
  const type = schema.type;
  const format = schema.format;
  if (type == "integer" && format == "unix-time") {
    const date = schema;
    if (date.minimum !== void 0)
      output.min = new Date(date.minimum).toISOString();
    if (date.maximum !== void 0)
      output.max = new Date(date.maximum).toISOString();
  } else if (type == "string") {
    const str = schema;
    const patterns = [
      str.pattern,
      ...str.allOf ? str.allOf.map((s3) => typeof s3 == "boolean" ? void 0 : s3.pattern) : []
    ].filter((s3) => s3 !== void 0);
    if (patterns.length > 0)
      output.pattern = patterns[0];
    if (str.minLength !== void 0)
      output.minlength = str.minLength;
    if (str.maxLength !== void 0)
      output.maxlength = str.maxLength;
  } else if (type == "number" || type == "integer") {
    const num = schema;
    if (num.minimum !== void 0)
      output.min = num.minimum;
    else if (num.exclusiveMinimum !== void 0)
      output.min = num.exclusiveMinimum + (type == "integer" ? 1 : Number.MIN_VALUE);
    if (num.maximum !== void 0)
      output.max = num.maximum;
    else if (num.exclusiveMaximum !== void 0)
      output.max = num.exclusiveMaximum - (type == "integer" ? 1 : Number.MIN_VALUE);
    if (num.multipleOf !== void 0)
      output.step = num.multipleOf;
  } else if (type == "array") {
    const arr = schema;
    if (arr.minItems !== void 0)
      output.min = arr.minItems;
    if (arr.maxItems !== void 0)
      output.max = arr.maxItems;
  }
  if (!info.isNullable && !info.isOptional) {
    output.required = true;
  }
  return Object.keys(output).length > 0 ? output : void 0;
}
function schemaHash(schema) {
  return hashCode(_schemaHash(schemaInfo(schema, false, []), 0, []));
}
function _schemaHash(info, depth, path) {
  if (!info)
    return "";
  function tab() {
    return "  ".repeat(depth);
  }
  function mapSchemas(schemas) {
    return schemas.map((s3) => _schemaHash(schemaInfo(s3, info?.isOptional ?? false, path), depth + 1, path)).filter((s3) => s3).join("|");
  }
  function nullish() {
    const output = [];
    if (info?.isNullable)
      output.push("null");
    if (info?.isOptional)
      output.push("undefined");
    return !output.length ? "" : "|" + output.join("|");
  }
  if (info.union) {
    return "Union {\n  " + tab() + mapSchemas(info.union) + "\n" + tab() + "}" + nullish();
  }
  if (info.properties) {
    const output = [];
    for (const [key2, prop] of Object.entries(info.properties)) {
      const propInfo = schemaInfo(prop, !info.required?.includes(key2) || prop.default !== void 0, [key2]);
      output.push(key2 + ": " + _schemaHash(propInfo, depth + 1, path));
    }
    return "Object {\n  " + tab() + output.join(",\n  ") + "\n" + tab() + "}" + nullish();
  }
  if (info.array) {
    return "Array[" + mapSchemas(info.array) + "]" + nullish();
  }
  return info.types.join("|") + nullish();
}
function hashCode(str) {
  let hash2 = 0;
  for (let i3 = 0, len = str.length; i3 < len; i3++) {
    const chr = str.charCodeAt(i3);
    hash2 = (hash2 << 5) - hash2 + chr;
    hash2 |= 0;
  }
  if (hash2 < 0)
    hash2 = hash2 >>> 0;
  return hash2.toString(36);
}
function createAdapter(adapter, jsonSchema) {
  if (!adapter || !("superFormValidationLibrary" in adapter)) {
    throw new SuperFormError('Superforms v2 requires a validation adapter for the schema. Import one of your choice from "sveltekit-superforms/adapters" and wrap the schema with it.');
  }
  if (!jsonSchema)
    jsonSchema = adapter.jsonSchema;
  return {
    ...adapter,
    constraints: adapter.constraints ?? constraints(jsonSchema),
    defaults: adapter.defaults ?? defaultValues(jsonSchema),
    shape: schemaShape(jsonSchema),
    id: schemaHash(jsonSchema)
  };
}
async function parseRequest(data2, schemaData, options2) {
  let parsed;
  if (data2 instanceof FormData) {
    parsed = parseFormData(data2, schemaData, options2);
  } else if (data2 instanceof URL || data2 instanceof URLSearchParams) {
    parsed = parseSearchParams(data2, schemaData, options2);
  } else if (data2 instanceof Request) {
    parsed = await tryParseFormData(data2, schemaData, options2);
  } else if (
    // RequestEvent
    data2 && typeof data2 === "object" && "request" in data2 && data2.request instanceof Request
  ) {
    parsed = await tryParseFormData(data2.request, schemaData, options2);
  } else {
    parsed = {
      id: void 0,
      data: data2,
      posted: false
    };
  }
  return parsed;
}
async function tryParseFormData(request, schemaData, options2) {
  let formData = void 0;
  try {
    formData = await request.formData();
  } catch (e3) {
    if (e3 instanceof TypeError && e3.message.includes("already been consumed")) {
      throw e3;
    }
    return { id: void 0, data: void 0, posted: false };
  }
  return parseFormData(formData, schemaData, options2);
}
function parseSearchParams(data2, schemaData, options2) {
  if (data2 instanceof URL)
    data2 = data2.searchParams;
  const convert = new FormData();
  for (const [key2, value] of data2.entries()) {
    convert.append(key2, value);
  }
  const output = parseFormData(convert, schemaData, options2);
  output.posted = false;
  return output;
}
function parseFormData(formData, schemaData, options2) {
  function tryParseSuperJson() {
    if (formData.has("__superform_json")) {
      try {
        const output = parse(formData.getAll("__superform_json").join("") ?? "");
        if (typeof output === "object") {
          const filePaths = Array.from(formData.keys());
          for (const path of filePaths.filter((path2) => path2.startsWith("__superform_file_"))) {
            const realPath = splitPath(path.substring(17));
            setPaths(output, [realPath], formData.get(path));
          }
          for (const path of filePaths.filter((path2) => path2.startsWith("__superform_files_"))) {
            const realPath = splitPath(path.substring(18));
            const allFiles = formData.getAll(path);
            setPaths(output, [realPath], Array.from(allFiles));
          }
          return output;
        }
      } catch {
      }
    }
    return null;
  }
  const data2 = tryParseSuperJson();
  const id2 = formData.get("__superform_id")?.toString();
  return data2 ? { id: id2, data: data2, posted: true } : {
    id: id2,
    data: _parseFormData(formData, schemaData, options2),
    posted: true
  };
}
function _parseFormData(formData, schema, options2) {
  const output = {};
  const schemaKeys = options2?.strict ? new Set([...formData.keys()].filter((key2) => !key2.startsWith("__superform_"))) : new Set([
    ...Object.keys(schema.properties ?? {}),
    ...schema.additionalProperties ? formData.keys() : []
  ].filter((key2) => !key2.startsWith("__superform_")));
  function parseSingleEntry(key2, entry, info) {
    if (options2?.preprocessed && options2.preprocessed.includes(key2)) {
      return entry;
    }
    if (entry && typeof entry !== "string") {
      const allowFiles = legacyMode ? options2?.allowFiles === true : options2?.allowFiles !== false;
      return !allowFiles ? void 0 : entry.size ? entry : info.isNullable ? null : void 0;
    }
    if (info.types.length > 1) {
      throw new SchemaError(unionError, key2);
    }
    const [type] = info.types;
    return parseFormDataEntry(key2, entry, type ?? "any", info);
  }
  const defaultPropertyType = typeof schema.additionalProperties == "object" ? schema.additionalProperties : { type: "string" };
  for (const key2 of schemaKeys) {
    const property = schema.properties ? schema.properties[key2] : defaultPropertyType;
    assertSchema(property, key2);
    const info = schemaInfo(property ?? defaultPropertyType, !schema.required?.includes(key2), [
      key2
    ]);
    if (!info)
      continue;
    if (!info.types.includes("boolean") && !schema.additionalProperties && !formData.has(key2)) {
      continue;
    }
    const entries = formData.getAll(key2);
    if (info.union && info.union.length > 1) {
      throw new SchemaError(unionError, key2);
    }
    if (info.types.includes("array") || info.types.includes("set")) {
      const items = property.items;
      if (!items || typeof items == "boolean" || Array.isArray(items) && items.length != 1) {
        throw new SchemaError('Arrays must have a single "items" property that defines its type.', key2);
      }
      const arrayType2 = Array.isArray(items) ? items[0] : items;
      assertSchema(arrayType2, key2);
      const arrayInfo = schemaInfo(arrayType2, info.isOptional, [key2]);
      if (!arrayInfo)
        continue;
      const arrayData = entries.map((e3) => parseSingleEntry(key2, e3, arrayInfo));
      output[key2] = info.types.includes("set") ? new Set(arrayData) : arrayData;
    } else {
      output[key2] = parseSingleEntry(key2, entries[entries.length - 1], info);
    }
  }
  return output;
}
function parseFormDataEntry(key2, value, type, info) {
  if (!value) {
    if (type == "boolean" && info.isOptional && info.schema.default === true) {
      return false;
    }
    const defaultValue2 = defaultValues(info.schema, info.isOptional, [key2]);
    if (info.schema.enum && defaultValue2 !== null && defaultValue2 !== void 0) {
      return value;
    }
    if (defaultValue2 !== void 0)
      return defaultValue2;
    if (info.isNullable)
      return null;
    if (info.isOptional)
      return void 0;
  }
  function typeError() {
    throw new SchemaError(type[0].toUpperCase() + type.slice(1) + ` type found. Set the dataType option to "json" and add use:enhance on the client to use nested data structures. More information: https://superforms.rocks/concepts/nested-data`, key2);
  }
  switch (type) {
    case "string":
    case "any":
      return value;
    case "integer":
      return parseInt(value ?? "", 10);
    case "number":
      return parseFloat(value ?? "");
    case "boolean":
      return Boolean(value == "false" ? "" : value).valueOf();
    case "unix-time": {
      const date = new Date(value ?? "");
      return !isNaN(date) ? date : void 0;
    }
    case "bigint":
      return BigInt(value ?? ".");
    case "symbol":
      return Symbol(String(value));
    case "set":
    case "array":
    case "object":
      return typeError();
    default:
      throw new SuperFormError("Unsupported schema type for FormData: " + type);
  }
}
async function validate(schema, data2) {
  const result = await schema.safeParseAsync(data2);
  if (result.success) {
    return {
      data: result.data,
      success: true
    };
  }
  return {
    issues: result.error.issues.map(({ message, path }) => ({ message, path })),
    success: false
  };
}
function _zod(schema, options2) {
  return /* @__PURE__ */ createAdapter({
    superFormValidationLibrary: "zod",
    validate: async (data2) => validate(schema, data2),
    jsonSchema: options2?.jsonSchema ?? /* @__PURE__ */ zodToJSONSchema(schema),
    defaults: options2?.defaults
  });
}
function _zodClient(schema) {
  return {
    superFormValidationLibrary: "zod",
    validate: async (data2) => validate(schema, data2)
  };
}
var import_memoize_weak;
var browser2;
var conversionFormatTypes;
var SuperFormError;
var SchemaError;
var noCustomValidityDataAttribute;
var isElementInViewport;
var scrollToAndCenter;
var immediateInputTypes;
var FetchStatus;
var activeTimers;
var scrollToFirstError;
var formIds;
var initialForms;
var defaultOnError;
var defaultFormOptions;
var LEGACY_MODE;
var STORYBOOK_MODE;
var legacyMode;
var unionError;
var memoize;
var defaultOptions3;
var zodToJSONSchema;
var zod;
var zodClient;
var loginSchema;
var logoutSchema;
var projectSchema;
var deleteProjectSchema;
var init_index4 = __esm({
  ".svelte-kit/output/server/chunks/index4.js"() {
    init_index2();
    init_stores2();
    init_prod_ssr();
    init_lifecycle();
    init_scheduler();
    init_client();
    init_devalue();
    init_devalue();
    init_just_clone();
    init_esm();
    init_esm2();
    import_memoize_weak = __toESM(require_memoize_weak(), 1);
    init_lib();
    browser2 = BROWSER;
    conversionFormatTypes = ["unix-time", "bigint", "any", "symbol", "set"];
    SuperFormError = class _SuperFormError extends Error {
      constructor(message) {
        super(message);
        Object.setPrototypeOf(this, _SuperFormError.prototype);
      }
    };
    SchemaError = class _SchemaError extends SuperFormError {
      path;
      constructor(message, path) {
        super((path && path.length ? `[${Array.isArray(path) ? path.join(".") : path}] ` : "") + message);
        this.path = Array.isArray(path) ? path.join(".") : path;
        Object.setPrototypeOf(this, _SchemaError.prototype);
      }
    };
    noCustomValidityDataAttribute = "noCustomValidity";
    isElementInViewport = (el, topOffset = 0) => {
      const rect = el.getBoundingClientRect();
      return rect.top >= topOffset && rect.left >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && rect.right <= (window.innerWidth || document.documentElement.clientWidth);
    };
    scrollToAndCenter = (el, offset2 = 1.125, behavior = "smooth") => {
      const elementRect = el.getBoundingClientRect();
      const absoluteElementTop = elementRect.top + window.pageYOffset;
      const top = absoluteElementTop - window.innerHeight / (2 * offset2);
      window.scrollTo({ left: 0, top, behavior });
    };
    immediateInputTypes = ["checkbox", "radio", "range", "file"];
    (function(FetchStatus2) {
      FetchStatus2[FetchStatus2["Idle"] = 0] = "Idle";
      FetchStatus2[FetchStatus2["Submitting"] = 1] = "Submitting";
      FetchStatus2[FetchStatus2["Delayed"] = 2] = "Delayed";
      FetchStatus2[FetchStatus2["Timeout"] = 3] = "Timeout";
    })(FetchStatus || (FetchStatus = {}));
    activeTimers = /* @__PURE__ */ new Set();
    scrollToFirstError = async (Form2, options2) => {
      if (options2.scrollToError == "off")
        return;
      const selector = options2.errorSelector;
      if (!selector)
        return;
      await tick();
      let el;
      el = Form2.querySelector(selector);
      if (!el)
        return;
      el = el.querySelector(selector) ?? el;
      const nav = options2.stickyNavbar ? document.querySelector(options2.stickyNavbar) : null;
      if (typeof options2.scrollToError != "string") {
        el.scrollIntoView(options2.scrollToError);
      } else if (!isElementInViewport(el, nav?.offsetHeight ?? 0)) {
        scrollToAndCenter(el, void 0, options2.scrollToError);
      }
      function Form_shouldAutoFocus(userAgent) {
        if (typeof options2.autoFocusOnError === "boolean")
          return options2.autoFocusOnError;
        else
          return !/iPhone|iPad|iPod|Android/i.test(userAgent);
      }
      if (!Form_shouldAutoFocus("Cloudflare-Workers"))
        return;
      let focusEl;
      focusEl = el;
      if (!["INPUT", "SELECT", "BUTTON", "TEXTAREA"].includes(focusEl.tagName)) {
        focusEl = focusEl.querySelector('input:not([type="hidden"]):not(.flatpickr-input), select, textarea');
      }
      if (focusEl) {
        try {
          focusEl.focus({ preventScroll: true });
          if (options2.selectErrorText && focusEl.tagName == "INPUT") {
            focusEl.select();
          }
        } catch (err) {
        }
      }
    };
    formIds = /* @__PURE__ */ new WeakMap();
    initialForms = /* @__PURE__ */ new WeakMap();
    defaultOnError = (event) => {
      console.warn("Unhandled Superform error, use onError event to handle it:", event.result.error);
    };
    defaultFormOptions = {
      applyAction: true,
      invalidateAll: true,
      resetForm: true,
      autoFocusOnError: "detect",
      scrollToError: "smooth",
      errorSelector: '[aria-invalid="true"],[data-invalid]',
      selectErrorText: false,
      stickyNavbar: void 0,
      taintedMessage: false,
      onSubmit: void 0,
      onResult: void 0,
      onUpdate: void 0,
      onUpdated: void 0,
      onError: defaultOnError,
      dataType: "form",
      validators: void 0,
      customValidity: false,
      clearOnSubmit: "errors-and-message",
      delayMs: 500,
      timeoutMs: 8e3,
      multipleSubmits: "prevent",
      SPA: void 0,
      validationMethod: "auto"
    };
    LEGACY_MODE = false;
    try {
      if (SUPERFORMS_LEGACY)
        LEGACY_MODE = true;
    } catch {
    }
    STORYBOOK_MODE = false;
    try {
      if (globalThis.STORIES)
        STORYBOOK_MODE = true;
    } catch {
    }
    legacyMode = false;
    try {
      if (SUPERFORMS_LEGACY)
        legacyMode = true;
    } catch {
    }
    unionError = 'FormData parsing failed: Unions are only supported when the dataType option for superForm is set to "json".';
    memoize = import_memoize_weak.default;
    defaultOptions3 = {
      dateStrategy: "integer",
      pipeStrategy: "output"
    };
    zodToJSONSchema = /* @__NO_SIDE_EFFECTS__ */
    (...params) => {
      params[1] = typeof params[1] == "object" ? { ...defaultOptions3, ...params[1] } : defaultOptions3;
      return zodToJsonSchema(...params);
    };
    zod = /* @__PURE__ */ memoize(_zod);
    zodClient = /* @__PURE__ */ memoize(_zodClient);
    loginSchema = z2.object({
      password: z2.string().min(1, { message: "Password is required" })
    });
    logoutSchema = z2.object({});
    projectSchema = z2.object({
      name: z2.string().min(1, { message: "Project name is required" }),
      type: z2.string({ required_error: "Please select a construction type" })
    });
    deleteProjectSchema = z2.object({
      name: z2.string().min(1, { message: "Project name is required" })
    });
  }
});
async function superValidate(data2, adapter, options2) {
  if (data2 && "superFormValidationLibrary" in data2) {
    options2 = adapter;
    adapter = data2;
    data2 = void 0;
  }
  const validator2 = adapter;
  const defaults6 = options2?.defaults ?? validator2.defaults;
  const jsonSchema = validator2.jsonSchema;
  const parsed = await parseRequest(data2, jsonSchema, options2);
  const addErrors = options2?.errors ?? (options2?.strict ? true : !!parsed.data);
  const parsedData = options2?.strict ? parsed.data ?? {} : mergeDefaults(parsed.data, defaults6);
  let status;
  if (!!parsed.data || addErrors) {
    status = await /* @__PURE__ */ validator2.validate(parsedData);
  } else {
    status = { success: false, issues: [] };
  }
  const valid = status.success;
  const errors = valid || !addErrors ? {} : mapErrors(status.issues, validator2.shape);
  const dataWithDefaults = valid ? status.data : replaceInvalidDefaults(options2?.strict ? mergeDefaults(parsedData, defaults6) : parsedData, defaults6, jsonSchema, status.issues, options2?.preprocessed);
  let outputData;
  if (jsonSchema.additionalProperties === false) {
    outputData = {};
    for (const key2 of Object.keys(jsonSchema.properties ?? {})) {
      if (key2 in dataWithDefaults)
        outputData[key2] = dataWithDefaults[key2];
    }
  } else {
    outputData = dataWithDefaults;
  }
  const output = {
    id: parsed.id ?? options2?.id ?? validator2.id,
    valid,
    posted: parsed.posted,
    errors,
    data: outputData
  };
  if (!parsed.posted) {
    output.constraints = validator2.constraints;
    if (Object.keys(validator2.shape).length) {
      output.shape = validator2.shape;
    }
  }
  return output;
}
var init_superValidate = __esm({
  ".svelte-kit/output/server/chunks/superValidate.js"() {
    init_chunks();
    init_just_clone();
    init_index4();
    init_esm();
  }
});
var layout_server_ts_exports2 = {};
__export(layout_server_ts_exports2, {
  load: () => load2
});
var import_memoize_weak2;
var load2;
var init_layout_server_ts2 = __esm({
  ".svelte-kit/output/server/entries/pages/(dashboard)/_layout.server.ts.js"() {
    init_client();
    init_index4();
    init_just_clone();
    init_esm();
    init_chunks();
    init_devalue();
    init_superValidate();
    import_memoize_weak2 = __toESM(require_memoize_weak(), 1);
    load2 = async () => {
      return {
        projectForm: await superValidate(zod(projectSchema)),
        deleteProjectForm: await superValidate(zod(deleteProjectSchema)),
        logoutForm: await superValidate(zod(logoutSchema))
      };
    };
  }
});
function find(iter, tar, key2) {
  for (key2 of iter.keys()) {
    if (dequal(key2, tar))
      return key2;
  }
}
function dequal(foo, bar) {
  var ctor, len, tmp;
  if (foo === bar)
    return true;
  if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
    if (ctor === Date)
      return foo.getTime() === bar.getTime();
    if (ctor === RegExp)
      return foo.toString() === bar.toString();
    if (ctor === Array) {
      if ((len = foo.length) === bar.length) {
        while (len-- && dequal(foo[len], bar[len]))
          ;
      }
      return len === -1;
    }
    if (ctor === Set) {
      if (foo.size !== bar.size) {
        return false;
      }
      for (len of foo) {
        tmp = len;
        if (tmp && typeof tmp === "object") {
          tmp = find(bar, tmp);
          if (!tmp)
            return false;
        }
        if (!bar.has(tmp))
          return false;
      }
      return true;
    }
    if (ctor === Map) {
      if (foo.size !== bar.size) {
        return false;
      }
      for (len of foo) {
        tmp = len[0];
        if (tmp && typeof tmp === "object") {
          tmp = find(bar, tmp);
          if (!tmp)
            return false;
        }
        if (!dequal(len[1], bar.get(tmp))) {
          return false;
        }
      }
      return true;
    }
    if (ctor === ArrayBuffer) {
      foo = new Uint8Array(foo);
      bar = new Uint8Array(bar);
    } else if (ctor === DataView) {
      if ((len = foo.byteLength) === bar.byteLength) {
        while (len-- && foo.getInt8(len) === bar.getInt8(len))
          ;
      }
      return len === -1;
    }
    if (ArrayBuffer.isView(foo)) {
      if ((len = foo.byteLength) === bar.byteLength) {
        while (len-- && foo[len] === bar[len])
          ;
      }
      return len === -1;
    }
    if (!ctor || typeof foo === "object") {
      len = 0;
      for (ctor in foo) {
        if (has.call(foo, ctor) && ++len && !has.call(bar, ctor))
          return false;
        if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor]))
          return false;
      }
      return Object.keys(bar).length === len;
    }
  }
  return foo !== foo && bar !== bar;
}
var has;
var init_dist = __esm({
  "node_modules/dequal/dist/index.mjs"() {
    has = Object.prototype.hasOwnProperty;
  }
});
function r2(e3) {
  var t2, f, n2 = "";
  if ("string" == typeof e3 || "number" == typeof e3)
    n2 += e3;
  else if ("object" == typeof e3)
    if (Array.isArray(e3)) {
      var o2 = e3.length;
      for (t2 = 0; t2 < o2; t2++)
        e3[t2] && (f = r2(e3[t2])) && (n2 && (n2 += " "), n2 += f);
    } else
      for (f in e3)
        e3[f] && (n2 && (n2 += " "), n2 += f);
  return n2;
}
function clsx() {
  for (var e3, t2, f = 0, n2 = "", o2 = arguments.length; f < o2; f++)
    (e3 = arguments[f]) && (t2 = r2(e3)) && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
var init_clsx = __esm({
  "node_modules/clsx/dist/clsx.mjs"() {
  }
});
function createClassUtils(config) {
  const classMap = createClassMap(config);
  const {
    conflictingClassGroups,
    conflictingClassGroupModifiers
  } = config;
  function getClassGroupId(className) {
    const classParts = className.split(CLASS_PART_SEPARATOR);
    if (classParts[0] === "" && classParts.length !== 1) {
      classParts.shift();
    }
    return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
  }
  function getConflictingClassGroupIds(classGroupId, hasPostfixModifier) {
    const conflicts = conflictingClassGroups[classGroupId] || [];
    if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
      return [...conflicts, ...conflictingClassGroupModifiers[classGroupId]];
    }
    return conflicts;
  }
  return {
    getClassGroupId,
    getConflictingClassGroupIds
  };
}
function getGroupRecursive(classParts, classPartObject) {
  if (classParts.length === 0) {
    return classPartObject.classGroupId;
  }
  const currentClassPart = classParts[0];
  const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
  const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : void 0;
  if (classGroupFromNextClassPart) {
    return classGroupFromNextClassPart;
  }
  if (classPartObject.validators.length === 0) {
    return void 0;
  }
  const classRest = classParts.join(CLASS_PART_SEPARATOR);
  return classPartObject.validators.find(({
    validator: validator2
  }) => validator2(classRest))?.classGroupId;
}
function getGroupIdForArbitraryProperty(className) {
  if (arbitraryPropertyRegex.test(className)) {
    const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
    const property = arbitraryPropertyClassName?.substring(0, arbitraryPropertyClassName.indexOf(":"));
    if (property) {
      return "arbitrary.." + property;
    }
  }
}
function createClassMap(config) {
  const {
    theme,
    prefix
  } = config;
  const classMap = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  const prefixedClassGroupEntries = getPrefixedClassGroupEntries(Object.entries(config.classGroups), prefix);
  prefixedClassGroupEntries.forEach(([classGroupId, classGroup]) => {
    processClassesRecursively(classGroup, classMap, classGroupId, theme);
  });
  return classMap;
}
function processClassesRecursively(classGroup, classPartObject, classGroupId, theme) {
  classGroup.forEach((classDefinition) => {
    if (typeof classDefinition === "string") {
      const classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
      classPartObjectToEdit.classGroupId = classGroupId;
      return;
    }
    if (typeof classDefinition === "function") {
      if (isThemeGetter(classDefinition)) {
        processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
        return;
      }
      classPartObject.validators.push({
        validator: classDefinition,
        classGroupId
      });
      return;
    }
    Object.entries(classDefinition).forEach(([key2, classGroup2]) => {
      processClassesRecursively(classGroup2, getPart(classPartObject, key2), classGroupId, theme);
    });
  });
}
function getPart(classPartObject, path) {
  let currentClassPartObject = classPartObject;
  path.split(CLASS_PART_SEPARATOR).forEach((pathPart) => {
    if (!currentClassPartObject.nextPart.has(pathPart)) {
      currentClassPartObject.nextPart.set(pathPart, {
        nextPart: /* @__PURE__ */ new Map(),
        validators: []
      });
    }
    currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
  });
  return currentClassPartObject;
}
function isThemeGetter(func) {
  return func.isThemeGetter;
}
function getPrefixedClassGroupEntries(classGroupEntries, prefix) {
  if (!prefix) {
    return classGroupEntries;
  }
  return classGroupEntries.map(([classGroupId, classGroup]) => {
    const prefixedClassGroup = classGroup.map((classDefinition) => {
      if (typeof classDefinition === "string") {
        return prefix + classDefinition;
      }
      if (typeof classDefinition === "object") {
        return Object.fromEntries(Object.entries(classDefinition).map(([key2, value]) => [prefix + key2, value]));
      }
      return classDefinition;
    });
    return [classGroupId, prefixedClassGroup];
  });
}
function createLruCache(maxCacheSize) {
  if (maxCacheSize < 1) {
    return {
      get: () => void 0,
      set: () => {
      }
    };
  }
  let cacheSize = 0;
  let cache = /* @__PURE__ */ new Map();
  let previousCache = /* @__PURE__ */ new Map();
  function update2(key2, value) {
    cache.set(key2, value);
    cacheSize++;
    if (cacheSize > maxCacheSize) {
      cacheSize = 0;
      previousCache = cache;
      cache = /* @__PURE__ */ new Map();
    }
  }
  return {
    get(key2) {
      let value = cache.get(key2);
      if (value !== void 0) {
        return value;
      }
      if ((value = previousCache.get(key2)) !== void 0) {
        update2(key2, value);
        return value;
      }
    },
    set(key2, value) {
      if (cache.has(key2)) {
        cache.set(key2, value);
      } else {
        update2(key2, value);
      }
    }
  };
}
function createSplitModifiers(config) {
  const separator = config.separator;
  const isSeparatorSingleCharacter = separator.length === 1;
  const firstSeparatorCharacter = separator[0];
  const separatorLength = separator.length;
  return function splitModifiers(className) {
    const modifiers = [];
    let bracketDepth = 0;
    let modifierStart = 0;
    let postfixModifierPosition;
    for (let index15 = 0; index15 < className.length; index15++) {
      let currentCharacter = className[index15];
      if (bracketDepth === 0) {
        if (currentCharacter === firstSeparatorCharacter && (isSeparatorSingleCharacter || className.slice(index15, index15 + separatorLength) === separator)) {
          modifiers.push(className.slice(modifierStart, index15));
          modifierStart = index15 + separatorLength;
          continue;
        }
        if (currentCharacter === "/") {
          postfixModifierPosition = index15;
          continue;
        }
      }
      if (currentCharacter === "[") {
        bracketDepth++;
      } else if (currentCharacter === "]") {
        bracketDepth--;
      }
    }
    const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);
    const hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);
    const baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;
    const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : void 0;
    return {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    };
  };
}
function sortModifiers(modifiers) {
  if (modifiers.length <= 1) {
    return modifiers;
  }
  const sortedModifiers = [];
  let unsortedModifiers = [];
  modifiers.forEach((modifier) => {
    const isArbitraryVariant = modifier[0] === "[";
    if (isArbitraryVariant) {
      sortedModifiers.push(...unsortedModifiers.sort(), modifier);
      unsortedModifiers = [];
    } else {
      unsortedModifiers.push(modifier);
    }
  });
  sortedModifiers.push(...unsortedModifiers.sort());
  return sortedModifiers;
}
function createConfigUtils(config) {
  return {
    cache: createLruCache(config.cacheSize),
    splitModifiers: createSplitModifiers(config),
    ...createClassUtils(config)
  };
}
function mergeClassList(classList, configUtils) {
  const {
    splitModifiers,
    getClassGroupId,
    getConflictingClassGroupIds
  } = configUtils;
  const classGroupsInConflict = /* @__PURE__ */ new Set();
  return classList.trim().split(SPLIT_CLASSES_REGEX).map((originalClassName) => {
    const {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    } = splitModifiers(originalClassName);
    let classGroupId = getClassGroupId(maybePostfixModifierPosition ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
    let hasPostfixModifier = Boolean(maybePostfixModifierPosition);
    if (!classGroupId) {
      if (!maybePostfixModifierPosition) {
        return {
          isTailwindClass: false,
          originalClassName
        };
      }
      classGroupId = getClassGroupId(baseClassName);
      if (!classGroupId) {
        return {
          isTailwindClass: false,
          originalClassName
        };
      }
      hasPostfixModifier = false;
    }
    const variantModifier = sortModifiers(modifiers).join(":");
    const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
    return {
      isTailwindClass: true,
      modifierId,
      classGroupId,
      originalClassName,
      hasPostfixModifier
    };
  }).reverse().filter((parsed) => {
    if (!parsed.isTailwindClass) {
      return true;
    }
    const {
      modifierId,
      classGroupId,
      hasPostfixModifier
    } = parsed;
    const classId = modifierId + classGroupId;
    if (classGroupsInConflict.has(classId)) {
      return false;
    }
    classGroupsInConflict.add(classId);
    getConflictingClassGroupIds(classGroupId, hasPostfixModifier).forEach((group) => classGroupsInConflict.add(modifierId + group));
    return true;
  }).reverse().map((parsed) => parsed.originalClassName).join(" ");
}
function twJoin() {
  let index15 = 0;
  let argument;
  let resolvedValue;
  let string = "";
  while (index15 < arguments.length) {
    if (argument = arguments[index15++]) {
      if (resolvedValue = toValue(argument)) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
}
function toValue(mix) {
  if (typeof mix === "string") {
    return mix;
  }
  let resolvedValue;
  let string = "";
  for (let k2 = 0; k2 < mix.length; k2++) {
    if (mix[k2]) {
      if (resolvedValue = toValue(mix[k2])) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
}
function createTailwindMerge(createConfigFirst, ...createConfigRest) {
  let configUtils;
  let cacheGet;
  let cacheSet;
  let functionToCall = initTailwindMerge;
  function initTailwindMerge(classList) {
    const config = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());
    configUtils = createConfigUtils(config);
    cacheGet = configUtils.cache.get;
    cacheSet = configUtils.cache.set;
    functionToCall = tailwindMerge;
    return tailwindMerge(classList);
  }
  function tailwindMerge(classList) {
    const cachedResult = cacheGet(classList);
    if (cachedResult) {
      return cachedResult;
    }
    const result = mergeClassList(classList, configUtils);
    cacheSet(classList, result);
    return result;
  }
  return function callTailwindMerge() {
    return functionToCall(twJoin.apply(null, arguments));
  };
}
function fromTheme(key2) {
  const themeGetter = (theme) => theme[key2] || [];
  themeGetter.isThemeGetter = true;
  return themeGetter;
}
function isLength(value) {
  return isNumber(value) || stringLengths.has(value) || fractionRegex.test(value);
}
function isArbitraryLength(value) {
  return getIsArbitraryValue(value, "length", isLengthOnly);
}
function isNumber(value) {
  return Boolean(value) && !Number.isNaN(Number(value));
}
function isArbitraryNumber(value) {
  return getIsArbitraryValue(value, "number", isNumber);
}
function isInteger2(value) {
  return Boolean(value) && Number.isInteger(Number(value));
}
function isPercent(value) {
  return value.endsWith("%") && isNumber(value.slice(0, -1));
}
function isArbitraryValue(value) {
  return arbitraryValueRegex.test(value);
}
function isTshirtSize(value) {
  return tshirtUnitRegex.test(value);
}
function isArbitrarySize(value) {
  return getIsArbitraryValue(value, sizeLabels, isNever);
}
function isArbitraryPosition(value) {
  return getIsArbitraryValue(value, "position", isNever);
}
function isArbitraryImage(value) {
  return getIsArbitraryValue(value, imageLabels, isImage);
}
function isArbitraryShadow(value) {
  return getIsArbitraryValue(value, "", isShadow);
}
function isAny() {
  return true;
}
function getIsArbitraryValue(value, label, testValue) {
  const result = arbitraryValueRegex.exec(value);
  if (result) {
    if (result[1]) {
      return typeof label === "string" ? result[1] === label : label.has(result[1]);
    }
    return testValue(result[2]);
  }
  return false;
}
function isLengthOnly(value) {
  return lengthUnitRegex.test(value) && !colorFunctionRegex.test(value);
}
function isNever() {
  return false;
}
function isShadow(value) {
  return shadowRegex.test(value);
}
function isImage(value) {
  return imageRegex.test(value);
}
function getDefaultConfig() {
  const colors = fromTheme("colors");
  const spacing = fromTheme("spacing");
  const blur = fromTheme("blur");
  const brightness = fromTheme("brightness");
  const borderColor = fromTheme("borderColor");
  const borderRadius = fromTheme("borderRadius");
  const borderSpacing = fromTheme("borderSpacing");
  const borderWidth = fromTheme("borderWidth");
  const contrast = fromTheme("contrast");
  const grayscale = fromTheme("grayscale");
  const hueRotate = fromTheme("hueRotate");
  const invert = fromTheme("invert");
  const gap = fromTheme("gap");
  const gradientColorStops = fromTheme("gradientColorStops");
  const gradientColorStopPositions = fromTheme("gradientColorStopPositions");
  const inset = fromTheme("inset");
  const margin = fromTheme("margin");
  const opacity = fromTheme("opacity");
  const padding = fromTheme("padding");
  const saturate = fromTheme("saturate");
  const scale2 = fromTheme("scale");
  const sepia = fromTheme("sepia");
  const skew = fromTheme("skew");
  const space = fromTheme("space");
  const translate = fromTheme("translate");
  const getOverscroll = () => ["auto", "contain", "none"];
  const getOverflow = () => ["auto", "hidden", "clip", "visible", "scroll"];
  const getSpacingWithAutoAndArbitrary = () => ["auto", isArbitraryValue, spacing];
  const getSpacingWithArbitrary = () => [isArbitraryValue, spacing];
  const getLengthWithEmptyAndArbitrary = () => ["", isLength, isArbitraryLength];
  const getNumberWithAutoAndArbitrary = () => ["auto", isNumber, isArbitraryValue];
  const getPositions = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"];
  const getLineStyles = () => ["solid", "dashed", "dotted", "double", "none"];
  const getBlendModes = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity", "plus-lighter"];
  const getAlign = () => ["start", "end", "center", "between", "around", "evenly", "stretch"];
  const getZeroAndEmpty = () => ["", "0", isArbitraryValue];
  const getBreaks = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
  const getNumber = () => [isNumber, isArbitraryNumber];
  const getNumberAndArbitrary = () => [isNumber, isArbitraryValue];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [isAny],
      spacing: [isLength, isArbitraryLength],
      blur: ["none", "", isTshirtSize, isArbitraryValue],
      brightness: getNumber(),
      borderColor: [colors],
      borderRadius: ["none", "", "full", isTshirtSize, isArbitraryValue],
      borderSpacing: getSpacingWithArbitrary(),
      borderWidth: getLengthWithEmptyAndArbitrary(),
      contrast: getNumber(),
      grayscale: getZeroAndEmpty(),
      hueRotate: getNumberAndArbitrary(),
      invert: getZeroAndEmpty(),
      gap: getSpacingWithArbitrary(),
      gradientColorStops: [colors],
      gradientColorStopPositions: [isPercent, isArbitraryLength],
      inset: getSpacingWithAutoAndArbitrary(),
      margin: getSpacingWithAutoAndArbitrary(),
      opacity: getNumber(),
      padding: getSpacingWithArbitrary(),
      saturate: getNumber(),
      scale: getNumber(),
      sepia: getZeroAndEmpty(),
      skew: getNumberAndArbitrary(),
      space: getSpacingWithArbitrary(),
      translate: getSpacingWithArbitrary()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", isArbitraryValue]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [isTshirtSize]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": getBreaks()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": getBreaks()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...getPositions(), isArbitraryValue]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: getOverflow()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": getOverflow()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": getOverflow()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: getOverscroll()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": getOverscroll()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": getOverscroll()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [inset]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [inset]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [inset]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [inset]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [inset]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [inset]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [inset]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [inset]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [inset]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", isInteger2, isArbitraryValue]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: getSpacingWithAutoAndArbitrary()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", isArbitraryValue]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: getZeroAndEmpty()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: getZeroAndEmpty()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", isInteger2, isArbitraryValue]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [isAny]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", isInteger2, isArbitraryValue]
        }, isArbitraryValue]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [isAny]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [isInteger2, isArbitraryValue]
        }, isArbitraryValue]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [gap]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [gap]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [gap]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...getAlign()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...getAlign(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...getAlign(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [padding]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [padding]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [padding]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [padding]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [padding]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [padding]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [padding]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [padding]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [padding]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [margin]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [margin]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [margin]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [margin]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [margin]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [margin]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [margin]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [margin]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [margin]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [space]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [space]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", isArbitraryValue, spacing]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [isArbitraryValue, spacing, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [isArbitraryValue, spacing, "none", "full", "min", "max", "fit", "prose", {
          screen: [isTshirtSize]
        }, isTshirtSize]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [isArbitraryValue, spacing, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [isArbitraryValue, spacing, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", isTshirtSize, isArbitraryLength]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", isArbitraryNumber]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [isAny]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", isArbitraryValue]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", isNumber, isArbitraryNumber]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", isLength, isArbitraryValue]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", isArbitraryValue]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", isArbitraryValue]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [colors]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [opacity]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [colors]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [opacity]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...getLineStyles(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", isLength, isArbitraryLength]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", isLength, isArbitraryValue]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [colors]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: getSpacingWithArbitrary()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryValue]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", isArbitraryValue]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [opacity]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...getPositions(), isArbitraryPosition]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", isArbitrarySize]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, isArbitraryImage]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [colors]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [gradientColorStops]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [borderRadius]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [borderRadius]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [borderRadius]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [borderRadius]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [borderRadius]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [borderRadius]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [borderRadius]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [borderRadius]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [borderRadius]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [borderRadius]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [borderRadius]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [borderRadius]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [borderRadius]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [borderRadius]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [borderRadius]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [borderWidth]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [borderWidth]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [borderWidth]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [borderWidth]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [borderWidth]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [borderWidth]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [borderWidth]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [borderWidth]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [borderWidth]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [opacity]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...getLineStyles(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [borderWidth]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [borderWidth]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [opacity]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: getLineStyles()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [borderColor]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [borderColor]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [borderColor]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [borderColor]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [borderColor]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [borderColor]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [borderColor]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [borderColor]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...getLineStyles()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [isLength, isArbitraryValue]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [isLength, isArbitraryLength]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [colors]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: getLengthWithEmptyAndArbitrary()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [colors]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [opacity]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [isLength, isArbitraryLength]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [colors]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", isTshirtSize, isArbitraryShadow]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [isAny]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [opacity]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": getBlendModes()
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": getBlendModes()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [blur]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [brightness]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [contrast]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", isTshirtSize, isArbitraryValue]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [grayscale]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [hueRotate]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [invert]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [saturate]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [sepia]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [blur]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [brightness]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [contrast]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [grayscale]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [hueRotate]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [invert]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [opacity]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [saturate]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [sepia]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [borderSpacing]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [borderSpacing]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [borderSpacing]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", isArbitraryValue]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: getNumberAndArbitrary()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", isArbitraryValue]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: getNumberAndArbitrary()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", isArbitraryValue]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [scale2]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [scale2]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [scale2]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [isInteger2, isArbitraryValue]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [translate]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [translate]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [skew]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [skew]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", isArbitraryValue]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", colors]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryValue]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [colors]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", isArbitraryValue]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [colors, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [isLength, isArbitraryLength, isArbitraryNumber]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [colors, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}
function mergeConfigs(baseConfig, {
  cacheSize,
  prefix,
  separator,
  extend = {},
  override: override2 = {}
}) {
  overrideProperty(baseConfig, "cacheSize", cacheSize);
  overrideProperty(baseConfig, "prefix", prefix);
  overrideProperty(baseConfig, "separator", separator);
  for (const configKey in override2) {
    overrideConfigProperties(baseConfig[configKey], override2[configKey]);
  }
  for (const key2 in extend) {
    mergeConfigProperties(baseConfig[key2], extend[key2]);
  }
  return baseConfig;
}
function overrideProperty(baseObject, overrideKey, overrideValue) {
  if (overrideValue !== void 0) {
    baseObject[overrideKey] = overrideValue;
  }
}
function overrideConfigProperties(baseObject, overrideObject) {
  if (overrideObject) {
    for (const key2 in overrideObject) {
      overrideProperty(baseObject, key2, overrideObject[key2]);
    }
  }
}
function mergeConfigProperties(baseObject, mergeObject) {
  if (mergeObject) {
    for (const key2 in mergeObject) {
      const mergeValue = mergeObject[key2];
      if (mergeValue !== void 0) {
        baseObject[key2] = (baseObject[key2] || []).concat(mergeValue);
      }
    }
  }
}
function extendTailwindMerge(configExtension, ...createConfig) {
  return typeof configExtension === "function" ? createTailwindMerge(getDefaultConfig, configExtension, ...createConfig) : createTailwindMerge(() => mergeConfigs(getDefaultConfig(), configExtension), ...createConfig);
}
var CLASS_PART_SEPARATOR;
var arbitraryPropertyRegex;
var IMPORTANT_MODIFIER;
var SPLIT_CLASSES_REGEX;
var arbitraryValueRegex;
var fractionRegex;
var stringLengths;
var tshirtUnitRegex;
var lengthUnitRegex;
var colorFunctionRegex;
var shadowRegex;
var imageRegex;
var sizeLabels;
var imageLabels;
var twMerge;
var init_bundle_mjs = __esm({
  "node_modules/tailwind-merge/dist/bundle-mjs.mjs"() {
    CLASS_PART_SEPARATOR = "-";
    arbitraryPropertyRegex = /^\[(.+)\]$/;
    IMPORTANT_MODIFIER = "!";
    SPLIT_CLASSES_REGEX = /\s+/;
    arbitraryValueRegex = /^\[(?:([a-z-]+):)?(.+)\]$/i;
    fractionRegex = /^\d+\/\d+$/;
    stringLengths = /* @__PURE__ */ new Set(["px", "full", "screen"]);
    tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
    lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
    colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/;
    shadowRegex = /^-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
    imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
    sizeLabels = /* @__PURE__ */ new Set(["length", "size", "percentage"]);
    imageLabels = /* @__PURE__ */ new Set(["image", "url"]);
    twMerge = /* @__PURE__ */ createTailwindMerge(getDefaultConfig);
  }
});
function i(e3, o2) {
  e3.forEach(function(r4) {
    Array.isArray(r4) ? i(r4, o2) : o2.push(r4);
  });
}
function y2(e3) {
  let o2 = [];
  return i(e3, o2), o2;
}
var l2;
var u;
var x2;
var a;
var p2;
var g;
var init_chunk_JXBJZR5A = __esm({
  "node_modules/tailwind-variants/dist/chunk-JXBJZR5A.js"() {
    l2 = (e3) => typeof e3 == "boolean" ? `${e3}` : e3 === 0 ? "0" : e3;
    u = (e3) => !e3 || typeof e3 != "object" || Object.keys(e3).length === 0;
    x2 = (e3, o2) => JSON.stringify(e3) === JSON.stringify(o2);
    a = (...e3) => y2(e3).filter(Boolean);
    p2 = (e3, o2) => {
      let r4 = {}, c2 = Object.keys(e3), f = Object.keys(o2);
      for (let t2 of c2)
        if (f.includes(t2)) {
          let s3 = e3[t2], n2 = o2[t2];
          typeof s3 == "object" && typeof n2 == "object" ? r4[t2] = p2(s3, n2) : Array.isArray(s3) || Array.isArray(n2) ? r4[t2] = a(n2, s3) : r4[t2] = n2 + " " + s3;
        } else
          r4[t2] = e3[t2];
      for (let t2 of f)
        c2.includes(t2) || (r4[t2] = o2[t2]);
      return r4;
    };
    g = (e3) => !e3 || typeof e3 != "string" ? e3 : e3.replace(/\s+/g, " ").trim();
  }
});
var ie2;
var Z3;
var N2;
var R2;
var C3;
var q2;
var j;
var Y3;
var ce2;
var init_dist2 = __esm({
  "node_modules/tailwind-variants/dist/index.js"() {
    init_chunk_JXBJZR5A();
    init_bundle_mjs();
    ie2 = { twMerge: true, twMergeConfig: {}, responsiveVariants: false };
    Z3 = (s3) => s3 || void 0;
    N2 = (...s3) => Z3(y2(s3).filter(Boolean).join(" "));
    R2 = null;
    C3 = {};
    q2 = false;
    j = (...s3) => (b$1) => b$1.twMerge ? ((!R2 || q2) && (q2 = false, R2 = u(C3) ? twMerge : extendTailwindMerge({ ...C3, extend: { theme: C3.theme, classGroups: C3.classGroups, conflictingClassGroupModifiers: C3.conflictingClassGroupModifiers, conflictingClassGroups: C3.conflictingClassGroups, ...C3.extend } })), Z3(R2(N2(s3)))) : N2(s3);
    Y3 = (s3, b2) => {
      for (let e3 in b2)
        s3.hasOwnProperty(e3) ? s3[e3] = N2(s3[e3], b2[e3]) : s3[e3] = b2[e3];
      return s3;
    };
    ce2 = (s3, b$1) => {
      let { extend: e3 = null, slots: M2 = {}, variants: F3 = {}, compoundVariants: h$1 = [], compoundSlots: V2 = [], defaultVariants: U2 = {} } = s3, m = { ...ie2, ...b$1 }, S3 = e3 != null && e3.base ? N2(e3.base, s3 == null ? void 0 : s3.base) : s3 == null ? void 0 : s3.base, g$1 = e3 != null && e3.variants && !u(e3.variants) ? p2(F3, e3.variants) : F3, A2 = e3 != null && e3.defaultVariants && !u(e3.defaultVariants) ? { ...e3.defaultVariants, ...U2 } : U2;
      !u(m.twMergeConfig) && !x2(m.twMergeConfig, C3) && (q2 = true, C3 = m.twMergeConfig);
      let O2 = u(e3 == null ? void 0 : e3.slots), $ = u(M2) ? {} : { base: N2(s3 == null ? void 0 : s3.base, O2 && (e3 == null ? void 0 : e3.base)), ...M2 }, w3 = O2 ? $ : Y3({ ...e3 == null ? void 0 : e3.slots }, u($) ? { base: s3 == null ? void 0 : s3.base } : $), v3 = (f$1) => {
        if (u(g$1) && u(M2) && O2)
          return j(S3, f$1 == null ? void 0 : f$1.class, f$1 == null ? void 0 : f$1.className)(m);
        if (h$1 && !Array.isArray(h$1))
          throw new TypeError(`The "compoundVariants" prop must be an array. Received: ${typeof h$1}`);
        if (V2 && !Array.isArray(V2))
          throw new TypeError(`The "compoundSlots" prop must be an array. Received: ${typeof V2}`);
        let K2 = (t2, n2, a2 = [], i3) => {
          let r4 = a2;
          if (typeof n2 == "string")
            r4 = r4.concat(g(n2).split(" ").map((l3) => `${t2}:${l3}`));
          else if (Array.isArray(n2))
            r4 = r4.concat(n2.reduce((l3, c2) => l3.concat(`${t2}:${c2}`), []));
          else if (typeof n2 == "object" && typeof i3 == "string") {
            for (let l3 in n2)
              if (n2.hasOwnProperty(l3) && l3 === i3) {
                let c2 = n2[l3];
                if (c2 && typeof c2 == "string") {
                  let o2 = g(c2);
                  r4[i3] ? r4[i3] = r4[i3].concat(o2.split(" ").map((u2) => `${t2}:${u2}`)) : r4[i3] = o2.split(" ").map((u2) => `${t2}:${u2}`);
                } else
                  Array.isArray(c2) && c2.length > 0 && (r4[i3] = c2.reduce((o2, u2) => o2.concat(`${t2}:${u2}`), []));
              }
          }
          return r4;
        }, W2 = (t2, n2 = g$1, a$1 = null, i3 = null) => {
          var I2;
          let r4 = n2[t2];
          if (!r4 || u(r4))
            return null;
          let l3 = (I2 = i3 == null ? void 0 : i3[t2]) != null ? I2 : f$1 == null ? void 0 : f$1[t2];
          if (l3 === null)
            return null;
          let c2 = l2(l3), o2 = Array.isArray(m.responsiveVariants) && m.responsiveVariants.length > 0 || m.responsiveVariants === true, u2 = A2 == null ? void 0 : A2[t2], d = [];
          if (typeof c2 == "object" && o2)
            for (let [T2, J3] of Object.entries(c2)) {
              let ne = r4[J3];
              if (T2 === "initial") {
                u2 = J3;
                continue;
              }
              Array.isArray(m.responsiveVariants) && !m.responsiveVariants.includes(T2) || (d = K2(T2, ne, d, a$1));
            }
          let ae3 = c2 != null && typeof c2 != "object" ? c2 : l2(u2), k2 = r4[ae3] || r4.false;
          return typeof d == "object" && typeof a$1 == "string" && d[a$1] ? Y3(d, k2) : d.length > 0 ? (d.push(k2), d) : k2;
        }, P2 = () => g$1 ? Object.keys(g$1).map((t2) => W2(t2, g$1)) : null, p3 = (t2, n2) => {
          if (!g$1 || typeof g$1 != "object")
            return null;
          let a2 = new Array();
          for (let i3 in g$1) {
            let r4 = W2(i3, g$1, t2, n2), l3 = t2 === "base" && typeof r4 == "string" ? r4 : r4 && r4[t2];
            l3 && (a2[a2.length] = l3);
          }
          return a2;
        }, x4 = {};
        for (let t2 in f$1)
          f$1[t2] !== void 0 && (x4[t2] = f$1[t2]);
        let z3 = (t2, n2) => {
          var i3;
          let a2 = typeof (f$1 == null ? void 0 : f$1[t2]) == "object" ? { [t2]: (i3 = f$1[t2]) == null ? void 0 : i3.initial } : {};
          return { ...A2, ...x4, ...a2, ...n2 };
        }, D3 = (t2 = [], n2) => {
          let a2 = [];
          for (let { class: i3, className: r4, ...l3 } of t2) {
            let c2 = true;
            for (let [o2, u2] of Object.entries(l3)) {
              let d = z3(o2, n2);
              if (Array.isArray(u2)) {
                if (!u2.includes(d[o2])) {
                  c2 = false;
                  break;
                }
              } else if (d[o2] !== u2) {
                c2 = false;
                break;
              }
            }
            c2 && (i3 && a2.push(i3), r4 && a2.push(r4));
          }
          return a2;
        }, H3 = (t2) => {
          let n2 = D3(h$1, t2), a2 = D3(e3 == null ? void 0 : e3.compoundVariants, t2);
          return a(a2, n2);
        }, ee2 = (t2) => {
          let n2 = H3(t2);
          if (!Array.isArray(n2))
            return n2;
          let a2 = {};
          for (let i3 of n2)
            if (typeof i3 == "string" && (a2.base = j(a2.base, i3)(m)), typeof i3 == "object")
              for (let [r4, l3] of Object.entries(i3))
                a2[r4] = j(a2[r4], l3)(m);
          return a2;
        }, te2 = (t2) => {
          if (V2.length < 1)
            return null;
          let n2 = {};
          for (let { slots: a2 = [], class: i3, className: r4, ...l3 } of V2) {
            if (!u(l3)) {
              let c2 = true;
              for (let o2 of Object.keys(l3)) {
                let u2 = z3(o2, t2)[o2];
                if (u2 === void 0 || (Array.isArray(l3[o2]) ? !l3[o2].includes(u2) : l3[o2] !== u2)) {
                  c2 = false;
                  break;
                }
              }
              if (!c2)
                continue;
            }
            for (let c2 of a2)
              n2[c2] = n2[c2] || [], n2[c2].push([i3, r4]);
          }
          return n2;
        };
        if (!u(M2) || !O2) {
          let t2 = {};
          if (typeof w3 == "object" && !u(w3))
            for (let n2 of Object.keys(w3))
              t2[n2] = (a2) => {
                var i3, r4;
                return j(w3[n2], p3(n2, a2), ((i3 = ee2(a2)) != null ? i3 : [])[n2], ((r4 = te2(a2)) != null ? r4 : [])[n2], a2 == null ? void 0 : a2.class, a2 == null ? void 0 : a2.className)(m);
              };
          return t2;
        }
        return j(S3, P2(), H3(), f$1 == null ? void 0 : f$1.class, f$1 == null ? void 0 : f$1.className)(m);
      }, _ = () => {
        if (!(!g$1 || typeof g$1 != "object"))
          return Object.keys(g$1);
      };
      return v3.variantKeys = _(), v3.extend = e3, v3.base = S3, v3.slots = w3, v3.variants = g$1, v3.defaultVariants = A2, v3.compoundSlots = V2, v3.compoundVariants = h$1, v3;
    };
  }
});
function is_void(name5) {
  return void_element_names.test(name5) || name5.toLowerCase() === "!doctype";
}
function cubicOut(t2) {
  const f = t2 - 1;
  return f * f * f + 1;
}
function cn(...inputs) {
  return twMerge(clsx(inputs));
}
function styleToString(style) {
  return Object.keys(style).reduce((str, key2) => {
    if (style[key2] === void 0)
      return str;
    return str + `${key2}:${style[key2]};`;
  }, "");
}
function disabledAttr(disabled) {
  return disabled ? true : void 0;
}
function portalAttr(portal) {
  if (portal !== null) {
    return "";
  }
  return void 0;
}
function lightable(value) {
  function subscribe2(run2) {
    run2(value);
    return () => {
    };
  }
  return { subscribe: subscribe2 };
}
function getElementByMeltId(id2) {
  if (!isBrowser2)
    return null;
  const el = document.querySelector(`[data-melt-id="${id2}"]`);
  return isHTMLElement(el) ? el : null;
}
function makeElement(name5, args) {
  const { stores, action, returned } = args ?? {};
  const derivedStore = (() => {
    if (stores && returned) {
      return derived(stores, (values) => {
        const result = returned(values);
        if (isFunctionWithParams(result)) {
          const fn = (...args2) => {
            return hiddenAction({
              ...result(...args2),
              [`data-melt-${name5}`]: "",
              action: action ?? noop2
            });
          };
          fn.action = action ?? noop2;
          return fn;
        }
        return hiddenAction({
          ...result,
          [`data-melt-${name5}`]: "",
          action: action ?? noop2
        });
      });
    } else {
      const returnedFn = returned;
      const result = returnedFn?.();
      if (isFunctionWithParams(result)) {
        const resultFn = (...args2) => {
          return hiddenAction({
            ...result(...args2),
            [`data-melt-${name5}`]: "",
            action: action ?? noop2
          });
        };
        resultFn.action = action ?? noop2;
        return lightable(resultFn);
      }
      return lightable(hiddenAction({
        ...result,
        [`data-melt-${name5}`]: "",
        action: action ?? noop2
      }));
    }
  })();
  const actionFn = action ?? (() => {
  });
  actionFn.subscribe = derivedStore.subscribe;
  return actionFn;
}
function createElHelpers(prefix) {
  const name5 = (part) => part ? `${prefix}-${part}` : prefix;
  const attribute = (part) => `data-melt-${prefix}${part ? `-${part}` : ""}`;
  const selector = (part) => `[data-melt-${prefix}${part ? `-${part}` : ""}]`;
  const getEl = (part) => document.querySelector(selector(part));
  return {
    name: name5,
    attribute,
    selector,
    getEl
  };
}
function isElement(element) {
  return element instanceof Element;
}
function isHTMLElement(element) {
  return element instanceof HTMLElement;
}
function isHTMLInputElement(element) {
  return element instanceof HTMLInputElement;
}
function isHTMLLabelElement(element) {
  return element instanceof HTMLLabelElement;
}
function isHTMLButtonElement(element) {
  return element instanceof HTMLButtonElement;
}
function isElementDisabled(element) {
  const ariaDisabled = element.getAttribute("aria-disabled");
  const disabled = element.getAttribute("disabled");
  const dataDisabled = element.hasAttribute("data-disabled");
  if (ariaDisabled === "true" || disabled !== null || dataDisabled) {
    return true;
  }
  return false;
}
function isObject3(value) {
  return value !== null && typeof value === "object";
}
function isReadable(value) {
  return isObject3(value) && "subscribe" in value;
}
function executeCallbacks(...callbacks) {
  return (...args) => {
    for (const callback of callbacks) {
      if (typeof callback === "function") {
        callback(...args);
      }
    }
  };
}
function noop2() {
}
function addEventListener2(target, event, handler, options2) {
  const events = Array.isArray(event) ? event : [event];
  events.forEach((_event) => target.addEventListener(_event, handler, options2));
  return () => {
    events.forEach((_event) => target.removeEventListener(_event, handler, options2));
  };
}
function addMeltEventListener(target, event, handler, options2) {
  const events = Array.isArray(event) ? event : [event];
  if (typeof handler === "function") {
    const handlerWithMelt = withMelt((_event) => handler(_event));
    events.forEach((_event) => target.addEventListener(_event, handlerWithMelt, options2));
    return () => {
      events.forEach((_event) => target.removeEventListener(_event, handlerWithMelt, options2));
    };
  }
  return () => noop2();
}
function dispatchMeltEvent(originalEvent) {
  const node = originalEvent.currentTarget;
  if (!isHTMLElement(node))
    return null;
  const customMeltEvent = new CustomEvent(`m-${originalEvent.type}`, {
    detail: {
      originalEvent
    },
    cancelable: true
  });
  node.dispatchEvent(customMeltEvent);
  return customMeltEvent;
}
function withMelt(handler) {
  return (event) => {
    const customEvent = dispatchMeltEvent(event);
    if (customEvent?.defaultPrevented)
      return;
    return handler(event);
  };
}
function omit(obj, ...keys) {
  const result = {};
  for (const key2 of Object.keys(obj)) {
    if (!keys.includes(key2)) {
      result[key2] = obj[key2];
    }
  }
  return result;
}
function stripValues(inputObject, toStrip, recursive) {
  return Object.fromEntries(Object.entries(inputObject).filter(([_, value]) => !dequal(value, toStrip)));
}
function removeUndefined(obj) {
  const result = {};
  for (const key2 in obj) {
    const value = obj[key2];
    if (value !== void 0) {
      result[key2] = value;
    }
  }
  return result;
}
function withGet(store) {
  return {
    ...store,
    get: () => get_store_value(store)
  };
}
function effect(stores, fn) {
  let cb2 = void 0;
  const destroy = derived(stores, (stores2) => {
    cb2?.();
    cb2 = fn(stores2);
  }).subscribe(noop2);
  const unsub = () => {
    destroy();
    cb2?.();
  };
  safeOnDestroy(unsub);
  return unsub;
}
function toReadableStores(properties) {
  const result = {};
  Object.keys(properties).forEach((key2) => {
    const propertyKey = key2;
    const value = properties[propertyKey];
    if (isReadable(value)) {
      result[propertyKey] = withGet(value);
    } else {
      result[propertyKey] = withGet(readable(value));
    }
  });
  return result;
}
function createHiddenInput(props) {
  const withDefaults = {
    ...defaults,
    ...removeUndefined(props)
  };
  const { name: elName } = createElHelpers(withDefaults.prefix);
  const { value, name: name5, disabled, required } = toReadableStores(omit(withDefaults, "prefix"));
  const nameStore = name5;
  const hiddenInput = makeElement(elName("hidden-input"), {
    stores: [value, nameStore, disabled, required],
    returned: ([$value, $name, $disabled, $required]) => {
      return {
        name: $name,
        value: $value?.toString(),
        "aria-hidden": "true",
        hidden: true,
        disabled: $disabled,
        required: $required,
        tabIndex: -1,
        style: styleToString({
          position: "absolute",
          opacity: 0,
          "pointer-events": "none",
          margin: 0,
          transform: "translateX(-100%)"
        })
      };
    },
    action: (node) => {
      const unsub = value.subscribe((newValue) => {
        node.value = newValue;
        node.dispatchEvent(new Event("change", { bubbles: true }));
      });
      return {
        destroy: unsub
      };
    }
  });
  return hiddenInput;
}
function getAttrs(builders) {
  const attrs = {};
  builders.forEach((builder) => {
    Object.keys(builder).forEach((key2) => {
      if (key2 !== "action") {
        attrs[key2] = builder[key2];
      }
    });
  });
  return attrs;
}
var void_element_names;
var flyAndScale;
var hiddenAction;
var isFunctionWithParams;
var isBrowser2;
var isFunction;
var safeOnMount;
var safeOnDestroy;
var kbd;
var FIRST_KEYS;
var LAST_KEYS;
var FIRST_LAST_KEYS;
var SELECTION_KEYS;
var documentEscapeKeyStore;
var useEscapeKeydown;
var defaults;
var Button$1;
var Button;
var buttonVariants;
var init_index3 = __esm({
  ".svelte-kit/output/server/chunks/index3.js"() {
    init_lifecycle();
    init_ssr();
    init_dist();
    init_clsx();
    init_bundle_mjs();
    init_dist2();
    init_index2();
    init_ssr2();
    void_element_names = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;
    flyAndScale = (node, params = { y: -8, x: 0, start: 0.95, duration: 150 }) => {
      const style = getComputedStyle(node);
      const transform = style.transform === "none" ? "" : style.transform;
      const scaleConversion = (valueA, scaleA, scaleB) => {
        const [minA, maxA] = scaleA;
        const [minB, maxB] = scaleB;
        const percentage = (valueA - minA) / (maxA - minA);
        const valueB = percentage * (maxB - minB) + minB;
        return valueB;
      };
      const styleToString22 = (style2) => {
        return Object.keys(style2).reduce((str, key2) => {
          if (style2[key2] === void 0)
            return str;
          return str + `${key2}:${style2[key2]};`;
        }, "");
      };
      return {
        duration: params.duration ?? 200,
        delay: 0,
        css: (t2) => {
          const y3 = scaleConversion(t2, [0, 1], [params.y ?? 5, 0]);
          const x4 = scaleConversion(t2, [0, 1], [params.x ?? 0, 0]);
          const scale2 = scaleConversion(t2, [0, 1], [params.start ?? 0.95, 1]);
          return styleToString22({
            transform: `${transform} translate3d(${x4}px, ${y3}px, 0) scale(${scale2})`,
            opacity: t2
          });
        },
        easing: cubicOut
      };
    };
    ({
      type: "hidden",
      "aria-hidden": true,
      hidden: true,
      tabIndex: -1,
      style: styleToString({
        position: "absolute",
        opacity: 0,
        "pointer-events": "none",
        margin: 0,
        transform: "translateX(-100%)"
      })
    });
    hiddenAction = (obj) => {
      return new Proxy(obj, {
        get(target, prop, receiver) {
          return Reflect.get(target, prop, receiver);
        },
        ownKeys(target) {
          return Reflect.ownKeys(target).filter((key2) => key2 !== "action");
        }
      });
    };
    isFunctionWithParams = (fn) => {
      return typeof fn === "function";
    };
    makeElement("empty");
    isBrowser2 = typeof document !== "undefined";
    isFunction = (v3) => typeof v3 === "function";
    safeOnMount = (fn) => {
      try {
        onMount(fn);
      } catch {
        return fn;
      }
    };
    safeOnDestroy = (fn) => {
      try {
        onDestroy(fn);
      } catch {
        return fn;
      }
    };
    withGet.writable = function(initial2) {
      const internal2 = writable(initial2);
      let value = initial2;
      return {
        subscribe: internal2.subscribe,
        set(newValue) {
          internal2.set(newValue);
          value = newValue;
        },
        update(updater) {
          const newValue = updater(value);
          internal2.set(newValue);
          value = newValue;
        },
        get() {
          return value;
        }
      };
    };
    withGet.derived = function(stores, fn) {
      const subscribers = /* @__PURE__ */ new Map();
      const get2 = () => {
        const values = Array.isArray(stores) ? stores.map((store) => store.get()) : stores.get();
        return fn(values);
      };
      const subscribe2 = (subscriber) => {
        const unsubscribers = [];
        const storesArr = Array.isArray(stores) ? stores : [stores];
        storesArr.forEach((store) => {
          unsubscribers.push(store.subscribe(() => {
            subscriber(get2());
          }));
        });
        subscriber(get2());
        subscribers.set(subscriber, unsubscribers);
        return () => {
          const unsubscribers2 = subscribers.get(subscriber);
          if (unsubscribers2) {
            for (const unsubscribe of unsubscribers2) {
              unsubscribe();
            }
          }
          subscribers.delete(subscriber);
        };
      };
      return {
        get: get2,
        subscribe: subscribe2
      };
    };
    kbd = {
      ALT: "Alt",
      ARROW_DOWN: "ArrowDown",
      ARROW_LEFT: "ArrowLeft",
      ARROW_RIGHT: "ArrowRight",
      ARROW_UP: "ArrowUp",
      BACKSPACE: "Backspace",
      CAPS_LOCK: "CapsLock",
      CONTROL: "Control",
      DELETE: "Delete",
      END: "End",
      ENTER: "Enter",
      ESCAPE: "Escape",
      F1: "F1",
      F10: "F10",
      F11: "F11",
      F12: "F12",
      F2: "F2",
      F3: "F3",
      F4: "F4",
      F5: "F5",
      F6: "F6",
      F7: "F7",
      F8: "F8",
      F9: "F9",
      HOME: "Home",
      META: "Meta",
      PAGE_DOWN: "PageDown",
      PAGE_UP: "PageUp",
      SHIFT: "Shift",
      SPACE: " ",
      TAB: "Tab",
      CTRL: "Control",
      ASTERISK: "*",
      A: "a",
      P: "p"
    };
    FIRST_KEYS = [kbd.ARROW_DOWN, kbd.PAGE_UP, kbd.HOME];
    LAST_KEYS = [kbd.ARROW_UP, kbd.PAGE_DOWN, kbd.END];
    FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
    SELECTION_KEYS = [kbd.ENTER, kbd.SPACE];
    readable(void 0, (set) => {
      function clicked(event) {
        set(event);
        set(void 0);
      }
      const unsubscribe = addEventListener2(document, "pointerup", clicked, {
        passive: false,
        capture: true
      });
      return unsubscribe;
    });
    documentEscapeKeyStore = readable(void 0, (set) => {
      function keydown(event) {
        if (event && event.key === kbd.ESCAPE) {
          set(event);
        }
        set(void 0);
      }
      const unsubscribe = addEventListener2(document, "keydown", keydown, {
        passive: false
      });
      return unsubscribe;
    });
    useEscapeKeydown = (node, config = {}) => {
      let unsub = noop2;
      function update2(config2 = {}) {
        unsub();
        const options2 = { enabled: true, ...config2 };
        const enabled = isReadable(options2.enabled) ? options2.enabled : readable(options2.enabled);
        unsub = executeCallbacks(
          // Handle escape keydowns
          documentEscapeKeyStore.subscribe((e3) => {
            if (!e3 || !get_store_value(enabled))
              return;
            const target = e3.target;
            if (!isHTMLElement(target) || target.closest("[data-escapee]") !== node) {
              return;
            }
            e3.preventDefault();
            if (options2.ignore) {
              if (isFunction(options2.ignore)) {
                if (options2.ignore(e3))
                  return;
              } else if (Array.isArray(options2.ignore)) {
                if (options2.ignore.length > 0 && options2.ignore.some((ignoreEl) => {
                  return ignoreEl && target === ignoreEl;
                }))
                  return;
              }
            }
            options2.handler?.(e3);
          }),
          effect(enabled, ($enabled) => {
            if ($enabled) {
              node.dataset.escapee = "";
            } else {
              delete node.dataset.escapee;
            }
          })
        );
      }
      update2(config);
      return {
        update: update2,
        destroy() {
          node.removeAttribute("data-escapee");
          unsub();
        }
      };
    };
    defaults = {
      prefix: "",
      disabled: readable(false),
      required: readable(false),
      name: readable(void 0)
    };
    Button$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["href", "type", "builders", "el"]);
      let { href = void 0 } = $$props;
      let { type = void 0 } = $$props;
      let { builders = [] } = $$props;
      let { el = void 0 } = $$props;
      const attrs = { "data-button-root": "" };
      if ($$props.href === void 0 && $$bindings.href && href !== void 0)
        $$bindings.href(href);
      if ($$props.type === void 0 && $$bindings.type && type !== void 0)
        $$bindings.type(type);
      if ($$props.builders === void 0 && $$bindings.builders && builders !== void 0)
        $$bindings.builders(builders);
      if ($$props.el === void 0 && $$bindings.el && el !== void 0)
        $$bindings.el(el);
      return `${builders && builders.length ? ` ${((tag) => {
        return tag ? `<${href ? "a" : "button"}${spread(
          [
            {
              type: escape_attribute_value(href ? void 0 : type)
            },
            { href: escape_attribute_value(href) },
            { tabindex: "0" },
            escape_object(getAttrs(builders)),
            escape_object($$restProps),
            escape_object(attrs)
          ],
          {}
        )}${add_attribute("this", el, 0)}>${is_void(tag) ? "" : `${slots.default ? slots.default({}) : ``}`}${is_void(tag) ? "" : `</${tag}>`}` : "";
      })(href ? "a" : "button")}` : ` ${((tag) => {
        return tag ? `<${href ? "a" : "button"}${spread(
          [
            {
              type: escape_attribute_value(href ? void 0 : type)
            },
            { href: escape_attribute_value(href) },
            { tabindex: "0" },
            escape_object($$restProps),
            escape_object(attrs)
          ],
          {}
        )}>${is_void(tag) ? "" : `${slots.default ? slots.default({}) : ``}`}${is_void(tag) ? "" : `</${tag}>`}` : "";
      })(href ? "a" : "button")}`}`;
    });
    Button = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class", "variant", "size", "builders"]);
      let { class: className = void 0 } = $$props;
      let { variant = "default" } = $$props;
      let { size: size3 = "default" } = $$props;
      let { builders = [] } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.variant === void 0 && $$bindings.variant && variant !== void 0)
        $$bindings.variant(variant);
      if ($$props.size === void 0 && $$bindings.size && size3 !== void 0)
        $$bindings.size(size3);
      if ($$props.builders === void 0 && $$bindings.builders && builders !== void 0)
        $$bindings.builders(builders);
      return `${validate_component(Button$1, "ButtonPrimitive.Root").$$render(
        $$result,
        Object.assign(
          {},
          { builders },
          {
            class: cn(buttonVariants({ variant, size: size3, className }))
          },
          { type: "button" },
          $$restProps
        ),
        {},
        {
          default: () => {
            return `${slots.default ? slots.default({}) : ``}`;
          }
        }
      )}`;
    });
    buttonVariants = ce2({
      base: "inline-flex items-center justify-center rounded-md text-sm font-medium whitespace-nowrap transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50",
      variants: {
        variant: {
          default: "bg-primary text-primary-foreground shadow hover:bg-primary/90",
          secondary: "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
          destructive: "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
          outline: "text-tertiary-foreground border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
          tertiary: "bg-tertiary text-tertiary-foreground shadow-sm hover:bg-tertiary/80",
          ghost: "text-tertiary-foreground hover:bg-accent",
          link: "text-primary underline-offset-4 hover:underline"
        },
        size: {
          default: "h-9 px-4 py-2",
          sm: "h-8 rounded-md px-3 text-xs",
          lg: "h-10 rounded-md px-8",
          icon: "h-9 w-9"
        }
      },
      defaultVariants: {
        variant: "default",
        size: "default"
      }
    });
  }
});
function createLabel() {
  const root = makeElement("label", {
    action: (node) => {
      const mouseDown = addMeltEventListener(node, "mousedown", (e3) => {
        if (!e3.defaultPrevented && e3.detail > 1) {
          e3.preventDefault();
        }
      });
      return {
        destroy: mouseDown
      };
    }
  });
  return {
    elements: {
      root
    }
  };
}
function createBitAttrs(bit, parts) {
  const attrs = {};
  parts.forEach((part) => {
    attrs[part] = {
      [`data-${bit}-${part}`]: ""
    };
  });
  return (part) => attrs[part];
}
function createDispatcher() {
  const dispatch = createEventDispatcher();
  return (e3) => {
    const { originalEvent } = e3.detail;
    const { cancelable } = e3;
    const type = originalEvent.type;
    const shouldContinue = dispatch(type, { originalEvent, currentTarget: originalEvent.currentTarget }, { cancelable });
    if (!shouldContinue) {
      e3.preventDefault();
    }
  };
}
var Input;
var init_input = __esm({
  ".svelte-kit/output/server/chunks/input.js"() {
    init_dist();
    init_index3();
    init_lifecycle();
    init_ssr();
    Input = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class", "value"]);
      let { class: className = void 0 } = $$props;
      let { value = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.value === void 0 && $$bindings.value && value !== void 0)
        $$bindings.value(value);
      return `<input${spread(
        [
          {
            class: escape_attribute_value(cn("flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-sm shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50", className))
          },
          escape_object($$restProps)
        ],
        {}
      )}${add_attribute("value", value, 0)}>`;
    });
  }
});
var urlAlphabet;
var nanoid;
var init_non_secure = __esm({
  "node_modules/nanoid/non-secure/index.js"() {
    urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
    nanoid = (size3 = 21) => {
      let id2 = "";
      let i3 = size3;
      while (i3--) {
        id2 += urlAlphabet[Math.random() * 64 | 0];
      }
      return id2;
    };
  }
});
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb2 = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb2 : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}
var min;
var max;
var round;
var floor;
var createCoords;
var oppositeSideMap;
var oppositeAlignmentMap;
var init_floating_ui_utils = __esm({
  "node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs"() {
    min = Math.min;
    max = Math.max;
    round = Math.round;
    floor = Math.floor;
    createCoords = (v3) => ({
      x: v3,
      y: v3
    });
    oppositeSideMap = {
      left: "right",
      right: "left",
      bottom: "top",
      top: "bottom"
    };
    oppositeAlignmentMap = {
      start: "end",
      end: "start"
    };
  }
});
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
async function detectOverflow(state, options2) {
  var _await$platform$isEle;
  if (options2 === void 0) {
    options2 = {};
  }
  const {
    x: x4,
    y: y3,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options2, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    ...rects.floating,
    x: x4,
    y: y3
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
async function convertValueToCoords(state, options2) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options2, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var computePosition;
var arrow;
var flip;
var offset;
var shift;
var size;
var init_floating_ui_core = __esm({
  "node_modules/@floating-ui/core/dist/floating-ui.core.mjs"() {
    init_floating_ui_utils();
    init_floating_ui_utils();
    computePosition = async (reference, floating, config) => {
      const {
        placement = "bottom",
        strategy = "absolute",
        middleware = [],
        platform: platform2
      } = config;
      const validMiddleware = middleware.filter(Boolean);
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
      let rects = await platform2.getElementRects({
        reference,
        floating,
        strategy
      });
      let {
        x: x4,
        y: y3
      } = computeCoordsFromPlacement(rects, placement, rtl);
      let statefulPlacement = placement;
      let middlewareData = {};
      let resetCount = 0;
      for (let i3 = 0; i3 < validMiddleware.length; i3++) {
        const {
          name: name5,
          fn
        } = validMiddleware[i3];
        const {
          x: nextX,
          y: nextY,
          data: data2,
          reset: reset2
        } = await fn({
          x: x4,
          y: y3,
          initialPlacement: placement,
          placement: statefulPlacement,
          strategy,
          middlewareData,
          rects,
          platform: platform2,
          elements: {
            reference,
            floating
          }
        });
        x4 = nextX != null ? nextX : x4;
        y3 = nextY != null ? nextY : y3;
        middlewareData = {
          ...middlewareData,
          [name5]: {
            ...middlewareData[name5],
            ...data2
          }
        };
        if (reset2 && resetCount <= 50) {
          resetCount++;
          if (typeof reset2 === "object") {
            if (reset2.placement) {
              statefulPlacement = reset2.placement;
            }
            if (reset2.rects) {
              rects = reset2.rects === true ? await platform2.getElementRects({
                reference,
                floating,
                strategy
              }) : reset2.rects;
            }
            ({
              x: x4,
              y: y3
            } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
          }
          i3 = -1;
        }
      }
      return {
        x: x4,
        y: y3,
        placement: statefulPlacement,
        strategy,
        middlewareData
      };
    };
    arrow = (options2) => ({
      name: "arrow",
      options: options2,
      async fn(state) {
        const {
          x: x4,
          y: y3,
          placement,
          rects,
          platform: platform2,
          elements,
          middlewareData
        } = state;
        const {
          element,
          padding = 0
        } = evaluate(options2, state) || {};
        if (element == null) {
          return {};
        }
        const paddingObject = getPaddingObject(padding);
        const coords = {
          x: x4,
          y: y3
        };
        const axis = getAlignmentAxis(placement);
        const length = getAxisLength(axis);
        const arrowDimensions = await platform2.getDimensions(element);
        const isYAxis = axis === "y";
        const minProp = isYAxis ? "top" : "left";
        const maxProp = isYAxis ? "bottom" : "right";
        const clientProp = isYAxis ? "clientHeight" : "clientWidth";
        const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
        const startDiff = coords[axis] - rects.reference[axis];
        const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
        let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
        if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
          clientSize = elements.floating[clientProp] || rects.floating[length];
        }
        const centerToReference = endDiff / 2 - startDiff / 2;
        const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
        const minPadding = min(paddingObject[minProp], largestPossiblePadding);
        const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
        const min$1 = minPadding;
        const max2 = clientSize - arrowDimensions[length] - maxPadding;
        const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
        const offset2 = clamp(min$1, center, max2);
        const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
        const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
        return {
          [axis]: coords[axis] + alignmentOffset,
          data: {
            [axis]: offset2,
            centerOffset: center - offset2 - alignmentOffset,
            ...shouldAddOffset && {
              alignmentOffset
            }
          },
          reset: shouldAddOffset
        };
      }
    });
    flip = function(options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      return {
        name: "flip",
        options: options2,
        async fn(state) {
          var _middlewareData$arrow, _middlewareData$flip;
          const {
            placement,
            middlewareData,
            rects,
            initialPlacement,
            platform: platform2,
            elements
          } = state;
          const {
            mainAxis: checkMainAxis = true,
            crossAxis: checkCrossAxis = true,
            fallbackPlacements: specifiedFallbackPlacements,
            fallbackStrategy = "bestFit",
            fallbackAxisSideDirection = "none",
            flipAlignment = true,
            ...detectOverflowOptions
          } = evaluate(options2, state);
          if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
            return {};
          }
          const side = getSide(placement);
          const isBasePlacement = getSide(initialPlacement) === initialPlacement;
          const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
          const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
          if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
            fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
          }
          const placements2 = [initialPlacement, ...fallbackPlacements];
          const overflow = await detectOverflow(state, detectOverflowOptions);
          const overflows = [];
          let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
          if (checkMainAxis) {
            overflows.push(overflow[side]);
          }
          if (checkCrossAxis) {
            const sides2 = getAlignmentSides(placement, rects, rtl);
            overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
          }
          overflowsData = [...overflowsData, {
            placement,
            overflows
          }];
          if (!overflows.every((side2) => side2 <= 0)) {
            var _middlewareData$flip2, _overflowsData$filter;
            const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
            const nextPlacement = placements2[nextIndex];
            if (nextPlacement) {
              return {
                data: {
                  index: nextIndex,
                  overflows: overflowsData
                },
                reset: {
                  placement: nextPlacement
                }
              };
            }
            let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a2, b2) => a2.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
            if (!resetPlacement) {
              switch (fallbackStrategy) {
                case "bestFit": {
                  var _overflowsData$map$so;
                  const placement2 = (_overflowsData$map$so = overflowsData.map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b2) => a2[1] - b2[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
                  if (placement2) {
                    resetPlacement = placement2;
                  }
                  break;
                }
                case "initialPlacement":
                  resetPlacement = initialPlacement;
                  break;
              }
            }
            if (placement !== resetPlacement) {
              return {
                reset: {
                  placement: resetPlacement
                }
              };
            }
          }
          return {};
        }
      };
    };
    offset = function(options2) {
      if (options2 === void 0) {
        options2 = 0;
      }
      return {
        name: "offset",
        options: options2,
        async fn(state) {
          var _middlewareData$offse, _middlewareData$arrow;
          const {
            x: x4,
            y: y3,
            placement,
            middlewareData
          } = state;
          const diffCoords = await convertValueToCoords(state, options2);
          if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
            return {};
          }
          return {
            x: x4 + diffCoords.x,
            y: y3 + diffCoords.y,
            data: {
              ...diffCoords,
              placement
            }
          };
        }
      };
    };
    shift = function(options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      return {
        name: "shift",
        options: options2,
        async fn(state) {
          const {
            x: x4,
            y: y3,
            placement
          } = state;
          const {
            mainAxis: checkMainAxis = true,
            crossAxis: checkCrossAxis = false,
            limiter = {
              fn: (_ref) => {
                let {
                  x: x5,
                  y: y4
                } = _ref;
                return {
                  x: x5,
                  y: y4
                };
              }
            },
            ...detectOverflowOptions
          } = evaluate(options2, state);
          const coords = {
            x: x4,
            y: y3
          };
          const overflow = await detectOverflow(state, detectOverflowOptions);
          const crossAxis = getSideAxis(getSide(placement));
          const mainAxis = getOppositeAxis(crossAxis);
          let mainAxisCoord = coords[mainAxis];
          let crossAxisCoord = coords[crossAxis];
          if (checkMainAxis) {
            const minSide = mainAxis === "y" ? "top" : "left";
            const maxSide = mainAxis === "y" ? "bottom" : "right";
            const min2 = mainAxisCoord + overflow[minSide];
            const max2 = mainAxisCoord - overflow[maxSide];
            mainAxisCoord = clamp(min2, mainAxisCoord, max2);
          }
          if (checkCrossAxis) {
            const minSide = crossAxis === "y" ? "top" : "left";
            const maxSide = crossAxis === "y" ? "bottom" : "right";
            const min2 = crossAxisCoord + overflow[minSide];
            const max2 = crossAxisCoord - overflow[maxSide];
            crossAxisCoord = clamp(min2, crossAxisCoord, max2);
          }
          const limitedCoords = limiter.fn({
            ...state,
            [mainAxis]: mainAxisCoord,
            [crossAxis]: crossAxisCoord
          });
          return {
            ...limitedCoords,
            data: {
              x: limitedCoords.x - x4,
              y: limitedCoords.y - y3
            }
          };
        }
      };
    };
    size = function(options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      return {
        name: "size",
        options: options2,
        async fn(state) {
          const {
            placement,
            rects,
            platform: platform2,
            elements
          } = state;
          const {
            apply = () => {
            },
            ...detectOverflowOptions
          } = evaluate(options2, state);
          const overflow = await detectOverflow(state, detectOverflowOptions);
          const side = getSide(placement);
          const alignment = getAlignment(placement);
          const isYAxis = getSideAxis(placement) === "y";
          const {
            width,
            height
          } = rects.floating;
          let heightSide;
          let widthSide;
          if (side === "top" || side === "bottom") {
            heightSide = side;
            widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
          } else {
            widthSide = side;
            heightSide = alignment === "end" ? "top" : "bottom";
          }
          const overflowAvailableHeight = height - overflow[heightSide];
          const overflowAvailableWidth = width - overflow[widthSide];
          const noShift = !state.middlewareData.shift;
          let availableHeight = overflowAvailableHeight;
          let availableWidth = overflowAvailableWidth;
          if (isYAxis) {
            const maximumClippingWidth = width - overflow.left - overflow.right;
            availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
          } else {
            const maximumClippingHeight = height - overflow.top - overflow.bottom;
            availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
          }
          if (noShift && !alignment) {
            const xMin = max(overflow.left, 0);
            const xMax = max(overflow.right, 0);
            const yMin = max(overflow.top, 0);
            const yMax = max(overflow.bottom, 0);
            if (isYAxis) {
              availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
            } else {
              availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
            }
          }
          await apply({
            ...state,
            availableWidth,
            availableHeight
          });
          const nextDimensions = await platform2.getDimensions(elements.floating);
          if (width !== nextDimensions.width || height !== nextDimensions.height) {
            return {
              reset: {
                rects: true
              }
            };
          }
          return {};
        }
      };
    };
  }
});
function getNodeName(node) {
  if (isNode2(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode2(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode2(value) {
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement2(value) {
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement2(value) {
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isContainingBlock(element) {
  const webkit = isWebKit();
  const css4 = getComputedStyle2(element);
  return css4.transform !== "none" || css4.perspective !== "none" || (css4.containerType ? css4.containerType !== "normal" : false) || !webkit && (css4.backdropFilter ? css4.backdropFilter !== "none" : false) || !webkit && (css4.filter ? css4.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css4.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css4.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement2(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = getParentNode(currentNode);
    }
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement2(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement2(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
var init_floating_ui_utils_dom = __esm({
  "node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs"() {
  }
});
function getCssDimensions(element) {
  const css4 = getComputedStyle2(element);
  let width = parseFloat(css4.width) || 0;
  let height = parseFloat(css4.height) || 0;
  const hasOffset = isHTMLElement2(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement2(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement2(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x4 = ($ ? round(rect.width) : rect.width) / width;
  let y3 = ($ ? round(rect.height) : rect.height) / height;
  if (!x4 || !Number.isFinite(x4)) {
    x4 = 1;
  }
  if (!y3 || !Number.isFinite(y3)) {
    y3 = 1;
  }
  return {
    x: x4,
    y: y3
  };
}
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale2 = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement2(offsetParent)) {
        scale2 = getScale(offsetParent);
      }
    } else {
      scale2 = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x4 = (clientRect.left + visualOffsets.x) / scale2.x;
  let y3 = (clientRect.top + visualOffsets.y) / scale2.y;
  let width = clientRect.width / scale2.x;
  let height = clientRect.height / scale2.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement2(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = currentWin.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css4 = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css4.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css4.paddingTop)) * iframeScale.y;
      x4 *= iframeScale.x;
      y3 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x4 += left;
      y3 += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = currentWin.frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x4,
    y: y3
  });
}
function isTopLayer(floating) {
  return topLayerSelectors.some((selector) => {
    try {
      return floating.matches(selector);
    } catch (e3) {
      return false;
    }
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale2 = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement2(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement2(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale2 = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale2.x,
    height: rect.height * scale2.y,
    x: rect.x * scale2.x - scroll.scrollLeft * scale2.x + offsets.x,
    y: rect.y * scale2.y - scroll.scrollTop * scale2.y + offsets.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body2 = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body2.scrollWidth, body2.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body2.scrollHeight, body2.clientHeight);
  let x4 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y3 = -scroll.scrollTop;
  if (getComputedStyle2(body2).direction === "rtl") {
    x4 += max(html.clientWidth, body2.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x4,
    y: y3
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x4 = 0;
  let y3 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x4 = visualViewport.offsetLeft;
      y3 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x4,
    y: y3
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale2 = isHTMLElement2(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale2.x;
  const height = element.clientHeight * scale2.y;
  const x4 = left * scale2.x;
  const y3 = top * scale2.y;
  return {
    width,
    height,
    x: x4,
    y: y3
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement2(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement2(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement2(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement2(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement2(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const x4 = rect.left + scroll.scrollLeft - offsets.x;
  const y3 = rect.top + scroll.scrollTop - offsets.y;
  return {
    x: x4,
    y: y3,
    width: rect.width,
    height: rect.height
  };
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement2(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  return element.offsetParent;
}
function getOffsetParent(element, polyfill) {
  const window2 = getWindow(element);
  if (!isHTMLElement2(element) || isTopLayer(element)) {
    return window2;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options2 = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 100);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options2,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e3) {
      io = new IntersectionObserver(handleObserve, options2);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update2, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options2;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update2, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update2);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update2) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update2();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update2();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update2();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update2);
      ancestorResize && ancestor.removeEventListener("resize", update2);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var noOffsets;
var topLayerSelectors;
var getElementRects;
var platform;
var shift2;
var flip2;
var size2;
var arrow2;
var computePosition2;
var init_floating_ui_dom = __esm({
  "node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs"() {
    init_floating_ui_core();
    init_floating_ui_core();
    init_floating_ui_utils();
    init_floating_ui_utils_dom();
    noOffsets = /* @__PURE__ */ createCoords(0);
    topLayerSelectors = [":popover-open", ":modal"];
    getElementRects = async function(data2) {
      const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
      const getDimensionsFn = this.getDimensions;
      return {
        reference: getRectRelativeToOffsetParent(data2.reference, await getOffsetParentFn(data2.floating), data2.strategy),
        floating: {
          x: 0,
          y: 0,
          ...await getDimensionsFn(data2.floating)
        }
      };
    };
    platform = {
      convertOffsetParentRelativeRectToViewportRelativeRect,
      getDocumentElement,
      getClippingRect,
      getOffsetParent,
      getElementRects,
      getClientRects,
      getDimensions,
      getScale,
      isElement: isElement2,
      isRTL
    };
    shift2 = shift;
    flip2 = flip;
    size2 = size;
    arrow2 = arrow;
    computePosition2 = (reference, floating, options2) => {
      const cache = /* @__PURE__ */ new Map();
      const mergedOptions = {
        platform,
        ...options2
      };
      const platformWithCache = {
        ...mergedOptions.platform,
        _c: cache
      };
      return computePosition(reference, floating, {
        ...mergedOptions,
        platform: platformWithCache
      });
    };
  }
});
var candidateSelectors;
var candidateSelector;
var NoElement;
var matches;
var getRootNode;
var isInert;
var isContentEditable;
var getCandidates;
var getCandidatesIteratively;
var hasTabIndex;
var getTabIndex;
var getSortOrderTabIndex;
var sortOrderedTabbables;
var isInput;
var isHiddenInput;
var isDetailsWithSummary;
var getCheckedRadio;
var isTabbableRadio;
var isRadio;
var isNonTabbableRadio;
var isNodeAttached;
var isZeroArea;
var isHidden;
var isDisabledFromFieldset;
var isNodeMatchingSelectorFocusable;
var isNodeMatchingSelectorTabbable;
var isValidShadowRootTabbable;
var sortByOrder;
var tabbable;
var focusable;
var isTabbable;
var focusableCandidateSelector;
var isFocusable;
var init_index_esm3 = __esm({
  "node_modules/tabbable/dist/index.esm.js"() {
    candidateSelectors = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"];
    candidateSelector = /* @__PURE__ */ candidateSelectors.join(",");
    NoElement = typeof Element === "undefined";
    matches = NoElement ? function() {
    } : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
    getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
      var _element$getRootNode;
      return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
    } : function(element) {
      return element === null || element === void 0 ? void 0 : element.ownerDocument;
    };
    isInert = function isInert2(node, lookUp) {
      var _node$getAttribute;
      if (lookUp === void 0) {
        lookUp = true;
      }
      var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, "inert");
      var inert = inertAtt === "" || inertAtt === "true";
      var result = inert || lookUp && node && isInert2(node.parentNode);
      return result;
    };
    isContentEditable = function isContentEditable2(node) {
      var _node$getAttribute2;
      var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, "contenteditable");
      return attValue === "" || attValue === "true";
    };
    getCandidates = function getCandidates2(el, includeContainer, filter) {
      if (isInert(el)) {
        return [];
      }
      var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
      if (includeContainer && matches.call(el, candidateSelector)) {
        candidates.unshift(el);
      }
      candidates = candidates.filter(filter);
      return candidates;
    };
    getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options2) {
      var candidates = [];
      var elementsToCheck = Array.from(elements);
      while (elementsToCheck.length) {
        var element = elementsToCheck.shift();
        if (isInert(element, false)) {
          continue;
        }
        if (element.tagName === "SLOT") {
          var assigned = element.assignedElements();
          var content = assigned.length ? assigned : element.children;
          var nestedCandidates = getCandidatesIteratively2(content, true, options2);
          if (options2.flatten) {
            candidates.push.apply(candidates, nestedCandidates);
          } else {
            candidates.push({
              scopeParent: element,
              candidates: nestedCandidates
            });
          }
        } else {
          var validCandidate = matches.call(element, candidateSelector);
          if (validCandidate && options2.filter(element) && (includeContainer || !elements.includes(element))) {
            candidates.push(element);
          }
          var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
          typeof options2.getShadowRoot === "function" && options2.getShadowRoot(element);
          var validShadowRoot = !isInert(shadowRoot, false) && (!options2.shadowRootFilter || options2.shadowRootFilter(element));
          if (shadowRoot && validShadowRoot) {
            var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options2);
            if (options2.flatten) {
              candidates.push.apply(candidates, _nestedCandidates);
            } else {
              candidates.push({
                scopeParent: element,
                candidates: _nestedCandidates
              });
            }
          } else {
            elementsToCheck.unshift.apply(elementsToCheck, element.children);
          }
        }
      }
      return candidates;
    };
    hasTabIndex = function hasTabIndex2(node) {
      return !isNaN(parseInt(node.getAttribute("tabindex"), 10));
    };
    getTabIndex = function getTabIndex2(node) {
      if (!node) {
        throw new Error("No node provided");
      }
      if (node.tabIndex < 0) {
        if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {
          return 0;
        }
      }
      return node.tabIndex;
    };
    getSortOrderTabIndex = function getSortOrderTabIndex2(node, isScope) {
      var tabIndex = getTabIndex(node);
      if (tabIndex < 0 && isScope && !hasTabIndex(node)) {
        return 0;
      }
      return tabIndex;
    };
    sortOrderedTabbables = function sortOrderedTabbables2(a2, b2) {
      return a2.tabIndex === b2.tabIndex ? a2.documentOrder - b2.documentOrder : a2.tabIndex - b2.tabIndex;
    };
    isInput = function isInput2(node) {
      return node.tagName === "INPUT";
    };
    isHiddenInput = function isHiddenInput2(node) {
      return isInput(node) && node.type === "hidden";
    };
    isDetailsWithSummary = function isDetailsWithSummary2(node) {
      var r4 = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
        return child.tagName === "SUMMARY";
      });
      return r4;
    };
    getCheckedRadio = function getCheckedRadio2(nodes, form) {
      for (var i3 = 0; i3 < nodes.length; i3++) {
        if (nodes[i3].checked && nodes[i3].form === form) {
          return nodes[i3];
        }
      }
    };
    isTabbableRadio = function isTabbableRadio2(node) {
      if (!node.name) {
        return true;
      }
      var radioScope = node.form || getRootNode(node);
      var queryRadios = function queryRadios2(name5) {
        return radioScope.querySelectorAll('input[type="radio"][name="' + name5 + '"]');
      };
      var radioSet;
      if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
        radioSet = queryRadios(window.CSS.escape(node.name));
      } else {
        try {
          radioSet = queryRadios(node.name);
        } catch (err) {
          console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
          return false;
        }
      }
      var checked = getCheckedRadio(radioSet, node.form);
      return !checked || checked === node;
    };
    isRadio = function isRadio2(node) {
      return isInput(node) && node.type === "radio";
    };
    isNonTabbableRadio = function isNonTabbableRadio2(node) {
      return isRadio(node) && !isTabbableRadio(node);
    };
    isNodeAttached = function isNodeAttached2(node) {
      var _nodeRoot;
      var nodeRoot = node && getRootNode(node);
      var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;
      var attached = false;
      if (nodeRoot && nodeRoot !== node) {
        var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
        attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));
        while (!attached && nodeRootHost) {
          var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
          nodeRoot = getRootNode(nodeRootHost);
          nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
          attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));
        }
      }
      return attached;
    };
    isZeroArea = function isZeroArea2(node) {
      var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
      return width === 0 && height === 0;
    };
    isHidden = function isHidden2(node, _ref) {
      var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
      if (getComputedStyle(node).visibility === "hidden") {
        return true;
      }
      var isDirectSummary = matches.call(node, "details>summary:first-of-type");
      var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
      if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
        return true;
      }
      if (!displayCheck || displayCheck === "full" || displayCheck === "legacy-full") {
        if (typeof getShadowRoot === "function") {
          var originalNode = node;
          while (node) {
            var parentElement = node.parentElement;
            var rootNode = getRootNode(node);
            if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
              return isZeroArea(node);
            } else if (node.assignedSlot) {
              node = node.assignedSlot;
            } else if (!parentElement && rootNode !== node.ownerDocument) {
              node = rootNode.host;
            } else {
              node = parentElement;
            }
          }
          node = originalNode;
        }
        if (isNodeAttached(node)) {
          return !node.getClientRects().length;
        }
        if (displayCheck !== "legacy-full") {
          return true;
        }
      } else if (displayCheck === "non-zero-area") {
        return isZeroArea(node);
      }
      return false;
    };
    isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
      if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
        var parentNode = node.parentElement;
        while (parentNode) {
          if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
            for (var i3 = 0; i3 < parentNode.children.length; i3++) {
              var child = parentNode.children.item(i3);
              if (child.tagName === "LEGEND") {
                return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
              }
            }
            return true;
          }
          parentNode = parentNode.parentElement;
        }
      }
      return false;
    };
    isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options2, node) {
      if (node.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
      //  because we're limited in the type of selectors we can use in JSDom (see related
      //  note related to `candidateSelectors`)
      isInert(node) || isHiddenInput(node) || isHidden(node, options2) || // For a details element with a summary, the summary element gets the focus
      isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
        return false;
      }
      return true;
    };
    isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options2, node) {
      if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options2, node)) {
        return false;
      }
      return true;
    };
    isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
      var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
      if (isNaN(tabIndex) || tabIndex >= 0) {
        return true;
      }
      return false;
    };
    sortByOrder = function sortByOrder2(candidates) {
      var regularTabbables = [];
      var orderedTabbables = [];
      candidates.forEach(function(item, i3) {
        var isScope = !!item.scopeParent;
        var element = isScope ? item.scopeParent : item;
        var candidateTabindex = getSortOrderTabIndex(element, isScope);
        var elements = isScope ? sortByOrder2(item.candidates) : element;
        if (candidateTabindex === 0) {
          isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
        } else {
          orderedTabbables.push({
            documentOrder: i3,
            tabIndex: candidateTabindex,
            item,
            isScope,
            content: elements
          });
        }
      });
      return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
        sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
        return acc;
      }, []).concat(regularTabbables);
    };
    tabbable = function tabbable2(container, options2) {
      options2 = options2 || {};
      var candidates;
      if (options2.getShadowRoot) {
        candidates = getCandidatesIteratively([container], options2.includeContainer, {
          filter: isNodeMatchingSelectorTabbable.bind(null, options2),
          flatten: false,
          getShadowRoot: options2.getShadowRoot,
          shadowRootFilter: isValidShadowRootTabbable
        });
      } else {
        candidates = getCandidates(container, options2.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options2));
      }
      return sortByOrder(candidates);
    };
    focusable = function focusable2(container, options2) {
      options2 = options2 || {};
      var candidates;
      if (options2.getShadowRoot) {
        candidates = getCandidatesIteratively([container], options2.includeContainer, {
          filter: isNodeMatchingSelectorFocusable.bind(null, options2),
          flatten: true,
          getShadowRoot: options2.getShadowRoot
        });
      } else {
        candidates = getCandidates(container, options2.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options2));
      }
      return candidates;
    };
    isTabbable = function isTabbable2(node, options2) {
      options2 = options2 || {};
      if (!node) {
        throw new Error("No node provided");
      }
      if (matches.call(node, candidateSelector) === false) {
        return false;
      }
      return isNodeMatchingSelectorTabbable(options2, node);
    };
    focusableCandidateSelector = /* @__PURE__ */ candidateSelectors.concat("iframe").join(",");
    isFocusable = function isFocusable2(node, options2) {
      options2 = options2 || {};
      if (!node) {
        throw new Error("No node provided");
      }
      if (matches.call(node, focusableCandidateSelector) === false) {
        return false;
      }
      return isNodeMatchingSelectorFocusable(options2, node);
    };
  }
});
function ownKeys(e3, r4) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r4 && (o2 = o2.filter(function(r5) {
      return Object.getOwnPropertyDescriptor(e3, r5).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread2(e3) {
  for (var r4 = 1; r4 < arguments.length; r4++) {
    var t2 = null != arguments[r4] ? arguments[r4] : {};
    r4 % 2 ? ownKeys(Object(t2), true).forEach(function(r5) {
      _defineProperty(e3, r5, t2[r5]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r5) {
      Object.defineProperty(e3, r5, Object.getOwnPropertyDescriptor(t2, r5));
    });
  }
  return e3;
}
function _defineProperty(obj, key2, value) {
  key2 = _toPropertyKey(key2);
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key2 = _toPrimitive(arg, "string");
  return typeof key2 === "symbol" ? key2 : String(key2);
}
var activeFocusTraps;
var isSelectableInput;
var isEscapeEvent;
var isTabEvent;
var isKeyForward;
var isKeyBackward;
var delay;
var findIndex;
var valueOrHandler;
var getActualTarget;
var internalTrapStack;
var createFocusTrap;
var init_focus_trap_esm = __esm({
  "node_modules/focus-trap/dist/focus-trap.esm.js"() {
    init_index_esm3();
    activeFocusTraps = {
      activateTrap: function activateTrap(trapStack, trap) {
        if (trapStack.length > 0) {
          var activeTrap = trapStack[trapStack.length - 1];
          if (activeTrap !== trap) {
            activeTrap.pause();
          }
        }
        var trapIndex = trapStack.indexOf(trap);
        if (trapIndex === -1) {
          trapStack.push(trap);
        } else {
          trapStack.splice(trapIndex, 1);
          trapStack.push(trap);
        }
      },
      deactivateTrap: function deactivateTrap(trapStack, trap) {
        var trapIndex = trapStack.indexOf(trap);
        if (trapIndex !== -1) {
          trapStack.splice(trapIndex, 1);
        }
        if (trapStack.length > 0) {
          trapStack[trapStack.length - 1].unpause();
        }
      }
    };
    isSelectableInput = function isSelectableInput2(node) {
      return node.tagName && node.tagName.toLowerCase() === "input" && typeof node.select === "function";
    };
    isEscapeEvent = function isEscapeEvent2(e3) {
      return (e3 === null || e3 === void 0 ? void 0 : e3.key) === "Escape" || (e3 === null || e3 === void 0 ? void 0 : e3.key) === "Esc" || (e3 === null || e3 === void 0 ? void 0 : e3.keyCode) === 27;
    };
    isTabEvent = function isTabEvent2(e3) {
      return (e3 === null || e3 === void 0 ? void 0 : e3.key) === "Tab" || (e3 === null || e3 === void 0 ? void 0 : e3.keyCode) === 9;
    };
    isKeyForward = function isKeyForward2(e3) {
      return isTabEvent(e3) && !e3.shiftKey;
    };
    isKeyBackward = function isKeyBackward2(e3) {
      return isTabEvent(e3) && e3.shiftKey;
    };
    delay = function delay2(fn) {
      return setTimeout(fn, 0);
    };
    findIndex = function findIndex2(arr, fn) {
      var idx = -1;
      arr.every(function(value, i3) {
        if (fn(value)) {
          idx = i3;
          return false;
        }
        return true;
      });
      return idx;
    };
    valueOrHandler = function valueOrHandler2(value) {
      for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        params[_key - 1] = arguments[_key];
      }
      return typeof value === "function" ? value.apply(void 0, params) : value;
    };
    getActualTarget = function getActualTarget2(event) {
      return event.target.shadowRoot && typeof event.composedPath === "function" ? event.composedPath()[0] : event.target;
    };
    internalTrapStack = [];
    createFocusTrap = function createFocusTrap2(elements, userOptions) {
      var doc2 = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
      var trapStack = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.trapStack) || internalTrapStack;
      var config = _objectSpread2({
        returnFocusOnDeactivate: true,
        escapeDeactivates: true,
        delayInitialFocus: true,
        isKeyForward,
        isKeyBackward
      }, userOptions);
      var state = {
        // containers given to createFocusTrap()
        // @type {Array<HTMLElement>}
        containers: [],
        // list of objects identifying tabbable nodes in `containers` in the trap
        // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
        //  is active, but the trap should never get to a state where there isn't at least one group
        //  with at least one tabbable node in it (that would lead to an error condition that would
        //  result in an error being thrown)
        // @type {Array<{
        //   container: HTMLElement,
        //   tabbableNodes: Array<HTMLElement>, // empty if none
        //   focusableNodes: Array<HTMLElement>, // empty if none
        //   posTabIndexesFound: boolean,
        //   firstTabbableNode: HTMLElement|undefined,
        //   lastTabbableNode: HTMLElement|undefined,
        //   firstDomTabbableNode: HTMLElement|undefined,
        //   lastDomTabbableNode: HTMLElement|undefined,
        //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
        // }>}
        containerGroups: [],
        // same order/length as `containers` list
        // references to objects in `containerGroups`, but only those that actually have
        //  tabbable nodes in them
        // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
        //  the same length
        tabbableGroups: [],
        nodeFocusedBeforeActivation: null,
        mostRecentlyFocusedNode: null,
        active: false,
        paused: false,
        // timer ID for when delayInitialFocus is true and initial focus in this trap
        //  has been delayed during activation
        delayInitialFocusTimer: void 0,
        // the most recent KeyboardEvent for the configured nav key (typically [SHIFT+]TAB), if any
        recentNavEvent: void 0
      };
      var trap;
      var getOption = function getOption2(configOverrideOptions, optionName, configOptionName) {
        return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : config[configOptionName || optionName];
      };
      var findContainerIndex = function findContainerIndex2(element, event) {
        var composedPath = typeof (event === null || event === void 0 ? void 0 : event.composedPath) === "function" ? event.composedPath() : void 0;
        return state.containerGroups.findIndex(function(_ref) {
          var container = _ref.container, tabbableNodes = _ref.tabbableNodes;
          return container.contains(element) || // fall back to explicit tabbable search which will take into consideration any
          //  web components if the `tabbableOptions.getShadowRoot` option was used for
          //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
          //  look inside web components even if open)
          (composedPath === null || composedPath === void 0 ? void 0 : composedPath.includes(container)) || tabbableNodes.find(function(node) {
            return node === element;
          });
        });
      };
      var getNodeForOption = function getNodeForOption2(optionName) {
        var optionValue = config[optionName];
        if (typeof optionValue === "function") {
          for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            params[_key2 - 1] = arguments[_key2];
          }
          optionValue = optionValue.apply(void 0, params);
        }
        if (optionValue === true) {
          optionValue = void 0;
        }
        if (!optionValue) {
          if (optionValue === void 0 || optionValue === false) {
            return optionValue;
          }
          throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
        }
        var node = optionValue;
        if (typeof optionValue === "string") {
          node = doc2.querySelector(optionValue);
          if (!node) {
            throw new Error("`".concat(optionName, "` as selector refers to no known node"));
          }
        }
        return node;
      };
      var getInitialFocusNode = function getInitialFocusNode2() {
        var node = getNodeForOption("initialFocus");
        if (node === false) {
          return false;
        }
        if (node === void 0 || !isFocusable(node, config.tabbableOptions)) {
          if (findContainerIndex(doc2.activeElement) >= 0) {
            node = doc2.activeElement;
          } else {
            var firstTabbableGroup = state.tabbableGroups[0];
            var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
            node = firstTabbableNode || getNodeForOption("fallbackFocus");
          }
        }
        if (!node) {
          throw new Error("Your focus-trap needs to have at least one focusable element");
        }
        return node;
      };
      var updateTabbableNodes = function updateTabbableNodes2() {
        state.containerGroups = state.containers.map(function(container) {
          var tabbableNodes = tabbable(container, config.tabbableOptions);
          var focusableNodes = focusable(container, config.tabbableOptions);
          var firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : void 0;
          var lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : void 0;
          var firstDomTabbableNode = focusableNodes.find(function(node) {
            return isTabbable(node);
          });
          var lastDomTabbableNode = focusableNodes.slice().reverse().find(function(node) {
            return isTabbable(node);
          });
          var posTabIndexesFound = !!tabbableNodes.find(function(node) {
            return getTabIndex(node) > 0;
          });
          return {
            container,
            tabbableNodes,
            focusableNodes,
            /** True if at least one node with positive `tabindex` was found in this container. */
            posTabIndexesFound,
            /** First tabbable node in container, __tabindex__ order; `undefined` if none. */
            firstTabbableNode,
            /** Last tabbable node in container, __tabindex__ order; `undefined` if none. */
            lastTabbableNode,
            // NOTE: DOM order is NOT NECESSARILY "document position" order, but figuring that out
            //  would require more than just https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
            //  because that API doesn't work with Shadow DOM as well as it should (@see
            //  https://github.com/whatwg/dom/issues/320) and since this first/last is only needed, so far,
            //  to address an edge case related to positive tabindex support, this seems like a much easier,
            //  "close enough most of the time" alternative for positive tabindexes which should generally
            //  be avoided anyway...
            /** First tabbable node in container, __DOM__ order; `undefined` if none. */
            firstDomTabbableNode,
            /** Last tabbable node in container, __DOM__ order; `undefined` if none. */
            lastDomTabbableNode,
            /**
             * Finds the __tabbable__ node that follows the given node in the specified direction,
             *  in this container, if any.
             * @param {HTMLElement} node
             * @param {boolean} [forward] True if going in forward tab order; false if going
             *  in reverse.
             * @returns {HTMLElement|undefined} The next tabbable node, if any.
             */
            nextTabbableNode: function nextTabbableNode(node) {
              var forward2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
              var nodeIdx = tabbableNodes.indexOf(node);
              if (nodeIdx < 0) {
                if (forward2) {
                  return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find(function(el) {
                    return isTabbable(el);
                  });
                }
                return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find(function(el) {
                  return isTabbable(el);
                });
              }
              return tabbableNodes[nodeIdx + (forward2 ? 1 : -1)];
            }
          };
        });
        state.tabbableGroups = state.containerGroups.filter(function(group) {
          return group.tabbableNodes.length > 0;
        });
        if (state.tabbableGroups.length <= 0 && !getNodeForOption("fallbackFocus")) {
          throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
        }
        if (state.containerGroups.find(function(g2) {
          return g2.posTabIndexesFound;
        }) && state.containerGroups.length > 1) {
          throw new Error("At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.");
        }
      };
      var getActiveElement = function getActiveElement2(el) {
        var activeElement = el.activeElement;
        if (!activeElement) {
          return;
        }
        if (activeElement.shadowRoot && activeElement.shadowRoot.activeElement !== null) {
          return getActiveElement2(activeElement.shadowRoot);
        }
        return activeElement;
      };
      var tryFocus = function tryFocus2(node) {
        if (node === false) {
          return;
        }
        if (node === getActiveElement(document)) {
          return;
        }
        if (!node || !node.focus) {
          tryFocus2(getInitialFocusNode());
          return;
        }
        node.focus({
          preventScroll: !!config.preventScroll
        });
        state.mostRecentlyFocusedNode = node;
        if (isSelectableInput(node)) {
          node.select();
        }
      };
      var getReturnFocusNode = function getReturnFocusNode2(previousActiveElement) {
        var node = getNodeForOption("setReturnFocus", previousActiveElement);
        return node ? node : node === false ? false : previousActiveElement;
      };
      var findNextNavNode = function findNextNavNode2(_ref2) {
        var target = _ref2.target, event = _ref2.event, _ref2$isBackward = _ref2.isBackward, isBackward = _ref2$isBackward === void 0 ? false : _ref2$isBackward;
        target = target || getActualTarget(event);
        updateTabbableNodes();
        var destinationNode = null;
        if (state.tabbableGroups.length > 0) {
          var containerIndex = findContainerIndex(target, event);
          var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : void 0;
          if (containerIndex < 0) {
            if (isBackward) {
              destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
            } else {
              destinationNode = state.tabbableGroups[0].firstTabbableNode;
            }
          } else if (isBackward) {
            var startOfGroupIndex = findIndex(state.tabbableGroups, function(_ref3) {
              var firstTabbableNode = _ref3.firstTabbableNode;
              return target === firstTabbableNode;
            });
            if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {
              startOfGroupIndex = containerIndex;
            }
            if (startOfGroupIndex >= 0) {
              var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
              var destinationGroup = state.tabbableGroups[destinationGroupIndex];
              destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;
            } else if (!isTabEvent(event)) {
              destinationNode = containerGroup.nextTabbableNode(target, false);
            }
          } else {
            var lastOfGroupIndex = findIndex(state.tabbableGroups, function(_ref4) {
              var lastTabbableNode = _ref4.lastTabbableNode;
              return target === lastTabbableNode;
            });
            if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {
              lastOfGroupIndex = containerIndex;
            }
            if (lastOfGroupIndex >= 0) {
              var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
              var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
              destinationNode = getTabIndex(target) >= 0 ? _destinationGroup.firstTabbableNode : _destinationGroup.firstDomTabbableNode;
            } else if (!isTabEvent(event)) {
              destinationNode = containerGroup.nextTabbableNode(target);
            }
          }
        } else {
          destinationNode = getNodeForOption("fallbackFocus");
        }
        return destinationNode;
      };
      var checkPointerDown = function checkPointerDown2(e3) {
        var target = getActualTarget(e3);
        if (findContainerIndex(target, e3) >= 0) {
          return;
        }
        if (valueOrHandler(config.clickOutsideDeactivates, e3)) {
          trap.deactivate({
            // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
            //  which will result in the outside click setting focus to the node
            //  that was clicked (and if not focusable, to "nothing"); by setting
            //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
            //  on activation (or the configured `setReturnFocus` node), whether the
            //  outside click was on a focusable node or not
            returnFocus: config.returnFocusOnDeactivate
          });
          return;
        }
        if (valueOrHandler(config.allowOutsideClick, e3)) {
          return;
        }
        e3.preventDefault();
      };
      var checkFocusIn = function checkFocusIn2(event) {
        var target = getActualTarget(event);
        var targetContained = findContainerIndex(target, event) >= 0;
        if (targetContained || target instanceof Document) {
          if (targetContained) {
            state.mostRecentlyFocusedNode = target;
          }
        } else {
          event.stopImmediatePropagation();
          var nextNode;
          var navAcrossContainers = true;
          if (state.mostRecentlyFocusedNode) {
            if (getTabIndex(state.mostRecentlyFocusedNode) > 0) {
              var mruContainerIdx = findContainerIndex(state.mostRecentlyFocusedNode);
              var tabbableNodes = state.containerGroups[mruContainerIdx].tabbableNodes;
              if (tabbableNodes.length > 0) {
                var mruTabIdx = tabbableNodes.findIndex(function(node) {
                  return node === state.mostRecentlyFocusedNode;
                });
                if (mruTabIdx >= 0) {
                  if (config.isKeyForward(state.recentNavEvent)) {
                    if (mruTabIdx + 1 < tabbableNodes.length) {
                      nextNode = tabbableNodes[mruTabIdx + 1];
                      navAcrossContainers = false;
                    }
                  } else {
                    if (mruTabIdx - 1 >= 0) {
                      nextNode = tabbableNodes[mruTabIdx - 1];
                      navAcrossContainers = false;
                    }
                  }
                }
              }
            } else {
              if (!state.containerGroups.some(function(g2) {
                return g2.tabbableNodes.some(function(n2) {
                  return getTabIndex(n2) > 0;
                });
              })) {
                navAcrossContainers = false;
              }
            }
          } else {
            navAcrossContainers = false;
          }
          if (navAcrossContainers) {
            nextNode = findNextNavNode({
              // move FROM the MRU node, not event-related node (which will be the node that is
              //  outside the trap causing the focus escape we're trying to fix)
              target: state.mostRecentlyFocusedNode,
              isBackward: config.isKeyBackward(state.recentNavEvent)
            });
          }
          if (nextNode) {
            tryFocus(nextNode);
          } else {
            tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
          }
        }
        state.recentNavEvent = void 0;
      };
      var checkKeyNav = function checkKeyNav2(event) {
        var isBackward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        state.recentNavEvent = event;
        var destinationNode = findNextNavNode({
          event,
          isBackward
        });
        if (destinationNode) {
          if (isTabEvent(event)) {
            event.preventDefault();
          }
          tryFocus(destinationNode);
        }
      };
      var checkKey = function checkKey2(event) {
        if (isEscapeEvent(event) && valueOrHandler(config.escapeDeactivates, event) !== false) {
          event.preventDefault();
          trap.deactivate();
          return;
        }
        if (config.isKeyForward(event) || config.isKeyBackward(event)) {
          checkKeyNav(event, config.isKeyBackward(event));
        }
      };
      var checkClick = function checkClick2(e3) {
        var target = getActualTarget(e3);
        if (findContainerIndex(target, e3) >= 0) {
          return;
        }
        if (valueOrHandler(config.clickOutsideDeactivates, e3)) {
          return;
        }
        if (valueOrHandler(config.allowOutsideClick, e3)) {
          return;
        }
        e3.preventDefault();
        e3.stopImmediatePropagation();
      };
      var addListeners = function addListeners2() {
        if (!state.active) {
          return;
        }
        activeFocusTraps.activateTrap(trapStack, trap);
        state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function() {
          tryFocus(getInitialFocusNode());
        }) : tryFocus(getInitialFocusNode());
        doc2.addEventListener("focusin", checkFocusIn, true);
        doc2.addEventListener("mousedown", checkPointerDown, {
          capture: true,
          passive: false
        });
        doc2.addEventListener("touchstart", checkPointerDown, {
          capture: true,
          passive: false
        });
        doc2.addEventListener("click", checkClick, {
          capture: true,
          passive: false
        });
        doc2.addEventListener("keydown", checkKey, {
          capture: true,
          passive: false
        });
        return trap;
      };
      var removeListeners = function removeListeners2() {
        if (!state.active) {
          return;
        }
        doc2.removeEventListener("focusin", checkFocusIn, true);
        doc2.removeEventListener("mousedown", checkPointerDown, true);
        doc2.removeEventListener("touchstart", checkPointerDown, true);
        doc2.removeEventListener("click", checkClick, true);
        doc2.removeEventListener("keydown", checkKey, true);
        return trap;
      };
      var checkDomRemoval = function checkDomRemoval2(mutations) {
        var isFocusedNodeRemoved = mutations.some(function(mutation) {
          var removedNodes = Array.from(mutation.removedNodes);
          return removedNodes.some(function(node) {
            return node === state.mostRecentlyFocusedNode;
          });
        });
        if (isFocusedNodeRemoved) {
          tryFocus(getInitialFocusNode());
        }
      };
      var mutationObserver = typeof window !== "undefined" && "MutationObserver" in window ? new MutationObserver(checkDomRemoval) : void 0;
      var updateObservedNodes = function updateObservedNodes2() {
        if (!mutationObserver) {
          return;
        }
        mutationObserver.disconnect();
        if (state.active && !state.paused) {
          state.containers.map(function(container) {
            mutationObserver.observe(container, {
              subtree: true,
              childList: true
            });
          });
        }
      };
      trap = {
        get active() {
          return state.active;
        },
        get paused() {
          return state.paused;
        },
        activate: function activate(activateOptions) {
          if (state.active) {
            return this;
          }
          var onActivate = getOption(activateOptions, "onActivate");
          var onPostActivate = getOption(activateOptions, "onPostActivate");
          var checkCanFocusTrap = getOption(activateOptions, "checkCanFocusTrap");
          if (!checkCanFocusTrap) {
            updateTabbableNodes();
          }
          state.active = true;
          state.paused = false;
          state.nodeFocusedBeforeActivation = doc2.activeElement;
          onActivate === null || onActivate === void 0 || onActivate();
          var finishActivation = function finishActivation2() {
            if (checkCanFocusTrap) {
              updateTabbableNodes();
            }
            addListeners();
            updateObservedNodes();
            onPostActivate === null || onPostActivate === void 0 || onPostActivate();
          };
          if (checkCanFocusTrap) {
            checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);
            return this;
          }
          finishActivation();
          return this;
        },
        deactivate: function deactivate(deactivateOptions) {
          if (!state.active) {
            return this;
          }
          var options2 = _objectSpread2({
            onDeactivate: config.onDeactivate,
            onPostDeactivate: config.onPostDeactivate,
            checkCanReturnFocus: config.checkCanReturnFocus
          }, deactivateOptions);
          clearTimeout(state.delayInitialFocusTimer);
          state.delayInitialFocusTimer = void 0;
          removeListeners();
          state.active = false;
          state.paused = false;
          updateObservedNodes();
          activeFocusTraps.deactivateTrap(trapStack, trap);
          var onDeactivate = getOption(options2, "onDeactivate");
          var onPostDeactivate = getOption(options2, "onPostDeactivate");
          var checkCanReturnFocus = getOption(options2, "checkCanReturnFocus");
          var returnFocus = getOption(options2, "returnFocus", "returnFocusOnDeactivate");
          onDeactivate === null || onDeactivate === void 0 || onDeactivate();
          var finishDeactivation = function finishDeactivation2() {
            delay(function() {
              if (returnFocus) {
                tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
              }
              onPostDeactivate === null || onPostDeactivate === void 0 || onPostDeactivate();
            });
          };
          if (returnFocus && checkCanReturnFocus) {
            checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
            return this;
          }
          finishDeactivation();
          return this;
        },
        pause: function pause(pauseOptions) {
          if (state.paused || !state.active) {
            return this;
          }
          var onPause = getOption(pauseOptions, "onPause");
          var onPostPause = getOption(pauseOptions, "onPostPause");
          state.paused = true;
          onPause === null || onPause === void 0 || onPause();
          removeListeners();
          updateObservedNodes();
          onPostPause === null || onPostPause === void 0 || onPostPause();
          return this;
        },
        unpause: function unpause(unpauseOptions) {
          if (!state.paused || !state.active) {
            return this;
          }
          var onUnpause = getOption(unpauseOptions, "onUnpause");
          var onPostUnpause = getOption(unpauseOptions, "onPostUnpause");
          state.paused = false;
          onUnpause === null || onUnpause === void 0 || onUnpause();
          updateTabbableNodes();
          addListeners();
          updateObservedNodes();
          onPostUnpause === null || onPostUnpause === void 0 || onPostUnpause();
          return this;
        },
        updateContainerElements: function updateContainerElements(containerElements) {
          var elementsAsArray = [].concat(containerElements).filter(Boolean);
          state.containers = elementsAsArray.map(function(element) {
            return typeof element === "string" ? doc2.querySelector(element) : element;
          });
          if (state.active) {
            updateTabbableNodes();
          }
          updateObservedNodes();
          return this;
        }
      };
      trap.updateContainerElements(elements);
      return trap;
    };
  }
});
function arraysAreEqual(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }
  return arr1.every((value, index15) => value === arr2[index15]);
}
function back(array2, index15, increment, loop = true) {
  const previousIndex = index15 - increment;
  if (previousIndex <= 0) {
    return loop ? array2[array2.length - 1] : array2[0];
  }
  return array2[previousIndex];
}
function forward(array2, index15, increment, loop = true) {
  const nextIndex = index15 + increment;
  if (nextIndex > array2.length - 1) {
    return loop ? array2[0] : array2[array2.length - 1];
  }
  return array2[nextIndex];
}
function next(array2, index15, loop = true) {
  if (index15 === array2.length - 1) {
    return loop ? array2[0] : array2[index15];
  }
  return array2[index15 + 1];
}
function prev(array2, currentIndex, loop = true) {
  if (currentIndex <= 0) {
    return loop ? array2[array2.length - 1] : array2[0];
  }
  return array2[currentIndex - 1];
}
function last(array2) {
  return array2[array2.length - 1];
}
function wrapArray(array2, startIndex) {
  return array2.map((_, index15) => array2[(startIndex + index15) % array2.length]);
}
function toggle(item, array2, compare3 = dequal) {
  const itemIdx = array2.findIndex((innerItem) => compare3(innerItem, item));
  if (itemIdx !== -1) {
    array2.splice(itemIdx, 1);
  } else {
    array2.push(item);
  }
  return array2;
}
function addHighlight(element) {
  element.setAttribute("data-highlighted", "");
}
function removeHighlight(element) {
  element.removeAttribute("data-highlighted");
}
function getOptions(el) {
  return Array.from(el.querySelectorAll('[role="option"]:not([data-disabled])')).filter((el2) => isHTMLElement(el2));
}
function sleep(ms) {
  return new Promise((resolve2) => setTimeout(resolve2, ms));
}
function generateId() {
  return nanoid(10);
}
function generateIds(args) {
  return args.reduce((acc, curr) => {
    acc[curr] = generateId();
    return acc;
  }, {});
}
function debounce(fn, wait = 500) {
  let timeout = null;
  return function(...args) {
    const later = () => {
      timeout = null;
      fn(...args);
    };
    timeout && clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}
function getPlatform() {
  const agent = navigator.userAgentData;
  return agent?.platform ?? navigator.platform;
}
function assignStyle(el, style) {
  if (!el)
    return;
  const previousStyle = el.style.cssText;
  Object.assign(el.style, style);
  return () => {
    el.style.cssText = previousStyle;
  };
}
function setCSSProperty(el, property, value) {
  if (!el)
    return;
  const previousValue = el.style.getPropertyValue(property);
  el.style.setProperty(property, value);
  return () => {
    if (previousValue) {
      el.style.setProperty(property, previousValue);
    } else {
      el.style.removeProperty(property);
    }
  };
}
function getPaddingProperty(documentElement) {
  const documentLeft = documentElement.getBoundingClientRect().left;
  const scrollbarX = Math.round(documentLeft) + documentElement.scrollLeft;
  return scrollbarX ? "paddingLeft" : "paddingRight";
}
function removeScroll(_document) {
  const doc2 = _document ?? document;
  const win = doc2.defaultView ?? window;
  const { documentElement, body: body2 } = doc2;
  const locked = body2.hasAttribute(LOCK_CLASSNAME);
  if (locked)
    return noop2;
  body2.setAttribute(LOCK_CLASSNAME, "");
  const scrollbarWidth = win.innerWidth - documentElement.clientWidth;
  const setScrollbarWidthProperty = () => setCSSProperty(documentElement, "--scrollbar-width", `${scrollbarWidth}px`);
  const paddingProperty = getPaddingProperty(documentElement);
  const scrollbarSidePadding = win.getComputedStyle(body2)[paddingProperty];
  const setStyle = () => assignStyle(body2, {
    overflow: "hidden",
    [paddingProperty]: `calc(${scrollbarSidePadding} + ${scrollbarWidth}px)`
  });
  const setIOSStyle = () => {
    const { scrollX, scrollY, visualViewport } = win;
    const offsetLeft = visualViewport?.offsetLeft ?? 0;
    const offsetTop = visualViewport?.offsetTop ?? 0;
    const restoreStyle = assignStyle(body2, {
      position: "fixed",
      overflow: "hidden",
      top: `${-(scrollY - Math.floor(offsetTop))}px`,
      left: `${-(scrollX - Math.floor(offsetLeft))}px`,
      right: "0",
      [paddingProperty]: `calc(${scrollbarSidePadding} + ${scrollbarWidth}px)`
    });
    return () => {
      restoreStyle?.();
      win.scrollTo(scrollX, scrollY);
    };
  };
  const cleanups = [setScrollbarWidthProperty(), isIos() ? setIOSStyle() : setStyle()];
  return () => {
    cleanups.forEach((fn) => fn?.());
    body2.removeAttribute(LOCK_CLASSNAME);
  };
}
function derivedVisible(obj) {
  const { open, forceVisible, activeTrigger } = obj;
  return derived([open, forceVisible, activeTrigger], ([$open, $forceVisible, $activeTrigger]) => ($open || $forceVisible) && $activeTrigger !== null);
}
function toWritableStores(properties) {
  const result = {};
  Object.keys(properties).forEach((key2) => {
    const propertyKey = key2;
    const value = properties[propertyKey];
    result[propertyKey] = withGet(writable(value));
  });
  return result;
}
function handleRovingFocus(nextElement) {
  if (!isBrowser2)
    return;
  sleep(1).then(() => {
    const currentFocusedElement = document.activeElement;
    if (!isHTMLElement(currentFocusedElement) || currentFocusedElement === nextElement)
      return;
    currentFocusedElement.tabIndex = -1;
    if (nextElement) {
      nextElement.tabIndex = 0;
      nextElement.focus();
    }
  });
}
function getFocusableElements() {
  return Array.from(document.querySelectorAll('a[href]:not([tabindex="-1"]), button:not([disabled]):not([tabindex="-1"]), input:not([disabled]):not([tabindex="-1"]), select:not([disabled]):not([tabindex="-1"]), textarea:not([disabled]):not([tabindex="-1"]), [tabindex]:not([tabindex="-1"])'));
}
function getNextFocusable(currentElement) {
  const focusableElements = getFocusableElements();
  const currentIndex = focusableElements.indexOf(currentElement);
  const nextIndex = currentIndex + 1;
  const nextElement = focusableElements[nextIndex];
  if (nextIndex < focusableElements.length && isHTMLElement(nextElement)) {
    return nextElement;
  }
  return null;
}
function getPreviousFocusable(currentElement) {
  const focusableElements = getFocusableElements();
  const currentIndex = focusableElements.indexOf(currentElement);
  const previousIndex = currentIndex - 1;
  const prevElement = focusableElements[previousIndex];
  if (previousIndex >= 0 && isHTMLElement(prevElement)) {
    return prevElement;
  }
  return null;
}
function createTypeaheadSearch(args = {}) {
  const withDefaults = { ...defaults$3, ...args };
  const typed = withGet(writable([]));
  const resetTyped = debounce(() => {
    typed.update(() => []);
  });
  const handleTypeaheadSearch = (key2, items) => {
    if (ignoredKeys.has(key2))
      return;
    const currentItem = withDefaults.getCurrentItem();
    const $typed = get_store_value(typed);
    if (!Array.isArray($typed)) {
      return;
    }
    $typed.push(key2.toLowerCase());
    typed.set($typed);
    const candidateItems = items.filter((item) => {
      if (item.getAttribute("disabled") === "true" || item.getAttribute("aria-disabled") === "true" || item.hasAttribute("data-disabled")) {
        return false;
      }
      return true;
    });
    const isRepeated = $typed.length > 1 && $typed.every((char) => char === $typed[0]);
    const normalizeSearch = isRepeated ? $typed[0] : $typed.join("");
    const currentItemIndex = isHTMLElement(currentItem) ? candidateItems.indexOf(currentItem) : -1;
    let wrappedItems = wrapArray(candidateItems, Math.max(currentItemIndex, 0));
    const excludeCurrentItem = normalizeSearch.length === 1;
    if (excludeCurrentItem) {
      wrappedItems = wrappedItems.filter((v3) => v3 !== currentItem);
    }
    const nextItem = wrappedItems.find((item) => item?.innerText && item.innerText.toLowerCase().startsWith(normalizeSearch.toLowerCase()));
    if (isHTMLElement(nextItem) && nextItem !== currentItem) {
      withDefaults.onMatch(nextItem);
    }
    resetTyped();
  };
  return {
    typed,
    resetTyped,
    handleTypeaheadSearch
  };
}
function getPortalParent(node) {
  let parent = node.parentElement;
  while (isHTMLElement(parent) && !parent.hasAttribute("data-portal")) {
    parent = parent.parentElement;
  }
  return parent || "body";
}
function getPortalDestination(node, portalProp) {
  if (portalProp !== void 0)
    return portalProp;
  const portalParent = getPortalParent(node);
  if (portalParent === "body")
    return document.body;
  return null;
}
function createClickOutsideIgnore(meltId) {
  return (e3) => {
    const target = e3.target;
    const triggerEl = getElementByMeltId(meltId);
    if (!triggerEl || !isElement(target))
      return false;
    const id2 = triggerEl.id;
    if (isHTMLLabelElement(target) && id2 === target.htmlFor) {
      return true;
    }
    if (target.closest(`label[for="${id2}"]`)) {
      return true;
    }
    return false;
  };
}
async function handleFocus(args) {
  const { prop, defaultEl } = args;
  await Promise.all([sleep(1), tick]);
  if (prop === void 0) {
    defaultEl?.focus();
    return;
  }
  const returned = isFunction(prop) ? prop(defaultEl) : prop;
  if (typeof returned === "string") {
    const el = document.querySelector(returned);
    if (!isHTMLElement(el))
      return;
    el.focus();
  } else if (isHTMLElement(returned)) {
    returned.focus();
  }
}
function useFloating(reference, floating, opts = {}) {
  if (!floating || !reference || opts === null)
    return {
      destroy: noop2
    };
  const options2 = { ...defaultConfig$1, ...opts };
  const arrowEl = floating.querySelector("[data-arrow=true]");
  const middleware = [];
  if (options2.flip) {
    middleware.push(flip2({
      boundary: options2.boundary,
      padding: options2.overflowPadding
    }));
  }
  const arrowOffset = isHTMLElement(arrowEl) ? arrowEl.offsetHeight / 2 : 0;
  if (options2.gutter || options2.offset) {
    const data2 = options2.gutter ? { mainAxis: options2.gutter } : options2.offset;
    if (data2?.mainAxis != null) {
      data2.mainAxis += arrowOffset;
    }
    middleware.push(offset(data2));
  }
  middleware.push(shift2({
    boundary: options2.boundary,
    crossAxis: options2.overlap,
    padding: options2.overflowPadding
  }));
  if (arrowEl) {
    middleware.push(arrow2({ element: arrowEl, padding: 8 }));
  }
  middleware.push(size2({
    padding: options2.overflowPadding,
    apply({ rects, availableHeight, availableWidth }) {
      if (options2.sameWidth) {
        Object.assign(floating.style, {
          width: `${Math.round(rects.reference.width)}px`,
          minWidth: "unset"
        });
      }
      if (options2.fitViewport) {
        Object.assign(floating.style, {
          maxWidth: `${availableWidth}px`,
          maxHeight: `${availableHeight}px`
        });
      }
    }
  }));
  function compute() {
    if (!reference || !floating)
      return;
    if (isHTMLElement(reference) && !reference.ownerDocument.documentElement.contains(reference))
      return;
    const { placement, strategy } = options2;
    computePosition2(reference, floating, {
      placement,
      middleware,
      strategy
    }).then((data2) => {
      const x4 = Math.round(data2.x);
      const y3 = Math.round(data2.y);
      Object.assign(floating.style, {
        position: options2.strategy,
        top: `${y3}px`,
        left: `${x4}px`
      });
      if (isHTMLElement(arrowEl) && data2.middlewareData.arrow) {
        const { x: x22, y: y22 } = data2.middlewareData.arrow;
        const dir = data2.placement.split("-")[0];
        Object.assign(arrowEl.style, {
          position: "absolute",
          left: x22 != null ? `${x22}px` : "",
          top: y22 != null ? `${y22}px` : "",
          [dir]: `calc(100% - ${arrowOffset}px)`,
          transform: ARROW_TRANSFORM[dir],
          backgroundColor: "inherit",
          zIndex: "inherit"
        });
      }
      return data2;
    });
  }
  Object.assign(floating.style, {
    position: options2.strategy
  });
  return {
    destroy: autoUpdate(reference, floating, compute)
  };
}
function createFocusTrap3(config = {}) {
  let trap;
  const { immediate, ...focusTrapOptions } = config;
  const hasFocus = writable(false);
  const isPaused = writable(false);
  const activate = (opts) => trap?.activate(opts);
  const deactivate = (opts) => {
    trap?.deactivate(opts);
  };
  const pause = () => {
    if (trap) {
      trap.pause();
      isPaused.set(true);
    }
  };
  const unpause = () => {
    if (trap) {
      trap.unpause();
      isPaused.set(false);
    }
  };
  const useFocusTrap = (node) => {
    trap = createFocusTrap(node, {
      ...focusTrapOptions,
      onActivate() {
        hasFocus.set(true);
        config.onActivate?.();
      },
      onDeactivate() {
        hasFocus.set(false);
        config.onDeactivate?.();
      }
    });
    if (immediate) {
      activate();
    }
    return {
      destroy() {
        deactivate();
        trap = void 0;
      }
    };
  };
  return {
    useFocusTrap,
    hasFocus: readonly(hasFocus),
    isPaused: readonly(isPaused),
    activate,
    deactivate,
    pause,
    unpause
  };
}
function useModal(node, config) {
  let unsubInteractOutside = noop2;
  function removeNodeFromVisibleModals() {
    const index15 = visibleModals.indexOf(node);
    if (index15 >= 0) {
      visibleModals.splice(index15, 1);
    }
  }
  function update2(config2) {
    unsubInteractOutside();
    const { open, onClose, shouldCloseOnInteractOutside, closeOnInteractOutside } = config2;
    sleep(100).then(() => {
      if (open) {
        visibleModals.push(node);
      } else {
        removeNodeFromVisibleModals();
      }
    });
    function isLastModal() {
      return last(visibleModals) === node;
    }
    function closeModal() {
      if (isLastModal() && onClose) {
        onClose();
        removeNodeFromVisibleModals();
      }
    }
    function onInteractOutsideStart(e3) {
      const target = e3.target;
      if (!isElement(target))
        return;
      if (target && isLastModal()) {
        e3.preventDefault();
        e3.stopPropagation();
        e3.stopImmediatePropagation();
      }
    }
    function onInteractOutside(e3) {
      if (shouldCloseOnInteractOutside?.(e3) && isLastModal()) {
        e3.preventDefault();
        e3.stopPropagation();
        e3.stopImmediatePropagation();
        closeModal();
      }
    }
    unsubInteractOutside = useInteractOutside(node, {
      onInteractOutsideStart,
      onInteractOutside: closeOnInteractOutside ? onInteractOutside : void 0,
      enabled: open
    }).destroy;
  }
  update2(config);
  return {
    update: update2,
    destroy() {
      removeNodeFromVisibleModals();
      unsubInteractOutside();
    }
  };
}
function useInteractOutside(node, config) {
  let unsub = noop2;
  let isPointerDown = false;
  let isPointerDownInside = false;
  let ignoreEmulatedMouseEvents = false;
  function update2(config2) {
    unsub();
    const { onInteractOutside, onInteractOutsideStart, enabled } = config2;
    if (!enabled)
      return;
    function onPointerDown(e3) {
      if (onInteractOutside && isValidEvent(e3, node)) {
        onInteractOutsideStart?.(e3);
      }
      const target = e3.target;
      if (isElement(target) && isOrContainsTarget(node, target)) {
        isPointerDownInside = true;
      }
      isPointerDown = true;
    }
    function triggerInteractOutside(e3) {
      onInteractOutside?.(e3);
    }
    const documentObj = getOwnerDocument(node);
    if (typeof PointerEvent !== "undefined") {
      const onPointerUp = (e3) => {
        if (shouldTriggerInteractOutside(e3)) {
          triggerInteractOutside(e3);
        }
        resetPointerState();
      };
      unsub = executeCallbacks(addEventListener2(documentObj, "pointerdown", onPointerDown, true), addEventListener2(documentObj, "pointerup", onPointerUp, true));
    } else {
      const onMouseUp = (e3) => {
        if (ignoreEmulatedMouseEvents) {
          ignoreEmulatedMouseEvents = false;
        } else if (shouldTriggerInteractOutside(e3)) {
          triggerInteractOutside(e3);
        }
        resetPointerState();
      };
      const onTouchEnd = (e3) => {
        ignoreEmulatedMouseEvents = true;
        if (shouldTriggerInteractOutside(e3)) {
          triggerInteractOutside(e3);
        }
        resetPointerState();
      };
      unsub = executeCallbacks(addEventListener2(documentObj, "mousedown", onPointerDown, true), addEventListener2(documentObj, "mouseup", onMouseUp, true), addEventListener2(documentObj, "touchstart", onPointerDown, true), addEventListener2(documentObj, "touchend", onTouchEnd, true));
    }
  }
  function shouldTriggerInteractOutside(e3) {
    if (isPointerDown && !isPointerDownInside && isValidEvent(e3, node)) {
      return true;
    }
    return false;
  }
  function resetPointerState() {
    isPointerDown = false;
    isPointerDownInside = false;
  }
  update2(config);
  return {
    update: update2,
    destroy: unsub
  };
}
function isValidEvent(e3, node) {
  if ("button" in e3 && e3.button > 0)
    return false;
  const target = e3.target;
  if (!isElement(target))
    return false;
  const ownerDocument = target.ownerDocument;
  if (!ownerDocument || !ownerDocument.documentElement.contains(target)) {
    return false;
  }
  return node && !isOrContainsTarget(node, target);
}
function isOrContainsTarget(node, target) {
  return node === target || node.contains(target);
}
function getOwnerDocument(el) {
  return el?.ownerDocument ?? document;
}
function createListbox(props) {
  const withDefaults = { ...defaults$2, ...props };
  const activeTrigger = withGet(writable(null));
  const highlightedItem = withGet(writable(null));
  const selectedWritable = withDefaults.selected ?? writable(withDefaults.defaultSelected);
  const selected = overridable(selectedWritable, withDefaults?.onSelectedChange);
  const highlighted = derived(highlightedItem, ($highlightedItem) => $highlightedItem ? getOptionProps($highlightedItem) : void 0);
  const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);
  const open = overridable(openWritable, withDefaults?.onOpenChange);
  const options2 = toWritableStores({
    ...omit(withDefaults, "open", "defaultOpen", "builder", "ids"),
    multiple: withDefaults.multiple ?? false
  });
  const { scrollAlignment, loop, closeOnOutsideClick, closeOnEscape, preventScroll, portal, forceVisible, positioning, multiple, arrowSize, disabled, required, typeahead, name: nameProp, highlightOnHover, onOutsideClick } = options2;
  const { name: name22, selector } = createElHelpers(withDefaults.builder);
  const ids = toWritableStores({ ...generateIds(listboxIdParts), ...withDefaults.ids });
  const { handleTypeaheadSearch } = createTypeaheadSearch({
    onMatch: (element) => {
      highlightedItem.set(element);
      element.scrollIntoView({ block: scrollAlignment.get() });
    },
    getCurrentItem() {
      return highlightedItem.get();
    }
  });
  function getOptionProps(el) {
    const value = el.getAttribute("data-value");
    const label2 = el.getAttribute("data-label");
    const disabled2 = el.hasAttribute("data-disabled");
    return {
      value: value ? JSON.parse(value) : value,
      label: label2 ?? el.textContent ?? void 0,
      disabled: disabled2 ? true : false
    };
  }
  const setOption = (newOption) => {
    selected.update(($option) => {
      const $multiple = multiple.get();
      if ($multiple) {
        const optionArr = Array.isArray($option) ? [...$option] : [];
        return toggle(newOption, optionArr, (itemA, itemB) => dequal(itemA.value, itemB.value));
      }
      return newOption;
    });
  };
  function selectItem(item) {
    const props2 = getOptionProps(item);
    setOption(props2);
  }
  async function openMenu() {
    open.set(true);
    const triggerEl = document.getElementById(ids.trigger.get());
    if (!triggerEl)
      return;
    activeTrigger.set(triggerEl);
    await tick();
    const menuElement = document.getElementById(ids.menu.get());
    if (!isHTMLElement(menuElement))
      return;
    const selectedItem = menuElement.querySelector("[aria-selected=true]");
    if (!isHTMLElement(selectedItem))
      return;
    highlightedItem.set(selectedItem);
  }
  function closeMenu() {
    open.set(false);
    highlightedItem.set(null);
  }
  const isVisible = derivedVisible({ open, forceVisible, activeTrigger });
  const isSelected = derived([selected], ([$selected]) => {
    return (value) => {
      if (Array.isArray($selected)) {
        return $selected.some((o2) => dequal(o2.value, value));
      }
      if (isObject3(value)) {
        return dequal($selected?.value, stripValues(value, void 0));
      }
      return dequal($selected?.value, value);
    };
  });
  const isHighlighted = derived([highlighted], ([$value]) => {
    return (item) => {
      return dequal($value?.value, item);
    };
  });
  const trigger = makeElement(name22("trigger"), {
    stores: [open, highlightedItem, disabled, ids.menu, ids.trigger, ids.label],
    returned: ([$open, $highlightedItem, $disabled, $menuId, $triggerId, $labelId]) => {
      return {
        "aria-activedescendant": $highlightedItem?.id,
        "aria-autocomplete": "list",
        "aria-controls": $menuId,
        "aria-expanded": $open,
        "aria-labelledby": $labelId,
        // autocomplete: 'off',
        id: $triggerId,
        role: "combobox",
        disabled: disabledAttr($disabled),
        type: withDefaults.builder === "select" ? "button" : void 0
      };
    },
    action: (node) => {
      const isInput3 = isHTMLInputElement(node);
      const unsubscribe = executeCallbacks(
        addMeltEventListener(node, "click", () => {
          node.focus();
          const $open = open.get();
          if ($open) {
            closeMenu();
          } else {
            openMenu();
          }
        }),
        // Handle all input key events including typing, meta, and navigation.
        addMeltEventListener(node, "keydown", (e3) => {
          const $open = open.get();
          if (!$open) {
            if (INTERACTION_KEYS.includes(e3.key)) {
              return;
            }
            if (e3.key === kbd.TAB) {
              return;
            }
            if (e3.key === kbd.BACKSPACE && isInput3 && node.value === "") {
              return;
            }
            if (e3.key === kbd.SPACE && isHTMLButtonElement(node)) {
              return;
            }
            openMenu();
            tick().then(() => {
              const $selectedItem = selected.get();
              if ($selectedItem)
                return;
              const menuEl = document.getElementById(ids.menu.get());
              if (!isHTMLElement(menuEl))
                return;
              const enabledItems = Array.from(menuEl.querySelectorAll(`${selector("item")}:not([data-disabled]):not([data-hidden])`)).filter((item) => isHTMLElement(item));
              if (!enabledItems.length)
                return;
              if (e3.key === kbd.ARROW_DOWN) {
                highlightedItem.set(enabledItems[0]);
                enabledItems[0].scrollIntoView({ block: scrollAlignment.get() });
              } else if (e3.key === kbd.ARROW_UP) {
                highlightedItem.set(last(enabledItems));
                last(enabledItems).scrollIntoView({ block: scrollAlignment.get() });
              }
            });
          }
          if (e3.key === kbd.TAB) {
            closeMenu();
            return;
          }
          if (e3.key === kbd.ENTER || e3.key === kbd.SPACE && isHTMLButtonElement(node)) {
            e3.preventDefault();
            const $highlightedItem = highlightedItem.get();
            if ($highlightedItem) {
              selectItem($highlightedItem);
            }
            if (!multiple.get()) {
              closeMenu();
            }
          }
          if (e3.key === kbd.ARROW_UP && e3.altKey) {
            closeMenu();
          }
          if (FIRST_LAST_KEYS.includes(e3.key)) {
            e3.preventDefault();
            const menuElement = document.getElementById(ids.menu.get());
            if (!isHTMLElement(menuElement))
              return;
            const itemElements = getOptions(menuElement);
            if (!itemElements.length)
              return;
            const candidateNodes = itemElements.filter((opt) => !isElementDisabled(opt) && opt.dataset.hidden === void 0);
            const $currentItem = highlightedItem.get();
            const currentIndex = $currentItem ? candidateNodes.indexOf($currentItem) : -1;
            const $loop = loop.get();
            const $scrollAlignment = scrollAlignment.get();
            let nextItem;
            switch (e3.key) {
              case kbd.ARROW_DOWN:
                nextItem = next(candidateNodes, currentIndex, $loop);
                break;
              case kbd.ARROW_UP:
                nextItem = prev(candidateNodes, currentIndex, $loop);
                break;
              case kbd.PAGE_DOWN:
                nextItem = forward(candidateNodes, currentIndex, 10, $loop);
                break;
              case kbd.PAGE_UP:
                nextItem = back(candidateNodes, currentIndex, 10, $loop);
                break;
              case kbd.HOME:
                nextItem = candidateNodes[0];
                break;
              case kbd.END:
                nextItem = last(candidateNodes);
                break;
              default:
                return;
            }
            highlightedItem.set(nextItem);
            nextItem?.scrollIntoView({ block: $scrollAlignment });
          } else if (typeahead.get()) {
            const menuEl = document.getElementById(ids.menu.get());
            if (!isHTMLElement(menuEl))
              return;
            handleTypeaheadSearch(e3.key, getOptions(menuEl));
          }
        })
      );
      let unsubEscapeKeydown = noop2;
      const escape2 = useEscapeKeydown(node, {
        handler: closeMenu,
        enabled: derived([open, closeOnEscape], ([$open, $closeOnEscape]) => {
          return $open && $closeOnEscape;
        })
      });
      if (escape2 && escape2.destroy) {
        unsubEscapeKeydown = escape2.destroy;
      }
      return {
        destroy() {
          unsubscribe();
          unsubEscapeKeydown();
        }
      };
    }
  });
  const menu = makeElement(name22("menu"), {
    stores: [isVisible, ids.menu],
    returned: ([$isVisible, $menuId]) => {
      return {
        hidden: $isVisible ? void 0 : true,
        id: $menuId,
        role: "listbox",
        style: styleToString({ display: $isVisible ? void 0 : "none" })
      };
    },
    action: (node) => {
      let unsubPopper = noop2;
      const unsubscribe = executeCallbacks(
        // Bind the popper portal to the input element.
        effect([isVisible, portal, closeOnOutsideClick, positioning, activeTrigger], ([$isVisible, $portal, $closeOnOutsideClick, $positioning, $activeTrigger]) => {
          unsubPopper();
          if (!$isVisible || !$activeTrigger)
            return;
          const ignoreHandler = createClickOutsideIgnore(ids.trigger.get());
          const popper = usePopper(node, {
            anchorElement: $activeTrigger,
            open,
            options: {
              floating: $positioning,
              focusTrap: null,
              modal: {
                closeOnInteractOutside: $closeOnOutsideClick,
                onClose: closeMenu,
                open: $isVisible,
                shouldCloseOnInteractOutside: (e3) => {
                  onOutsideClick.get()?.(e3);
                  if (e3.defaultPrevented)
                    return false;
                  const target = e3.target;
                  if (!isElement(target))
                    return false;
                  if (target === $activeTrigger || $activeTrigger.contains(target)) {
                    return false;
                  }
                  if (ignoreHandler(e3))
                    return false;
                  return true;
                }
              },
              escapeKeydown: null,
              portal: getPortalDestination(node, $portal)
            }
          });
          if (popper && popper.destroy) {
            unsubPopper = popper.destroy;
          }
        })
      );
      return {
        destroy: () => {
          unsubscribe();
          unsubPopper();
        }
      };
    }
  });
  const { elements: { root: labelBuilder } } = createLabel();
  const { action: labelAction } = get_store_value(labelBuilder);
  const label = makeElement(name22("label"), {
    stores: [ids.label, ids.trigger],
    returned: ([$labelId, $triggerId]) => {
      return {
        id: $labelId,
        for: $triggerId
      };
    },
    action: labelAction
  });
  const option = makeElement(name22("option"), {
    stores: [isSelected],
    returned: ([$isSelected]) => (props2) => {
      const selected2 = $isSelected(props2.value);
      return {
        "data-value": JSON.stringify(props2.value),
        "data-label": props2.label,
        "data-disabled": disabledAttr(props2.disabled),
        "aria-disabled": props2.disabled ? true : void 0,
        "aria-selected": selected2,
        "data-selected": selected2 ? "" : void 0,
        id: generateId(),
        role: "option"
      };
    },
    action: (node) => {
      const unsubscribe = executeCallbacks(addMeltEventListener(node, "click", (e3) => {
        if (isElementDisabled(node)) {
          e3.preventDefault();
          return;
        }
        selectItem(node);
        if (!multiple.get()) {
          closeMenu();
        }
      }), effect(highlightOnHover, ($highlightOnHover) => {
        if (!$highlightOnHover)
          return;
        const unsub = executeCallbacks(addMeltEventListener(node, "mouseover", () => {
          highlightedItem.set(node);
        }), addMeltEventListener(node, "mouseleave", () => {
          highlightedItem.set(null);
        }));
        return unsub;
      }));
      return { destroy: unsubscribe };
    }
  });
  const group = makeElement(name22("group"), {
    returned: () => {
      return (groupId) => ({
        role: "group",
        "aria-labelledby": groupId
      });
    }
  });
  const groupLabel = makeElement(name22("group-label"), {
    returned: () => {
      return (groupId) => ({
        id: groupId
      });
    }
  });
  const hiddenInput = createHiddenInput({
    value: derived([selected], ([$selected]) => {
      const value = Array.isArray($selected) ? $selected.map((o2) => o2.value) : $selected?.value;
      return typeof value === "string" ? value : JSON.stringify(value);
    }),
    name: readonly(nameProp),
    required,
    prefix: withDefaults.builder
  });
  const arrow22 = makeElement(name22("arrow"), {
    stores: arrowSize,
    returned: ($arrowSize) => ({
      "data-arrow": true,
      style: styleToString({
        position: "absolute",
        width: `var(--arrow-size, ${$arrowSize}px)`,
        height: `var(--arrow-size, ${$arrowSize}px)`
      })
    })
  });
  safeOnMount(() => {
    if (!isBrowser2)
      return;
    const menuEl = document.getElementById(ids.menu.get());
    const triggerEl = document.getElementById(ids.trigger.get());
    if (triggerEl) {
      activeTrigger.set(triggerEl);
    }
    if (!menuEl)
      return;
    const selectedEl = menuEl.querySelector("[data-selected]");
    if (!isHTMLElement(selectedEl))
      return;
  });
  effect([highlightedItem], ([$highlightedItem]) => {
    if (!isBrowser2)
      return;
    const menuElement = document.getElementById(ids.menu.get());
    if (!isHTMLElement(menuElement))
      return;
    getOptions(menuElement).forEach((node) => {
      if (node === $highlightedItem) {
        addHighlight(node);
      } else {
        removeHighlight(node);
      }
    });
  });
  effect([open], ([$open]) => {
    if (!isBrowser2)
      return;
    let unsubScroll = noop2;
    if (preventScroll.get() && $open) {
      unsubScroll = removeScroll();
    }
    return () => {
      unsubScroll();
    };
  });
  return {
    ids,
    elements: {
      trigger,
      group,
      option,
      menu,
      groupLabel,
      label,
      hiddenInput,
      arrow: arrow22
    },
    states: {
      open,
      selected,
      highlighted,
      highlightedItem
    },
    helpers: {
      isSelected,
      isHighlighted,
      closeMenu
    },
    options: options2
  };
}
function createDialog(props) {
  const withDefaults = { ...defaults$1, ...props };
  const options2 = toWritableStores(omit(withDefaults, "ids"));
  const { preventScroll, closeOnEscape, closeOnOutsideClick, role, portal, forceVisible, openFocus, closeFocus, onOutsideClick } = options2;
  const activeTrigger = withGet.writable(null);
  const ids = toWritableStores({
    ...generateIds(dialogIdParts),
    ...withDefaults.ids
  });
  const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);
  const open = overridable(openWritable, withDefaults?.onOpenChange);
  const isVisible = derived([open, forceVisible], ([$open, $forceVisible]) => {
    return $open || $forceVisible;
  });
  let unsubScroll = noop2;
  function handleOpen(e3) {
    const el = e3.currentTarget;
    const triggerEl = e3.currentTarget;
    if (!isHTMLElement(el) || !isHTMLElement(triggerEl))
      return;
    open.set(true);
    activeTrigger.set(triggerEl);
  }
  function handleClose() {
    open.set(false);
    handleFocus({
      prop: closeFocus.get(),
      defaultEl: activeTrigger.get()
    });
  }
  const trigger = makeElement(name3("trigger"), {
    stores: [open],
    returned: ([$open]) => {
      return {
        "aria-haspopup": "dialog",
        "aria-expanded": $open,
        type: "button"
      };
    },
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "click", (e3) => {
        handleOpen(e3);
      }), addMeltEventListener(node, "keydown", (e3) => {
        if (e3.key !== kbd.ENTER && e3.key !== kbd.SPACE)
          return;
        e3.preventDefault();
        handleOpen(e3);
      }));
      return {
        destroy: unsub
      };
    }
  });
  const overlay = makeElement(name3("overlay"), {
    stores: [isVisible, open],
    returned: ([$isVisible, $open]) => {
      return {
        hidden: $isVisible ? void 0 : true,
        tabindex: -1,
        style: styleToString({
          display: $isVisible ? void 0 : "none"
        }),
        "aria-hidden": true,
        "data-state": $open ? "open" : "closed"
      };
    },
    action: (node) => {
      let unsubEscapeKeydown = noop2;
      if (closeOnEscape.get()) {
        const escapeKeydown = useEscapeKeydown(node, {
          handler: () => {
            handleClose();
          }
        });
        if (escapeKeydown && escapeKeydown.destroy) {
          unsubEscapeKeydown = escapeKeydown.destroy;
        }
      }
      return {
        destroy() {
          unsubEscapeKeydown();
        }
      };
    }
  });
  const content = makeElement(name3("content"), {
    stores: [isVisible, ids.content, ids.description, ids.title, open],
    returned: ([$isVisible, $contentId, $descriptionId, $titleId, $open]) => {
      return {
        id: $contentId,
        role: role.get(),
        "aria-describedby": $descriptionId,
        "aria-labelledby": $titleId,
        "aria-modal": $isVisible ? "true" : void 0,
        "data-state": $open ? "open" : "closed",
        tabindex: -1,
        hidden: $isVisible ? void 0 : true,
        style: styleToString({
          display: $isVisible ? void 0 : "none"
        })
      };
    },
    action: (node) => {
      let activate = noop2;
      let deactivate = noop2;
      const destroy = executeCallbacks(effect([open], ([$open]) => {
        if (!$open)
          return;
        const focusTrap = createFocusTrap3({
          immediate: false,
          escapeDeactivates: true,
          clickOutsideDeactivates: true,
          returnFocusOnDeactivate: false,
          fallbackFocus: node
        });
        activate = focusTrap.activate;
        deactivate = focusTrap.deactivate;
        const ac2 = focusTrap.useFocusTrap(node);
        if (ac2 && ac2.destroy) {
          return ac2.destroy;
        } else {
          return focusTrap.deactivate;
        }
      }), effect([closeOnOutsideClick, open], ([$closeOnOutsideClick, $open]) => {
        return useModal(node, {
          open: $open,
          closeOnInteractOutside: $closeOnOutsideClick,
          onClose() {
            handleClose();
          },
          shouldCloseOnInteractOutside(e3) {
            onOutsideClick.get()?.(e3);
            if (e3.defaultPrevented)
              return false;
            return true;
          }
        }).destroy;
      }), effect([closeOnEscape], ([$closeOnEscape]) => {
        if (!$closeOnEscape)
          return noop2;
        const escapeKeydown = useEscapeKeydown(node, {
          handler: () => {
            handleClose();
          }
        });
        if (escapeKeydown && escapeKeydown.destroy) {
          return escapeKeydown.destroy;
        }
        return noop2;
      }), effect([isVisible], ([$isVisible]) => {
        tick().then(() => {
          if (!$isVisible) {
            deactivate();
          } else {
            activate();
          }
        });
      }));
      return {
        destroy: () => {
          unsubScroll();
          destroy();
        }
      };
    }
  });
  const portalled = makeElement(name3("portalled"), {
    stores: portal,
    returned: ($portal) => ({
      "data-portal": portalAttr($portal)
    }),
    action: (node) => {
      const unsubPortal = effect([portal], ([$portal]) => {
        if ($portal === null)
          return noop2;
        const portalDestination = getPortalDestination(node, $portal);
        if (portalDestination === null)
          return noop2;
        const portalAction = usePortal(node, portalDestination);
        if (portalAction && portalAction.destroy) {
          return portalAction.destroy;
        } else {
          return noop2;
        }
      });
      return {
        destroy() {
          unsubPortal();
        }
      };
    }
  });
  const title = makeElement(name3("title"), {
    stores: [ids.title],
    returned: ([$titleId]) => ({
      id: $titleId
    })
  });
  const description = makeElement(name3("description"), {
    stores: [ids.description],
    returned: ([$descriptionId]) => ({
      id: $descriptionId
    })
  });
  const close = makeElement(name3("close"), {
    returned: () => ({
      type: "button"
    }),
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "click", () => {
        handleClose();
      }), addMeltEventListener(node, "keydown", (e3) => {
        if (e3.key !== kbd.SPACE && e3.key !== kbd.ENTER)
          return;
        e3.preventDefault();
        handleClose();
      }));
      return {
        destroy: unsub
      };
    }
  });
  effect([open, preventScroll], ([$open, $preventScroll]) => {
    if (!isBrowser2)
      return;
    if ($preventScroll && $open)
      unsubScroll = removeScroll();
    if ($open) {
      const contentEl = document.getElementById(ids.content.get());
      handleFocus({ prop: openFocus.get(), defaultEl: contentEl });
    }
    return () => {
      if (!forceVisible.get()) {
        unsubScroll();
      }
    };
  });
  return {
    ids,
    elements: {
      content,
      trigger,
      title,
      description,
      overlay,
      close,
      portalled
    },
    states: {
      open
    },
    options: options2
  };
}
function createSelect(props) {
  const listbox = createListbox({ ...props, builder: "select" });
  const selectedLabel = derived(listbox.states.selected, ($selected) => {
    if (Array.isArray($selected)) {
      return $selected.map((o2) => o2.label).join(", ");
    }
    return $selected?.label ?? "";
  });
  return {
    ...listbox,
    elements: {
      ...listbox.elements
    },
    states: {
      ...listbox.states,
      selectedLabel
    }
  };
}
function removeUndefined2(obj) {
  const result = {};
  for (const key2 in obj) {
    const value = obj[key2];
    if (value !== void 0) {
      result[key2] = value;
    }
  }
  return result;
}
function getOptionUpdater(options2) {
  return function(key2, value) {
    if (value === void 0)
      return;
    const store = options2[key2];
    if (store) {
      store.set(value);
    }
  };
}
function getPositioningUpdater(store) {
  return (props = {}) => {
    return updatePositioning$1(store, props);
  };
}
function updatePositioning$1(store, props) {
  const defaultPositioningProps = {
    side: "bottom",
    align: "center",
    sideOffset: 0,
    alignOffset: 0,
    sameWidth: false,
    avoidCollisions: true,
    collisionPadding: 8,
    fitViewport: false,
    strategy: "absolute",
    overlap: false
  };
  const withDefaults = { ...defaultPositioningProps, ...props };
  store.update((prev2) => {
    return {
      ...prev2,
      placement: joinPlacement(withDefaults.side, withDefaults.align),
      offset: {
        ...prev2.offset,
        mainAxis: withDefaults.sideOffset,
        crossAxis: withDefaults.alignOffset
      },
      gutter: 0,
      sameWidth: withDefaults.sameWidth,
      flip: withDefaults.avoidCollisions,
      overflowPadding: withDefaults.collisionPadding,
      boundary: withDefaults.collisionBoundary,
      fitViewport: withDefaults.fitViewport,
      strategy: withDefaults.strategy,
      overlap: withDefaults.overlap
    };
  });
}
function joinPlacement(side, align) {
  if (align === "center")
    return side;
  return `${side}-${align}`;
}
function getDialogData() {
  const NAME2 = "dialog";
  const PARTS2 = [
    "close",
    "content",
    "description",
    "overlay",
    "portal",
    "title",
    "trigger"
  ];
  return {
    NAME: NAME2,
    PARTS: PARTS2
  };
}
function setCtx$1(props) {
  const { NAME: NAME2, PARTS: PARTS2 } = getDialogData();
  const getAttrs2 = createBitAttrs(NAME2, PARTS2);
  const dialog = {
    ...createDialog({ ...removeUndefined2(props), role: "dialog", forceVisible: true }),
    getAttrs: getAttrs2
  };
  setContext(NAME2, dialog);
  return {
    ...dialog,
    updateOption: getOptionUpdater(dialog.options)
  };
}
function getCtx$1() {
  const { NAME: NAME2 } = getDialogData();
  return getContext(NAME2);
}
function getSelectData() {
  const NAME2 = "select";
  const GROUP_NAME2 = "select-group";
  const ITEM_NAME = "select-item";
  const PARTS2 = [
    "arrow",
    "content",
    "group",
    "item",
    "indicator",
    "input",
    "label",
    "trigger",
    "value"
  ];
  return {
    NAME: NAME2,
    GROUP_NAME: GROUP_NAME2,
    ITEM_NAME,
    PARTS: PARTS2
  };
}
function getCtx() {
  const { NAME: NAME2 } = getSelectData();
  return getContext(NAME2);
}
function setCtx(props) {
  const { NAME: NAME2, PARTS: PARTS2 } = getSelectData();
  const getAttrs2 = createBitAttrs(NAME2, PARTS2);
  const select = {
    ...createSelect({ ...removeUndefined2(props), forceVisible: true }),
    getAttrs: getAttrs2
  };
  setContext(NAME2, select);
  return {
    ...select,
    updateOption: getOptionUpdater(select.options)
  };
}
function setItemCtx(value) {
  const { ITEM_NAME } = getSelectData();
  const select = getCtx();
  setContext(ITEM_NAME, value);
  return select;
}
function getItemIndicator() {
  const { ITEM_NAME } = getSelectData();
  const { helpers: { isSelected }, getAttrs: getAttrs2 } = getCtx();
  const value = getContext(ITEM_NAME);
  return {
    value,
    isSelected,
    getAttrs: getAttrs2
  };
}
function updatePositioning(props) {
  const defaultPlacement = {
    side: "bottom",
    align: "center",
    sameWidth: true
  };
  const withDefaults = { ...defaultPlacement, ...props };
  const { options: { positioning } } = getCtx();
  const updater = getPositioningUpdater(positioning);
  updater(withDefaults);
}
function fade(node, { delay: delay3 = 0, duration = 400, easing = identity } = {}) {
  const o2 = +getComputedStyle(node).opacity;
  return {
    delay: delay3,
    duration,
    easing,
    css: (t2) => `opacity: ${t2 * o2}`
  };
}
function scale(node, { delay: delay3 = 0, duration = 400, easing = cubicOut, start = 0, opacity = 0 } = {}) {
  const style = getComputedStyle(node);
  const target_opacity = +style.opacity;
  const transform = style.transform === "none" ? "" : style.transform;
  const sd2 = 1 - start;
  const od2 = target_opacity * (1 - opacity);
  return {
    delay: delay3,
    duration,
    easing,
    css: (_t, u2) => `
			transform: ${transform} scale(${1 - sd2 * u2});
			opacity: ${target_opacity - od2 * u2}
		`
  };
}
var CaretSort;
var CaretSort$1;
var Check;
var Check$1;
var Plus;
var overridable;
var isDom;
var pt;
var isTouchDevice;
var isMac;
var isApple;
var isIos;
var LOCK_CLASSNAME;
var ignoredKeys;
var defaults$3;
var defaultConfig$1;
var ARROW_TRANSFORM;
var visibleModals;
var defaultConfig;
var usePopper;
var usePortal;
var INTERACTION_KEYS;
var defaults$2;
var listboxIdParts;
var name3;
var defaults$1;
var dialogIdParts;
var defaults2;
var createSeparator;
var Dialog;
var Dialog_portal$1;
var Dialog_content$1;
var Dialog_trigger;
var Select;
var Select_content$1;
var Select_item$1;
var Select_item_indicator;
var Select_trigger$1;
var Select_value;
var Dialog_portal;
var Dialog_content;
var Root$1;
var Trigger;
var Select_item;
var Select_content;
var Select_trigger;
var Root2;
var Value;
var init_index5 = __esm({
  ".svelte-kit/output/server/chunks/index5.js"() {
    init_lifecycle();
    init_ssr();
    init_dist();
    init_index3();
    init_index2();
    init_scheduler();
    init_input();
    init_clsx();
    init_non_secure();
    init_floating_ui_dom();
    init_focus_trap_esm();
    CaretSort = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["color", "size"]);
      let { color = "currentColor" } = $$props;
      let { size: size22 = 15 } = $$props;
      if ($$props.color === void 0 && $$bindings.color && color !== void 0)
        $$bindings.color(color);
      if ($$props.size === void 0 && $$bindings.size && size22 !== void 0)
        $$bindings.size(size22);
      return `<svg${spread(
        [
          { width: escape_attribute_value(size22) },
          { height: escape_attribute_value(size22) },
          { viewBox: "0 0 15 15" },
          { fill: "none" },
          { xmlns: "http://www.w3.org/2000/svg" },
          escape_object($$restProps)
        ],
        {}
      )}><path fill-rule="evenodd" clip-rule="evenodd" d="M4.93179 5.43179C4.75605 5.60753 4.75605 5.89245 4.93179 6.06819C5.10753 6.24392 5.39245 6.24392 5.56819 6.06819L7.49999 4.13638L9.43179 6.06819C9.60753 6.24392 9.89245 6.24392 10.0682 6.06819C10.2439 5.89245 10.2439 5.60753 10.0682 5.43179L7.81819 3.18179C7.73379 3.0974 7.61933 3.04999 7.49999 3.04999C7.38064 3.04999 7.26618 3.0974 7.18179 3.18179L4.93179 5.43179ZM10.0682 9.56819C10.2439 9.39245 10.2439 9.10753 10.0682 8.93179C9.89245 8.75606 9.60753 8.75606 9.43179 8.93179L7.49999 10.8636L5.56819 8.93179C5.39245 8.75606 5.10753 8.75606 4.93179 8.93179C4.75605 9.10753 4.75605 9.39245 4.93179 9.56819L7.18179 11.8182C7.35753 11.9939 7.64245 11.9939 7.81819 11.8182L10.0682 9.56819Z"${add_attribute("fill", color, 0)}></path></svg>`;
    });
    CaretSort$1 = CaretSort;
    Check = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["color", "size"]);
      let { color = "currentColor" } = $$props;
      let { size: size22 = 15 } = $$props;
      if ($$props.color === void 0 && $$bindings.color && color !== void 0)
        $$bindings.color(color);
      if ($$props.size === void 0 && $$bindings.size && size22 !== void 0)
        $$bindings.size(size22);
      return `<svg${spread(
        [
          { width: escape_attribute_value(size22) },
          { height: escape_attribute_value(size22) },
          { viewBox: "0 0 15 15" },
          { fill: "none" },
          { xmlns: "http://www.w3.org/2000/svg" },
          escape_object($$restProps)
        ],
        {}
      )}><path fill-rule="evenodd" clip-rule="evenodd" d="M11.4669 3.72684C11.7558 3.91574 11.8369 4.30308 11.648 4.59198L7.39799 11.092C7.29783 11.2452 7.13556 11.3467 6.95402 11.3699C6.77247 11.3931 6.58989 11.3355 6.45446 11.2124L3.70446 8.71241C3.44905 8.48022 3.43023 8.08494 3.66242 7.82953C3.89461 7.57412 4.28989 7.55529 4.5453 7.78749L6.75292 9.79441L10.6018 3.90792C10.7907 3.61902 11.178 3.53795 11.4669 3.72684Z"${add_attribute("fill", color, 0)}></path></svg>`;
    });
    Check$1 = Check;
    Plus = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, []);
      return `<svg${add_attribute("class", $$restProps.class, 0)} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h14"></path><path d="M12 5v14"></path></svg>`;
    });
    overridable = (_store, onChange) => {
      const store = withGet(_store);
      const update2 = (updater, sideEffect) => {
        store.update((curr) => {
          const next2 = updater(curr);
          let res = next2;
          if (onChange) {
            res = onChange({ curr, next: next2 });
          }
          sideEffect?.(res);
          return res;
        });
      };
      const set = (curr) => {
        update2(() => curr);
      };
      return {
        ...store,
        update: update2,
        set
      };
    };
    isDom = () => typeof window !== "undefined";
    pt = (v3) => isDom() && v3.test(getPlatform().toLowerCase());
    isTouchDevice = () => isDom() && !!navigator.maxTouchPoints;
    isMac = () => pt(/^mac/) && !isTouchDevice();
    isApple = () => pt(/mac|iphone|ipad|ipod/i);
    isIos = () => isApple() && !isMac();
    LOCK_CLASSNAME = "data-melt-scroll-lock";
    ignoredKeys = /* @__PURE__ */ new Set(["Shift", "Control", "Alt", "Meta", "CapsLock", "NumLock"]);
    defaults$3 = {
      onMatch: handleRovingFocus,
      getCurrentItem: () => document.activeElement
    };
    defaultConfig$1 = {
      strategy: "absolute",
      placement: "top",
      gutter: 5,
      flip: true,
      sameWidth: false,
      overflowPadding: 8
    };
    ARROW_TRANSFORM = {
      bottom: "rotate(45deg)",
      left: "rotate(135deg)",
      top: "rotate(225deg)",
      right: "rotate(315deg)"
    };
    visibleModals = [];
    defaultConfig = {
      floating: {},
      focusTrap: {},
      modal: {},
      escapeKeydown: {},
      portal: "body"
    };
    usePopper = (popperElement, args) => {
      popperElement.dataset.escapee = "";
      const { anchorElement, open, options: options2 } = args;
      if (!anchorElement || !open || !options2) {
        return { destroy: noop2 };
      }
      const opts = { ...defaultConfig, ...options2 };
      const callbacks = [];
      if (opts.portal !== null) {
        const portal = usePortal(popperElement, opts.portal);
        if (portal?.destroy) {
          callbacks.push(portal.destroy);
        }
      }
      callbacks.push(useFloating(anchorElement, popperElement, opts.floating).destroy);
      if (opts.focusTrap !== null) {
        const { useFocusTrap } = createFocusTrap3({
          immediate: true,
          escapeDeactivates: false,
          allowOutsideClick: true,
          returnFocusOnDeactivate: false,
          fallbackFocus: popperElement,
          ...opts.focusTrap
        });
        const usedFocusTrap = useFocusTrap(popperElement);
        if (usedFocusTrap?.destroy) {
          callbacks.push(usedFocusTrap.destroy);
        }
      }
      if (opts.modal !== null) {
        callbacks.push(useModal(popperElement, {
          onClose: () => {
            if (isHTMLElement(anchorElement)) {
              open.set(false);
              anchorElement.focus();
            }
          },
          shouldCloseOnInteractOutside: (e3) => {
            if (e3.defaultPrevented)
              return false;
            if (isHTMLElement(anchorElement) && anchorElement.contains(e3.target)) {
              return false;
            }
            return true;
          },
          ...opts.modal
        }).destroy);
      }
      if (opts.escapeKeydown !== null) {
        callbacks.push(useEscapeKeydown(popperElement, {
          enabled: open,
          handler: () => {
            open.set(false);
          },
          ...opts.escapeKeydown
        }).destroy);
      }
      const unsubscribe = executeCallbacks(...callbacks);
      return {
        destroy() {
          unsubscribe();
        }
      };
    };
    usePortal = (el, target = "body") => {
      let targetEl;
      if (!isHTMLElement(target) && typeof target !== "string") {
        return {
          destroy: noop2
        };
      }
      async function update2(newTarget) {
        target = newTarget;
        if (typeof target === "string") {
          targetEl = document.querySelector(target);
          if (targetEl === null) {
            await tick();
            targetEl = document.querySelector(target);
          }
          if (targetEl === null) {
            throw new Error(`No element found matching css selector: "${target}"`);
          }
        } else if (target instanceof HTMLElement) {
          targetEl = target;
        } else {
          throw new TypeError(`Unknown portal target type: ${target === null ? "null" : typeof target}. Allowed types: string (CSS selector) or HTMLElement.`);
        }
        el.dataset.portal = "";
        targetEl.appendChild(el);
        el.hidden = false;
      }
      function destroy() {
        el.remove();
      }
      update2(target);
      return {
        update: update2,
        destroy
      };
    };
    INTERACTION_KEYS = [kbd.ARROW_LEFT, kbd.ESCAPE, kbd.ARROW_RIGHT, kbd.SHIFT, kbd.CAPS_LOCK, kbd.CONTROL, kbd.ALT, kbd.META, kbd.ENTER, kbd.F1, kbd.F2, kbd.F3, kbd.F4, kbd.F5, kbd.F6, kbd.F7, kbd.F8, kbd.F9, kbd.F10, kbd.F11, kbd.F12];
    defaults$2 = {
      positioning: {
        placement: "bottom",
        sameWidth: true
      },
      scrollAlignment: "nearest",
      loop: true,
      defaultOpen: false,
      closeOnOutsideClick: true,
      preventScroll: true,
      closeOnEscape: true,
      forceVisible: false,
      portal: void 0,
      builder: "listbox",
      disabled: false,
      required: false,
      name: void 0,
      typeahead: true,
      highlightOnHover: true,
      onOutsideClick: void 0
    };
    listboxIdParts = ["trigger", "menu", "label"];
    ({ name: name3 } = createElHelpers("dialog"));
    defaults$1 = {
      preventScroll: true,
      closeOnEscape: true,
      closeOnOutsideClick: true,
      role: "dialog",
      defaultOpen: false,
      portal: void 0,
      forceVisible: false,
      openFocus: void 0,
      closeFocus: void 0,
      onOutsideClick: void 0
    };
    dialogIdParts = ["content", "title", "description"];
    defaults2 = {
      orientation: "horizontal",
      decorative: false
    };
    createSeparator = (props) => {
      const withDefaults = { ...defaults2, ...props };
      const options2 = toWritableStores(withDefaults);
      const { orientation, decorative } = options2;
      const root = makeElement("separator", {
        stores: [orientation, decorative],
        returned: ([$orientation, $decorative]) => {
          const ariaOrientation = $orientation === "vertical" ? $orientation : void 0;
          return {
            role: $decorative ? "none" : "separator",
            "aria-orientation": ariaOrientation,
            "aria-hidden": $decorative,
            "data-orientation": $orientation
          };
        }
      });
      return {
        elements: {
          root
        },
        options: options2
      };
    };
    Dialog = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $idValues, $$unsubscribe_idValues;
      let { preventScroll = void 0 } = $$props;
      let { closeOnEscape = void 0 } = $$props;
      let { closeOnOutsideClick = void 0 } = $$props;
      let { portal = void 0 } = $$props;
      let { open = void 0 } = $$props;
      let { onOpenChange = void 0 } = $$props;
      let { openFocus = void 0 } = $$props;
      let { closeFocus = void 0 } = $$props;
      let { onOutsideClick = void 0 } = $$props;
      const { states: { open: localOpen }, updateOption, ids } = setCtx$1({
        closeOnEscape,
        preventScroll,
        closeOnOutsideClick,
        portal,
        forceVisible: true,
        defaultOpen: open,
        openFocus,
        closeFocus,
        onOutsideClick,
        onOpenChange: ({ next: next2 }) => {
          if (open !== next2) {
            onOpenChange?.(next2);
            open = next2;
          }
          return next2;
        }
      });
      const idValues = derived([ids.content, ids.description, ids.title], ([$contentId, $descriptionId, $titleId]) => ({
        content: $contentId,
        description: $descriptionId,
        title: $titleId
      }));
      $$unsubscribe_idValues = subscribe(idValues, (value) => $idValues = value);
      if ($$props.preventScroll === void 0 && $$bindings.preventScroll && preventScroll !== void 0)
        $$bindings.preventScroll(preventScroll);
      if ($$props.closeOnEscape === void 0 && $$bindings.closeOnEscape && closeOnEscape !== void 0)
        $$bindings.closeOnEscape(closeOnEscape);
      if ($$props.closeOnOutsideClick === void 0 && $$bindings.closeOnOutsideClick && closeOnOutsideClick !== void 0)
        $$bindings.closeOnOutsideClick(closeOnOutsideClick);
      if ($$props.portal === void 0 && $$bindings.portal && portal !== void 0)
        $$bindings.portal(portal);
      if ($$props.open === void 0 && $$bindings.open && open !== void 0)
        $$bindings.open(open);
      if ($$props.onOpenChange === void 0 && $$bindings.onOpenChange && onOpenChange !== void 0)
        $$bindings.onOpenChange(onOpenChange);
      if ($$props.openFocus === void 0 && $$bindings.openFocus && openFocus !== void 0)
        $$bindings.openFocus(openFocus);
      if ($$props.closeFocus === void 0 && $$bindings.closeFocus && closeFocus !== void 0)
        $$bindings.closeFocus(closeFocus);
      if ($$props.onOutsideClick === void 0 && $$bindings.onOutsideClick && onOutsideClick !== void 0)
        $$bindings.onOutsideClick(onOutsideClick);
      open !== void 0 && localOpen.set(open);
      {
        updateOption("preventScroll", preventScroll);
      }
      {
        updateOption("closeOnEscape", closeOnEscape);
      }
      {
        updateOption("closeOnOutsideClick", closeOnOutsideClick);
      }
      {
        updateOption("portal", portal);
      }
      {
        updateOption("openFocus", openFocus);
      }
      {
        updateOption("closeFocus", closeFocus);
      }
      {
        updateOption("onOutsideClick", onOutsideClick);
      }
      $$unsubscribe_idValues();
      return `${slots.default ? slots.default({ ids: $idValues }) : ``}`;
    });
    Dialog_portal$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let builder;
      let $$restProps = compute_rest_props($$props, ["asChild", "el"]);
      let $portalled, $$unsubscribe_portalled;
      let { asChild = false } = $$props;
      let { el = void 0 } = $$props;
      const { elements: { portalled }, getAttrs: getAttrs2 } = getCtx$1();
      $$unsubscribe_portalled = subscribe(portalled, (value) => $portalled = value);
      const attrs = getAttrs2("portal");
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      if ($$props.el === void 0 && $$bindings.el && el !== void 0)
        $$bindings.el(el);
      builder = $portalled;
      {
        Object.assign(builder, attrs);
      }
      $$unsubscribe_portalled();
      return `${asChild ? `${slots.default ? slots.default({ builder }) : ``}` : `<div${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}>${slots.default ? slots.default({ builder }) : ``}</div>`}`;
    });
    Dialog_content$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let builder;
      let $$restProps = compute_rest_props($$props, [
        "transition",
        "transitionConfig",
        "inTransition",
        "inTransitionConfig",
        "outTransition",
        "outTransitionConfig",
        "asChild",
        "id",
        "el"
      ]);
      let $content, $$unsubscribe_content;
      let $open, $$unsubscribe_open;
      let { transition = void 0 } = $$props;
      let { transitionConfig = void 0 } = $$props;
      let { inTransition = void 0 } = $$props;
      let { inTransitionConfig = void 0 } = $$props;
      let { outTransition = void 0 } = $$props;
      let { outTransitionConfig = void 0 } = $$props;
      let { asChild = false } = $$props;
      let { id: id2 = void 0 } = $$props;
      let { el = void 0 } = $$props;
      const { elements: { content }, states: { open }, ids, getAttrs: getAttrs2 } = getCtx$1();
      $$unsubscribe_content = subscribe(content, (value) => $content = value);
      $$unsubscribe_open = subscribe(open, (value) => $open = value);
      const attrs = getAttrs2("content");
      if ($$props.transition === void 0 && $$bindings.transition && transition !== void 0)
        $$bindings.transition(transition);
      if ($$props.transitionConfig === void 0 && $$bindings.transitionConfig && transitionConfig !== void 0)
        $$bindings.transitionConfig(transitionConfig);
      if ($$props.inTransition === void 0 && $$bindings.inTransition && inTransition !== void 0)
        $$bindings.inTransition(inTransition);
      if ($$props.inTransitionConfig === void 0 && $$bindings.inTransitionConfig && inTransitionConfig !== void 0)
        $$bindings.inTransitionConfig(inTransitionConfig);
      if ($$props.outTransition === void 0 && $$bindings.outTransition && outTransition !== void 0)
        $$bindings.outTransition(outTransition);
      if ($$props.outTransitionConfig === void 0 && $$bindings.outTransitionConfig && outTransitionConfig !== void 0)
        $$bindings.outTransitionConfig(outTransitionConfig);
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      if ($$props.id === void 0 && $$bindings.id && id2 !== void 0)
        $$bindings.id(id2);
      if ($$props.el === void 0 && $$bindings.el && el !== void 0)
        $$bindings.el(el);
      {
        if (id2) {
          ids.content.set(id2);
        }
      }
      builder = $content;
      {
        Object.assign(builder, attrs);
      }
      $$unsubscribe_content();
      $$unsubscribe_open();
      return `${asChild && $open ? `${slots.default ? slots.default({ builder }) : ``}` : `${transition && $open ? `<div${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}>${slots.default ? slots.default({ builder }) : ``}</div>` : `${inTransition && outTransition && $open ? `<div${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}>${slots.default ? slots.default({ builder }) : ``}</div>` : `${inTransition && $open ? `<div${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}>${slots.default ? slots.default({ builder }) : ``}</div>` : `${outTransition && $open ? `<div${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}>${slots.default ? slots.default({ builder }) : ``}</div>` : `${$open ? `<div${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}>${slots.default ? slots.default({ builder }) : ``}</div>` : ``}`}`}`}`}`}`;
    });
    Dialog_trigger = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let builder;
      let $$restProps = compute_rest_props($$props, ["asChild", "el"]);
      let $trigger, $$unsubscribe_trigger;
      let { asChild = false } = $$props;
      let { el = void 0 } = $$props;
      const { elements: { trigger }, getAttrs: getAttrs2 } = getCtx$1();
      $$unsubscribe_trigger = subscribe(trigger, (value) => $trigger = value);
      createDispatcher();
      const attrs = getAttrs2("trigger");
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      if ($$props.el === void 0 && $$bindings.el && el !== void 0)
        $$bindings.el(el);
      builder = $trigger;
      {
        Object.assign(builder, attrs);
      }
      $$unsubscribe_trigger();
      return `${asChild ? `${slots.default ? slots.default({ builder }) : ``}` : `<button${spread([escape_object(builder), { type: "button" }, escape_object($$restProps)], {})}${add_attribute("this", el, 0)}>${slots.default ? slots.default({ builder }) : ``}</button>`}`;
    });
    Select = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $idValues, $$unsubscribe_idValues;
      let { required = void 0 } = $$props;
      let { disabled = void 0 } = $$props;
      let { preventScroll = void 0 } = $$props;
      let { loop = void 0 } = $$props;
      let { closeOnEscape = void 0 } = $$props;
      let { closeOnOutsideClick = void 0 } = $$props;
      let { portal = void 0 } = $$props;
      let { name: name22 = void 0 } = $$props;
      let { multiple = false } = $$props;
      let { selected = void 0 } = $$props;
      let { onSelectedChange = void 0 } = $$props;
      let { open = void 0 } = $$props;
      let { onOpenChange = void 0 } = $$props;
      let { items = [] } = $$props;
      let { onOutsideClick = void 0 } = $$props;
      const { states: { open: localOpen, selected: localSelected }, updateOption, ids } = setCtx({
        required,
        disabled,
        preventScroll,
        loop,
        closeOnEscape,
        closeOnOutsideClick,
        portal,
        name: name22,
        onOutsideClick,
        multiple,
        forceVisible: true,
        defaultSelected: Array.isArray(selected) ? [...selected] : (
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          selected
        ),
        defaultOpen: open,
        onSelectedChange: ({ next: next2 }) => {
          if (Array.isArray(next2)) {
            if (!Array.isArray(selected) || !arraysAreEqual(selected, next2)) {
              onSelectedChange?.(next2);
              selected = next2;
              return next2;
            }
            return next2;
          }
          if (selected !== next2) {
            onSelectedChange?.(next2);
            selected = next2;
          }
          return next2;
        },
        onOpenChange: ({ next: next2 }) => {
          if (open !== next2) {
            onOpenChange?.(next2);
            open = next2;
          }
          return next2;
        },
        items
      });
      const idValues = derived([ids.menu, ids.trigger, ids.label], ([$menuId, $triggerId, $labelId]) => ({
        menu: $menuId,
        trigger: $triggerId,
        label: $labelId
      }));
      $$unsubscribe_idValues = subscribe(idValues, (value) => $idValues = value);
      if ($$props.required === void 0 && $$bindings.required && required !== void 0)
        $$bindings.required(required);
      if ($$props.disabled === void 0 && $$bindings.disabled && disabled !== void 0)
        $$bindings.disabled(disabled);
      if ($$props.preventScroll === void 0 && $$bindings.preventScroll && preventScroll !== void 0)
        $$bindings.preventScroll(preventScroll);
      if ($$props.loop === void 0 && $$bindings.loop && loop !== void 0)
        $$bindings.loop(loop);
      if ($$props.closeOnEscape === void 0 && $$bindings.closeOnEscape && closeOnEscape !== void 0)
        $$bindings.closeOnEscape(closeOnEscape);
      if ($$props.closeOnOutsideClick === void 0 && $$bindings.closeOnOutsideClick && closeOnOutsideClick !== void 0)
        $$bindings.closeOnOutsideClick(closeOnOutsideClick);
      if ($$props.portal === void 0 && $$bindings.portal && portal !== void 0)
        $$bindings.portal(portal);
      if ($$props.name === void 0 && $$bindings.name && name22 !== void 0)
        $$bindings.name(name22);
      if ($$props.multiple === void 0 && $$bindings.multiple && multiple !== void 0)
        $$bindings.multiple(multiple);
      if ($$props.selected === void 0 && $$bindings.selected && selected !== void 0)
        $$bindings.selected(selected);
      if ($$props.onSelectedChange === void 0 && $$bindings.onSelectedChange && onSelectedChange !== void 0)
        $$bindings.onSelectedChange(onSelectedChange);
      if ($$props.open === void 0 && $$bindings.open && open !== void 0)
        $$bindings.open(open);
      if ($$props.onOpenChange === void 0 && $$bindings.onOpenChange && onOpenChange !== void 0)
        $$bindings.onOpenChange(onOpenChange);
      if ($$props.items === void 0 && $$bindings.items && items !== void 0)
        $$bindings.items(items);
      if ($$props.onOutsideClick === void 0 && $$bindings.onOutsideClick && onOutsideClick !== void 0)
        $$bindings.onOutsideClick(onOutsideClick);
      open !== void 0 && localOpen.set(open);
      selected !== void 0 && localSelected.set(Array.isArray(selected) ? [...selected] : (
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        selected
      ));
      {
        updateOption("required", required);
      }
      {
        updateOption("disabled", disabled);
      }
      {
        updateOption("preventScroll", preventScroll);
      }
      {
        updateOption("loop", loop);
      }
      {
        updateOption("closeOnEscape", closeOnEscape);
      }
      {
        updateOption("closeOnOutsideClick", closeOnOutsideClick);
      }
      {
        updateOption("portal", portal);
      }
      {
        updateOption("name", name22);
      }
      {
        updateOption("multiple", multiple);
      }
      {
        updateOption("onOutsideClick", onOutsideClick);
      }
      $$unsubscribe_idValues();
      return `${slots.default ? slots.default({ ids: $idValues }) : ``}`;
    });
    Select_content$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let builder;
      let $$restProps = compute_rest_props($$props, [
        "transition",
        "transitionConfig",
        "inTransition",
        "inTransitionConfig",
        "outTransition",
        "outTransitionConfig",
        "asChild",
        "id",
        "side",
        "align",
        "sideOffset",
        "alignOffset",
        "collisionPadding",
        "avoidCollisions",
        "collisionBoundary",
        "sameWidth",
        "fitViewport",
        "strategy",
        "overlap",
        "el"
      ]);
      let $open, $$unsubscribe_open;
      let $menu, $$unsubscribe_menu;
      let { transition = void 0 } = $$props;
      let { transitionConfig = void 0 } = $$props;
      let { inTransition = void 0 } = $$props;
      let { inTransitionConfig = void 0 } = $$props;
      let { outTransition = void 0 } = $$props;
      let { outTransitionConfig = void 0 } = $$props;
      let { asChild = false } = $$props;
      let { id: id2 = void 0 } = $$props;
      let { side = "bottom" } = $$props;
      let { align = "center" } = $$props;
      let { sideOffset = 0 } = $$props;
      let { alignOffset = 0 } = $$props;
      let { collisionPadding = 8 } = $$props;
      let { avoidCollisions = true } = $$props;
      let { collisionBoundary = void 0 } = $$props;
      let { sameWidth = true } = $$props;
      let { fitViewport = false } = $$props;
      let { strategy = "absolute" } = $$props;
      let { overlap = false } = $$props;
      let { el = void 0 } = $$props;
      const { elements: { menu }, states: { open }, ids, getAttrs: getAttrs2 } = getCtx();
      $$unsubscribe_menu = subscribe(menu, (value) => $menu = value);
      $$unsubscribe_open = subscribe(open, (value) => $open = value);
      createDispatcher();
      const attrs = getAttrs2("content");
      if ($$props.transition === void 0 && $$bindings.transition && transition !== void 0)
        $$bindings.transition(transition);
      if ($$props.transitionConfig === void 0 && $$bindings.transitionConfig && transitionConfig !== void 0)
        $$bindings.transitionConfig(transitionConfig);
      if ($$props.inTransition === void 0 && $$bindings.inTransition && inTransition !== void 0)
        $$bindings.inTransition(inTransition);
      if ($$props.inTransitionConfig === void 0 && $$bindings.inTransitionConfig && inTransitionConfig !== void 0)
        $$bindings.inTransitionConfig(inTransitionConfig);
      if ($$props.outTransition === void 0 && $$bindings.outTransition && outTransition !== void 0)
        $$bindings.outTransition(outTransition);
      if ($$props.outTransitionConfig === void 0 && $$bindings.outTransitionConfig && outTransitionConfig !== void 0)
        $$bindings.outTransitionConfig(outTransitionConfig);
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      if ($$props.id === void 0 && $$bindings.id && id2 !== void 0)
        $$bindings.id(id2);
      if ($$props.side === void 0 && $$bindings.side && side !== void 0)
        $$bindings.side(side);
      if ($$props.align === void 0 && $$bindings.align && align !== void 0)
        $$bindings.align(align);
      if ($$props.sideOffset === void 0 && $$bindings.sideOffset && sideOffset !== void 0)
        $$bindings.sideOffset(sideOffset);
      if ($$props.alignOffset === void 0 && $$bindings.alignOffset && alignOffset !== void 0)
        $$bindings.alignOffset(alignOffset);
      if ($$props.collisionPadding === void 0 && $$bindings.collisionPadding && collisionPadding !== void 0)
        $$bindings.collisionPadding(collisionPadding);
      if ($$props.avoidCollisions === void 0 && $$bindings.avoidCollisions && avoidCollisions !== void 0)
        $$bindings.avoidCollisions(avoidCollisions);
      if ($$props.collisionBoundary === void 0 && $$bindings.collisionBoundary && collisionBoundary !== void 0)
        $$bindings.collisionBoundary(collisionBoundary);
      if ($$props.sameWidth === void 0 && $$bindings.sameWidth && sameWidth !== void 0)
        $$bindings.sameWidth(sameWidth);
      if ($$props.fitViewport === void 0 && $$bindings.fitViewport && fitViewport !== void 0)
        $$bindings.fitViewport(fitViewport);
      if ($$props.strategy === void 0 && $$bindings.strategy && strategy !== void 0)
        $$bindings.strategy(strategy);
      if ($$props.overlap === void 0 && $$bindings.overlap && overlap !== void 0)
        $$bindings.overlap(overlap);
      if ($$props.el === void 0 && $$bindings.el && el !== void 0)
        $$bindings.el(el);
      {
        if (id2) {
          ids.menu.set(id2);
        }
      }
      builder = $menu;
      {
        Object.assign(builder, attrs);
      }
      {
        if ($open) {
          updatePositioning({
            side,
            align,
            sideOffset,
            alignOffset,
            collisionPadding,
            avoidCollisions,
            collisionBoundary,
            sameWidth,
            fitViewport,
            strategy,
            overlap
          });
        }
      }
      $$unsubscribe_open();
      $$unsubscribe_menu();
      return ` ${asChild && $open ? `${slots.default ? slots.default({ builder }) : ``}` : `${transition && $open ? `<div${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}>${slots.default ? slots.default({ builder }) : ``}</div>` : `${inTransition && outTransition && $open ? `<div${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}>${slots.default ? slots.default({ builder }) : ``}</div>` : `${inTransition && $open ? `<div${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}>${slots.default ? slots.default({ builder }) : ``}</div>` : `${outTransition && $open ? `<div${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}>${slots.default ? slots.default({ builder }) : ``}</div>` : `${$open ? `<div${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}>${slots.default ? slots.default({ builder }) : ``}</div>` : ``}`}`}`}`}`}`;
    });
    Select_item$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let builder;
      let isSelected;
      let $$restProps = compute_rest_props($$props, ["value", "disabled", "label", "asChild", "el"]);
      let $isSelectedStore, $$unsubscribe_isSelectedStore;
      let $item, $$unsubscribe_item;
      let { value } = $$props;
      let { disabled = void 0 } = $$props;
      let { label = void 0 } = $$props;
      let { asChild = false } = $$props;
      let { el = void 0 } = $$props;
      const { elements: { option: item }, helpers: { isSelected: isSelectedStore }, getAttrs: getAttrs2 } = setItemCtx(value);
      $$unsubscribe_item = subscribe(item, (value2) => $item = value2);
      $$unsubscribe_isSelectedStore = subscribe(isSelectedStore, (value2) => $isSelectedStore = value2);
      createDispatcher();
      const attrs = getAttrs2("item");
      if ($$props.value === void 0 && $$bindings.value && value !== void 0)
        $$bindings.value(value);
      if ($$props.disabled === void 0 && $$bindings.disabled && disabled !== void 0)
        $$bindings.disabled(disabled);
      if ($$props.label === void 0 && $$bindings.label && label !== void 0)
        $$bindings.label(label);
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      if ($$props.el === void 0 && $$bindings.el && el !== void 0)
        $$bindings.el(el);
      builder = $item({ value, disabled, label });
      {
        Object.assign(builder, attrs);
      }
      isSelected = $isSelectedStore(value);
      $$unsubscribe_isSelectedStore();
      $$unsubscribe_item();
      return ` ${asChild ? `${slots.default ? slots.default({ builder, isSelected }) : ``}` : `<div${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}>${slots.default ? slots.default({ builder, isSelected }) : ` ${escape(label ? label : value)} `}</div>`}`;
    });
    Select_item_indicator = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["asChild", "el"]);
      let $isSelected, $$unsubscribe_isSelected;
      let { asChild = false } = $$props;
      let { el = void 0 } = $$props;
      const { isSelected, value, getAttrs: getAttrs2 } = getItemIndicator();
      $$unsubscribe_isSelected = subscribe(isSelected, (value2) => $isSelected = value2);
      const attrs = getAttrs2("indicator");
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      if ($$props.el === void 0 && $$bindings.el && el !== void 0)
        $$bindings.el(el);
      $$unsubscribe_isSelected();
      return `${asChild ? `${slots.default ? slots.default({ attrs, isSelected: $isSelected(value) }) : ``}` : `<div${spread([escape_object($$restProps), escape_object(attrs)], {})}${add_attribute("this", el, 0)}>${$isSelected(value) ? `${slots.default ? slots.default({ attrs, isSelected: $isSelected(value) }) : ``}` : ``}</div>`}`;
    });
    Select_trigger$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let builder;
      let $$restProps = compute_rest_props($$props, ["asChild", "id", "el"]);
      let $trigger, $$unsubscribe_trigger;
      let { asChild = false } = $$props;
      let { id: id2 = void 0 } = $$props;
      let { el = void 0 } = $$props;
      const { elements: { trigger }, ids, getAttrs: getAttrs2 } = getCtx();
      $$unsubscribe_trigger = subscribe(trigger, (value) => $trigger = value);
      createDispatcher();
      const attrs = getAttrs2("trigger");
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      if ($$props.id === void 0 && $$bindings.id && id2 !== void 0)
        $$bindings.id(id2);
      if ($$props.el === void 0 && $$bindings.el && el !== void 0)
        $$bindings.el(el);
      {
        if (id2) {
          ids.trigger.set(id2);
        }
      }
      builder = $trigger;
      {
        Object.assign(builder, attrs);
      }
      $$unsubscribe_trigger();
      return `${asChild ? `${slots.default ? slots.default({ builder }) : ``}` : `<button${spread([escape_object(builder), { type: "button" }, escape_object($$restProps)], {})}${add_attribute("this", el, 0)}>${slots.default ? slots.default({ builder }) : ``}</button>`}`;
    });
    Select_value = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let label;
      let $$restProps = compute_rest_props($$props, ["placeholder", "asChild", "el"]);
      let $selectedLabel, $$unsubscribe_selectedLabel;
      let { placeholder = "" } = $$props;
      let { asChild = false } = $$props;
      let { el = void 0 } = $$props;
      const { states: { selectedLabel }, getAttrs: getAttrs2 } = getCtx();
      $$unsubscribe_selectedLabel = subscribe(selectedLabel, (value) => $selectedLabel = value);
      const attrs = getAttrs2("value");
      if ($$props.placeholder === void 0 && $$bindings.placeholder && placeholder !== void 0)
        $$bindings.placeholder(placeholder);
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      if ($$props.el === void 0 && $$bindings.el && el !== void 0)
        $$bindings.el(el);
      label = $selectedLabel;
      $$unsubscribe_selectedLabel();
      return `${asChild ? `${slots.default ? slots.default({ label, attrs }) : ``}` : `<span${spread(
        [
          escape_object($$restProps),
          escape_object(attrs),
          {
            "data-placeholder": escape_attribute_value(!label ? "" : void 0)
          }
        ],
        {}
      )}${add_attribute("this", el, 0)}>${escape(label ? label : placeholder)}</span>`}`;
    });
    Dialog_portal = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, []);
      return `${validate_component(Dialog_portal$1, "DialogPrimitive.Portal").$$render($$result, Object.assign({}, $$restProps), {}, {
        default: () => {
          return `${slots.default ? slots.default({}) : ``}`;
        }
      })}`;
    });
    Dialog_content = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class", "transition", "transitionConfig"]);
      let { class: className = void 0 } = $$props;
      let { transition = flyAndScale } = $$props;
      let { transitionConfig = { duration: 200 } } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.transition === void 0 && $$bindings.transition && transition !== void 0)
        $$bindings.transition(transition);
      if ($$props.transitionConfig === void 0 && $$bindings.transitionConfig && transitionConfig !== void 0)
        $$bindings.transitionConfig(transitionConfig);
      return `${validate_component(Dialog_portal, "Dialog.Portal").$$render($$result, {}, {}, {
        default: () => {
          return ` ${validate_component(Dialog_content$1, "DialogPrimitive.Content").$$render(
            $$result,
            Object.assign(
              {},
              { transition },
              { transitionConfig },
              {
                class: cn("fixed left-[50%] top-[50%] z-50 grid max-w-[90%] w-6xl translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg sm:rounded-lg md:w-full", className)
              },
              $$restProps
            ),
            {},
            {
              default: () => {
                return `${slots.default ? slots.default({}) : ``}      `;
              }
            }
          )}`;
        }
      })}`;
    });
    Root$1 = Dialog;
    Trigger = Dialog_trigger;
    Select_item = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class", "value", "label", "disabled"]);
      let { class: className = void 0 } = $$props;
      let { value } = $$props;
      let { label = void 0 } = $$props;
      let { disabled = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.value === void 0 && $$bindings.value && value !== void 0)
        $$bindings.value(value);
      if ($$props.label === void 0 && $$bindings.label && label !== void 0)
        $$bindings.label(label);
      if ($$props.disabled === void 0 && $$bindings.disabled && disabled !== void 0)
        $$bindings.disabled(disabled);
      return `${validate_component(Select_item$1, "SelectPrimitive.Item").$$render(
        $$result,
        Object.assign(
          {},
          { value },
          { disabled },
          { label },
          {
            class: cn("relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none data-[disabled]:pointer-events-none data-[highlighted]:bg-accent data-[highlighted]:text-accent-foreground data-[disabled]:opacity-50", className)
          },
          $$restProps
        ),
        {},
        {
          default: () => {
            return `<span class="absolute right-2 flex h-3.5 w-3.5 items-center justify-center">${validate_component(Select_item_indicator, "SelectPrimitive.ItemIndicator").$$render($$result, {}, {}, {
              default: () => {
                return `${validate_component(Check$1, "Check").$$render($$result, { class: "h-4 w-4" }, {}, {})}`;
              }
            })}</span> ${slots.default ? slots.default({}) : ` ${escape(label ? label : value)} `}`;
          }
        }
      )}`;
    });
    Select_content = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, [
        "class",
        "sideOffset",
        "inTransition",
        "inTransitionConfig",
        "outTransition",
        "outTransitionConfig"
      ]);
      let { class: className = void 0 } = $$props;
      let { sideOffset = 4 } = $$props;
      let { inTransition = flyAndScale } = $$props;
      let { inTransitionConfig = void 0 } = $$props;
      let { outTransition = scale } = $$props;
      let { outTransitionConfig = { start: 0.95, opacity: 0, duration: 50 } } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.sideOffset === void 0 && $$bindings.sideOffset && sideOffset !== void 0)
        $$bindings.sideOffset(sideOffset);
      if ($$props.inTransition === void 0 && $$bindings.inTransition && inTransition !== void 0)
        $$bindings.inTransition(inTransition);
      if ($$props.inTransitionConfig === void 0 && $$bindings.inTransitionConfig && inTransitionConfig !== void 0)
        $$bindings.inTransitionConfig(inTransitionConfig);
      if ($$props.outTransition === void 0 && $$bindings.outTransition && outTransition !== void 0)
        $$bindings.outTransition(outTransition);
      if ($$props.outTransitionConfig === void 0 && $$bindings.outTransitionConfig && outTransitionConfig !== void 0)
        $$bindings.outTransitionConfig(outTransitionConfig);
      return `${validate_component(Select_content$1, "SelectPrimitive.Content").$$render(
        $$result,
        Object.assign(
          {},
          { inTransition },
          { inTransitionConfig },
          { outTransition },
          { outTransitionConfig },
          { sideOffset },
          {
            class: cn("relative z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md focus:outline-none", className)
          },
          $$restProps
        ),
        {},
        {
          default: () => {
            return `<div class="w-full p-1">${slots.default ? slots.default({}) : ``}</div>`;
          }
        }
      )}`;
    });
    Select_trigger = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class"]);
      let { class: className = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      return `${validate_component(Select_trigger$1, "SelectPrimitive.Trigger").$$render(
        $$result,
        Object.assign(
          {},
          {
            class: cn("flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1", className)
          },
          $$restProps
        ),
        {},
        {
          default: () => {
            return `${slots.default ? slots.default({}) : ``} <div>${validate_component(CaretSort$1, "CaretSort").$$render($$result, { class: "h-4 w-4 opacity-50" }, {}, {})}</div>`;
          }
        }
      )}`;
    });
    Root2 = Select;
    Value = Select_value;
  }
});
var MagnifyingGlass;
var MagnifyingGlass$1;
var init_MagnifyingGlass = __esm({
  ".svelte-kit/output/server/chunks/MagnifyingGlass.js"() {
    init_lifecycle();
    init_ssr();
    MagnifyingGlass = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["color", "size"]);
      let { color = "currentColor" } = $$props;
      let { size: size3 = 15 } = $$props;
      if ($$props.color === void 0 && $$bindings.color && color !== void 0)
        $$bindings.color(color);
      if ($$props.size === void 0 && $$bindings.size && size3 !== void 0)
        $$bindings.size(size3);
      return `<svg${spread(
        [
          { width: escape_attribute_value(size3) },
          { height: escape_attribute_value(size3) },
          { viewBox: "0 0 15 15" },
          { fill: "none" },
          { xmlns: "http://www.w3.org/2000/svg" },
          escape_object($$restProps)
        ],
        {}
      )}><path fill-rule="evenodd" clip-rule="evenodd" d="M10 6.5C10 8.433 8.433 10 6.5 10C4.567 10 3 8.433 3 6.5C3 4.567 4.567 3 6.5 3C8.433 3 10 4.567 10 6.5ZM9.30884 10.0159C8.53901 10.6318 7.56251 11 6.5 11C4.01472 11 2 8.98528 2 6.5C2 4.01472 4.01472 2 6.5 2C8.98528 2 11 4.01472 11 6.5C11 7.56251 10.6318 8.53901 10.0159 9.30884L12.8536 12.1464C13.0488 12.3417 13.0488 12.6583 12.8536 12.8536C12.6583 13.0488 12.3417 13.0488 12.1464 12.8536L9.30884 10.0159Z"${add_attribute("fill", color, 0)}></path></svg>`;
    });
    MagnifyingGlass$1 = MagnifyingGlass;
  }
});
function commandScoreInner(string, abbreviation, lowerString, lowerAbbreviation, stringIndex, abbreviationIndex, memoizedResults) {
  if (abbreviationIndex === abbreviation.length) {
    if (stringIndex === string.length) {
      return SCORE_CONTINUE_MATCH;
    }
    return PENALTY_NOT_COMPLETE;
  }
  const memoizeKey = `${stringIndex},${abbreviationIndex}`;
  if (memoizedResults[memoizeKey] !== void 0) {
    return memoizedResults[memoizeKey];
  }
  const abbreviationChar = lowerAbbreviation.charAt(abbreviationIndex);
  let index15 = lowerString.indexOf(abbreviationChar, stringIndex);
  let highScore = 0;
  let score, transposedScore, wordBreaks, spaceBreaks;
  while (index15 >= 0) {
    score = commandScoreInner(string, abbreviation, lowerString, lowerAbbreviation, index15 + 1, abbreviationIndex + 1, memoizedResults);
    if (score > highScore) {
      if (index15 === stringIndex) {
        score *= SCORE_CONTINUE_MATCH;
      } else if (IS_GAP_REGEXP.test(string.charAt(index15 - 1))) {
        score *= SCORE_NON_SPACE_WORD_JUMP;
        wordBreaks = string.slice(stringIndex, index15 - 1).match(COUNT_GAPS_REGEXP);
        if (wordBreaks && stringIndex > 0) {
          score *= Math.pow(PENALTY_SKIPPED, wordBreaks.length);
        }
      } else if (IS_SPACE_REGEXP.test(string.charAt(index15 - 1))) {
        score *= SCORE_SPACE_WORD_JUMP;
        spaceBreaks = string.slice(stringIndex, index15 - 1).match(COUNT_SPACE_REGEXP);
        if (spaceBreaks && stringIndex > 0) {
          score *= Math.pow(PENALTY_SKIPPED, spaceBreaks.length);
        }
      } else {
        score *= SCORE_CHARACTER_JUMP;
        if (stringIndex > 0) {
          score *= Math.pow(PENALTY_SKIPPED, index15 - stringIndex);
        }
      }
      if (string.charAt(index15) !== abbreviation.charAt(abbreviationIndex)) {
        score *= PENALTY_CASE_MISMATCH;
      }
    }
    if (score < SCORE_TRANSPOSITION && lowerString.charAt(index15 - 1) === lowerAbbreviation.charAt(abbreviationIndex + 1) || lowerAbbreviation.charAt(abbreviationIndex + 1) === lowerAbbreviation.charAt(abbreviationIndex) && // allow duplicate letters. Ref #7428
    lowerString.charAt(index15 - 1) !== lowerAbbreviation.charAt(abbreviationIndex)) {
      transposedScore = commandScoreInner(string, abbreviation, lowerString, lowerAbbreviation, index15 + 1, abbreviationIndex + 2, memoizedResults);
      if (transposedScore * SCORE_TRANSPOSITION > score) {
        score = transposedScore * SCORE_TRANSPOSITION;
      }
    }
    if (score > highScore) {
      highScore = score;
    }
    index15 = lowerString.indexOf(abbreviationChar, index15 + 1);
  }
  memoizedResults[memoizeKey] = highScore;
  return highScore;
}
function formatInput(string) {
  return string.toLowerCase().replace(COUNT_SPACE_REGEXP, " ");
}
function commandScore(string, abbreviation) {
  return commandScoreInner(string, abbreviation, formatInput(string), formatInput(abbreviation), 0, 0, {});
}
function isHTMLElement3(element) {
  return element instanceof HTMLElement;
}
function isHTMLInputElement2(element) {
  return element instanceof HTMLInputElement;
}
function isUndefined(value) {
  return value === void 0;
}
function generateId2() {
  return nanoid(10);
}
function omit2(obj, ...keys) {
  const result = {};
  for (const key2 of Object.keys(obj)) {
    if (!keys.includes(key2)) {
      result[key2] = obj[key2];
    }
  }
  return result;
}
function removeUndefined3(obj) {
  const result = {};
  for (const key2 in obj) {
    const value = obj[key2];
    if (value !== void 0) {
      result[key2] = value;
    }
  }
  return result;
}
function toWritableStores2(properties) {
  const result = {};
  Object.keys(properties).forEach((key2) => {
    const propertyKey = key2;
    const value = properties[propertyKey];
    result[propertyKey] = writable(value);
  });
  return result;
}
function styleToString$2(style) {
  return Object.keys(style).reduce((str, key2) => {
    if (style[key2] === void 0)
      return str;
    return str + `${key2}:${style[key2]};`;
  }, "");
}
function addEventListener$1(target, event, handler, options2) {
  const events = Array.isArray(event) ? event : [event];
  events.forEach((_event) => target.addEventListener(_event, handler, options2));
  return () => {
    events.forEach((_event) => target.removeEventListener(_event, handler, options2));
  };
}
function executeCallbacks2(...callbacks) {
  return (...args) => {
    for (const callback of callbacks) {
      if (typeof callback === "function") {
        callback(...args);
      }
    }
  };
}
function getCtx2() {
  return getContext(NAME$m);
}
function getState() {
  return getContext(STATE_NAME);
}
function createGroup(alwaysRender) {
  const id2 = generateId2();
  setContext(GROUP_NAME, {
    id: id2,
    alwaysRender: isUndefined(alwaysRender) ? false : alwaysRender
  });
  return { id: id2 };
}
function getGroup() {
  const context = getContext(GROUP_NAME);
  if (!context)
    return void 0;
  return context;
}
function createState(initialValues) {
  const defaultState = {
    search: "",
    value: "",
    filtered: {
      count: 0,
      items: /* @__PURE__ */ new Map(),
      groups: /* @__PURE__ */ new Set()
    }
  };
  const state = writable(initialValues ? { ...defaultState, ...removeUndefined3(initialValues) } : defaultState);
  return state;
}
function createCommand(props) {
  const ids = {
    root: generateId2(),
    list: generateId2(),
    label: generateId2(),
    input: generateId2(),
    ...props.ids
  };
  const withDefaults = {
    ...defaults3,
    ...removeUndefined3(props)
  };
  const state = props.state ?? createState({
    value: withDefaults.value
  });
  const allItems = writable(/* @__PURE__ */ new Set());
  const allGroups = writable(/* @__PURE__ */ new Map());
  const allIds = writable(/* @__PURE__ */ new Map());
  const commandEl = writable(null);
  const options2 = toWritableStores2(omit2(withDefaults, "value", "ids"));
  const { shouldFilter, loop, filter, label } = options2;
  const context = {
    value: (id2, value) => {
      if (value !== get_store_value(allIds).get(id2)) {
        allIds.update(($allIds) => {
          $allIds.set(id2, value);
          return $allIds;
        });
        state.update(($state) => {
          $state.filtered.items.set(id2, score(value, $state.search));
          const sortedState = sort($state, get_store_value(shouldFilter));
          return sortedState;
        });
      }
    },
    // Track item lifecycle (add/remove)
    item: (id2, groupId) => {
      allItems.update(($allItems) => $allItems.add(id2));
      if (groupId) {
        allGroups.update(($allGroups) => {
          if (!$allGroups.has(groupId)) {
            $allGroups.set(groupId, /* @__PURE__ */ new Set([id2]));
          } else {
            $allGroups.get(groupId)?.add(id2);
          }
          return $allGroups;
        });
      }
      state.update(($state) => {
        const $shouldFilter = get_store_value(shouldFilter);
        const filteredState = filterItems($state, $shouldFilter);
        const sortedState = sort(filteredState, $shouldFilter);
        if (!sortedState.value) {
          const value = selectFirstItem();
          sortedState.value = value ?? "";
        }
        return sortedState;
      });
      return () => {
        allIds.update(($allIds) => {
          $allIds.delete(id2);
          return $allIds;
        });
        allItems.update(($allItems) => {
          $allItems.delete(id2);
          return $allItems;
        });
        state.update(($state) => {
          $state.filtered.items.delete(id2);
          const selectedItem = getSelectedItem();
          const filteredState = filterItems($state);
          if (selectedItem?.getAttribute("id") === id2) {
            filteredState.value = selectFirstItem() ?? "";
          }
          return $state;
        });
      };
    },
    group: (id2) => {
      allGroups.update(($allGroups) => {
        if (!$allGroups.has(id2)) {
          $allGroups.set(id2, /* @__PURE__ */ new Set());
        }
        return $allGroups;
      });
      return () => {
        allIds.update(($allIds) => {
          $allIds.delete(id2);
          return $allIds;
        });
        allGroups.update(($allGroups) => {
          $allGroups.delete(id2);
          return $allGroups;
        });
      };
    },
    filter: () => {
      return get_store_value(shouldFilter);
    },
    label: get_store_value(label) || props["aria-label"] || "",
    commandEl,
    ids,
    updateState
  };
  function updateState(key2, value, preventScroll) {
    const $shouldFilter = get_store_value(shouldFilter);
    state.update((curr) => {
      if (Object.is(curr[key2], value))
        return curr;
      curr[key2] = value;
      if (key2 === "search") {
        const filteredState = filterItems(curr, $shouldFilter);
        curr = filteredState;
        const sortedState = sort(curr, $shouldFilter);
        curr = sortedState;
        tick().then(() => state.update((curr2) => {
          curr2.value = selectFirstItem() ?? "";
          return curr2;
        }));
      } else if (key2 === "value") {
        props.onValueChange?.(curr.value);
        if (!preventScroll) {
          tick().then(() => scrollSelectedIntoView());
        }
      }
      return curr;
    });
  }
  function filterItems(state2, shouldFilterVal) {
    const $shouldFilter = shouldFilterVal ?? get_store_value(shouldFilter);
    const $allItems = get_store_value(allItems);
    const $allIds = get_store_value(allIds);
    if (!state2.search || !$shouldFilter) {
      state2.filtered.count = $allItems.size;
      return state2;
    }
    state2.filtered.groups = /* @__PURE__ */ new Set();
    let itemCount = 0;
    for (const id2 of $allItems) {
      const value = $allIds.get(id2);
      const rank = score(value, state2.search);
      state2.filtered.items.set(id2, rank);
      if (rank > 0) {
        itemCount++;
      }
    }
    for (const [groupId, group] of get_store_value(allGroups)) {
      for (const itemId of group) {
        const rank = state2.filtered.items.get(itemId);
        if (rank && rank > 0) {
          state2.filtered.groups.add(groupId);
        }
      }
    }
    state2.filtered.count = itemCount;
    return state2;
  }
  function sort(state2, shouldFilterVal) {
    const $shouldFilter = shouldFilterVal ?? get_store_value(shouldFilter);
    if (!state2.search || !$shouldFilter) {
      return state2;
    }
    const scores = state2.filtered.items;
    const groups = [];
    const $allGroups = get_store_value(allGroups);
    state2.filtered.groups.forEach((value) => {
      const items = $allGroups.get(value);
      if (!items)
        return;
      let max2 = 0;
      items.forEach((item) => {
        const score2 = scores.get(item);
        if (isUndefined(score2))
          return;
        max2 = Math.max(score2, max2);
      });
      groups.push([value, max2]);
    });
    const rootEl = document.getElementById(ids.root);
    if (!rootEl)
      return state2;
    const list = rootEl.querySelector(LIST_SELECTOR);
    getValidItems(rootEl).sort((a2, b2) => {
      const valueA = a2.getAttribute(VALUE_ATTR) ?? "";
      const valueB = b2.getAttribute(VALUE_ATTR) ?? "";
      return (scores.get(valueA) ?? 0) - (scores.get(valueB) ?? 0);
    }).forEach((item) => {
      const group = item.closest(GROUP_ITEMS_SELECTOR);
      const closest = item.closest(`${GROUP_ITEMS_SELECTOR} > *`);
      if (isHTMLElement3(group)) {
        if (item.parentElement === group) {
          group.appendChild(item);
        } else {
          if (!isHTMLElement3(closest))
            return;
          group.appendChild(closest);
        }
      } else {
        if (!isHTMLElement3(list))
          return;
        if (item.parentElement === list) {
          list.appendChild(item);
        } else {
          if (!isHTMLElement3(closest))
            return;
          list.appendChild(closest);
        }
      }
    });
    groups.sort((a2, b2) => b2[1] - a2[1]).forEach((group) => {
      const el = rootEl.querySelector(`${GROUP_SELECTOR}[${VALUE_ATTR}="${group[0]}"]`);
      if (!isHTMLElement3(el))
        return;
      el.parentElement?.appendChild(el);
    });
    return state2;
  }
  function selectFirstItem() {
    const item = getValidItems().find((item2) => !item2.ariaDisabled);
    if (!item)
      return;
    const value = item.getAttribute(VALUE_ATTR);
    if (!value)
      return;
    return value;
  }
  function score(value, search) {
    const lowerCaseAndTrimmedValue = value?.toLowerCase().trim();
    const filterFn = get_store_value(filter);
    if (!filterFn) {
      return lowerCaseAndTrimmedValue ? defaultFilter(lowerCaseAndTrimmedValue, search) : 0;
    }
    return lowerCaseAndTrimmedValue ? filterFn(lowerCaseAndTrimmedValue, search) : 0;
  }
  function scrollSelectedIntoView() {
    const item = getSelectedItem();
    if (!item) {
      return;
    }
    if (item.parentElement?.firstChild === item) {
      tick().then(() => item.closest(GROUP_SELECTOR)?.querySelector(GROUP_HEADING_SELECTOR)?.scrollIntoView({
        block: "nearest"
      }));
    }
    tick().then(() => item.scrollIntoView({ block: "nearest" }));
  }
  function getValidItems(rootElement) {
    const rootEl = rootElement ?? document.getElementById(ids.root);
    if (!rootEl)
      return [];
    return Array.from(rootEl.querySelectorAll(VALID_ITEM_SELECTOR)).filter((el) => isHTMLElement3(el));
  }
  function getSelectedItem(rootElement) {
    const rootEl = rootElement ?? document.getElementById(ids.root);
    if (!rootEl)
      return;
    const selectedEl = rootEl.querySelector(`${VALID_ITEM_SELECTOR}[aria-selected="true"]`);
    if (!isHTMLElement3(selectedEl))
      return null;
    return selectedEl;
  }
  function updateSelectedToIndex(index15) {
    const rootEl = document.getElementById(ids.root);
    if (!rootEl)
      return;
    const items = getValidItems(rootEl);
    const item = items[index15];
    if (!item)
      return;
  }
  function updateSelectedByChange(change) {
    const selected = getSelectedItem();
    const items = getValidItems();
    const index15 = items.findIndex((item) => item === selected);
    let newSelected = items[index15 + change];
    if (get_store_value(loop)) {
      if (index15 + change < 0) {
        newSelected = items[items.length - 1];
      } else if (index15 + change === items.length) {
        newSelected = items[0];
      } else {
        newSelected = items[index15 + change];
      }
    }
    if (newSelected) {
      updateState("value", newSelected.getAttribute(VALUE_ATTR) ?? "");
    }
  }
  function updateSelectedToGroup(change) {
    const selected = getSelectedItem();
    let group = selected?.closest(GROUP_SELECTOR);
    let item = void 0;
    while (group && !item) {
      group = change > 0 ? findNextSibling(group, GROUP_SELECTOR) : findPreviousSibling(group, GROUP_SELECTOR);
      item = group?.querySelector(VALID_ITEM_SELECTOR);
    }
    if (item) {
      updateState("value", item.getAttribute(VALUE_ATTR) ?? "");
    } else {
      updateSelectedByChange(change);
    }
  }
  function last2() {
    return updateSelectedToIndex(getValidItems().length - 1);
  }
  function next2(e3) {
    e3.preventDefault();
    if (e3.metaKey) {
      last2();
    } else if (e3.altKey) {
      updateSelectedToGroup(1);
    } else {
      updateSelectedByChange(1);
    }
  }
  function prev2(e3) {
    e3.preventDefault();
    if (e3.metaKey) {
      updateSelectedToIndex(0);
    } else if (e3.altKey) {
      updateSelectedToGroup(-1);
    } else {
      updateSelectedByChange(-1);
    }
  }
  function handleRootKeydown(e3) {
    switch (e3.key) {
      case kbd$1.ARROW_DOWN:
        next2(e3);
        break;
      case kbd$1.ARROW_UP:
        prev2(e3);
        break;
      case kbd$1.HOME:
        e3.preventDefault();
        updateSelectedToIndex(0);
        break;
      case kbd$1.END:
        e3.preventDefault();
        last2();
        break;
      case kbd$1.ENTER: {
        e3.preventDefault();
        const item = getSelectedItem();
        if (item) {
          item.click();
        }
      }
    }
  }
  setContext(NAME$m, context);
  const stateStore = {
    subscribe: state.subscribe,
    update: state.update,
    set: state.set,
    updateState
  };
  setContext(STATE_NAME, stateStore);
  return {
    state: stateStore,
    handleRootKeydown,
    commandEl,
    ids
  };
}
function findNextSibling(el, selector) {
  let sibling = el.nextElementSibling;
  while (sibling) {
    if (sibling.matches(selector))
      return sibling;
    sibling = sibling.nextElementSibling;
  }
}
function findPreviousSibling(el, selector) {
  let sibling = el.previousElementSibling;
  while (sibling) {
    if (sibling.matches(selector))
      return sibling;
    sibling = sibling.previousElementSibling;
  }
}
function styleToString$1(style) {
  return Object.keys(style).reduce((str, key2) => {
    if (style[key2] === void 0)
      return str;
    return str + `${key2}:${style[key2]};`;
  }, "");
}
function addEventListener3(target, event, handler, options2) {
  const events = Array.isArray(event) ? event : [event];
  events.forEach((_event) => target.addEventListener(_event, handler, options2));
  return () => {
    events.forEach((_event) => target.removeEventListener(_event, handler, options2));
  };
}
function createBitAttrs2(bit, parts) {
  const attrs = {};
  parts.forEach((part) => {
    attrs[part] = {
      [`data-bits-${bit}-${part}`]: ""
    };
  });
  return (part) => attrs[part];
}
function styleToString2(style) {
  return Object.keys(style).reduce((str, key2) => {
    if (style[key2] === void 0)
      return str;
    return str + `${key2}:${style[key2]};`;
  }, "");
}
function sleep2(ms) {
  return new Promise((resolve2) => setTimeout(resolve2, ms));
}
var SCORE_CONTINUE_MATCH;
var SCORE_SPACE_WORD_JUMP;
var SCORE_NON_SPACE_WORD_JUMP;
var SCORE_CHARACTER_JUMP;
var SCORE_TRANSPOSITION;
var PENALTY_SKIPPED;
var PENALTY_CASE_MISMATCH;
var PENALTY_NOT_COMPLETE;
var IS_GAP_REGEXP;
var COUNT_GAPS_REGEXP;
var IS_SPACE_REGEXP;
var COUNT_SPACE_REGEXP;
var isBrowser3;
var kbd$1;
var srOnlyStyles;
var NAME$m;
var STATE_NAME;
var GROUP_NAME;
var LIST_SELECTOR;
var GROUP_SELECTOR;
var GROUP_ITEMS_SELECTOR;
var GROUP_HEADING_SELECTOR;
var ITEM_SELECTOR;
var VALID_ITEM_SELECTOR;
var VALUE_ATTR;
var defaultFilter;
var defaults3;
var Command$1;
var kbd2;
var NAME$l;
var PARTS$l;
var NAME$k;
var PARTS$k;
var NAME$j;
var PARTS$j;
var NAME$i;
var PARTS$i;
var NAME$h;
var PARTS$h;
var NAME$g;
var PARTS$g;
var NAME$f;
var PARTS$f;
var NAME$e;
var PARTS$e;
var NAME$d;
var PARTS$d;
var NAME$c;
var PARTS$c;
var NAME$b;
var PARTS$b;
var NAME$a;
var PARTS$a;
var NAME$9;
var PARTS$9;
var NAME$8;
var PARTS$8;
var NAME$7;
var PARTS$7;
var NAME$6;
var PARTS$6;
var NAME$5;
var PARTS$5;
var NAME$4;
var PARTS$4;
var NAME$3;
var PARTS$3;
var NAME$2;
var PARTS$2;
var NAME$1;
var PARTS$1;
var NAME;
var PARTS;
var CommandEmpty;
var CommandGroup;
var CommandInput;
var CommandItem;
var Command;
var Command_empty;
var Command_group;
var Command_item;
var Command_input;
var init_command_input = __esm({
  ".svelte-kit/output/server/chunks/command-input.js"() {
    init_lifecycle();
    init_ssr();
    init_dist();
    init_index3();
    init_index2();
    init_scheduler();
    init_non_secure();
    init_MagnifyingGlass();
    SCORE_CONTINUE_MATCH = 1;
    SCORE_SPACE_WORD_JUMP = 0.9;
    SCORE_NON_SPACE_WORD_JUMP = 0.8;
    SCORE_CHARACTER_JUMP = 0.17;
    SCORE_TRANSPOSITION = 0.1;
    PENALTY_SKIPPED = 0.999;
    PENALTY_CASE_MISMATCH = 0.9999;
    PENALTY_NOT_COMPLETE = 0.99;
    IS_GAP_REGEXP = /[\\/_+.#"@[({&]/;
    COUNT_GAPS_REGEXP = /[\\/_+.#"@[({&]/g;
    IS_SPACE_REGEXP = /[\s-]/;
    COUNT_SPACE_REGEXP = /[\s-]/g;
    isBrowser3 = typeof document !== "undefined";
    kbd$1 = {
      ALT: "Alt",
      ARROW_DOWN: "ArrowDown",
      ARROW_LEFT: "ArrowLeft",
      ARROW_RIGHT: "ArrowRight",
      ARROW_UP: "ArrowUp",
      BACKSPACE: "Backspace",
      CAPS_LOCK: "CapsLock",
      CONTROL: "Control",
      DELETE: "Delete",
      END: "End",
      ENTER: "Enter",
      ESCAPE: "Escape",
      F1: "F1",
      F10: "F10",
      F11: "F11",
      F12: "F12",
      F2: "F2",
      F3: "F3",
      F4: "F4",
      F5: "F5",
      F6: "F6",
      F7: "F7",
      F8: "F8",
      F9: "F9",
      HOME: "Home",
      META: "Meta",
      PAGE_DOWN: "PageDown",
      PAGE_UP: "PageUp",
      SHIFT: "Shift",
      SPACE: " ",
      TAB: "Tab",
      CTRL: "Control",
      ASTERISK: "*"
    };
    srOnlyStyles = {
      position: "absolute",
      width: "1px",
      height: "1px",
      padding: "0",
      margin: "-1px",
      overflow: "hidden",
      clip: "rect(0, 0, 0, 0)",
      whiteSpace: "nowrap",
      borderWidth: "0"
    };
    NAME$m = "Command";
    STATE_NAME = "CommandState";
    GROUP_NAME = "CommandGroup";
    LIST_SELECTOR = `[data-cmdk-list-sizer]`;
    GROUP_SELECTOR = `[data-cmdk-group]`;
    GROUP_ITEMS_SELECTOR = `[data-cmdk-group-items]`;
    GROUP_HEADING_SELECTOR = `[data-cmdk-group-heading]`;
    ITEM_SELECTOR = `[data-cmdk-item]`;
    VALID_ITEM_SELECTOR = `${ITEM_SELECTOR}:not([aria-disabled="true"])`;
    VALUE_ATTR = `data-value`;
    defaultFilter = (value, search) => commandScore(value, search);
    defaults3 = {
      label: "Command menu",
      shouldFilter: true,
      loop: false,
      onValueChange: void 0,
      value: void 0,
      filter: defaultFilter,
      ids: {
        root: generateId2(),
        list: generateId2(),
        label: generateId2(),
        input: generateId2()
      }
    };
    Command$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let slotProps;
      let $$restProps = compute_rest_props($$props, [
        "label",
        "shouldFilter",
        "filter",
        "value",
        "onValueChange",
        "loop",
        "onKeydown",
        "state",
        "ids",
        "asChild"
      ]);
      let $stateStore, $$unsubscribe_stateStore;
      let { label = void 0 } = $$props;
      let { shouldFilter = true } = $$props;
      let { filter = void 0 } = $$props;
      let { value = void 0 } = $$props;
      let { onValueChange = void 0 } = $$props;
      let { loop = void 0 } = $$props;
      let { onKeydown = void 0 } = $$props;
      let { state = void 0 } = $$props;
      let { ids = void 0 } = $$props;
      let { asChild = false } = $$props;
      const { commandEl, handleRootKeydown, ids: commandIds, state: stateStore } = createCommand({
        label,
        shouldFilter,
        filter,
        value,
        onValueChange: (next2) => {
          if (next2 !== value) {
            value = next2;
            onValueChange?.(next2);
          }
        },
        loop,
        state,
        ids
      });
      $$unsubscribe_stateStore = subscribe(stateStore, (value2) => $stateStore = value2);
      function syncValueAndState(value2) {
        if (value2 && value2 !== $stateStore.value) {
          set_store_value(stateStore, $stateStore.value = value2, $stateStore);
        }
      }
      function rootAction(node) {
        commandEl.set(node);
        const unsubEvents = executeCallbacks2(addEventListener$1(node, "keydown", handleKeydown));
        return { destroy: unsubEvents };
      }
      const rootAttrs = {
        role: "application",
        id: commandIds.root,
        "data-cmdk-root": ""
      };
      const labelAttrs = {
        "data-cmdk-label": "",
        for: commandIds.input,
        id: commandIds.label,
        style: styleToString$2(srOnlyStyles)
      };
      function handleKeydown(e3) {
        onKeydown?.(e3);
        if (e3.defaultPrevented)
          return;
        handleRootKeydown(e3);
      }
      const root = { action: rootAction, attrs: rootAttrs };
      if ($$props.label === void 0 && $$bindings.label && label !== void 0)
        $$bindings.label(label);
      if ($$props.shouldFilter === void 0 && $$bindings.shouldFilter && shouldFilter !== void 0)
        $$bindings.shouldFilter(shouldFilter);
      if ($$props.filter === void 0 && $$bindings.filter && filter !== void 0)
        $$bindings.filter(filter);
      if ($$props.value === void 0 && $$bindings.value && value !== void 0)
        $$bindings.value(value);
      if ($$props.onValueChange === void 0 && $$bindings.onValueChange && onValueChange !== void 0)
        $$bindings.onValueChange(onValueChange);
      if ($$props.loop === void 0 && $$bindings.loop && loop !== void 0)
        $$bindings.loop(loop);
      if ($$props.onKeydown === void 0 && $$bindings.onKeydown && onKeydown !== void 0)
        $$bindings.onKeydown(onKeydown);
      if ($$props.state === void 0 && $$bindings.state && state !== void 0)
        $$bindings.state(state);
      if ($$props.ids === void 0 && $$bindings.ids && ids !== void 0)
        $$bindings.ids(ids);
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      {
        syncValueAndState(value);
      }
      slotProps = {
        root,
        label: { attrs: labelAttrs },
        stateStore,
        state: $stateStore
      };
      $$unsubscribe_stateStore();
      return `${asChild ? `${slots.default ? slots.default({ ...slotProps }) : ``}` : `<div${spread([escape_object(rootAttrs), escape_object($$restProps)], {})}> <label${spread([escape_object(labelAttrs)], {})}>${escape(label ?? "")}</label> ${slots.default ? slots.default({ ...slotProps }) : ``}</div>`}`;
    });
    ({
      type: "hidden",
      "aria-hidden": true,
      hidden: true,
      tabIndex: -1,
      style: styleToString$1({
        position: "absolute",
        opacity: 0,
        "pointer-events": "none",
        margin: 0,
        transform: "translateX(-100%)"
      })
    });
    kbd2 = {
      ALT: "Alt",
      ARROW_DOWN: "ArrowDown",
      ARROW_LEFT: "ArrowLeft",
      ARROW_RIGHT: "ArrowRight",
      ARROW_UP: "ArrowUp",
      BACKSPACE: "Backspace",
      CAPS_LOCK: "CapsLock",
      CONTROL: "Control",
      DELETE: "Delete",
      END: "End",
      ENTER: "Enter",
      ESCAPE: "Escape",
      F1: "F1",
      F10: "F10",
      F11: "F11",
      F12: "F12",
      F2: "F2",
      F3: "F3",
      F4: "F4",
      F5: "F5",
      F6: "F6",
      F7: "F7",
      F8: "F8",
      F9: "F9",
      HOME: "Home",
      META: "Meta",
      PAGE_DOWN: "PageDown",
      PAGE_UP: "PageUp",
      SHIFT: "Shift",
      SPACE: " ",
      TAB: "Tab",
      CTRL: "Control",
      ASTERISK: "*",
      A: "a",
      P: "p"
    };
    readable(void 0, (set) => {
      function clicked(event) {
        set(event);
        set(void 0);
      }
      const unsubscribe = addEventListener3(document, "pointerup", clicked, {
        passive: false,
        capture: true
      });
      return unsubscribe;
    });
    readable(void 0, (set) => {
      function keydown(event) {
        if (event && event.key === kbd2.ESCAPE) {
          set(event);
        }
        set(void 0);
      }
      const unsubscribe = addEventListener3(document, "keydown", keydown, {
        passive: false,
        capture: true
      });
      return unsubscribe;
    });
    styleToString2({
      position: "absolute",
      width: "1px",
      height: "1px",
      padding: "0",
      margin: "-1px",
      overflow: "hidden",
      clip: "rect(0, 0, 0, 0)",
      whiteSpace: "nowrap",
      borderWidth: "0"
    });
    styleToString2({
      position: "absolute",
      width: "25px",
      height: "25px",
      opacity: "0",
      margin: "0px",
      pointerEvents: "none",
      transform: "translateX(-100%)"
    });
    NAME$l = "accordion";
    PARTS$l = ["root", "content", "header", "item", "trigger"];
    createBitAttrs2(NAME$l, PARTS$l);
    NAME$k = "alert-dialog";
    PARTS$k = [
      "action",
      "cancel",
      "content",
      "description",
      "overlay",
      "portal",
      "title",
      "trigger"
    ];
    createBitAttrs2(NAME$k, PARTS$k);
    NAME$j = "avatar";
    PARTS$j = ["root", "image", "fallback"];
    createBitAttrs2(NAME$j, PARTS$j);
    NAME$i = "checkbox";
    PARTS$i = ["root", "input", "indicator"];
    createBitAttrs2(NAME$i, PARTS$i);
    NAME$h = "collapsible";
    PARTS$h = ["root", "content", "trigger"];
    createBitAttrs2(NAME$h, PARTS$h);
    NAME$g = "context-menu";
    PARTS$g = [
      "arrow",
      "checkbox-indicator",
      "checkbox-item",
      "content",
      "group",
      "item",
      "label",
      "radio-group",
      "radio-item",
      "separator",
      "sub-content",
      "sub-trigger",
      "trigger"
    ];
    createBitAttrs2(NAME$g, PARTS$g);
    NAME$f = "dialog";
    PARTS$f = ["close", "content", "description", "overlay", "portal", "title", "trigger"];
    createBitAttrs2(NAME$f, PARTS$f);
    NAME$e = "dropdown-menu";
    PARTS$e = [
      "arrow",
      "checkbox-indicator",
      "checkbox-item",
      "content",
      "group",
      "item",
      "label",
      "radio-group",
      "radio-item",
      "separator",
      "sub-content",
      "sub-trigger",
      "trigger"
    ];
    createBitAttrs2(NAME$e, PARTS$e);
    NAME$d = "link-preview";
    PARTS$d = ["arrow", "content", "trigger"];
    createBitAttrs2(NAME$d, PARTS$d);
    NAME$c = "label";
    PARTS$c = ["root"];
    createBitAttrs2(NAME$c, PARTS$c);
    NAME$b = "menubar";
    PARTS$b = [
      "root",
      "arrow",
      "checkbox-indicator",
      "checkbox-item",
      "content",
      "group",
      "item",
      "label",
      "radio-group",
      "radio-item",
      "separator",
      "sub-content",
      "sub-trigger",
      "trigger"
    ];
    createBitAttrs2(NAME$b, PARTS$b);
    NAME$a = "popover";
    PARTS$a = ["arrow", "close", "content", "trigger"];
    createBitAttrs2(NAME$a, PARTS$a);
    NAME$9 = "progress";
    PARTS$9 = ["root"];
    createBitAttrs2(NAME$9, PARTS$9);
    NAME$8 = "radio-group";
    PARTS$8 = ["root", "item", "input"];
    createBitAttrs2(NAME$8, PARTS$8);
    NAME$7 = "select";
    PARTS$7 = ["arrow", "content", "group", "item", "input", "label", "trigger", "value"];
    createBitAttrs2(NAME$7, PARTS$7);
    NAME$6 = "separator";
    PARTS$6 = ["root"];
    createBitAttrs2(NAME$6, PARTS$6);
    NAME$5 = "slider";
    PARTS$5 = ["root", "input", "range", "thumb", "tick"];
    createBitAttrs2(NAME$5, PARTS$5);
    NAME$4 = "switch";
    PARTS$4 = ["root", "input", "thumb"];
    createBitAttrs2(NAME$4, PARTS$4);
    NAME$3 = "tabs";
    PARTS$3 = ["root", "content", "list", "trigger"];
    createBitAttrs2(NAME$3, PARTS$3);
    NAME$2 = "toggle";
    PARTS$2 = ["root", "input"];
    createBitAttrs2(NAME$2, PARTS$2);
    NAME$1 = "toggle-group";
    PARTS$1 = ["root", "item"];
    createBitAttrs2(NAME$1, PARTS$1);
    NAME = "tooltip";
    PARTS = ["arrow", "content", "trigger"];
    createBitAttrs2(NAME, PARTS);
    CommandEmpty = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      compute_rest_props($$props, ["asChild"]);
      let $state, $$unsubscribe_state;
      let { asChild = false } = $$props;
      const state = getState();
      $$unsubscribe_state = subscribe(state, (value) => $state = value);
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      $state.filtered.count === 0;
      $$unsubscribe_state();
      return `${``}`;
    });
    CommandGroup = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let containerAttrs;
      let groupAttrs;
      let container;
      let group;
      let $$restProps = compute_rest_props($$props, ["heading", "value", "alwaysRender", "asChild"]);
      let $render, $$unsubscribe_render;
      let { heading = void 0 } = $$props;
      let { value = "" } = $$props;
      let { alwaysRender = false } = $$props;
      let { asChild = false } = $$props;
      const { id: id2 } = createGroup(alwaysRender);
      const context = getCtx2();
      const state = getState();
      const headingId = generateId2();
      const render = derived(state, ($state) => {
        if (alwaysRender)
          return true;
        if (context.filter() === false)
          return true;
        if (!$state.search)
          return true;
        return $state.filtered.groups.has(id2);
      });
      $$unsubscribe_render = subscribe(render, (value2) => $render = value2);
      function containerAction(node) {
        if (value) {
          context.value(id2, value);
          node.setAttribute(VALUE_ATTR, value);
          return;
        }
        if (heading) {
          value = heading.trim().toLowerCase();
        } else if (node.textContent) {
          value = node.textContent.trim().toLowerCase();
        }
        context.value(id2, value);
        node.setAttribute(VALUE_ATTR, value);
      }
      const headingAttrs = {
        "data-cmdk-group-heading": "",
        "aria-hidden": true,
        id: headingId
      };
      if ($$props.heading === void 0 && $$bindings.heading && heading !== void 0)
        $$bindings.heading(heading);
      if ($$props.value === void 0 && $$bindings.value && value !== void 0)
        $$bindings.value(value);
      if ($$props.alwaysRender === void 0 && $$bindings.alwaysRender && alwaysRender !== void 0)
        $$bindings.alwaysRender(alwaysRender);
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      containerAttrs = {
        "data-cmdk-group": "",
        role: "presentation",
        hidden: $render ? void 0 : true,
        "data-value": value
      };
      groupAttrs = {
        "data-cmdk-group-items": "",
        role: "group",
        "aria-labelledby": heading ? headingId : void 0
      };
      container = {
        action: containerAction,
        attrs: containerAttrs
      };
      group = { attrs: groupAttrs };
      $$unsubscribe_render();
      return `${asChild ? `${slots.default ? slots.default({
        container,
        group,
        heading: { attrs: headingAttrs }
      }) : ``}` : `<div${spread([escape_object(containerAttrs), escape_object($$restProps)], {})}>${heading ? `<div${spread([escape_object(headingAttrs)], {})}>${escape(heading)}</div>` : ``} <div${spread([escape_object(groupAttrs)], {})}>${slots.default ? slots.default({
        container,
        group,
        heading: { attrs: headingAttrs }
      }) : ``}</div></div>`}`;
    });
    CommandInput = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["autofocus", "value", "asChild", "el"]);
      let $selectedItemId, $$unsubscribe_selectedItemId;
      let $search, $$unsubscribe_search;
      const { ids, commandEl } = getCtx2();
      const state = getState();
      const search = derived(state, ($state) => $state.search);
      $$unsubscribe_search = subscribe(search, (value2) => $search = value2);
      const valueStore = derived(state, ($state) => $state.value);
      let { autofocus = void 0 } = $$props;
      let { value = $search } = $$props;
      let { asChild = false } = $$props;
      let { el = void 0 } = $$props;
      const selectedItemId = derived([valueStore, commandEl], ([$value, $commandEl]) => {
        if (!isBrowser3)
          return void 0;
        const item = $commandEl?.querySelector(`${ITEM_SELECTOR}[${VALUE_ATTR}="${$value}"]`);
        return item?.getAttribute("id");
      });
      $$unsubscribe_selectedItemId = subscribe(selectedItemId, (value2) => $selectedItemId = value2);
      function handleValueUpdate(v3) {
        state.updateState("search", v3);
      }
      function action(node) {
        if (autofocus) {
          sleep2(10).then(() => node.focus());
        }
        const unsubEvents = addEventListener$1(node, "change", (e3) => {
          if (!isHTMLInputElement2(e3.target))
            return;
          state.updateState("search", e3.target.value);
        });
        return { destroy: unsubEvents };
      }
      let attrs;
      if ($$props.autofocus === void 0 && $$bindings.autofocus && autofocus !== void 0)
        $$bindings.autofocus(autofocus);
      if ($$props.value === void 0 && $$bindings.value && value !== void 0)
        $$bindings.value(value);
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      if ($$props.el === void 0 && $$bindings.el && el !== void 0)
        $$bindings.el(el);
      {
        handleValueUpdate(value);
      }
      attrs = {
        type: "text",
        "data-cmdk-input": "",
        autocomplete: "off",
        autocorrect: "off",
        spellcheck: false,
        "aria-autocomplete": "list",
        role: "combobox",
        "aria-expanded": true,
        "aria-controls": ids.list,
        "aria-labelledby": ids.label,
        "aria-activedescendant": $selectedItemId ?? void 0,
        id: ids.input
      };
      $$unsubscribe_selectedItemId();
      $$unsubscribe_search();
      return `${asChild ? `${slots.default ? slots.default({ action, attrs }) : ``}` : `<input${spread([escape_object(attrs), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}${add_attribute("value", value, 0)}>`}`;
    });
    CommandItem = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let attrs;
      let $$restProps = compute_rest_props($$props, ["disabled", "value", "onSelect", "alwaysRender", "asChild", "id"]);
      let $selected, $$unsubscribe_selected;
      let $render, $$unsubscribe_render;
      let { disabled = false } = $$props;
      let { value = "" } = $$props;
      let { onSelect = void 0 } = $$props;
      let { alwaysRender = false } = $$props;
      let { asChild = false } = $$props;
      let { id: id2 = generateId2() } = $$props;
      const groupContext = getGroup();
      const context = getCtx2();
      const state = getState();
      const trueAlwaysRender = alwaysRender ?? groupContext?.alwaysRender;
      const render = derived(state, ($state) => {
        if (trueAlwaysRender || context.filter() === false || !$state.search)
          return true;
        const currentScore = $state.filtered.items.get(id2);
        if (isUndefined(currentScore))
          return false;
        return currentScore > 0;
      });
      $$unsubscribe_render = subscribe(render, (value2) => $render = value2);
      let isFirstRender = true;
      const selected = derived(state, ($state) => $state.value === value);
      $$unsubscribe_selected = subscribe(selected, (value2) => $selected = value2);
      function action(node) {
        if (!value && node.textContent) {
          value = node.textContent.trim().toLowerCase();
        }
        context.value(id2, value);
        node.setAttribute(VALUE_ATTR, value);
        const unsubEvents = executeCallbacks2(
          addEventListener$1(node, "pointermove", () => {
            if (disabled)
              return;
            select();
          }),
          addEventListener$1(node, "click", () => {
            if (disabled)
              return;
            handleItemClick();
          })
        );
        return {
          destroy() {
            unsubEvents();
          }
        };
      }
      function handleItemClick() {
        select();
        onSelect?.(value);
      }
      function select() {
        state.updateState("value", value, true);
      }
      if ($$props.disabled === void 0 && $$bindings.disabled && disabled !== void 0)
        $$bindings.disabled(disabled);
      if ($$props.value === void 0 && $$bindings.value && value !== void 0)
        $$bindings.value(value);
      if ($$props.onSelect === void 0 && $$bindings.onSelect && onSelect !== void 0)
        $$bindings.onSelect(onSelect);
      if ($$props.alwaysRender === void 0 && $$bindings.alwaysRender && alwaysRender !== void 0)
        $$bindings.alwaysRender(alwaysRender);
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      if ($$props.id === void 0 && $$bindings.id && id2 !== void 0)
        $$bindings.id(id2);
      attrs = {
        "aria-disabled": disabled ? true : void 0,
        "aria-selected": $selected ? true : void 0,
        "data-disabled": disabled ? true : void 0,
        "data-selected": $selected ? true : void 0,
        "data-cmdk-item": "",
        "data-value": value,
        role: "option",
        id: id2
      };
      $$unsubscribe_selected();
      $$unsubscribe_render();
      return `${$render || isFirstRender ? `${asChild ? `${slots.default ? slots.default({ action, attrs }) : ``}` : `<div${spread([escape_object(attrs), escape_object($$restProps)], {})}>${slots.default ? slots.default({ action, attrs }) : ``}</div>`}` : ``}`;
    });
    Command = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["value", "class"]);
      let { value = void 0 } = $$props;
      let { class: className = void 0 } = $$props;
      if ($$props.value === void 0 && $$bindings.value && value !== void 0)
        $$bindings.value(value);
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      let $$settled;
      let $$rendered;
      let previous_head = $$result.head;
      do {
        $$settled = true;
        $$result.head = previous_head;
        $$rendered = `${validate_component(Command$1, "CommandPrimitive.Root").$$render(
          $$result,
          Object.assign(
            {},
            {
              class: cn("flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground", className)
            },
            $$restProps,
            { value }
          ),
          {
            value: ($$value) => {
              value = $$value;
              $$settled = false;
            }
          },
          {
            default: () => {
              return `${slots.default ? slots.default({}) : ``}`;
            }
          }
        )}`;
      } while (!$$settled);
      return $$rendered;
    });
    Command_empty = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class"]);
      let { class: className = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      return `${validate_component(CommandEmpty, "CommandPrimitive.Empty").$$render(
        $$result,
        Object.assign(
          {},
          {
            class: cn("py-6 text-center text-sm", className)
          },
          $$restProps
        ),
        {},
        {
          default: () => {
            return `${slots.default ? slots.default({}) : ``}`;
          }
        }
      )}`;
    });
    Command_group = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class"]);
      let { class: className = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      return `${validate_component(CommandGroup, "CommandPrimitive.Group").$$render(
        $$result,
        Object.assign(
          {},
          {
            class: cn("overflow-hidden p-1 text-foreground [&_[data-cmdk-group-heading]]:px-2 [&_[data-cmdk-group-heading]]:py-1.5 [&_[data-cmdk-group-heading]]:text-xs [&_[data-cmdk-group-heading]]:font-medium [&_[data-cmdk-group-heading]]:text-muted-foreground", className)
          },
          $$restProps
        ),
        {},
        {
          default: () => {
            return `${slots.default ? slots.default({}) : ``}`;
          }
        }
      )}`;
    });
    Command_item = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["asChild", "class"]);
      let { asChild = false } = $$props;
      let { class: className = void 0 } = $$props;
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      return `${validate_component(CommandItem, "CommandPrimitive.Item").$$render(
        $$result,
        Object.assign(
          {},
          { asChild },
          {
            class: cn("relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none aria-selected:bg-accent aria-selected:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50", className)
          },
          $$restProps
        ),
        {},
        {
          default: ({ action, attrs }) => {
            return `${slots.default ? slots.default({ action, attrs }) : ``}`;
          }
        }
      )}`;
    });
    Command_input = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class", "value"]);
      let { class: className = void 0 } = $$props;
      let { value = "" } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.value === void 0 && $$bindings.value && value !== void 0)
        $$bindings.value(value);
      let $$settled;
      let $$rendered;
      let previous_head = $$result.head;
      do {
        $$settled = true;
        $$result.head = previous_head;
        $$rendered = `<div class="peer flex items-center px-3" data-cmdk-input-wrapper="">${validate_component(MagnifyingGlass$1, "MagnifyingGlass").$$render(
          $$result,
          {
            class: "mr-2 h-4 w-4 shrink-0 opacity-50"
          },
          {},
          {}
        )} ${validate_component(CommandInput, "CommandPrimitive.Input").$$render(
          $$result,
          Object.assign(
            {},
            {
              class: cn("flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50", className)
            },
            $$restProps,
            { value }
          ),
          {
            value: ($$value) => {
              value = $$value;
              $$settled = false;
            }
          },
          {}
        )}</div>`;
      } while (!$$settled);
      return $$rendered;
    });
  }
});
function getLabelData() {
  const NAME2 = "label";
  const PARTS2 = ["root"];
  const getAttrs2 = createBitAttrs(NAME2, PARTS2);
  return {
    NAME: NAME2,
    getAttrs: getAttrs2
  };
}
function setFormField(props) {
  setContext(FORM_FIELD, props);
  return props;
}
function getFormField() {
  if (!hasContext(FORM_FIELD)) {
    ctxError("Form.Field");
  }
  return getContext(FORM_FIELD);
}
function setFormControl(props) {
  setContext(FORM_CONTROL, props);
  return props;
}
function getFormControl() {
  if (!hasContext(FORM_CONTROL)) {
    ctxError("<Control />");
  }
  return getContext(FORM_CONTROL);
}
function ctxError(ctx) {
  console.error(`Unable to find \`${ctx}\` context. Did you forget to wrap the component in a \`${ctx}\`?`);
}
function getAriaDescribedBy({ fieldErrorsId = void 0, descriptionId = void 0, errors }) {
  let describedBy = "";
  if (descriptionId) {
    describedBy += descriptionId + " ";
  }
  if (errors.length && fieldErrorsId) {
    describedBy += fieldErrorsId;
  }
  return describedBy ? describedBy.trim() : void 0;
}
function getAriaRequired(constraints2) {
  if (!("required" in constraints2))
    return void 0;
  return constraints2.required ? "true" : void 0;
}
function getAriaInvalid(errors) {
  return errors && errors.length ? "true" : void 0;
}
function getDataFsError(errors) {
  return errors && errors.length ? "" : void 0;
}
function generateId3() {
  return nanoid(5);
}
function extractErrorArray(errors) {
  if (Array.isArray(errors))
    return errors;
  if (typeof errors === "object" && "_errors" in errors) {
    if (errors._errors !== void 0)
      return errors._errors;
  }
  return [];
}
var Spinners;
var Label$1;
var FORM_FIELD;
var FORM_CONTROL;
var Field;
var Control$1;
var Label;
var Form_label;
var Form_field;
var Form_button;
var Control;
var init_index6 = __esm({
  ".svelte-kit/output/server/chunks/index6.js"() {
    init_lifecycle();
    init_ssr();
    init_index3();
    init_dist();
    init_input();
    init_index2();
    init_non_secure();
    init_clsx();
    Spinners = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, []);
      return `<svg${add_attribute("class", $$restProps.class, 0)} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12a9 9 0 1 1-6.219-8.56"></path></svg>`;
    });
    Label$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let builder;
      let $$restProps = compute_rest_props($$props, ["asChild", "el"]);
      let $root, $$unsubscribe_root;
      let { asChild = false } = $$props;
      let { el = void 0 } = $$props;
      const { elements: { root } } = createLabel();
      $$unsubscribe_root = subscribe(root, (value) => $root = value);
      createDispatcher();
      const { getAttrs: getAttrs2 } = getLabelData();
      const attrs = getAttrs2("root");
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      if ($$props.el === void 0 && $$bindings.el && el !== void 0)
        $$bindings.el(el);
      builder = $root;
      {
        Object.assign(builder, attrs);
      }
      $$unsubscribe_root();
      return `${asChild ? `${slots.default ? slots.default({ builder }) : ``}` : `<label${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}>${slots.default ? slots.default({ builder }) : ``}</label>`}`;
    });
    FORM_FIELD = Symbol("FORM_FIELD_CTX");
    FORM_CONTROL = Symbol("FORM_CONTROL_CTX");
    Field = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let formErrors;
      let formConstraints;
      let formTainted;
      let formData;
      let isTainted;
      let $formTainted, $$unsubscribe_formTainted = noop, $$subscribe_formTainted = () => ($$unsubscribe_formTainted(), $$unsubscribe_formTainted = subscribe(formTainted, ($$value) => $formTainted = $$value), formTainted);
      let $formConstraints, $$unsubscribe_formConstraints = noop, $$subscribe_formConstraints = () => ($$unsubscribe_formConstraints(), $$unsubscribe_formConstraints = subscribe(formConstraints, ($$value) => $formConstraints = $$value), formConstraints);
      let $formErrors, $$unsubscribe_formErrors = noop, $$subscribe_formErrors = () => ($$unsubscribe_formErrors(), $$unsubscribe_formErrors = subscribe(formErrors, ($$value) => $formErrors = $$value), formErrors);
      let $formData, $$unsubscribe_formData = noop, $$subscribe_formData = () => ($$unsubscribe_formData(), $$unsubscribe_formData = subscribe(formData, ($$value) => $formData = $$value), formData);
      let $errors, $$unsubscribe_errors;
      let $tainted, $$unsubscribe_tainted;
      let { form } = $$props;
      let { name: name5 } = $$props;
      const field = {
        name: writable(name5),
        errors: writable([]),
        constraints: writable({}),
        tainted: writable(false),
        fieldErrorsId: writable(),
        descriptionId: writable(),
        form
      };
      const { tainted, errors } = field;
      $$unsubscribe_tainted = subscribe(tainted, (value) => $tainted = value);
      $$unsubscribe_errors = subscribe(errors, (value) => $errors = value);
      setFormField(field);
      if ($$props.form === void 0 && $$bindings.form && form !== void 0)
        $$bindings.form(form);
      if ($$props.name === void 0 && $$bindings.name && name5 !== void 0)
        $$bindings.name(name5);
      $$subscribe_formErrors({ errors: formErrors, constraints: formConstraints, tainted: formTainted, form: formData, isTainted } = form, $$subscribe_formConstraints(), $$subscribe_formTainted(), $$subscribe_formData());
      {
        field.name.set(name5);
      }
      {
        field.errors.set(extractErrorArray($formErrors[name5]));
      }
      {
        field.constraints.set($formConstraints[name5] ?? {});
      }
      {
        field.tainted.set($formTainted ? isTainted($formTainted[name5]) : false);
      }
      $$unsubscribe_formTainted();
      $$unsubscribe_formConstraints();
      $$unsubscribe_formErrors();
      $$unsubscribe_formData();
      $$unsubscribe_errors();
      $$unsubscribe_tainted();
      return ` ${slots.default ? slots.default({
        value: $formData[name5],
        errors: $errors,
        tainted: $tainted,
        constraints: $formConstraints[name5]
      }) : ``}`;
    });
    Control$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let errorAttr;
      let attrs;
      let labelAttrs;
      let $idStore, $$unsubscribe_idStore;
      let $constraints, $$unsubscribe_constraints;
      let $errors, $$unsubscribe_errors;
      let $descriptionId, $$unsubscribe_descriptionId;
      let $fieldErrorsId, $$unsubscribe_fieldErrorsId;
      let $name, $$unsubscribe_name;
      let { id: id2 = generateId3() } = $$props;
      const { name: name5, fieldErrorsId, descriptionId, errors, constraints: constraints2 } = getFormField();
      $$unsubscribe_name = subscribe(name5, (value) => $name = value);
      $$unsubscribe_fieldErrorsId = subscribe(fieldErrorsId, (value) => $fieldErrorsId = value);
      $$unsubscribe_descriptionId = subscribe(descriptionId, (value) => $descriptionId = value);
      $$unsubscribe_errors = subscribe(errors, (value) => $errors = value);
      $$unsubscribe_constraints = subscribe(constraints2, (value) => $constraints = value);
      const controlContext = {
        id: writable(id2),
        attrs: writable(),
        labelAttrs: writable()
      };
      const { id: idStore } = controlContext;
      $$unsubscribe_idStore = subscribe(idStore, (value) => $idStore = value);
      setFormControl(controlContext);
      if ($$props.id === void 0 && $$bindings.id && id2 !== void 0)
        $$bindings.id(id2);
      {
        controlContext.id.set(id2);
      }
      errorAttr = getDataFsError($errors);
      attrs = {
        name: $name,
        id: $idStore,
        "data-fs-error": errorAttr,
        "aria-describedby": getAriaDescribedBy({
          fieldErrorsId: $fieldErrorsId,
          descriptionId: $descriptionId,
          errors: $errors
        }),
        "aria-invalid": getAriaInvalid($errors),
        "aria-required": getAriaRequired($constraints),
        "data-fs-control": ""
      };
      labelAttrs = {
        for: $idStore,
        "data-fs-label": "",
        "data-fs-error": errorAttr
      };
      {
        controlContext.attrs.set(attrs);
      }
      {
        controlContext.labelAttrs.set(labelAttrs);
      }
      $$unsubscribe_idStore();
      $$unsubscribe_constraints();
      $$unsubscribe_errors();
      $$unsubscribe_descriptionId();
      $$unsubscribe_fieldErrorsId();
      $$unsubscribe_name();
      return ` ${slots.default ? slots.default({ attrs }) : ``}`;
    });
    Label = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class"]);
      let { class: className = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      return `${validate_component(Label$1, "LabelPrimitive.Root").$$render(
        $$result,
        Object.assign(
          {},
          {
            class: cn("text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70", className)
          },
          $$restProps
        ),
        {},
        {
          default: () => {
            return `${slots.default ? slots.default({}) : ``}`;
          }
        }
      )}`;
    });
    Form_label = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class"]);
      let $labelAttrs, $$unsubscribe_labelAttrs;
      let { class: className = void 0 } = $$props;
      const { labelAttrs } = getFormControl();
      $$unsubscribe_labelAttrs = subscribe(labelAttrs, (value) => $labelAttrs = value);
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      $$unsubscribe_labelAttrs();
      return `${validate_component(Label, "Label").$$render(
        $$result,
        Object.assign(
          {},
          $labelAttrs,
          {
            class: cn("data-[fs-error]:text-destructive", className)
          },
          $$restProps
        ),
        {},
        {
          default: () => {
            return `${slots.default ? slots.default({ labelAttrs }) : ``}`;
          }
        }
      )}`;
    });
    Form_field = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { form } = $$props;
      let { name: name5 } = $$props;
      let { class: className = void 0 } = $$props;
      if ($$props.form === void 0 && $$bindings.form && form !== void 0)
        $$bindings.form(form);
      if ($$props.name === void 0 && $$bindings.name && name5 !== void 0)
        $$bindings.name(name5);
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      return `${validate_component(Field, "FormPrimitive.Field").$$render($$result, { form, name: name5 }, {}, {
        default: ({ constraints: constraints2, errors, tainted, value }) => {
          return `<div${add_attribute("class", cn("space-y-2", className), 0)}>${slots.default ? slots.default({ constraints: constraints2, errors, tainted, value }) : ``}</div>`;
        }
      })}`;
    });
    Form_button = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, []);
      return `${validate_component(Button, "Button.Root").$$render($$result, Object.assign({}, { type: "submit" }, $$restProps), {}, {
        default: () => {
          return `${slots.default ? slots.default({}) : ``}`;
        }
      })}`;
    });
    Control = Control$1;
  }
});
var Moon;
var Moon$1;
var Sun;
var Sun$1;
var Mode_toggle;
var init_mode_toggle = __esm({
  ".svelte-kit/output/server/chunks/mode-toggle.js"() {
    init_lifecycle();
    init_ssr();
    init_stores();
    init_index3();
    Moon = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["color", "size"]);
      let { color = "currentColor" } = $$props;
      let { size: size3 = 15 } = $$props;
      if ($$props.color === void 0 && $$bindings.color && color !== void 0)
        $$bindings.color(color);
      if ($$props.size === void 0 && $$bindings.size && size3 !== void 0)
        $$bindings.size(size3);
      return `<svg${spread(
        [
          { width: escape_attribute_value(size3) },
          { height: escape_attribute_value(size3) },
          { viewBox: "0 0 15 15" },
          { fill: "none" },
          { xmlns: "http://www.w3.org/2000/svg" },
          escape_object($$restProps)
        ],
        {}
      )}><path fill-rule="evenodd" clip-rule="evenodd" d="M2.89998 0.499976C2.89998 0.279062 2.72089 0.0999756 2.49998 0.0999756C2.27906 0.0999756 2.09998 0.279062 2.09998 0.499976V1.09998H1.49998C1.27906 1.09998 1.09998 1.27906 1.09998 1.49998C1.09998 1.72089 1.27906 1.89998 1.49998 1.89998H2.09998V2.49998C2.09998 2.72089 2.27906 2.89998 2.49998 2.89998C2.72089 2.89998 2.89998 2.72089 2.89998 2.49998V1.89998H3.49998C3.72089 1.89998 3.89998 1.72089 3.89998 1.49998C3.89998 1.27906 3.72089 1.09998 3.49998 1.09998H2.89998V0.499976ZM5.89998 3.49998C5.89998 3.27906 5.72089 3.09998 5.49998 3.09998C5.27906 3.09998 5.09998 3.27906 5.09998 3.49998V4.09998H4.49998C4.27906 4.09998 4.09998 4.27906 4.09998 4.49998C4.09998 4.72089 4.27906 4.89998 4.49998 4.89998H5.09998V5.49998C5.09998 5.72089 5.27906 5.89998 5.49998 5.89998C5.72089 5.89998 5.89998 5.72089 5.89998 5.49998V4.89998H6.49998C6.72089 4.89998 6.89998 4.72089 6.89998 4.49998C6.89998 4.27906 6.72089 4.09998 6.49998 4.09998H5.89998V3.49998ZM1.89998 6.49998C1.89998 6.27906 1.72089 6.09998 1.49998 6.09998C1.27906 6.09998 1.09998 6.27906 1.09998 6.49998V7.09998H0.499976C0.279062 7.09998 0.0999756 7.27906 0.0999756 7.49998C0.0999756 7.72089 0.279062 7.89998 0.499976 7.89998H1.09998V8.49998C1.09998 8.72089 1.27906 8.89997 1.49998 8.89997C1.72089 8.89997 1.89998 8.72089 1.89998 8.49998V7.89998H2.49998C2.72089 7.89998 2.89998 7.72089 2.89998 7.49998C2.89998 7.27906 2.72089 7.09998 2.49998 7.09998H1.89998V6.49998ZM8.54406 0.98184L8.24618 0.941586C8.03275 0.917676 7.90692 1.1655 8.02936 1.34194C8.17013 1.54479 8.29981 1.75592 8.41754 1.97445C8.91878 2.90485 9.20322 3.96932 9.20322 5.10022C9.20322 8.37201 6.82247 11.0878 3.69887 11.6097C3.45736 11.65 3.20988 11.6772 2.96008 11.6906C2.74563 11.702 2.62729 11.9535 2.77721 12.1072C2.84551 12.1773 2.91535 12.2458 2.98667 12.3128L3.05883 12.3795L3.31883 12.6045L3.50684 12.7532L3.62796 12.8433L3.81491 12.9742L3.99079 13.089C4.11175 13.1651 4.23536 13.2375 4.36157 13.3059L4.62496 13.4412L4.88553 13.5607L5.18837 13.6828L5.43169 13.7686C5.56564 13.8128 5.70149 13.8529 5.83857 13.8885C5.94262 13.9155 6.04767 13.9401 6.15405 13.9622C6.27993 13.9883 6.40713 14.0109 6.53544 14.0298L6.85241 14.0685L7.11934 14.0892C7.24637 14.0965 7.37436 14.1002 7.50322 14.1002C11.1483 14.1002 14.1032 11.1453 14.1032 7.50023C14.1032 7.25044 14.0893 7.00389 14.0623 6.76131L14.0255 6.48407C13.991 6.26083 13.9453 6.04129 13.8891 5.82642C13.8213 5.56709 13.7382 5.31398 13.6409 5.06881L13.5279 4.80132L13.4507 4.63542L13.3766 4.48666C13.2178 4.17773 13.0353 3.88295 12.8312 3.60423L12.6782 3.40352L12.4793 3.16432L12.3157 2.98361L12.1961 2.85951L12.0355 2.70246L11.8134 2.50184L11.4925 2.24191L11.2483 2.06498L10.9562 1.87446L10.6346 1.68894L10.3073 1.52378L10.1938 1.47176L9.95488 1.3706L9.67791 1.2669L9.42566 1.1846L9.10075 1.09489L8.83599 1.03486L8.54406 0.98184ZM10.4032 5.30023C10.4032 4.27588 10.2002 3.29829 9.83244 2.40604C11.7623 3.28995 13.1032 5.23862 13.1032 7.50023C13.1032 10.593 10.596 13.1002 7.50322 13.1002C6.63646 13.1002 5.81597 12.9036 5.08355 12.5522C6.5419 12.0941 7.81081 11.2082 8.74322 10.0416C8.87963 10.2284 9.10028 10.3497 9.34928 10.3497C9.76349 10.3497 10.0993 10.0139 10.0993 9.59971C10.0993 9.24256 9.84965 8.94373 9.51535 8.86816C9.57741 8.75165 9.63653 8.63334 9.6926 8.51332C9.88358 8.63163 10.1088 8.69993 10.35 8.69993C11.0403 8.69993 11.6 8.14028 11.6 7.44993C11.6 6.75976 11.0406 6.20024 10.3505 6.19993C10.3853 5.90487 10.4032 5.60464 10.4032 5.30023Z"${add_attribute("fill", color, 0)}></path></svg>`;
    });
    Moon$1 = Moon;
    Sun = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["color", "size"]);
      let { color = "currentColor" } = $$props;
      let { size: size3 = 15 } = $$props;
      if ($$props.color === void 0 && $$bindings.color && color !== void 0)
        $$bindings.color(color);
      if ($$props.size === void 0 && $$bindings.size && size3 !== void 0)
        $$bindings.size(size3);
      return `<svg${spread(
        [
          { width: escape_attribute_value(size3) },
          { height: escape_attribute_value(size3) },
          { viewBox: "0 0 15 15" },
          { fill: "none" },
          { xmlns: "http://www.w3.org/2000/svg" },
          escape_object($$restProps)
        ],
        {}
      )}><path fill-rule="evenodd" clip-rule="evenodd" d="M7.5 0C7.77614 0 8 0.223858 8 0.5V2.5C8 2.77614 7.77614 3 7.5 3C7.22386 3 7 2.77614 7 2.5V0.5C7 0.223858 7.22386 0 7.5 0ZM2.1967 2.1967C2.39196 2.00144 2.70854 2.00144 2.90381 2.1967L4.31802 3.61091C4.51328 3.80617 4.51328 4.12276 4.31802 4.31802C4.12276 4.51328 3.80617 4.51328 3.61091 4.31802L2.1967 2.90381C2.00144 2.70854 2.00144 2.39196 2.1967 2.1967ZM0.5 7C0.223858 7 0 7.22386 0 7.5C0 7.77614 0.223858 8 0.5 8H2.5C2.77614 8 3 7.77614 3 7.5C3 7.22386 2.77614 7 2.5 7H0.5ZM2.1967 12.8033C2.00144 12.608 2.00144 12.2915 2.1967 12.0962L3.61091 10.682C3.80617 10.4867 4.12276 10.4867 4.31802 10.682C4.51328 10.8772 4.51328 11.1938 4.31802 11.3891L2.90381 12.8033C2.70854 12.9986 2.39196 12.9986 2.1967 12.8033ZM12.5 7C12.2239 7 12 7.22386 12 7.5C12 7.77614 12.2239 8 12.5 8H14.5C14.7761 8 15 7.77614 15 7.5C15 7.22386 14.7761 7 14.5 7H12.5ZM10.682 4.31802C10.4867 4.12276 10.4867 3.80617 10.682 3.61091L12.0962 2.1967C12.2915 2.00144 12.608 2.00144 12.8033 2.1967C12.9986 2.39196 12.9986 2.70854 12.8033 2.90381L11.3891 4.31802C11.1938 4.51328 10.8772 4.51328 10.682 4.31802ZM8 12.5C8 12.2239 7.77614 12 7.5 12C7.22386 12 7 12.2239 7 12.5V14.5C7 14.7761 7.22386 15 7.5 15C7.77614 15 8 14.7761 8 14.5V12.5ZM10.682 10.682C10.8772 10.4867 11.1938 10.4867 11.3891 10.682L12.8033 12.0962C12.9986 12.2915 12.9986 12.608 12.8033 12.8033C12.608 12.9986 12.2915 12.9986 12.0962 12.8033L10.682 11.3891C10.4867 11.1938 10.4867 10.8772 10.682 10.682ZM5.5 7.5C5.5 6.39543 6.39543 5.5 7.5 5.5C8.60457 5.5 9.5 6.39543 9.5 7.5C9.5 8.60457 8.60457 9.5 7.5 9.5C6.39543 9.5 5.5 8.60457 5.5 7.5ZM7.5 4.5C5.84315 4.5 4.5 5.84315 4.5 7.5C4.5 9.15685 5.84315 10.5 7.5 10.5C9.15685 10.5 10.5 9.15685 10.5 7.5C10.5 5.84315 9.15685 4.5 7.5 4.5Z"${add_attribute("fill", color, 0)}></path></svg>`;
    });
    Sun$1 = Sun;
    Mode_toggle = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, []);
      return `${validate_component(Button, "Button").$$render(
        $$result,
        {
          variant: "outline",
          class: cn("ml-auto hidden items-center rounded-lg p-2 md:inline-flex", $$restProps.class)
        },
        {},
        {
          default: () => {
            return `${validate_component(Sun$1, "Sun").$$render(
              $$result,
              {
                class: "h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0"
              },
              {},
              {}
            )} ${validate_component(Moon$1, "Moon").$$render(
              $$result,
              {
                class: "absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100"
              },
              {},
              {}
            )} <span class="sr-only" data-svelte-h="svelte-ntgole">Toggle theme</span>`;
          }
        }
      )}`;
    });
  }
});
var layout_svelte_exports2 = {};
__export(layout_svelte_exports2, {
  default: () => Layout2
});
function createPopover(args) {
  const withDefaults = { ...defaults4, ...args };
  const options2 = toWritableStores(omit(withDefaults, "open", "ids"));
  const { positioning, arrowSize, disableFocusTrap, preventScroll, closeOnEscape, closeOnOutsideClick, portal, forceVisible, openFocus, closeFocus, onOutsideClick } = options2;
  const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);
  const open = overridable(openWritable, withDefaults?.onOpenChange);
  const activeTrigger = writable(null);
  const ids = toWritableStores({ ...generateIds(popoverIdParts), ...withDefaults.ids });
  safeOnMount(() => {
    activeTrigger.set(document.getElementById(ids.trigger.get()));
  });
  function handleClose() {
    open.set(false);
    const triggerEl = document.getElementById(ids.trigger.get());
    handleFocus({ prop: closeFocus.get(), defaultEl: triggerEl });
  }
  const isVisible = derivedVisible({ open, activeTrigger, forceVisible });
  const content = makeElement(name4("content"), {
    stores: [isVisible, portal, ids.content],
    returned: ([$isVisible, $portal, $contentId]) => {
      return {
        hidden: $isVisible && isBrowser2 ? void 0 : true,
        tabindex: -1,
        style: styleToString({
          display: $isVisible ? void 0 : "none"
        }),
        id: $contentId,
        "data-state": $isVisible ? "open" : "closed",
        "data-portal": portalAttr($portal)
      };
    },
    action: (node) => {
      let unsubPopper = noop2;
      const unsubDerived = effect([
        isVisible,
        activeTrigger,
        positioning,
        disableFocusTrap,
        closeOnEscape,
        closeOnOutsideClick,
        portal
      ], ([$isVisible, $activeTrigger, $positioning, $disableFocusTrap, $closeOnEscape, $closeOnOutsideClick, $portal]) => {
        unsubPopper();
        if (!$isVisible || !$activeTrigger)
          return;
        const popper = usePopper(node, {
          anchorElement: $activeTrigger,
          open,
          options: {
            floating: $positioning,
            focusTrap: $disableFocusTrap ? null : {
              returnFocusOnDeactivate: false,
              clickOutsideDeactivates: true,
              escapeDeactivates: true
            },
            modal: {
              shouldCloseOnInteractOutside,
              onClose: handleClose,
              open: $isVisible,
              closeOnInteractOutside: $closeOnOutsideClick
            },
            escapeKeydown: $closeOnEscape ? {
              handler: () => {
                handleClose();
              }
            } : null,
            portal: getPortalDestination(node, $portal)
          }
        });
        if (popper && popper.destroy) {
          unsubPopper = popper.destroy;
        }
      });
      return {
        destroy() {
          unsubDerived();
          unsubPopper();
        }
      };
    }
  });
  function toggleOpen(triggerEl) {
    open.update((prev2) => {
      return !prev2;
    });
    if (triggerEl) {
      activeTrigger.set(triggerEl);
    }
  }
  function shouldCloseOnInteractOutside(e3) {
    onOutsideClick.get()?.(e3);
    if (e3.defaultPrevented)
      return false;
    const target = e3.target;
    const triggerEl = document.getElementById(ids.trigger.get());
    if (triggerEl && isElement(target)) {
      if (target === triggerEl || triggerEl.contains(target))
        return false;
    }
    return true;
  }
  const trigger = makeElement(name4("trigger"), {
    stores: [isVisible, ids.content, ids.trigger],
    returned: ([$isVisible, $contentId, $triggerId]) => {
      return {
        role: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": $isVisible ? "true" : "false",
        "data-state": stateAttr($isVisible),
        "aria-controls": $contentId,
        id: $triggerId
      };
    },
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "click", () => {
        toggleOpen(node);
      }), addMeltEventListener(node, "keydown", (e3) => {
        if (e3.key !== kbd.ENTER && e3.key !== kbd.SPACE)
          return;
        e3.preventDefault();
        toggleOpen(node);
      }));
      return {
        destroy: unsub
      };
    }
  });
  const overlay = makeElement(name4("overlay"), {
    stores: [isVisible],
    returned: ([$isVisible]) => {
      return {
        hidden: $isVisible ? void 0 : true,
        tabindex: -1,
        style: styleToString({
          display: $isVisible ? void 0 : "none"
        }),
        "aria-hidden": "true",
        "data-state": stateAttr($isVisible)
      };
    },
    action: (node) => {
      let unsubEscapeKeydown = noop2;
      if (closeOnEscape.get()) {
        const escapeKeydown = useEscapeKeydown(node, {
          handler: () => {
            handleClose();
          }
        });
        if (escapeKeydown && escapeKeydown.destroy) {
          unsubEscapeKeydown = escapeKeydown.destroy;
        }
      }
      const unsubPortal = effect([portal], ([$portal]) => {
        if ($portal === null)
          return noop2;
        const portalDestination = getPortalDestination(node, $portal);
        if (portalDestination === null)
          return noop2;
        const portalAction = usePortal(node, portalDestination);
        if (portalAction && portalAction.destroy) {
          return portalAction.destroy;
        } else {
          return noop2;
        }
      });
      return {
        destroy() {
          unsubEscapeKeydown();
          unsubPortal();
        }
      };
    }
  });
  const arrow3 = makeElement(name4("arrow"), {
    stores: arrowSize,
    returned: ($arrowSize) => ({
      "data-arrow": true,
      style: styleToString({
        position: "absolute",
        width: `var(--arrow-size, ${$arrowSize}px)`,
        height: `var(--arrow-size, ${$arrowSize}px)`
      })
    })
  });
  const close = makeElement(name4("close"), {
    returned: () => ({
      type: "button"
    }),
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "click", (e3) => {
        if (e3.defaultPrevented)
          return;
        handleClose();
      }), addMeltEventListener(node, "keydown", (e3) => {
        if (e3.defaultPrevented)
          return;
        if (e3.key !== kbd.ENTER && e3.key !== kbd.SPACE)
          return;
        e3.preventDefault();
        toggleOpen();
      }));
      return {
        destroy: unsub
      };
    }
  });
  effect([open, activeTrigger, preventScroll], ([$open, $activeTrigger, $preventScroll]) => {
    if (!isBrowser2)
      return;
    const unsubs = [];
    if ($open) {
      if (!$activeTrigger) {
        tick().then(() => {
          const triggerEl2 = document.getElementById(ids.trigger.get());
          if (!isHTMLElement(triggerEl2))
            return;
          activeTrigger.set(triggerEl2);
        });
      }
      if ($preventScroll) {
        unsubs.push(removeScroll());
      }
      const triggerEl = $activeTrigger ?? document.getElementById(ids.trigger.get());
      handleFocus({ prop: openFocus.get(), defaultEl: triggerEl });
    }
    return () => {
      unsubs.forEach((unsub) => unsub());
    };
  });
  return {
    ids,
    elements: {
      trigger,
      content,
      arrow: arrow3,
      close,
      overlay
    },
    states: {
      open
    },
    options: options2
  };
}
function stateAttr(open) {
  return open ? "open" : "closed";
}
function getAlertDialogData() {
  const NAME2 = "alert-dialog";
  const PARTS2 = [
    "action",
    "cancel",
    "content",
    "description",
    "overlay",
    "portal",
    "title",
    "trigger"
  ];
  return { NAME: NAME2, PARTS: PARTS2 };
}
function setCtx$2(props) {
  const { NAME: NAME2, PARTS: PARTS2 } = getAlertDialogData();
  const getAttrs2 = createBitAttrs(NAME2, PARTS2);
  const initAlertDialog = createDialog({
    ...removeUndefined2(props),
    role: "alertdialog",
    forceVisible: true
  });
  const alertDialog = {
    ...initAlertDialog,
    getAttrs: getAttrs2,
    updateOption: getOptionUpdater(initAlertDialog.options)
  };
  setContext(NAME2, alertDialog);
  return {
    ...alertDialog,
    updateOption: getOptionUpdater(alertDialog.options),
    getAttrs: getAttrs2
  };
}
function getCtx$12() {
  const { NAME: NAME2 } = getAlertDialogData();
  return getContext(NAME2);
}
function getSeparatorData() {
  const NAME2 = "separator";
  const PARTS2 = ["root"];
  return {
    NAME: NAME2,
    PARTS: PARTS2
  };
}
function setCtx$12(props) {
  const { NAME: NAME2, PARTS: PARTS2 } = getSeparatorData();
  const getAttrs2 = createBitAttrs(NAME2, PARTS2);
  const separator = { ...createSeparator(removeUndefined2(props)), getAttrs: getAttrs2 };
  return {
    ...separator,
    updateOption: getOptionUpdater(separator.options)
  };
}
function getPopoverData() {
  const NAME2 = "popover";
  const PARTS2 = ["arrow", "close", "content", "trigger"];
  return {
    NAME: NAME2,
    PARTS: PARTS2
  };
}
function setCtx2(props) {
  const { NAME: NAME2, PARTS: PARTS2 } = getPopoverData();
  const getAttrs2 = createBitAttrs(NAME2, PARTS2);
  const popover = {
    ...createPopover({
      positioning: {
        placement: "bottom",
        gutter: 0
      },
      ...removeUndefined2(props),
      forceVisible: true
    }),
    getAttrs: getAttrs2
  };
  setContext(NAME2, popover);
  return {
    ...popover,
    updateOption: getOptionUpdater(popover.options)
  };
}
function getCtx3() {
  const { NAME: NAME2 } = getPopoverData();
  return getContext(NAME2);
}
function updatePositioning2(props) {
  const defaultPlacement = {
    side: "bottom",
    align: "center"
  };
  const withDefaults = { ...defaultPlacement, ...props };
  const { options: { positioning } } = getCtx3();
  const updater = getPositioningUpdater(positioning);
  updater(withDefaults);
}
var import_memoize_weak3;
var ChevronDown;
var ChevronDown$1;
var Info;
var Progress;
var Hamburger;
var Map_pin;
var Log_out;
var Users;
var Images;
var Calendar_check;
var Wallet;
var Trash;
var sidebarItems;
var defaults4;
var name4;
var popoverIdParts;
var Alert_dialog;
var Alert_dialog_title$1;
var Alert_dialog_action$1;
var Alert_dialog_cancel$1;
var Alert_dialog_portal$1;
var Alert_dialog_content$1;
var Alert_dialog_overlay$1;
var Alert_dialog_trigger;
var Alert_dialog_description$1;
var Separator$1;
var Dialog_overlay$1;
var Popover;
var Popover_content$1;
var Popover_trigger;
var Popover_content;
var Root$12;
var Trigger$1;
var CommandSeparator;
var Dialog_overlay;
var Command_separator;
var Separator;
var Sidebar_project_dialog;
var Alert_dialog_title;
var Alert_dialog_action;
var Alert_dialog_cancel;
var Alert_dialog_portal;
var Alert_dialog_footer;
var Alert_dialog_header;
var Alert_dialog_overlay;
var Alert_dialog_content;
var Alert_dialog_description;
var Root3;
var Trigger2;
var Sidebar_project_list;
var Sidebar;
var Header;
var Layout2;
var init_layout_svelte2 = __esm({
  ".svelte-kit/output/server/entries/pages/(dashboard)/_layout.svelte.js"() {
    init_ssr();
    init_index3();
    init_lifecycle();
    init_stores2();
    init_index4();
    init_just_clone();
    init_esm();
    init_chunks();
    init_devalue();
    import_memoize_weak3 = __toESM(require_memoize_weak(), 1);
    init_dist();
    init_index5();
    init_index2();
    init_scheduler();
    init_input();
    init_clsx();
    init_command_input();
    init_index6();
    init_client();
    init_mode_toggle();
    ChevronDown = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["color", "size"]);
      let { color = "currentColor" } = $$props;
      let { size: size3 = 15 } = $$props;
      if ($$props.color === void 0 && $$bindings.color && color !== void 0)
        $$bindings.color(color);
      if ($$props.size === void 0 && $$bindings.size && size3 !== void 0)
        $$bindings.size(size3);
      return `<svg${spread(
        [
          { width: escape_attribute_value(size3) },
          { height: escape_attribute_value(size3) },
          { viewBox: "0 0 15 15" },
          { fill: "none" },
          { xmlns: "http://www.w3.org/2000/svg" },
          escape_object($$restProps)
        ],
        {}
      )}><path fill-rule="evenodd" clip-rule="evenodd" d="M3.13523 6.15803C3.3241 5.95657 3.64052 5.94637 3.84197 6.13523L7.5 9.56464L11.158 6.13523C11.3595 5.94637 11.6759 5.95657 11.8648 6.15803C12.0536 6.35949 12.0434 6.67591 11.842 6.86477L7.84197 10.6148C7.64964 10.7951 7.35036 10.7951 7.15803 10.6148L3.15803 6.86477C2.95657 6.67591 2.94637 6.35949 3.13523 6.15803Z"${add_attribute("fill", color, 0)}></path></svg>`;
    });
    ChevronDown$1 = ChevronDown;
    Info = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, []);
      return `<svg${add_attribute("class", $$restProps.class, 0)} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><path d="M12 16v-4"></path><path d="M12 8h.01"></path></svg>`;
    });
    Progress = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, []);
      return `<svg${add_attribute("class", $$restProps.class, 0)} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 3v18h18"></path><path d="M13 17V9"></path><path d="M18 17V5"></path><path d="M8 17v-3"></path></svg>`;
    });
    Hamburger = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, []);
      return `<svg${add_attribute("class", $$restProps.class, 0)} aria-hidden="true" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path clip-rule="evenodd" fill-rule="evenodd" d="M2 4.75A.75.75 0 012.75 4h14.5a.75.75 0 010 1.5H2.75A.75.75 0 012 4.75zm0 10.5a.75.75 0 01.75-.75h7.5a.75.75 0 010 1.5h-7.5a.75.75 0 01-.75-.75zM2 10a.75.75 0 01.75-.75h14.5a.75.75 0 010 1.5H2.75A.75.75 0 012 10z"></path></svg>`;
    });
    Map_pin = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, []);
      return `<svg${add_attribute("class", $$restProps.class, 0)} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 10c0 6-8 12-8 12s-8-6-8-12a8 8 0 0 1 16 0Z"></path><circle cx="12" cy="10" r="3"></circle></svg>`;
    });
    Log_out = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, []);
      return `<svg${add_attribute("class", $$restProps.class, 0)} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path><polyline points="16 17 21 12 16 7"></polyline><line x1="21" x2="9" y1="12" y2="12"></line></svg>`;
    });
    Users = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, []);
      return `<svg${add_attribute("class", $$restProps.class, 0)} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M22 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg>`;
    });
    Images = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, []);
      return `<svg${add_attribute("class", $$restProps.class, 0)} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 22H4a2 2 0 0 1-2-2V6"></path><path d="m22 13-1.296-1.296a2.41 2.41 0 0 0-3.408 0L11 18"></path><circle cx="12" cy="8" r="2"></circle><rect width="16" height="16" x="6" y="2" rx="2"></rect></svg>`;
    });
    Calendar_check = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, []);
      return `<svg${add_attribute("class", $$restProps.class, 0)} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 2v4"></path><path d="M16 2v4"></path><path d="M21 14V6a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h8"></path><path d="M3 10h18"></path><path d="m16 20 2 2 4-4"></path></svg>`;
    });
    Wallet = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, []);
      return `<svg${add_attribute("class", $$restProps.class, 0)} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12V7H5a2 2 0 0 1 0-4h14v4"></path><path d="M3 5v14a2 2 0 0 0 2 2h16v-5"></path><path d="M18 12a2 2 0 0 0 0 4h4v-4Z"></path></svg>`;
    });
    Trash = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, []);
      return `<svg${add_attribute("class", $$restProps.class, 0)} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"></path><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"></path><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"></path><line x1="10" x2="10" y1="11" y2="17"></line><line x1="14" x2="14" y1="11" y2="17"></line></svg>`;
    });
    sidebarItems = [
      {
        Icon: Info,
        label: "Identitas Proyek",
        href: "identitas-proyek"
      },
      {
        Icon: Users,
        label: "Tim Pelaksana",
        href: "tim-pelaksana"
      },
      {
        Icon: Images,
        label: "Gambar Desain",
        href: "gambar-desain"
      },
      {
        Icon: Calendar_check,
        label: "Jadwal Project",
        href: "jadwal-project"
      },
      {
        Icon: Progress,
        label: "Progress",
        href: "progress"
      },
      {
        Icon: Map_pin,
        label: "Lokasi",
        href: "lokasi"
      },
      {
        Icon: Wallet,
        label: "Realisasi Biaya",
        href: "realisasi-biaya"
      }
      // {
      //   Icon: Flask,
      //   label: 'Experiments',
      //   href: `experiments`
      // }
    ];
    defaults4 = {
      positioning: {
        placement: "bottom"
      },
      arrowSize: 8,
      defaultOpen: false,
      disableFocusTrap: false,
      closeOnEscape: true,
      preventScroll: false,
      onOpenChange: void 0,
      closeOnOutsideClick: true,
      portal: void 0,
      forceVisible: false,
      openFocus: void 0,
      closeFocus: void 0,
      onOutsideClick: void 0
    };
    ({ name: name4 } = createElHelpers("popover"));
    popoverIdParts = ["trigger", "content"];
    Alert_dialog = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $idValues, $$unsubscribe_idValues;
      let { preventScroll = void 0 } = $$props;
      let { closeOnEscape = void 0 } = $$props;
      let { closeOnOutsideClick = false } = $$props;
      let { portal = void 0 } = $$props;
      let { open = void 0 } = $$props;
      let { onOpenChange = void 0 } = $$props;
      let { openFocus = void 0 } = $$props;
      let { closeFocus = void 0 } = $$props;
      let { onOutsideClick = void 0 } = $$props;
      const { states: { open: localOpen }, updateOption, ids } = setCtx$2({
        closeOnEscape,
        preventScroll,
        closeOnOutsideClick,
        portal,
        forceVisible: true,
        defaultOpen: open,
        openFocus,
        closeFocus,
        onOutsideClick,
        onOpenChange: ({ next: next2 }) => {
          if (open !== next2) {
            onOpenChange?.(next2);
            open = next2;
          }
          return next2;
        }
      });
      const idValues = derived([ids.content, ids.description, ids.title], ([$contentId, $descriptionId, $titleId]) => ({
        content: $contentId,
        description: $descriptionId,
        title: $titleId
      }));
      $$unsubscribe_idValues = subscribe(idValues, (value) => $idValues = value);
      if ($$props.preventScroll === void 0 && $$bindings.preventScroll && preventScroll !== void 0)
        $$bindings.preventScroll(preventScroll);
      if ($$props.closeOnEscape === void 0 && $$bindings.closeOnEscape && closeOnEscape !== void 0)
        $$bindings.closeOnEscape(closeOnEscape);
      if ($$props.closeOnOutsideClick === void 0 && $$bindings.closeOnOutsideClick && closeOnOutsideClick !== void 0)
        $$bindings.closeOnOutsideClick(closeOnOutsideClick);
      if ($$props.portal === void 0 && $$bindings.portal && portal !== void 0)
        $$bindings.portal(portal);
      if ($$props.open === void 0 && $$bindings.open && open !== void 0)
        $$bindings.open(open);
      if ($$props.onOpenChange === void 0 && $$bindings.onOpenChange && onOpenChange !== void 0)
        $$bindings.onOpenChange(onOpenChange);
      if ($$props.openFocus === void 0 && $$bindings.openFocus && openFocus !== void 0)
        $$bindings.openFocus(openFocus);
      if ($$props.closeFocus === void 0 && $$bindings.closeFocus && closeFocus !== void 0)
        $$bindings.closeFocus(closeFocus);
      if ($$props.onOutsideClick === void 0 && $$bindings.onOutsideClick && onOutsideClick !== void 0)
        $$bindings.onOutsideClick(onOutsideClick);
      open !== void 0 && localOpen.set(open);
      {
        updateOption("preventScroll", preventScroll);
      }
      {
        updateOption("closeOnEscape", closeOnEscape);
      }
      {
        updateOption("closeOnOutsideClick", closeOnOutsideClick);
      }
      {
        updateOption("portal", portal);
      }
      {
        updateOption("openFocus", openFocus);
      }
      {
        updateOption("closeFocus", closeFocus);
      }
      {
        updateOption("onOutsideClick", onOutsideClick);
      }
      $$unsubscribe_idValues();
      return `${slots.default ? slots.default({ ids: $idValues }) : ``}`;
    });
    Alert_dialog_title$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let builder;
      let $$restProps = compute_rest_props($$props, ["level", "asChild", "id", "el"]);
      let $title, $$unsubscribe_title;
      let { level = "h2" } = $$props;
      let { asChild = false } = $$props;
      let { id: id2 = void 0 } = $$props;
      let { el = void 0 } = $$props;
      const { elements: { title }, ids, getAttrs: getAttrs2 } = getCtx$12();
      $$unsubscribe_title = subscribe(title, (value) => $title = value);
      const attrs = getAttrs2("title");
      if ($$props.level === void 0 && $$bindings.level && level !== void 0)
        $$bindings.level(level);
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      if ($$props.id === void 0 && $$bindings.id && id2 !== void 0)
        $$bindings.id(id2);
      if ($$props.el === void 0 && $$bindings.el && el !== void 0)
        $$bindings.el(el);
      {
        if (id2) {
          ids.title.set(id2);
        }
      }
      builder = $title;
      {
        Object.assign(builder, attrs);
      }
      $$unsubscribe_title();
      return `${asChild ? `${slots.default ? slots.default({ builder }) : ``}` : `${((tag) => {
        return tag ? `<${level}${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}>${is_void(tag) ? "" : `${slots.default ? slots.default({ builder }) : ``}`}${is_void(tag) ? "" : `</${tag}>`}` : "";
      })(level)}`}`;
    });
    Alert_dialog_action$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let builder;
      let $$restProps = compute_rest_props($$props, ["asChild", "el"]);
      let $close, $$unsubscribe_close;
      let { asChild = false } = $$props;
      let { el = void 0 } = $$props;
      const { elements: { close }, getAttrs: getAttrs2 } = getCtx$12();
      $$unsubscribe_close = subscribe(close, (value) => $close = value);
      createDispatcher();
      const attrs = getAttrs2("action");
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      if ($$props.el === void 0 && $$bindings.el && el !== void 0)
        $$bindings.el(el);
      builder = $close;
      {
        Object.assign(builder, attrs);
      }
      $$unsubscribe_close();
      return `${asChild ? `${slots.default ? slots.default({ builder }) : ``}` : `<button${spread([escape_object(builder), { type: "button" }, escape_object($$restProps)], {})}${add_attribute("this", el, 0)}>${slots.default ? slots.default({ builder }) : ``}</button>`}`;
    });
    Alert_dialog_cancel$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let builder;
      let $$restProps = compute_rest_props($$props, ["asChild", "el"]);
      let $close, $$unsubscribe_close;
      let { asChild = false } = $$props;
      let { el = void 0 } = $$props;
      const { elements: { close }, getAttrs: getAttrs2 } = getCtx$12();
      $$unsubscribe_close = subscribe(close, (value) => $close = value);
      createDispatcher();
      const attrs = getAttrs2("cancel");
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      if ($$props.el === void 0 && $$bindings.el && el !== void 0)
        $$bindings.el(el);
      builder = $close;
      {
        Object.assign(builder, attrs);
      }
      $$unsubscribe_close();
      return `${asChild ? `${slots.default ? slots.default({ builder }) : ``}` : `<button${spread([escape_object(builder), { type: "button" }, escape_object($$restProps)], {})}${add_attribute("this", el, 0)}>${slots.default ? slots.default({ builder }) : ``}</button>`}`;
    });
    Alert_dialog_portal$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let builder;
      let $$restProps = compute_rest_props($$props, ["asChild", "el"]);
      let $portalled, $$unsubscribe_portalled;
      let { asChild = false } = $$props;
      let { el = void 0 } = $$props;
      const { elements: { portalled }, getAttrs: getAttrs2 } = getCtx$12();
      $$unsubscribe_portalled = subscribe(portalled, (value) => $portalled = value);
      const attrs = getAttrs2("portal");
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      if ($$props.el === void 0 && $$bindings.el && el !== void 0)
        $$bindings.el(el);
      builder = $portalled;
      {
        Object.assign(builder, attrs);
      }
      $$unsubscribe_portalled();
      return `${asChild ? `${slots.default ? slots.default({ builder }) : ``}` : `<div${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}>${slots.default ? slots.default({ builder }) : ``}</div>`}`;
    });
    Alert_dialog_content$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let builder;
      let $$restProps = compute_rest_props($$props, [
        "transition",
        "transitionConfig",
        "inTransition",
        "inTransitionConfig",
        "outTransition",
        "outTransitionConfig",
        "id",
        "asChild",
        "el"
      ]);
      let $content, $$unsubscribe_content;
      let $open, $$unsubscribe_open;
      let { transition = void 0 } = $$props;
      let { transitionConfig = void 0 } = $$props;
      let { inTransition = void 0 } = $$props;
      let { inTransitionConfig = void 0 } = $$props;
      let { outTransition = void 0 } = $$props;
      let { outTransitionConfig = void 0 } = $$props;
      let { id: id2 = void 0 } = $$props;
      let { asChild = false } = $$props;
      let { el = void 0 } = $$props;
      const { elements: { content }, states: { open }, ids, getAttrs: getAttrs2 } = getCtx$12();
      $$unsubscribe_content = subscribe(content, (value) => $content = value);
      $$unsubscribe_open = subscribe(open, (value) => $open = value);
      const attrs = getAttrs2("content");
      if ($$props.transition === void 0 && $$bindings.transition && transition !== void 0)
        $$bindings.transition(transition);
      if ($$props.transitionConfig === void 0 && $$bindings.transitionConfig && transitionConfig !== void 0)
        $$bindings.transitionConfig(transitionConfig);
      if ($$props.inTransition === void 0 && $$bindings.inTransition && inTransition !== void 0)
        $$bindings.inTransition(inTransition);
      if ($$props.inTransitionConfig === void 0 && $$bindings.inTransitionConfig && inTransitionConfig !== void 0)
        $$bindings.inTransitionConfig(inTransitionConfig);
      if ($$props.outTransition === void 0 && $$bindings.outTransition && outTransition !== void 0)
        $$bindings.outTransition(outTransition);
      if ($$props.outTransitionConfig === void 0 && $$bindings.outTransitionConfig && outTransitionConfig !== void 0)
        $$bindings.outTransitionConfig(outTransitionConfig);
      if ($$props.id === void 0 && $$bindings.id && id2 !== void 0)
        $$bindings.id(id2);
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      if ($$props.el === void 0 && $$bindings.el && el !== void 0)
        $$bindings.el(el);
      {
        if (id2) {
          ids.content.set(id2);
        }
      }
      builder = $content;
      {
        Object.assign(builder, attrs);
      }
      $$unsubscribe_content();
      $$unsubscribe_open();
      return `${asChild && $open ? `${slots.default ? slots.default({ builder }) : ``}` : `${transition && $open ? `<div${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}>${slots.default ? slots.default({ builder }) : ``}</div>` : `${inTransition && outTransition && $open ? `<div${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}>${slots.default ? slots.default({ builder }) : ``}</div>` : `${inTransition && $open ? `<div${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}>${slots.default ? slots.default({ builder }) : ``}</div>` : `${outTransition && $open ? `<div${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}>${slots.default ? slots.default({ builder }) : ``}</div>` : `${$open ? `<div${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}>${slots.default ? slots.default({ builder }) : ``}</div>` : ``}`}`}`}`}`}`;
    });
    Alert_dialog_overlay$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let builder;
      let $$restProps = compute_rest_props($$props, [
        "transition",
        "transitionConfig",
        "inTransition",
        "inTransitionConfig",
        "outTransition",
        "outTransitionConfig",
        "asChild",
        "el"
      ]);
      let $overlay, $$unsubscribe_overlay;
      let $open, $$unsubscribe_open;
      let { transition = void 0 } = $$props;
      let { transitionConfig = void 0 } = $$props;
      let { inTransition = void 0 } = $$props;
      let { inTransitionConfig = void 0 } = $$props;
      let { outTransition = void 0 } = $$props;
      let { outTransitionConfig = void 0 } = $$props;
      let { asChild = false } = $$props;
      let { el = void 0 } = $$props;
      const { elements: { overlay }, states: { open }, getAttrs: getAttrs2 } = getCtx$12();
      $$unsubscribe_overlay = subscribe(overlay, (value) => $overlay = value);
      $$unsubscribe_open = subscribe(open, (value) => $open = value);
      const attrs = getAttrs2("overlay");
      if ($$props.transition === void 0 && $$bindings.transition && transition !== void 0)
        $$bindings.transition(transition);
      if ($$props.transitionConfig === void 0 && $$bindings.transitionConfig && transitionConfig !== void 0)
        $$bindings.transitionConfig(transitionConfig);
      if ($$props.inTransition === void 0 && $$bindings.inTransition && inTransition !== void 0)
        $$bindings.inTransition(inTransition);
      if ($$props.inTransitionConfig === void 0 && $$bindings.inTransitionConfig && inTransitionConfig !== void 0)
        $$bindings.inTransitionConfig(inTransitionConfig);
      if ($$props.outTransition === void 0 && $$bindings.outTransition && outTransition !== void 0)
        $$bindings.outTransition(outTransition);
      if ($$props.outTransitionConfig === void 0 && $$bindings.outTransitionConfig && outTransitionConfig !== void 0)
        $$bindings.outTransitionConfig(outTransitionConfig);
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      if ($$props.el === void 0 && $$bindings.el && el !== void 0)
        $$bindings.el(el);
      builder = $overlay;
      {
        Object.assign(builder, attrs);
      }
      $$unsubscribe_overlay();
      $$unsubscribe_open();
      return `${asChild && $open ? `${slots.default ? slots.default({ builder }) : ``}` : `${transition && $open ? `<div${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}></div>` : `${inTransition && outTransition && $open ? `<div${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}></div>` : `${inTransition && $open ? `<div${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}></div>` : `${outTransition && $open ? `<div${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}></div>` : `${$open ? `<div${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}></div>` : ``}`}`}`}`}`}`;
    });
    Alert_dialog_trigger = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let builder;
      let $$restProps = compute_rest_props($$props, ["asChild", "el"]);
      let $trigger, $$unsubscribe_trigger;
      let { asChild = false } = $$props;
      let { el = void 0 } = $$props;
      const { elements: { trigger }, getAttrs: getAttrs2 } = getCtx$12();
      $$unsubscribe_trigger = subscribe(trigger, (value) => $trigger = value);
      createDispatcher();
      const attrs = getAttrs2("trigger");
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      if ($$props.el === void 0 && $$bindings.el && el !== void 0)
        $$bindings.el(el);
      builder = $trigger;
      {
        Object.assign(builder, attrs);
      }
      $$unsubscribe_trigger();
      return `${asChild ? `${slots.default ? slots.default({ builder }) : ``}` : `<button${spread([escape_object(builder), { type: "button" }, escape_object($$restProps)], {})}${add_attribute("this", el, 0)}>${slots.default ? slots.default({ builder }) : ``}</button>`}`;
    });
    Alert_dialog_description$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let builder;
      let $$restProps = compute_rest_props($$props, ["asChild", "id", "el"]);
      let $description, $$unsubscribe_description;
      let { asChild = false } = $$props;
      let { id: id2 = void 0 } = $$props;
      let { el = void 0 } = $$props;
      const { elements: { description }, ids, getAttrs: getAttrs2 } = getCtx$12();
      $$unsubscribe_description = subscribe(description, (value) => $description = value);
      const attrs = getAttrs2("description");
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      if ($$props.id === void 0 && $$bindings.id && id2 !== void 0)
        $$bindings.id(id2);
      if ($$props.el === void 0 && $$bindings.el && el !== void 0)
        $$bindings.el(el);
      {
        if (id2) {
          ids.description.set(id2);
        }
      }
      builder = $description;
      {
        Object.assign(builder, attrs);
      }
      $$unsubscribe_description();
      return `${asChild ? `${slots.default ? slots.default({ builder }) : ``}` : `<div${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}>${slots.default ? slots.default({ builder }) : ``}</div>`}`;
    });
    Separator$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let builder;
      let $$restProps = compute_rest_props($$props, ["orientation", "decorative", "asChild", "el"]);
      let $root, $$unsubscribe_root;
      let { orientation = "horizontal" } = $$props;
      let { decorative = true } = $$props;
      let { asChild = false } = $$props;
      let { el = void 0 } = $$props;
      const { elements: { root }, updateOption, getAttrs: getAttrs2 } = setCtx$12({ orientation, decorative });
      $$unsubscribe_root = subscribe(root, (value) => $root = value);
      const attrs = getAttrs2("root");
      if ($$props.orientation === void 0 && $$bindings.orientation && orientation !== void 0)
        $$bindings.orientation(orientation);
      if ($$props.decorative === void 0 && $$bindings.decorative && decorative !== void 0)
        $$bindings.decorative(decorative);
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      if ($$props.el === void 0 && $$bindings.el && el !== void 0)
        $$bindings.el(el);
      {
        updateOption("orientation", orientation);
      }
      {
        updateOption("decorative", decorative);
      }
      builder = $root;
      {
        Object.assign(builder, attrs);
      }
      $$unsubscribe_root();
      return `${asChild ? `${slots.default ? slots.default({ builder }) : ``}` : `<div${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}></div>`}`;
    });
    Dialog_overlay$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let builder;
      let $$restProps = compute_rest_props($$props, [
        "transition",
        "transitionConfig",
        "inTransition",
        "inTransitionConfig",
        "outTransition",
        "outTransitionConfig",
        "asChild",
        "el"
      ]);
      let $overlay, $$unsubscribe_overlay;
      let $open, $$unsubscribe_open;
      let { transition = void 0 } = $$props;
      let { transitionConfig = void 0 } = $$props;
      let { inTransition = void 0 } = $$props;
      let { inTransitionConfig = void 0 } = $$props;
      let { outTransition = void 0 } = $$props;
      let { outTransitionConfig = void 0 } = $$props;
      let { asChild = false } = $$props;
      let { el = void 0 } = $$props;
      const { elements: { overlay }, states: { open }, getAttrs: getAttrs2 } = getCtx$1();
      $$unsubscribe_overlay = subscribe(overlay, (value) => $overlay = value);
      $$unsubscribe_open = subscribe(open, (value) => $open = value);
      const attrs = getAttrs2("overlay");
      if ($$props.transition === void 0 && $$bindings.transition && transition !== void 0)
        $$bindings.transition(transition);
      if ($$props.transitionConfig === void 0 && $$bindings.transitionConfig && transitionConfig !== void 0)
        $$bindings.transitionConfig(transitionConfig);
      if ($$props.inTransition === void 0 && $$bindings.inTransition && inTransition !== void 0)
        $$bindings.inTransition(inTransition);
      if ($$props.inTransitionConfig === void 0 && $$bindings.inTransitionConfig && inTransitionConfig !== void 0)
        $$bindings.inTransitionConfig(inTransitionConfig);
      if ($$props.outTransition === void 0 && $$bindings.outTransition && outTransition !== void 0)
        $$bindings.outTransition(outTransition);
      if ($$props.outTransitionConfig === void 0 && $$bindings.outTransitionConfig && outTransitionConfig !== void 0)
        $$bindings.outTransitionConfig(outTransitionConfig);
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      if ($$props.el === void 0 && $$bindings.el && el !== void 0)
        $$bindings.el(el);
      builder = $overlay;
      {
        Object.assign(builder, attrs);
      }
      $$unsubscribe_overlay();
      $$unsubscribe_open();
      return `${asChild && $open ? `${slots.default ? slots.default({ builder }) : ``}` : `${transition && $open ? ` <div${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}></div>` : `${inTransition && outTransition && $open ? ` <div${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}></div>` : `${inTransition && $open ? ` <div${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}></div>` : `${outTransition && $open ? ` <div${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}></div>` : `${$open ? ` <div${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}></div>` : ``}`}`}`}`}`}`;
    });
    Popover = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $idValues, $$unsubscribe_idValues;
      let { disableFocusTrap = void 0 } = $$props;
      let { closeOnEscape = void 0 } = $$props;
      let { closeOnOutsideClick = void 0 } = $$props;
      let { preventScroll = void 0 } = $$props;
      let { portal = void 0 } = $$props;
      let { open = void 0 } = $$props;
      let { onOpenChange = void 0 } = $$props;
      let { openFocus = void 0 } = $$props;
      let { closeFocus = void 0 } = $$props;
      let { onOutsideClick = void 0 } = $$props;
      const { updateOption, states: { open: localOpen }, ids } = setCtx2({
        disableFocusTrap,
        closeOnEscape,
        closeOnOutsideClick,
        preventScroll,
        portal,
        defaultOpen: open,
        openFocus,
        closeFocus,
        onOutsideClick,
        onOpenChange: ({ next: next2 }) => {
          if (open !== next2) {
            onOpenChange?.(next2);
            open = next2;
          }
          return next2;
        },
        positioning: { gutter: 0, offset: { mainAxis: 1 } }
      });
      const idValues = derived([ids.content, ids.trigger], ([$contentId, $triggerId]) => ({ content: $contentId, trigger: $triggerId }));
      $$unsubscribe_idValues = subscribe(idValues, (value) => $idValues = value);
      if ($$props.disableFocusTrap === void 0 && $$bindings.disableFocusTrap && disableFocusTrap !== void 0)
        $$bindings.disableFocusTrap(disableFocusTrap);
      if ($$props.closeOnEscape === void 0 && $$bindings.closeOnEscape && closeOnEscape !== void 0)
        $$bindings.closeOnEscape(closeOnEscape);
      if ($$props.closeOnOutsideClick === void 0 && $$bindings.closeOnOutsideClick && closeOnOutsideClick !== void 0)
        $$bindings.closeOnOutsideClick(closeOnOutsideClick);
      if ($$props.preventScroll === void 0 && $$bindings.preventScroll && preventScroll !== void 0)
        $$bindings.preventScroll(preventScroll);
      if ($$props.portal === void 0 && $$bindings.portal && portal !== void 0)
        $$bindings.portal(portal);
      if ($$props.open === void 0 && $$bindings.open && open !== void 0)
        $$bindings.open(open);
      if ($$props.onOpenChange === void 0 && $$bindings.onOpenChange && onOpenChange !== void 0)
        $$bindings.onOpenChange(onOpenChange);
      if ($$props.openFocus === void 0 && $$bindings.openFocus && openFocus !== void 0)
        $$bindings.openFocus(openFocus);
      if ($$props.closeFocus === void 0 && $$bindings.closeFocus && closeFocus !== void 0)
        $$bindings.closeFocus(closeFocus);
      if ($$props.onOutsideClick === void 0 && $$bindings.onOutsideClick && onOutsideClick !== void 0)
        $$bindings.onOutsideClick(onOutsideClick);
      open !== void 0 && localOpen.set(open);
      {
        updateOption("disableFocusTrap", disableFocusTrap);
      }
      {
        updateOption("closeOnEscape", closeOnEscape);
      }
      {
        updateOption("closeOnOutsideClick", closeOnOutsideClick);
      }
      {
        updateOption("preventScroll", preventScroll);
      }
      {
        updateOption("portal", portal);
      }
      {
        updateOption("openFocus", openFocus);
      }
      {
        updateOption("closeFocus", closeFocus);
      }
      {
        updateOption("onOutsideClick", onOutsideClick);
      }
      $$unsubscribe_idValues();
      return `${slots.default ? slots.default({ ids: $idValues }) : ``}`;
    });
    Popover_content$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let builder;
      let $$restProps = compute_rest_props($$props, [
        "transition",
        "transitionConfig",
        "inTransition",
        "inTransitionConfig",
        "outTransition",
        "outTransitionConfig",
        "asChild",
        "id",
        "side",
        "align",
        "sideOffset",
        "alignOffset",
        "collisionPadding",
        "avoidCollisions",
        "collisionBoundary",
        "sameWidth",
        "fitViewport",
        "strategy",
        "overlap",
        "el"
      ]);
      let $open, $$unsubscribe_open;
      let $content, $$unsubscribe_content;
      let { transition = void 0 } = $$props;
      let { transitionConfig = void 0 } = $$props;
      let { inTransition = void 0 } = $$props;
      let { inTransitionConfig = void 0 } = $$props;
      let { outTransition = void 0 } = $$props;
      let { outTransitionConfig = void 0 } = $$props;
      let { asChild = false } = $$props;
      let { id: id2 = void 0 } = $$props;
      let { side = "bottom" } = $$props;
      let { align = "center" } = $$props;
      let { sideOffset = 0 } = $$props;
      let { alignOffset = 0 } = $$props;
      let { collisionPadding = 8 } = $$props;
      let { avoidCollisions = true } = $$props;
      let { collisionBoundary = void 0 } = $$props;
      let { sameWidth = false } = $$props;
      let { fitViewport = false } = $$props;
      let { strategy = "absolute" } = $$props;
      let { overlap = false } = $$props;
      let { el = void 0 } = $$props;
      const { elements: { content }, states: { open }, ids, getAttrs: getAttrs2 } = getCtx3();
      $$unsubscribe_content = subscribe(content, (value) => $content = value);
      $$unsubscribe_open = subscribe(open, (value) => $open = value);
      const attrs = getAttrs2("content");
      if ($$props.transition === void 0 && $$bindings.transition && transition !== void 0)
        $$bindings.transition(transition);
      if ($$props.transitionConfig === void 0 && $$bindings.transitionConfig && transitionConfig !== void 0)
        $$bindings.transitionConfig(transitionConfig);
      if ($$props.inTransition === void 0 && $$bindings.inTransition && inTransition !== void 0)
        $$bindings.inTransition(inTransition);
      if ($$props.inTransitionConfig === void 0 && $$bindings.inTransitionConfig && inTransitionConfig !== void 0)
        $$bindings.inTransitionConfig(inTransitionConfig);
      if ($$props.outTransition === void 0 && $$bindings.outTransition && outTransition !== void 0)
        $$bindings.outTransition(outTransition);
      if ($$props.outTransitionConfig === void 0 && $$bindings.outTransitionConfig && outTransitionConfig !== void 0)
        $$bindings.outTransitionConfig(outTransitionConfig);
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      if ($$props.id === void 0 && $$bindings.id && id2 !== void 0)
        $$bindings.id(id2);
      if ($$props.side === void 0 && $$bindings.side && side !== void 0)
        $$bindings.side(side);
      if ($$props.align === void 0 && $$bindings.align && align !== void 0)
        $$bindings.align(align);
      if ($$props.sideOffset === void 0 && $$bindings.sideOffset && sideOffset !== void 0)
        $$bindings.sideOffset(sideOffset);
      if ($$props.alignOffset === void 0 && $$bindings.alignOffset && alignOffset !== void 0)
        $$bindings.alignOffset(alignOffset);
      if ($$props.collisionPadding === void 0 && $$bindings.collisionPadding && collisionPadding !== void 0)
        $$bindings.collisionPadding(collisionPadding);
      if ($$props.avoidCollisions === void 0 && $$bindings.avoidCollisions && avoidCollisions !== void 0)
        $$bindings.avoidCollisions(avoidCollisions);
      if ($$props.collisionBoundary === void 0 && $$bindings.collisionBoundary && collisionBoundary !== void 0)
        $$bindings.collisionBoundary(collisionBoundary);
      if ($$props.sameWidth === void 0 && $$bindings.sameWidth && sameWidth !== void 0)
        $$bindings.sameWidth(sameWidth);
      if ($$props.fitViewport === void 0 && $$bindings.fitViewport && fitViewport !== void 0)
        $$bindings.fitViewport(fitViewport);
      if ($$props.strategy === void 0 && $$bindings.strategy && strategy !== void 0)
        $$bindings.strategy(strategy);
      if ($$props.overlap === void 0 && $$bindings.overlap && overlap !== void 0)
        $$bindings.overlap(overlap);
      if ($$props.el === void 0 && $$bindings.el && el !== void 0)
        $$bindings.el(el);
      {
        if (id2) {
          ids.content.set(id2);
        }
      }
      builder = $content;
      {
        Object.assign(builder, attrs);
      }
      {
        if ($open) {
          updatePositioning2({
            side,
            align,
            sideOffset,
            alignOffset,
            collisionPadding,
            avoidCollisions,
            collisionBoundary,
            sameWidth,
            fitViewport,
            strategy,
            overlap
          });
        }
      }
      $$unsubscribe_open();
      $$unsubscribe_content();
      return `${asChild && $open ? `${slots.default ? slots.default({ builder }) : ``}` : `${transition && $open ? `<div${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}>${slots.default ? slots.default({ builder }) : ``}</div>` : `${inTransition && outTransition && $open ? `<div${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}>${slots.default ? slots.default({ builder }) : ``}</div>` : `${inTransition && $open ? `<div${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}>${slots.default ? slots.default({ builder }) : ``}</div>` : `${outTransition && $open ? `<div${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}>${slots.default ? slots.default({ builder }) : ``}</div>` : `${$open ? `<div${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}>${slots.default ? slots.default({ builder }) : ``}</div>` : ``}`}`}`}`}`}`;
    });
    Popover_trigger = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let attrs;
      let builder;
      let $$restProps = compute_rest_props($$props, ["asChild", "id", "el"]);
      let $trigger, $$unsubscribe_trigger;
      let $open, $$unsubscribe_open;
      let { asChild = false } = $$props;
      let { id: id2 = void 0 } = $$props;
      let { el = void 0 } = $$props;
      const { elements: { trigger }, states: { open }, ids, getAttrs: getAttrs2 } = getCtx3();
      $$unsubscribe_trigger = subscribe(trigger, (value) => $trigger = value);
      $$unsubscribe_open = subscribe(open, (value) => $open = value);
      createDispatcher();
      const bitsAttrs = getAttrs2("trigger");
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      if ($$props.id === void 0 && $$bindings.id && id2 !== void 0)
        $$bindings.id(id2);
      if ($$props.el === void 0 && $$bindings.el && el !== void 0)
        $$bindings.el(el);
      {
        if (id2) {
          ids.trigger.set(id2);
        }
      }
      attrs = {
        ...bitsAttrs,
        "aria-controls": $open ? ids.content : void 0
      };
      builder = $trigger;
      {
        Object.assign(builder, attrs);
      }
      $$unsubscribe_trigger();
      $$unsubscribe_open();
      return `${asChild ? `${slots.default ? slots.default({ builder }) : ``}` : `<button${spread([escape_object(builder), { type: "button" }, escape_object($$restProps)], {})}${add_attribute("this", el, 0)}>${slots.default ? slots.default({ builder }) : ``}</button>`}`;
    });
    Popover_content = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class", "transition", "transitionConfig", "align", "sideOffset"]);
      let { class: className = void 0 } = $$props;
      let { transition = flyAndScale } = $$props;
      let { transitionConfig = void 0 } = $$props;
      let { align = "center" } = $$props;
      let { sideOffset = 4 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.transition === void 0 && $$bindings.transition && transition !== void 0)
        $$bindings.transition(transition);
      if ($$props.transitionConfig === void 0 && $$bindings.transitionConfig && transitionConfig !== void 0)
        $$bindings.transitionConfig(transitionConfig);
      if ($$props.align === void 0 && $$bindings.align && align !== void 0)
        $$bindings.align(align);
      if ($$props.sideOffset === void 0 && $$bindings.sideOffset && sideOffset !== void 0)
        $$bindings.sideOffset(sideOffset);
      return `${validate_component(Popover_content$1, "PopoverPrimitive.Content").$$render(
        $$result,
        Object.assign({}, { transition }, { transitionConfig }, { align }, { sideOffset }, $$restProps, {
          class: cn("z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none", className)
        }),
        {},
        {
          default: () => {
            return `${slots.default ? slots.default({}) : ``}`;
          }
        }
      )}`;
    });
    Root$12 = Popover;
    Trigger$1 = Popover_trigger;
    CommandSeparator = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["alwaysRender", "asChild"]);
      let $render, $$unsubscribe_render;
      let { alwaysRender = false } = $$props;
      let { asChild = false } = $$props;
      const state = getState();
      const render = derived(state, ($state) => !$state.search);
      $$unsubscribe_render = subscribe(render, (value) => $render = value);
      const attrs = {
        "data-cmdk-separator": "",
        role: "separator"
      };
      if ($$props.alwaysRender === void 0 && $$bindings.alwaysRender && alwaysRender !== void 0)
        $$bindings.alwaysRender(alwaysRender);
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      $$unsubscribe_render();
      return `${$render || alwaysRender ? `${asChild ? `${slots.default ? slots.default({ attrs }) : ``}` : `<div${spread([escape_object(attrs), escape_object($$restProps)], {})}></div>`}` : ``}`;
    });
    Dialog_overlay = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class", "transition", "transitionConfig"]);
      let { class: className = void 0 } = $$props;
      let { transition = fade } = $$props;
      let { transitionConfig = { duration: 150 } } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.transition === void 0 && $$bindings.transition && transition !== void 0)
        $$bindings.transition(transition);
      if ($$props.transitionConfig === void 0 && $$bindings.transitionConfig && transitionConfig !== void 0)
        $$bindings.transitionConfig(transitionConfig);
      return `${validate_component(Dialog_overlay$1, "DialogPrimitive.Overlay").$$render(
        $$result,
        Object.assign(
          {},
          { transition },
          { transitionConfig },
          {
            class: cn("fixed inset-0 bg-background/80 ", className)
          },
          $$restProps
        ),
        {},
        {}
      )}`;
    });
    Command_separator = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class"]);
      let { class: className = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      return `${validate_component(CommandSeparator, "CommandPrimitive.Separator").$$render(
        $$result,
        Object.assign(
          {},
          {
            class: cn("-mx-1 h-px bg-border", className)
          },
          $$restProps
        ),
        {},
        {}
      )}`;
    });
    Separator = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class", "orientation", "decorative"]);
      let { class: className = void 0 } = $$props;
      let { orientation = "horizontal" } = $$props;
      let { decorative = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.orientation === void 0 && $$bindings.orientation && orientation !== void 0)
        $$bindings.orientation(orientation);
      if ($$props.decorative === void 0 && $$bindings.decorative && decorative !== void 0)
        $$bindings.decorative(decorative);
      return `${validate_component(Separator$1, "SeparatorPrimitive.Root").$$render(
        $$result,
        Object.assign(
          {},
          {
            class: cn(
              "shrink-0 bg-border",
              orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
              className
            )
          },
          { orientation },
          { decorative },
          $$restProps
        ),
        {},
        {}
      )}`;
    });
    Sidebar_project_dialog = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let selectedType;
      let disabled;
      let $$restProps = compute_rest_props($$props, ["projectForm", "params"]);
      let $formData, $$unsubscribe_formData;
      let { projectForm } = $$props;
      let { params } = $$props;
      let open = false;
      const form = superForm(projectForm, { validators: zodClient(projectSchema) });
      const { form: formData, enhance: enhance2 } = form;
      $$unsubscribe_formData = subscribe(formData, (value) => $formData = value);
      if ($$props.projectForm === void 0 && $$bindings.projectForm && projectForm !== void 0)
        $$bindings.projectForm(projectForm);
      if ($$props.params === void 0 && $$bindings.params && params !== void 0)
        $$bindings.params(params);
      let $$settled;
      let $$rendered;
      let previous_head = $$result.head;
      do {
        $$settled = true;
        $$result.head = previous_head;
        selectedType = $formData.type ? {
          label: $formData.type,
          value: $formData.type
        } : void 0;
        disabled = $formData.type !== "renovasi" && $formData.type !== "konstruksi" || $formData.name?.length <= 0;
        $$rendered = `${validate_component(Root$1, "Dialog.Root").$$render(
          $$result,
          {
            closeOnEscape: false,
            closeOnOutsideClick: false,
            onOpenChange: () => {
              $formData.name = "";
              $formData.type = "";
            },
            open
          },
          {
            open: ($$value) => {
              open = $$value;
              $$settled = false;
            }
          },
          {
            default: () => {
              return `${validate_component(Trigger, "Dialog.Trigger").$$render($$result, { class: $$restProps.class }, {}, {
                default: () => {
                  return `${validate_component(Plus, "Plus").$$render($$result, { class: "h-4 w-4" }, {}, {})}`;
                }
              })} ${validate_component(Dialog_overlay, "Dialog.Overlay").$$render(
                $$result,
                {
                  class: "fixed inset-0 z-30 bg-background/50 "
                },
                {},
                {}
              )} ${validate_component(Dialog_content, "Dialog.Content").$$render(
                $$result,
                {
                  class: "z-[60] w-screen border-none bg-card px-8 py-6"
                },
                {},
                {
                  default: () => {
                    return ` <form method="POST" action="${"/" + escape(params, true) + "?/create"}" class="space-y-4">${validate_component(Form_field, "Form.Field").$$render($$result, { form, name: "name" }, {}, {
                      default: () => {
                        return `${validate_component(Control, "Form.Control").$$render($$result, {}, {}, {
                          default: ({ attrs }) => {
                            return `${validate_component(Form_label, "Form.Label").$$render($$result, {}, {}, {
                              default: () => {
                                return `Nama Proyek`;
                              }
                            })} ${validate_component(Input, "Input").$$render(
                              $$result,
                              Object.assign({}, attrs, { autocomplete: "off" }, { value: $formData.name }),
                              {
                                value: ($$value) => {
                                  $formData.name = $$value;
                                  $$settled = false;
                                }
                              },
                              {}
                            )}`;
                          }
                        })}`;
                      }
                    })} ${validate_component(Form_field, "Form.Field").$$render($$result, { form, name: "type" }, {}, {
                      default: () => {
                        return `${validate_component(Control, "Form.Control").$$render($$result, {}, {}, {
                          default: ({ attrs }) => {
                            return `${validate_component(Form_label, "Form.Label").$$render($$result, {}, {}, {
                              default: () => {
                                return `Tipe`;
                              }
                            })} ${validate_component(Root2, "Select.Root").$$render(
                              $$result,
                              {
                                selected: selectedType,
                                onSelectedChange: (v3) => {
                                  v3 && ($formData.type = v3.value);
                                }
                              },
                              {},
                              {
                                default: () => {
                                  return `${validate_component(Select_trigger, "Select.Trigger").$$render($$result, Object.assign({}, attrs), {}, {
                                    default: () => {
                                      return `${validate_component(Value, "Select.Value").$$render(
                                        $$result,
                                        {
                                          placeholder: "Select Type",
                                          class: "capitalize"
                                        },
                                        {},
                                        {}
                                      )}`;
                                    }
                                  })} ${validate_component(Select_content, "Select.Content").$$render($$result, {}, {}, {
                                    default: () => {
                                      return `${validate_component(Select_item, "Select.Item").$$render($$result, { value: "konstruksi", label: "Konstruksi" }, {}, {
                                        default: () => {
                                          return `Konstruksi`;
                                        }
                                      })} ${validate_component(Select_item, "Select.Item").$$render($$result, { value: "renovasi", label: "Renovasi" }, {}, {
                                        default: () => {
                                          return `Renovasi`;
                                        }
                                      })}`;
                                    }
                                  })}`;
                                }
                              }
                            )} <input hidden${add_attribute("name", attrs.name, 0)}${add_attribute("value", $formData.type, 0)}>`;
                          }
                        })}`;
                      }
                    })} <div class="flex justify-end gap-2 pt-10">${validate_component(Button, "Button").$$render(
                      $$result,
                      {
                        variant: "outline",
                        class: "bg-transparent"
                      },
                      {},
                      {
                        default: () => {
                          return `Batalkan`;
                        }
                      }
                    )} ${validate_component(Form_button, "Form.Button").$$render(
                      $$result,
                      { class: "text-secondary", disabled },
                      {
                        disabled: ($$value) => {
                          disabled = $$value;
                          $$settled = false;
                        }
                      },
                      {
                        default: () => {
                          return `Tambah Proyek`;
                        }
                      }
                    )}</div></form> `;
                  }
                }
              )}`;
            }
          }
        )}`;
      } while (!$$settled);
      $$unsubscribe_formData();
      return $$rendered;
    });
    Alert_dialog_title = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class", "level"]);
      let { class: className = void 0 } = $$props;
      let { level = "h3" } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.level === void 0 && $$bindings.level && level !== void 0)
        $$bindings.level(level);
      return `${validate_component(Alert_dialog_title$1, "AlertDialogPrimitive.Title").$$render(
        $$result,
        Object.assign(
          {},
          {
            class: cn("text-lg font-semibold", className)
          },
          { level },
          $$restProps
        ),
        {},
        {
          default: () => {
            return `${slots.default ? slots.default({}) : ``}`;
          }
        }
      )}`;
    });
    Alert_dialog_action = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class"]);
      let { class: className = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      return `${validate_component(Alert_dialog_action$1, "AlertDialogPrimitive.Action").$$render($$result, Object.assign({}, { class: cn(buttonVariants(), className) }, $$restProps), {}, {
        default: ({ builder }) => {
          return `${slots.default ? slots.default({ builder }) : ``}`;
        }
      })}`;
    });
    Alert_dialog_cancel = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class"]);
      let { class: className = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      return `${validate_component(Alert_dialog_cancel$1, "AlertDialogPrimitive.Cancel").$$render(
        $$result,
        Object.assign(
          {},
          {
            class: cn(buttonVariants({ variant: "outline" }), "mt-2 sm:mt-0", className)
          },
          $$restProps
        ),
        {},
        {
          default: ({ builder }) => {
            return `${slots.default ? slots.default({ builder }) : ``}`;
          }
        }
      )}`;
    });
    Alert_dialog_portal = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, []);
      return `${validate_component(Alert_dialog_portal$1, "AlertDialogPrimitive.Portal").$$render($$result, Object.assign({}, $$restProps), {}, {
        default: () => {
          return `${slots.default ? slots.default({}) : ``}`;
        }
      })}`;
    });
    Alert_dialog_footer = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class"]);
      let { class: className = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      return `<div${spread(
        [
          {
            class: escape_attribute_value(cn("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2", className))
          },
          escape_object($$restProps)
        ],
        {}
      )}>${slots.default ? slots.default({}) : ``}</div>`;
    });
    Alert_dialog_header = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class"]);
      let { class: className = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      return `<div${spread(
        [
          {
            class: escape_attribute_value(cn("flex flex-col space-y-2 text-center sm:text-left", className))
          },
          escape_object($$restProps)
        ],
        {}
      )}>${slots.default ? slots.default({}) : ``}</div>`;
    });
    Alert_dialog_overlay = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class", "transition", "transitionConfig"]);
      let { class: className = void 0 } = $$props;
      let { transition = fade } = $$props;
      let { transitionConfig = { duration: 150 } } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.transition === void 0 && $$bindings.transition && transition !== void 0)
        $$bindings.transition(transition);
      if ($$props.transitionConfig === void 0 && $$bindings.transitionConfig && transitionConfig !== void 0)
        $$bindings.transitionConfig(transitionConfig);
      return `${validate_component(Alert_dialog_overlay$1, "AlertDialogPrimitive.Overlay").$$render(
        $$result,
        Object.assign(
          {},
          { transition },
          { transitionConfig },
          {
            class: cn("fixed inset-0 z-50 bg-background/50 backdrop-blur-sm", className)
          },
          $$restProps
        ),
        {},
        {}
      )}`;
    });
    Alert_dialog_content = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class", "transition", "transitionConfig"]);
      let { class: className = void 0 } = $$props;
      let { transition = flyAndScale } = $$props;
      let { transitionConfig = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.transition === void 0 && $$bindings.transition && transition !== void 0)
        $$bindings.transition(transition);
      if ($$props.transitionConfig === void 0 && $$bindings.transitionConfig && transitionConfig !== void 0)
        $$bindings.transitionConfig(transitionConfig);
      return `${validate_component(Alert_dialog_portal, "AlertDialog.Portal").$$render($$result, {}, {}, {
        default: () => {
          return `${validate_component(Alert_dialog_overlay, "AlertDialog.Overlay").$$render($$result, {}, {}, {})} ${validate_component(Alert_dialog_content$1, "AlertDialogPrimitive.Content").$$render(
            $$result,
            Object.assign(
              {},
              { transition },
              { transitionConfig },
              {
                class: cn("fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg  sm:rounded-lg md:w-full", className)
              },
              $$restProps
            ),
            {},
            {
              default: () => {
                return `${slots.default ? slots.default({}) : ``}`;
              }
            }
          )}`;
        }
      })}`;
    });
    Alert_dialog_description = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class"]);
      let { class: className = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      return `${validate_component(Alert_dialog_description$1, "AlertDialogPrimitive.Description").$$render(
        $$result,
        Object.assign(
          {},
          {
            class: cn("text-sm text-muted-foreground", className)
          },
          $$restProps
        ),
        {},
        {
          default: () => {
            return `${slots.default ? slots.default({}) : ``}`;
          }
        }
      )}`;
    });
    Root3 = Alert_dialog;
    Trigger2 = Alert_dialog_trigger;
    Sidebar_project_list = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$unsubscribe_formData;
      let { deleteProjectForm } = $$props;
      let { projects } = $$props;
      let { open } = $$props;
      let { params } = $$props;
      let { value } = $$props;
      const form = superForm(deleteProjectForm, {
        validators: zodClient(deleteProjectSchema)
      });
      const { form: formData, enhance: enhance2 } = form;
      $$unsubscribe_formData = subscribe(formData, (value2) => value2);
      if ($$props.deleteProjectForm === void 0 && $$bindings.deleteProjectForm && deleteProjectForm !== void 0)
        $$bindings.deleteProjectForm(deleteProjectForm);
      if ($$props.projects === void 0 && $$bindings.projects && projects !== void 0)
        $$bindings.projects(projects);
      if ($$props.open === void 0 && $$bindings.open && open !== void 0)
        $$bindings.open(open);
      if ($$props.params === void 0 && $$bindings.params && params !== void 0)
        $$bindings.params(params);
      if ($$props.value === void 0 && $$bindings.value && value !== void 0)
        $$bindings.value(value);
      $$unsubscribe_formData();
      return `${each(projects, (project) => {
        return ` ${project.startsWith(value.toLowerCase()) ? `${validate_component(Command_item, "CommandItem").$$render(
          $$result,
          {
            class: "flex h-10 p-0 capitalize",
            value: project,
            onSelect: (value2) => {
              {
                return;
              }
            }
          },
          {},
          {
            default: () => {
              return `<button class="flex h-full flex-1 cursor-default items-center pl-2 text-left capitalize">${validate_component(Check$1, "Check").$$render(
                $$result,
                {
                  class: cn("mr-2 h-4 w-4", params !== project && "text-transparent")
                },
                {},
                {}
              )} <span class="flex-1 truncate">${escape(project)}</span></button> ${validate_component(Root3, "AlertDialog.Root").$$render($$result, {}, {}, {
                default: () => {
                  return `${validate_component(Trigger2, "AlertDialog.Trigger").$$render($$result, { asChild: true }, {}, {
                    default: ({ builder }) => {
                      return `${validate_component(Button, "Button").$$render(
                        $$result,
                        {
                          variant: "ghost",
                          size: "sm",
                          type: "submit",
                          class: "hover:bg-transparent hover:text-destructive",
                          builders: [builder]
                        },
                        {},
                        {
                          default: () => {
                            return `${validate_component(Trash, "Trash").$$render($$result, { class: "h-3.5 w-3.5" }, {}, {})} `;
                          }
                        }
                      )} `;
                    }
                  })}  ${validate_component(Alert_dialog_content, "AlertDialog.Content").$$render($$result, { class: "bg-card" }, {}, {
                    default: () => {
                      return `${validate_component(Alert_dialog_header, "AlertDialog.Header").$$render($$result, {}, {}, {
                        default: () => {
                          return `${validate_component(Alert_dialog_title, "AlertDialog.Title").$$render($$result, {}, {}, {
                            default: () => {
                              return `Are you absolutely sure?`;
                            }
                          })} ${validate_component(Alert_dialog_description, "AlertDialog.Description").$$render($$result, {}, {}, {
                            default: () => {
                              return `This action cannot be undone. This will permanently delete the project.
						`;
                            }
                          })} `;
                        }
                      })} ${validate_component(Alert_dialog_footer, "AlertDialog.Footer").$$render($$result, {}, {}, {
                        default: () => {
                          return `${validate_component(Alert_dialog_cancel, "AlertDialog.Cancel").$$render($$result, { class: "bg-transparent" }, {}, {
                            default: () => {
                              return `Cancel`;
                            }
                          })} <form method="POST" action="/banjar?/delete">${validate_component(Form_field, "Form.Field").$$render($$result, { form, name: "name", class: "hidden" }, {}, {
                            default: () => {
                              return `${validate_component(Control, "Form.Control").$$render($$result, {}, {}, {
                                default: ({ attrs }) => {
                                  return `<input${spread([escape_object(attrs), { autocomplete: "off" }], {})}${add_attribute("value", project, 0)}> `;
                                }
                              })} `;
                            }
                          })} ${validate_component(Alert_dialog_action, "AlertDialog.Action").$$render(
                            $$result,
                            {
                              type: "submit",
                              class: "w-full bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90"
                            },
                            {},
                            {
                              default: () => {
                                return `Continue
							`;
                              }
                            }
                          )}</form> `;
                        }
                      })} `;
                    }
                  })} `;
                }
              })} `;
            }
          }
        )}` : ``}`;
      })}`;
    });
    Sidebar = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let params;
      let $$restProps = compute_rest_props($$props, ["data", "isMobileOpen"]);
      let $page, $$unsubscribe_page;
      let $delayed, $$unsubscribe_delayed;
      $$unsubscribe_page = subscribe(page, (value2) => $page = value2);
      let { data: data2 } = $$props;
      let { isMobileOpen } = $$props;
      let value = "";
      let open = false;
      const form = superForm(data2.logoutForm, {
        validators: zodClient(logoutSchema),
        delayMs: 250
      });
      const { delayed, enhance: enhance2 } = form;
      $$unsubscribe_delayed = subscribe(delayed, (value2) => $delayed = value2);
      if ($$props.data === void 0 && $$bindings.data && data2 !== void 0)
        $$bindings.data(data2);
      if ($$props.isMobileOpen === void 0 && $$bindings.isMobileOpen && isMobileOpen !== void 0)
        $$bindings.isMobileOpen(isMobileOpen);
      let $$settled;
      let $$rendered;
      let previous_head = $$result.head;
      do {
        $$settled = true;
        $$result.head = previous_head;
        params = $page.params.project;
        $$rendered = `<aside class="${[escape($$restProps.class, true), isMobileOpen ? "translate-x-0" : ""].join(" ").trim()}"><nav class="space-y-2 py-6"><div class="relative mb-4 w-full px-2">${validate_component(Root$12, "Popover.Root").$$render(
          $$result,
          { open },
          {
            open: ($$value) => {
              open = $$value;
              $$settled = false;
            }
          },
          {
            default: () => {
              return `${validate_component(Trigger$1, "Popover.Trigger").$$render($$result, { asChild: true }, {}, {
                default: ({ builder }) => {
                  return `${validate_component(Button, "Button").$$render(
                    $$result,
                    {
                      builders: [builder],
                      variant: "outline",
                      class: "w-full items-center justify-between rounded-sm border-none px-4 capitalize text-foreground focus-visible:ring-2"
                    },
                    {},
                    {
                      default: () => {
                        return `${escape(params)} ${validate_component(ChevronDown$1, "ChevronDown").$$render($$result, {}, {}, {})}`;
                      }
                    }
                  )}`;
                }
              })}  ${validate_component(Popover_content, "Popover.Content").$$render($$result, { class: "w-60 rounded-lg bg-card p-0" }, {}, {
                default: () => {
                  return `${validate_component(Command, "Command.Root").$$render(
                    $$result,
                    {
                      shouldFilter: false,
                      class: "rounded-lg bg-card p-0 shadow-lg"
                    },
                    {},
                    {
                      default: () => {
                        return `${validate_component(Command_input, "Command.Input").$$render(
                          $$result,
                          {
                            placeholder: "Cari Proyek...",
                            class: "h-10",
                            value
                          },
                          {
                            value: ($$value) => {
                              value = $$value;
                              $$settled = false;
                            }
                          },
                          {}
                        )} ${validate_component(Command_separator, "Command.Separator").$$render($$result, { alwaysRender: true }, {}, {})} ${validate_component(Command_empty, "Command.Empty").$$render($$result, {}, {}, {
                          default: () => {
                            return `No project found.`;
                          }
                        })} ${validate_component(Command_group, "Command.Group").$$render($$result, { class: "max-h-[70vh] overflow-y-auto" }, {}, {
                          default: () => {
                            return `${validate_component(Sidebar_project_list, "SidebarProjectList").$$render(
                              $$result,
                              {
                                params,
                                projects: data2.projects || [],
                                deleteProjectForm: data2.deleteProjectForm,
                                value,
                                open
                              },
                              {
                                value: ($$value) => {
                                  value = $$value;
                                  $$settled = false;
                                },
                                open: ($$value) => {
                                  open = $$value;
                                  $$settled = false;
                                }
                              },
                              {}
                            )} ${validate_component(Command_separator, "Command.Separator").$$render($$result, { class: "my-1" }, {}, {})} ${value === "" ? `${validate_component(Command_item, "Command.Item").$$render($$result, { class: "flex h-8 bg-accent p-0" }, {}, {
                              default: () => {
                                return `${validate_component(Sidebar_project_dialog, "SidebarProjectDialog").$$render(
                                  $$result,
                                  {
                                    params,
                                    projectForm: data2.projectForm,
                                    class: "flex h-full flex-1 cursor-pointer items-center justify-center rounded-md p-0"
                                  },
                                  {},
                                  {}
                                )}`;
                              }
                            })}` : ``}`;
                          }
                        })}`;
                      }
                    }
                  )}`;
                }
              })}`;
            }
          }
        )}</div> <ul class="space-y-1 px-2 font-medium">${each(sidebarItems, ({ Icon, label, href }) => {
          return `<li>${validate_component(Button, "Button").$$render(
            $$result,
            {
              href,
              variant: $page.url.pathname.endsWith(href) ? "default" : "ghost",
              class: "flex w-full rounded-full px-6 focus-visible:ring-2"
            },
            {},
            {
              default: () => {
                return `${validate_component(Icon, "Icon").$$render($$result, { class: "h-5 w-5" }, {}, {})} <span class="ms-4 flex flex-1 items-center truncate">${escape(label)}</span> `;
              }
            }
          )} </li>`;
        })}</ul> <div class="px-2">${validate_component(Separator, "Separator").$$render($$result, {}, {}, {})}</div> <div class="px-2"><form method="POST" action="${"/" + escape(params, true) + "?/logout"}">${validate_component(Form_button, "Form.Button").$$render(
          $$result,
          {
            variant: "ghost",
            class: "flex w-full rounded-full px-6 focus-visible:ring-2",
            disabled: $delayed
          },
          {},
          {
            default: () => {
              return `${$delayed ? `${validate_component(Spinners, "Spinner").$$render($$result, { class: "h-5 w-5 animate-spin" }, {}, {})}` : `${validate_component(Log_out, "LogOut").$$render($$result, { class: "h-5 w-5" }, {}, {})}`} <span class="ms-4 flex flex-1 items-center truncate" data-svelte-h="svelte-1olomt0">Log Out</span>`;
            }
          }
        )}</form></div></nav></aside>`;
      } while (!$$settled);
      $$unsubscribe_page();
      $$unsubscribe_delayed();
      return $$rendered;
    });
    Header = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["isMobileOpen"]);
      let { isMobileOpen } = $$props;
      if ($$props.isMobileOpen === void 0 && $$bindings.isMobileOpen && isMobileOpen !== void 0)
        $$bindings.isMobileOpen(isMobileOpen);
      return `<header${add_attribute("class", $$restProps.class, 0)}>${validate_component(Button, "Button").$$render(
        $$result,
        {
          variant: "ghost",
          class: "inline-flex h-fit items-center rounded-lg p-2 text-sm"
        },
        {},
        {
          default: () => {
            return `${validate_component(Hamburger, "Hamburger").$$render($$result, { class: "h-5 w-5" }, {}, {})} <span class="ms-3" data-svelte-h="svelte-f6bvaw">Menu</span>`;
          }
        }
      )} ${validate_component(Mode_toggle, "ModeToggle").$$render($$result, { class: "inline-flex" }, {}, {})}</header>`;
    });
    Layout2 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { data: data2 } = $$props;
      let isMobileOpen = false;
      if ($$props.data === void 0 && $$bindings.data && data2 !== void 0)
        $$bindings.data(data2);
      let $$settled;
      let $$rendered;
      let previous_head = $$result.head;
      do {
        $$settled = true;
        $$result.head = previous_head;
        $$rendered = `${validate_component(Sidebar, "Sidebar").$$render(
          $$result,
          {
            data: data2,
            class: "fixed left-0 top-0 z-40 h-screen w-64 max-w-[80%] -translate-x-full border-r bg-navbar shadow-md transition-transform duration-300 dark:border-none md:translate-x-0",
            isMobileOpen
          },
          {
            isMobileOpen: ($$value) => {
              isMobileOpen = $$value;
              $$settled = false;
            }
          },
          {}
        )} ${validate_component(Header, "Header").$$render(
          $$result,
          {
            class: "sticky top-0 z-10 flex items-center px-2 py-1.5 shadow backdrop-blur md:hidden md:px-4",
            isMobileOpen
          },
          {
            isMobileOpen: ($$value) => {
              isMobileOpen = $$value;
              $$settled = false;
            }
          },
          {}
        )} <main id="main-content" class="p-4 sm:p-6 md:ml-64"><button${add_attribute("class", cn("invisible fixed inset-0 z-30 block bg-background/80 opacity-0 backdrop-blur-sm transition-all duration-300", isMobileOpen && "visible opacity-100"), 0)}></button> ${slots.default ? slots.default({}) : ``}</main>`;
      } while (!$$settled);
      return $$rendered;
    });
  }
});
var __exports3 = {};
__export(__exports3, {
  component: () => component3,
  fonts: () => fonts3,
  imports: () => imports3,
  index: () => index3,
  server: () => layout_server_ts_exports2,
  server_id: () => server_id2,
  stylesheets: () => stylesheets3
});
var index3;
var component_cache3;
var component3;
var server_id2;
var imports3;
var stylesheets3;
var fonts3;
var init__3 = __esm({
  ".svelte-kit/output/server/nodes/2.js"() {
    init_layout_server_ts2();
    index3 = 2;
    component3 = async () => component_cache3 ??= (await Promise.resolve().then(() => (init_layout_svelte2(), layout_svelte_exports2))).default;
    server_id2 = "src/routes/(dashboard)/+layout.server.ts";
    imports3 = ["_app/immutable/nodes/2.vN7IOAhM.js", "_app/immutable/chunks/scheduler.Cglc-E-6.js", "_app/immutable/chunks/index.9iPnfnGV.js", "_app/immutable/chunks/index.BALLBs5G.js", "_app/immutable/chunks/index.C4PciY-_.js", "_app/immutable/chunks/each.Dtgx6mEA.js", "_app/immutable/chunks/stores.-qfiZ27n.js", "_app/immutable/chunks/entry.BIRdqJCX.js", "_app/immutable/chunks/index.BMlfrsHg.js", "_app/immutable/chunks/_commonjsHelpers.Cpj98o6Y.js", "_app/immutable/chunks/input.CyNn_tG7.js", "_app/immutable/chunks/index.BlvzRe2p.js", "_app/immutable/chunks/command-input.CeEokZ8F.js", "_app/immutable/chunks/MagnifyingGlass.1BoxrdsM.js", "_app/immutable/chunks/mode-toggle.Cs9G0DsI.js", "_app/immutable/chunks/mode.BQ9atwLW.js"];
    stylesheets3 = ["_app/immutable/assets/index.Bi8DJf9Z.css"];
    fonts3 = [];
  }
});
var error_svelte_exports2 = {};
__export(error_svelte_exports2, {
  default: () => Error3
});
var Error3;
var init_error_svelte2 = __esm({
  ".svelte-kit/output/server/entries/pages/(dashboard)/_error.svelte.js"() {
    init_lifecycle();
    init_ssr();
    init_stores2();
    Error3 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $page, $$unsubscribe_page;
      $$unsubscribe_page = subscribe(page, (value) => $page = value);
      $$unsubscribe_page();
      return `<h1>${escape($page.status)}: ${escape($page.error?.message)}</h1>`;
    });
  }
});
var __exports4 = {};
__export(__exports4, {
  component: () => component4,
  fonts: () => fonts4,
  imports: () => imports4,
  index: () => index4,
  stylesheets: () => stylesheets4
});
var index4;
var component_cache4;
var component4;
var imports4;
var stylesheets4;
var fonts4;
var init__4 = __esm({
  ".svelte-kit/output/server/nodes/3.js"() {
    index4 = 3;
    component4 = async () => component_cache4 ??= (await Promise.resolve().then(() => (init_error_svelte2(), error_svelte_exports2))).default;
    imports4 = ["_app/immutable/nodes/3.DpUob5Ha.js", "_app/immutable/chunks/scheduler.Cglc-E-6.js", "_app/immutable/chunks/index.9iPnfnGV.js", "_app/immutable/chunks/stores.-qfiZ27n.js", "_app/immutable/chunks/entry.BIRdqJCX.js", "_app/immutable/chunks/index.C4PciY-_.js"];
    stylesheets4 = [];
    fonts4 = [];
  }
});
var page_server_ts_exports = {};
__export(page_server_ts_exports, {
  actions: () => actions
});
var import_memoize_weak4;
var actions;
var init_page_server_ts = __esm({
  ".svelte-kit/output/server/entries/pages/(dashboard)/_project_/_page.server.ts.js"() {
    init_chunks();
    init_index7();
    init_client();
    init_index4();
    init_just_clone();
    init_esm();
    init_devalue();
    init_superValidate();
    import_memoize_weak4 = __toESM(require_memoize_weak(), 1);
    actions = {
      create: async (event) => {
        const form = await superValidate(event, zod(projectSchema));
        if (!form.valid) {
          return fail2(400, { form });
        }
        const projectName = form.data.name.toLowerCase();
        await createProject(projectName);
        redirect(303, `/${projectName}/identitas-proyek`);
      },
      delete: async (event) => {
        const form = await superValidate(event, zod(deleteProjectSchema));
        if (!form.valid) {
          return fail2(400, { form });
        }
        const projectName = form.data.name;
        await deleteProject(projectName);
        return { form };
      },
      logout: async ({ cookies }) => {
        cookies.set("session", "", {
          path: "/",
          expires: /* @__PURE__ */ new Date(0)
        });
        redirect(303, "/");
      }
    };
  }
});
var page_svelte_exports = {};
__export(page_svelte_exports, {
  default: () => Page
});
var Page;
var init_page_svelte = __esm({
  ".svelte-kit/output/server/entries/pages/(dashboard)/_project_/_page.svelte.js"() {
    init_lifecycle();
    init_ssr();
    init_client();
    init_stores2();
    Page = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$unsubscribe_page;
      $$unsubscribe_page = subscribe(page, (value) => value);
      $$unsubscribe_page();
      return ``;
    });
  }
});
var __exports5 = {};
__export(__exports5, {
  component: () => component5,
  fonts: () => fonts5,
  imports: () => imports5,
  index: () => index5,
  server: () => page_server_ts_exports,
  server_id: () => server_id3,
  stylesheets: () => stylesheets5
});
var index5;
var component_cache5;
var component5;
var server_id3;
var imports5;
var stylesheets5;
var fonts5;
var init__5 = __esm({
  ".svelte-kit/output/server/nodes/4.js"() {
    init_page_server_ts();
    index5 = 4;
    component5 = async () => component_cache5 ??= (await Promise.resolve().then(() => (init_page_svelte(), page_svelte_exports))).default;
    server_id3 = "src/routes/(dashboard)/[project]/+page.server.ts";
    imports5 = ["_app/immutable/nodes/4.B_w8Wun-.js", "_app/immutable/chunks/scheduler.Cglc-E-6.js", "_app/immutable/chunks/index.9iPnfnGV.js", "_app/immutable/chunks/entry.BIRdqJCX.js", "_app/immutable/chunks/index.C4PciY-_.js", "_app/immutable/chunks/stores.-qfiZ27n.js"];
    stylesheets5 = [];
    fonts5 = [];
  }
});
var page_svelte_exports2 = {};
__export(page_svelte_exports2, {
  default: () => Page2
});
var Page2;
var init_page_svelte2 = __esm({
  ".svelte-kit/output/server/entries/pages/(dashboard)/_project_/experiments/_page.svelte.js"() {
    init_ssr();
    init_mode_toggle();
    Page2 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { data: data2 } = $$props;
      if ($$props.data === void 0 && $$bindings.data && data2 !== void 0)
        $$bindings.data(data2);
      return `<div class="mb-4 flex items-center"><h1 class="text-3xl font-semibold" data-svelte-h="svelte-1dav5uf">Expremients</h1> ${validate_component(Mode_toggle, "ModeToggle").$$render($$result, {}, {}, {})}</div> <ul>${each(data2.projects, (project) => {
        return `<li>${escape(project)}</li>`;
      })}</ul>`;
    });
  }
});
var __exports6 = {};
__export(__exports6, {
  component: () => component6,
  fonts: () => fonts6,
  imports: () => imports6,
  index: () => index6,
  stylesheets: () => stylesheets6
});
var index6;
var component_cache6;
var component6;
var imports6;
var stylesheets6;
var fonts6;
var init__6 = __esm({
  ".svelte-kit/output/server/nodes/5.js"() {
    index6 = 5;
    component6 = async () => component_cache6 ??= (await Promise.resolve().then(() => (init_page_svelte2(), page_svelte_exports2))).default;
    imports6 = ["_app/immutable/nodes/5.X40XrU8t.js", "_app/immutable/chunks/scheduler.Cglc-E-6.js", "_app/immutable/chunks/index.9iPnfnGV.js", "_app/immutable/chunks/each.Dtgx6mEA.js", "_app/immutable/chunks/mode-toggle.Cs9G0DsI.js", "_app/immutable/chunks/mode.BQ9atwLW.js", "_app/immutable/chunks/index.C4PciY-_.js", "_app/immutable/chunks/index.BALLBs5G.js"];
    stylesheets6 = [];
    fonts6 = [];
  }
});
var page_svelte_exports3 = {};
__export(page_svelte_exports3, {
  default: () => Page3
});
var Page3;
var init_page_svelte3 = __esm({
  ".svelte-kit/output/server/entries/pages/(dashboard)/_project_/gambar-desain/_page.svelte.js"() {
    init_ssr();
    init_mode_toggle();
    Page3 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `<div class="mb-4 flex items-center"><h1 class="text-xl font-semibold" data-svelte-h="svelte-1rnm5oy">Gambar Desain</h1> ${validate_component(Mode_toggle, "ModeToggle").$$render($$result, {}, {}, {})}</div>`;
    });
  }
});
var __exports7 = {};
__export(__exports7, {
  component: () => component7,
  fonts: () => fonts7,
  imports: () => imports7,
  index: () => index7,
  stylesheets: () => stylesheets7
});
var index7;
var component_cache7;
var component7;
var imports7;
var stylesheets7;
var fonts7;
var init__7 = __esm({
  ".svelte-kit/output/server/nodes/6.js"() {
    index7 = 6;
    component7 = async () => component_cache7 ??= (await Promise.resolve().then(() => (init_page_svelte3(), page_svelte_exports3))).default;
    imports7 = ["_app/immutable/nodes/6.Dv4wsbxB.js", "_app/immutable/chunks/scheduler.Cglc-E-6.js", "_app/immutable/chunks/index.9iPnfnGV.js", "_app/immutable/chunks/mode-toggle.Cs9G0DsI.js", "_app/immutable/chunks/mode.BQ9atwLW.js", "_app/immutable/chunks/index.C4PciY-_.js", "_app/immutable/chunks/index.BALLBs5G.js"];
    stylesheets7 = [];
    fonts7 = [];
  }
});
var page_svelte_exports4 = {};
__export(page_svelte_exports4, {
  default: () => Page4
});
var Page4;
var init_page_svelte4 = __esm({
  ".svelte-kit/output/server/entries/pages/(dashboard)/_project_/identitas-proyek/_page.svelte.js"() {
    init_ssr();
    init_mode_toggle();
    Page4 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `<div class="mb-4 flex items-center"><h1 class="text-xl font-semibold" data-svelte-h="svelte-1jrfs43">Identitas Proyek</h1> ${validate_component(Mode_toggle, "ModeToggle").$$render($$result, {}, {}, {})}</div>`;
    });
  }
});
var __exports8 = {};
__export(__exports8, {
  component: () => component8,
  fonts: () => fonts8,
  imports: () => imports8,
  index: () => index8,
  stylesheets: () => stylesheets8
});
var index8;
var component_cache8;
var component8;
var imports8;
var stylesheets8;
var fonts8;
var init__8 = __esm({
  ".svelte-kit/output/server/nodes/7.js"() {
    index8 = 7;
    component8 = async () => component_cache8 ??= (await Promise.resolve().then(() => (init_page_svelte4(), page_svelte_exports4))).default;
    imports8 = ["_app/immutable/nodes/7.DyIvO_DV.js", "_app/immutable/chunks/scheduler.Cglc-E-6.js", "_app/immutable/chunks/index.9iPnfnGV.js", "_app/immutable/chunks/mode-toggle.Cs9G0DsI.js", "_app/immutable/chunks/mode.BQ9atwLW.js", "_app/immutable/chunks/index.C4PciY-_.js", "_app/immutable/chunks/index.BALLBs5G.js"];
    stylesheets8 = [];
    fonts8 = [];
  }
});
var page_svelte_exports5 = {};
__export(page_svelte_exports5, {
  default: () => Page5
});
var Page5;
var init_page_svelte5 = __esm({
  ".svelte-kit/output/server/entries/pages/(dashboard)/_project_/jadwal-project/_page.svelte.js"() {
    init_ssr();
    init_mode_toggle();
    Page5 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `<div class="mb-4 flex items-center"><h1 class="text-xl font-semibold" data-svelte-h="svelte-1582cjc">Jadwal Project</h1> ${validate_component(Mode_toggle, "ModeToggle").$$render($$result, {}, {}, {})}</div>`;
    });
  }
});
var __exports9 = {};
__export(__exports9, {
  component: () => component9,
  fonts: () => fonts9,
  imports: () => imports9,
  index: () => index9,
  stylesheets: () => stylesheets9
});
var index9;
var component_cache9;
var component9;
var imports9;
var stylesheets9;
var fonts9;
var init__9 = __esm({
  ".svelte-kit/output/server/nodes/8.js"() {
    index9 = 8;
    component9 = async () => component_cache9 ??= (await Promise.resolve().then(() => (init_page_svelte5(), page_svelte_exports5))).default;
    imports9 = ["_app/immutable/nodes/8.BFrm0vTZ.js", "_app/immutable/chunks/scheduler.Cglc-E-6.js", "_app/immutable/chunks/index.9iPnfnGV.js", "_app/immutable/chunks/mode-toggle.Cs9G0DsI.js", "_app/immutable/chunks/mode.BQ9atwLW.js", "_app/immutable/chunks/index.C4PciY-_.js", "_app/immutable/chunks/index.BALLBs5G.js"];
    stylesheets9 = [];
    fonts9 = [];
  }
});
var require_maplibre_gl = __commonJS({
  "node_modules/maplibre-gl/dist/maplibre-gl.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.maplibregl = factory());
    })(exports, function() {
      "use strict";
      var maplibregl2 = {};
      var modules = {};
      function define2(moduleName, _dependencies, moduleFactory) {
        modules[moduleName] = moduleFactory;
        if (moduleName !== "index") {
          return;
        }
        var workerBundleString = "var sharedModule = {}; (" + modules.shared + ")(sharedModule); (" + modules.worker + ")(sharedModule);";
        var sharedModule = {};
        modules.shared(sharedModule);
        modules.index(maplibregl2, sharedModule);
        if (typeof window !== "undefined") {
          maplibregl2.setWorkerUrl(window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" })));
        }
        return maplibregl2;
      }
      ;
      define2("shared", ["exports"], function(t2) {
        "use strict";
        function e3(t3, e4, r5, n3) {
          return new (r5 || (r5 = Promise))(function(i4, s4) {
            function a3(t4) {
              try {
                l4(n3.next(t4));
              } catch (t5) {
                s4(t5);
              }
            }
            function o3(t4) {
              try {
                l4(n3.throw(t4));
              } catch (t5) {
                s4(t5);
              }
            }
            function l4(t4) {
              var e5;
              t4.done ? i4(t4.value) : (e5 = t4.value, e5 instanceof r5 ? e5 : new r5(function(t5) {
                t5(e5);
              })).then(a3, o3);
            }
            l4((n3 = n3.apply(t3, e4 || [])).next());
          });
        }
        function r4(t3) {
          return t3 && t3.__esModule && Object.prototype.hasOwnProperty.call(t3, "default") ? t3.default : t3;
        }
        "function" == typeof SuppressedError && SuppressedError;
        var n2 = i3;
        function i3(t3, e4) {
          this.x = t3, this.y = e4;
        }
        i3.prototype = { clone: function() {
          return new i3(this.x, this.y);
        }, add: function(t3) {
          return this.clone()._add(t3);
        }, sub: function(t3) {
          return this.clone()._sub(t3);
        }, multByPoint: function(t3) {
          return this.clone()._multByPoint(t3);
        }, divByPoint: function(t3) {
          return this.clone()._divByPoint(t3);
        }, mult: function(t3) {
          return this.clone()._mult(t3);
        }, div: function(t3) {
          return this.clone()._div(t3);
        }, rotate: function(t3) {
          return this.clone()._rotate(t3);
        }, rotateAround: function(t3, e4) {
          return this.clone()._rotateAround(t3, e4);
        }, matMult: function(t3) {
          return this.clone()._matMult(t3);
        }, unit: function() {
          return this.clone()._unit();
        }, perp: function() {
          return this.clone()._perp();
        }, round: function() {
          return this.clone()._round();
        }, mag: function() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }, equals: function(t3) {
          return this.x === t3.x && this.y === t3.y;
        }, dist: function(t3) {
          return Math.sqrt(this.distSqr(t3));
        }, distSqr: function(t3) {
          var e4 = t3.x - this.x, r5 = t3.y - this.y;
          return e4 * e4 + r5 * r5;
        }, angle: function() {
          return Math.atan2(this.y, this.x);
        }, angleTo: function(t3) {
          return Math.atan2(this.y - t3.y, this.x - t3.x);
        }, angleWith: function(t3) {
          return this.angleWithSep(t3.x, t3.y);
        }, angleWithSep: function(t3, e4) {
          return Math.atan2(this.x * e4 - this.y * t3, this.x * t3 + this.y * e4);
        }, _matMult: function(t3) {
          var e4 = t3[2] * this.x + t3[3] * this.y;
          return this.x = t3[0] * this.x + t3[1] * this.y, this.y = e4, this;
        }, _add: function(t3) {
          return this.x += t3.x, this.y += t3.y, this;
        }, _sub: function(t3) {
          return this.x -= t3.x, this.y -= t3.y, this;
        }, _mult: function(t3) {
          return this.x *= t3, this.y *= t3, this;
        }, _div: function(t3) {
          return this.x /= t3, this.y /= t3, this;
        }, _multByPoint: function(t3) {
          return this.x *= t3.x, this.y *= t3.y, this;
        }, _divByPoint: function(t3) {
          return this.x /= t3.x, this.y /= t3.y, this;
        }, _unit: function() {
          return this._div(this.mag()), this;
        }, _perp: function() {
          var t3 = this.y;
          return this.y = this.x, this.x = -t3, this;
        }, _rotate: function(t3) {
          var e4 = Math.cos(t3), r5 = Math.sin(t3), n3 = r5 * this.x + e4 * this.y;
          return this.x = e4 * this.x - r5 * this.y, this.y = n3, this;
        }, _rotateAround: function(t3, e4) {
          var r5 = Math.cos(t3), n3 = Math.sin(t3), i4 = e4.y + n3 * (this.x - e4.x) + r5 * (this.y - e4.y);
          return this.x = e4.x + r5 * (this.x - e4.x) - n3 * (this.y - e4.y), this.y = i4, this;
        }, _round: function() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        } }, i3.convert = function(t3) {
          return t3 instanceof i3 ? t3 : Array.isArray(t3) ? new i3(t3[0], t3[1]) : t3;
        };
        var s3 = r4(n2), a2 = o2;
        function o2(t3, e4, r5, n3) {
          this.cx = 3 * t3, this.bx = 3 * (r5 - t3) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e4, this.by = 3 * (n3 - e4) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t3, this.p1y = e4, this.p2x = r5, this.p2y = n3;
        }
        o2.prototype = { sampleCurveX: function(t3) {
          return ((this.ax * t3 + this.bx) * t3 + this.cx) * t3;
        }, sampleCurveY: function(t3) {
          return ((this.ay * t3 + this.by) * t3 + this.cy) * t3;
        }, sampleCurveDerivativeX: function(t3) {
          return (3 * this.ax * t3 + 2 * this.bx) * t3 + this.cx;
        }, solveCurveX: function(t3, e4) {
          if (void 0 === e4 && (e4 = 1e-6), t3 < 0)
            return 0;
          if (t3 > 1)
            return 1;
          for (var r5 = t3, n3 = 0; n3 < 8; n3++) {
            var i4 = this.sampleCurveX(r5) - t3;
            if (Math.abs(i4) < e4)
              return r5;
            var s4 = this.sampleCurveDerivativeX(r5);
            if (Math.abs(s4) < 1e-6)
              break;
            r5 -= i4 / s4;
          }
          var a3 = 0, o3 = 1;
          for (r5 = t3, n3 = 0; n3 < 20 && (i4 = this.sampleCurveX(r5), !(Math.abs(i4 - t3) < e4)); n3++)
            t3 > i4 ? a3 = r5 : o3 = r5, r5 = 0.5 * (o3 - a3) + a3;
          return r5;
        }, solve: function(t3, e4) {
          return this.sampleCurveY(this.solveCurveX(t3, e4));
        } };
        var l3 = r4(a2);
        let u2, c2;
        function h() {
          return null == u2 && (u2 = "undefined" != typeof OffscreenCanvas && new OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof createImageBitmap), u2;
        }
        function p3() {
          if (null == c2 && (c2 = false, h())) {
            const t3 = 5, e4 = new OffscreenCanvas(t3, t3).getContext("2d", { willReadFrequently: true });
            if (e4) {
              for (let r6 = 0; r6 < t3 * t3; r6++) {
                const n3 = 4 * r6;
                e4.fillStyle = `rgb(${n3},${n3 + 1},${n3 + 2})`, e4.fillRect(r6 % t3, Math.floor(r6 / t3), 1, 1);
              }
              const r5 = e4.getImageData(0, 0, t3, t3).data;
              for (let e5 = 0; e5 < t3 * t3 * 4; e5++)
                if (e5 % 4 != 3 && r5[e5] !== e5) {
                  c2 = true;
                  break;
                }
            }
          }
          return c2 || false;
        }
        function f(t3, e4, r5, n3) {
          const i4 = new l3(t3, e4, r5, n3);
          return function(t4) {
            return i4.solve(t4);
          };
        }
        const d = f(0.25, 0.1, 0.25, 1);
        function y3(t3, e4, r5) {
          return Math.min(r5, Math.max(e4, t3));
        }
        function m(t3, e4, r5) {
          const n3 = r5 - e4, i4 = ((t3 - e4) % n3 + n3) % n3 + e4;
          return i4 === e4 ? r5 : i4;
        }
        function g2(t3, ...e4) {
          for (const r5 of e4)
            for (const e5 in r5)
              t3[e5] = r5[e5];
          return t3;
        }
        let x4 = 1;
        function v3(t3, e4, r5) {
          const n3 = {};
          for (const i4 in t3)
            n3[i4] = e4.call(r5 || this, t3[i4], i4, t3);
          return n3;
        }
        function b2(t3, e4, r5) {
          const n3 = {};
          for (const i4 in t3)
            e4.call(r5 || this, t3[i4], i4, t3) && (n3[i4] = t3[i4]);
          return n3;
        }
        function w3(t3) {
          return Array.isArray(t3) ? t3.map(w3) : "object" == typeof t3 && t3 ? v3(t3, w3) : t3;
        }
        const _ = {};
        function A2(t3) {
          _[t3] || ("undefined" != typeof console && console.warn(t3), _[t3] = true);
        }
        function S3(t3, e4, r5) {
          return (r5.y - t3.y) * (e4.x - t3.x) > (e4.y - t3.y) * (r5.x - t3.x);
        }
        function k2(t3) {
          let e4 = 0;
          for (let r5, n3, i4 = 0, s4 = t3.length, a3 = s4 - 1; i4 < s4; a3 = i4++)
            r5 = t3[i4], n3 = t3[a3], e4 += (n3.x - r5.x) * (r5.y + n3.y);
          return e4;
        }
        function I2(t3) {
          return "undefined" != typeof WorkerGlobalScope && void 0 !== t3 && t3 instanceof WorkerGlobalScope;
        }
        let z3 = null;
        function M2(t3) {
          return "undefined" != typeof ImageBitmap && t3 instanceof ImageBitmap;
        }
        const B2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        function C4(t3, r5, n3, i4, s4) {
          return e3(this, void 0, void 0, function* () {
            if ("undefined" == typeof VideoFrame)
              throw new Error("VideoFrame not supported");
            const e4 = new VideoFrame(t3, { timestamp: 0 });
            try {
              const a3 = null == e4 ? void 0 : e4.format;
              if (!a3 || !a3.startsWith("BGR") && !a3.startsWith("RGB"))
                throw new Error(`Unrecognized format ${a3}`);
              const o3 = a3.startsWith("BGR"), l4 = new Uint8ClampedArray(i4 * s4 * 4);
              if (yield e4.copyTo(l4, function(t4, e5, r6, n4, i5) {
                const s5 = 4 * Math.max(-e5, 0), a4 = (Math.max(0, r6) - r6) * n4 * 4 + s5, o4 = 4 * n4, l5 = Math.max(0, e5), u3 = Math.max(0, r6);
                return { rect: { x: l5, y: u3, width: Math.min(t4.width, e5 + n4) - l5, height: Math.min(t4.height, r6 + i5) - u3 }, layout: [{ offset: a4, stride: o4 }] };
              }(t3, r5, n3, i4, s4)), o3)
                for (let t4 = 0; t4 < l4.length; t4 += 4) {
                  const e5 = l4[t4];
                  l4[t4] = l4[t4 + 2], l4[t4 + 2] = e5;
                }
              return l4;
            } finally {
              e4.close();
            }
          });
        }
        let P2, V2;
        const E2 = "AbortError";
        function F3() {
          return new Error(E2);
        }
        const T2 = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
        function $(t3) {
          return T2.REGISTERED_PROTOCOLS[t3.substring(0, t3.indexOf("://"))];
        }
        const D3 = "global-dispatcher";
        class L2 extends Error {
          constructor(t3, e4, r5, n3) {
            super(`AJAXError: ${e4} (${t3}): ${r5}`), this.status = t3, this.statusText = e4, this.url = r5, this.body = n3;
          }
        }
        const O2 = () => I2(self) ? self.worker && self.worker.referrer : ("blob:" === window.location.protocol ? window.parent : window).location.href, R3 = function(t3, r5) {
          if (/:\/\//.test(t3.url) && !/^https?:|^file:/.test(t3.url)) {
            const e4 = $(t3.url);
            if (e4)
              return e4(t3, r5);
            if (I2(self) && self.worker && self.worker.actor)
              return self.worker.actor.sendAsync({ type: "getResource", data: t3, targetMapId: D3 }, r5);
          }
          if (!(/^file:/.test(n3 = t3.url) || /^file:/.test(O2()) && !/^\w+:/.test(n3))) {
            if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal"))
              return function(t4, r6) {
                return e3(this, void 0, void 0, function* () {
                  const e4 = new Request(t4.url, { method: t4.method || "GET", body: t4.body, credentials: t4.credentials, headers: t4.headers, cache: t4.cache, referrer: O2(), signal: r6.signal });
                  "json" === t4.type && e4.headers.set("Accept", "application/json");
                  const n4 = yield fetch(e4);
                  if (!n4.ok) {
                    const e5 = yield n4.blob();
                    throw new L2(n4.status, n4.statusText, t4.url, e5);
                  }
                  const i4 = "arrayBuffer" === t4.type || "image" === t4.type ? n4.arrayBuffer() : "json" === t4.type ? n4.json() : n4.text(), s4 = yield i4;
                  if (r6.signal.aborted)
                    throw F3();
                  return { data: s4, cacheControl: n4.headers.get("Cache-Control"), expires: n4.headers.get("Expires") };
                });
              }(t3, r5);
            if (I2(self) && self.worker && self.worker.actor)
              return self.worker.actor.sendAsync({ type: "getResource", data: t3, mustQueue: true, targetMapId: D3 }, r5);
          }
          var n3;
          return function(t4, e4) {
            return new Promise((r6, n4) => {
              const i4 = new XMLHttpRequest();
              i4.open(t4.method || "GET", t4.url, true), "arrayBuffer" !== t4.type && "image" !== t4.type || (i4.responseType = "arraybuffer");
              for (const e5 in t4.headers)
                i4.setRequestHeader(e5, t4.headers[e5]);
              "json" === t4.type && (i4.responseType = "text", i4.setRequestHeader("Accept", "application/json")), i4.withCredentials = "include" === t4.credentials, i4.onerror = () => {
                n4(new Error(i4.statusText));
              }, i4.onload = () => {
                if (!e4.signal.aborted)
                  if ((i4.status >= 200 && i4.status < 300 || 0 === i4.status) && null !== i4.response) {
                    let e5 = i4.response;
                    if ("json" === t4.type)
                      try {
                        e5 = JSON.parse(i4.response);
                      } catch (t5) {
                        return void n4(t5);
                      }
                    r6({ data: e5, cacheControl: i4.getResponseHeader("Cache-Control"), expires: i4.getResponseHeader("Expires") });
                  } else {
                    const e5 = new Blob([i4.response], { type: i4.getResponseHeader("Content-Type") });
                    n4(new L2(i4.status, i4.statusText, t4.url, e5));
                  }
              }, e4.signal.addEventListener("abort", () => {
                i4.abort(), n4(F3());
              }), i4.send(t4.body);
            });
          }(t3, r5);
        };
        function U2(t3) {
          if (!t3 || t3.indexOf("://") <= 0 || 0 === t3.indexOf("data:image/") || 0 === t3.indexOf("blob:"))
            return true;
          const e4 = new URL(t3), r5 = window.location;
          return e4.protocol === r5.protocol && e4.host === r5.host;
        }
        function j2(t3, e4, r5) {
          r5[t3] && -1 !== r5[t3].indexOf(e4) || (r5[t3] = r5[t3] || [], r5[t3].push(e4));
        }
        function q3(t3, e4, r5) {
          if (r5 && r5[t3]) {
            const n3 = r5[t3].indexOf(e4);
            -1 !== n3 && r5[t3].splice(n3, 1);
          }
        }
        class N3 {
          constructor(t3, e4 = {}) {
            g2(this, e4), this.type = t3;
          }
        }
        class Z4 extends N3 {
          constructor(t3, e4 = {}) {
            super("error", g2({ error: t3 }, e4));
          }
        }
        class K2 {
          on(t3, e4) {
            return this._listeners = this._listeners || {}, j2(t3, e4, this._listeners), this;
          }
          off(t3, e4) {
            return q3(t3, e4, this._listeners), q3(t3, e4, this._oneTimeListeners), this;
          }
          once(t3, e4) {
            return e4 ? (this._oneTimeListeners = this._oneTimeListeners || {}, j2(t3, e4, this._oneTimeListeners), this) : new Promise((e5) => this.once(t3, e5));
          }
          fire(t3, e4) {
            "string" == typeof t3 && (t3 = new N3(t3, e4 || {}));
            const r5 = t3.type;
            if (this.listens(r5)) {
              t3.target = this;
              const e5 = this._listeners && this._listeners[r5] ? this._listeners[r5].slice() : [];
              for (const r6 of e5)
                r6.call(this, t3);
              const n3 = this._oneTimeListeners && this._oneTimeListeners[r5] ? this._oneTimeListeners[r5].slice() : [];
              for (const e6 of n3)
                q3(r5, e6, this._oneTimeListeners), e6.call(this, t3);
              const i4 = this._eventedParent;
              i4 && (g2(t3, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i4.fire(t3));
            } else
              t3 instanceof Z4 && console.error(t3.error);
            return this;
          }
          listens(t3) {
            return this._listeners && this._listeners[t3] && this._listeners[t3].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t3] && this._oneTimeListeners[t3].length > 0 || this._eventedParent && this._eventedParent.listens(t3);
          }
          setEventedParent(t3, e4) {
            return this._eventedParent = t3, this._eventedParentData = e4, this;
          }
        }
        var G2 = { $version: 8, $root: { version: { required: true, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, sky: { type: "sky" }, terrain: { type: "terrain" }, sources: { required: true, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: true, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: true, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster: { type: { required: true, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster_dem: { type: { required: true, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_geojson: { type: { required: true, type: "enum", values: { geojson: {} } }, data: { required: true, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: false }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: false }, generateId: { type: "boolean", default: false }, promoteId: { type: "promoteId" } }, source_video: { type: { required: true, type: "enum", values: { video: {} } }, urls: { required: true, type: "array", value: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: true, type: "enum", values: { image: {} } }, url: { required: true, type: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: true }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: true }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: false, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: false, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: false, requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: false, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: true, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: true, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: false, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: false, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: false, requires: ["text-field", "icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {}, within: {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: false } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: false, expression: { interpolated: false, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: true, expression: { interpolated: true, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, sky: { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "fog-blend": { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "horizon-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, terrain: { source: { type: "string", required: true }, exaggeration: { type: "number", minimum: 0, default: 1 } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: true, requires: [{ "!": "fill-pattern" }, { "fill-antialias": true }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, requires: ["fill-extrusion-height"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: true, transition: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "line-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: true, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: false, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: true } }], expression: { interpolated: true, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: false, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: false, expression: { interpolated: true, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: true, overridable: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: true, units: "degrees", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: false, units: "milliseconds", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "background-pattern" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
        const J3 = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
        function X3(t3, e4) {
          const r5 = {};
          for (const e5 in t3)
            "ref" !== e5 && (r5[e5] = t3[e5]);
          return J3.forEach((t4) => {
            t4 in e4 && (r5[t4] = e4[t4]);
          }), r5;
        }
        function H3(t3, e4) {
          if (Array.isArray(t3)) {
            if (!Array.isArray(e4) || t3.length !== e4.length)
              return false;
            for (let r5 = 0; r5 < t3.length; r5++)
              if (!H3(t3[r5], e4[r5]))
                return false;
            return true;
          }
          if ("object" == typeof t3 && null !== t3 && null !== e4) {
            if ("object" != typeof e4)
              return false;
            if (Object.keys(t3).length !== Object.keys(e4).length)
              return false;
            for (const r5 in t3)
              if (!H3(t3[r5], e4[r5]))
                return false;
            return true;
          }
          return t3 === e4;
        }
        function Y4(t3, e4) {
          t3.push(e4);
        }
        function W2(t3, e4, r5) {
          Y4(r5, { command: "addSource", args: [t3, e4[t3]] });
        }
        function Q2(t3, e4, r5) {
          Y4(e4, { command: "removeSource", args: [t3] }), r5[t3] = true;
        }
        function tt(t3, e4, r5, n3) {
          Q2(t3, r5, n3), W2(t3, e4, r5);
        }
        function et2(t3, e4, r5) {
          let n3;
          for (n3 in t3[r5])
            if (Object.prototype.hasOwnProperty.call(t3[r5], n3) && "data" !== n3 && !H3(t3[r5][n3], e4[r5][n3]))
              return false;
          for (n3 in e4[r5])
            if (Object.prototype.hasOwnProperty.call(e4[r5], n3) && "data" !== n3 && !H3(t3[r5][n3], e4[r5][n3]))
              return false;
          return true;
        }
        function rt(t3, e4, r5, n3, i4, s4) {
          t3 = t3 || {}, e4 = e4 || {};
          for (const a3 in t3)
            Object.prototype.hasOwnProperty.call(t3, a3) && (H3(t3[a3], e4[a3]) || r5.push({ command: s4, args: [n3, a3, e4[a3], i4] }));
          for (const a3 in e4)
            Object.prototype.hasOwnProperty.call(e4, a3) && !Object.prototype.hasOwnProperty.call(t3, a3) && (H3(t3[a3], e4[a3]) || r5.push({ command: s4, args: [n3, a3, e4[a3], i4] }));
        }
        function nt(t3) {
          return t3.id;
        }
        function it(t3, e4) {
          return t3[e4.id] = e4, t3;
        }
        class st {
          constructor(t3, e4, r5, n3) {
            this.message = (t3 ? `${t3}: ` : "") + r5, n3 && (this.identifier = n3), null != e4 && e4.__line__ && (this.line = e4.__line__);
          }
        }
        function at(t3, ...e4) {
          for (const r5 of e4)
            for (const e5 in r5)
              t3[e5] = r5[e5];
          return t3;
        }
        class ot extends Error {
          constructor(t3, e4) {
            super(e4), this.message = e4, this.key = t3;
          }
        }
        class lt {
          constructor(t3, e4 = []) {
            this.parent = t3, this.bindings = {};
            for (const [t4, r5] of e4)
              this.bindings[t4] = r5;
          }
          concat(t3) {
            return new lt(this, t3);
          }
          get(t3) {
            if (this.bindings[t3])
              return this.bindings[t3];
            if (this.parent)
              return this.parent.get(t3);
            throw new Error(`${t3} not found in scope.`);
          }
          has(t3) {
            return !!this.bindings[t3] || !!this.parent && this.parent.has(t3);
          }
        }
        const ut = { kind: "null" }, ct = { kind: "number" }, ht = { kind: "string" }, pt2 = { kind: "boolean" }, ft = { kind: "color" }, dt = { kind: "object" }, yt = { kind: "value" }, mt = { kind: "collator" }, gt = { kind: "formatted" }, xt = { kind: "padding" }, vt = { kind: "resolvedImage" }, bt = { kind: "variableAnchorOffsetCollection" };
        function wt(t3, e4) {
          return { kind: "array", itemType: t3, N: e4 };
        }
        function _t(t3) {
          if ("array" === t3.kind) {
            const e4 = _t(t3.itemType);
            return "number" == typeof t3.N ? `array<${e4}, ${t3.N}>` : "value" === t3.itemType.kind ? "array" : `array<${e4}>`;
          }
          return t3.kind;
        }
        const At = [ut, ct, ht, pt2, ft, gt, dt, wt(yt), xt, vt, bt];
        function St(t3, e4) {
          if ("error" === e4.kind)
            return null;
          if ("array" === t3.kind) {
            if ("array" === e4.kind && (0 === e4.N && "value" === e4.itemType.kind || !St(t3.itemType, e4.itemType)) && ("number" != typeof t3.N || t3.N === e4.N))
              return null;
          } else {
            if (t3.kind === e4.kind)
              return null;
            if ("value" === t3.kind) {
              for (const t4 of At)
                if (!St(t4, e4))
                  return null;
            }
          }
          return `Expected ${_t(t3)} but found ${_t(e4)} instead.`;
        }
        function kt(t3, e4) {
          return e4.some((e5) => e5.kind === t3.kind);
        }
        function It(t3, e4) {
          return e4.some((e5) => "null" === e5 ? null === t3 : "array" === e5 ? Array.isArray(t3) : "object" === e5 ? t3 && !Array.isArray(t3) && "object" == typeof t3 : e5 === typeof t3);
        }
        function zt(t3, e4) {
          return "array" === t3.kind && "array" === e4.kind ? t3.itemType.kind === e4.itemType.kind && "number" == typeof t3.N : t3.kind === e4.kind;
        }
        const Mt = 0.96422, Bt = 0.82521, Ct = 4 / 29, Pt = 6 / 29, Vt = 3 * Pt * Pt, Et = Pt * Pt * Pt, Ft = Math.PI / 180, Tt = 180 / Math.PI;
        function $t(t3) {
          return (t3 %= 360) < 0 && (t3 += 360), t3;
        }
        function Dt([t3, e4, r5, n3]) {
          let i4, s4;
          const a3 = Ot((0.2225045 * (t3 = Lt(t3)) + 0.7168786 * (e4 = Lt(e4)) + 0.0606169 * (r5 = Lt(r5))) / 1);
          t3 === e4 && e4 === r5 ? i4 = s4 = a3 : (i4 = Ot((0.4360747 * t3 + 0.3850649 * e4 + 0.1430804 * r5) / Mt), s4 = Ot((0.0139322 * t3 + 0.0971045 * e4 + 0.7141733 * r5) / Bt));
          const o3 = 116 * a3 - 16;
          return [o3 < 0 ? 0 : o3, 500 * (i4 - a3), 200 * (a3 - s4), n3];
        }
        function Lt(t3) {
          return t3 <= 0.04045 ? t3 / 12.92 : Math.pow((t3 + 0.055) / 1.055, 2.4);
        }
        function Ot(t3) {
          return t3 > Et ? Math.pow(t3, 1 / 3) : t3 / Vt + Ct;
        }
        function Rt([t3, e4, r5, n3]) {
          let i4 = (t3 + 16) / 116, s4 = isNaN(e4) ? i4 : i4 + e4 / 500, a3 = isNaN(r5) ? i4 : i4 - r5 / 200;
          return i4 = 1 * jt(i4), s4 = Mt * jt(s4), a3 = Bt * jt(a3), [Ut(3.1338561 * s4 - 1.6168667 * i4 - 0.4906146 * a3), Ut(-0.9787684 * s4 + 1.9161415 * i4 + 0.033454 * a3), Ut(0.0719453 * s4 - 0.2289914 * i4 + 1.4052427 * a3), n3];
        }
        function Ut(t3) {
          return (t3 = t3 <= 304e-5 ? 12.92 * t3 : 1.055 * Math.pow(t3, 1 / 2.4) - 0.055) < 0 ? 0 : t3 > 1 ? 1 : t3;
        }
        function jt(t3) {
          return t3 > Pt ? t3 * t3 * t3 : Vt * (t3 - Ct);
        }
        function qt(t3) {
          return parseInt(t3.padEnd(2, t3), 16) / 255;
        }
        function Nt(t3, e4) {
          return Zt(e4 ? t3 / 100 : t3, 0, 1);
        }
        function Zt(t3, e4, r5) {
          return Math.min(Math.max(e4, t3), r5);
        }
        function Kt(t3) {
          return !t3.some(Number.isNaN);
        }
        const Gt = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
        class Jt {
          constructor(t3, e4, r5, n3 = 1, i4 = true) {
            this.r = t3, this.g = e4, this.b = r5, this.a = n3, i4 || (this.r *= n3, this.g *= n3, this.b *= n3, n3 || this.overwriteGetter("rgb", [t3, e4, r5, n3]));
          }
          static parse(t3) {
            if (t3 instanceof Jt)
              return t3;
            if ("string" != typeof t3)
              return;
            const e4 = function(t4) {
              if ("transparent" === (t4 = t4.toLowerCase().trim()))
                return [0, 0, 0, 0];
              const e5 = Gt[t4];
              if (e5) {
                const [t5, r6, n3] = e5;
                return [t5 / 255, r6 / 255, n3 / 255, 1];
              }
              if (t4.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(t4)) {
                const e6 = t4.length < 6 ? 1 : 2;
                let r6 = 1;
                return [qt(t4.slice(r6, r6 += e6)), qt(t4.slice(r6, r6 += e6)), qt(t4.slice(r6, r6 += e6)), qt(t4.slice(r6, r6 + e6) || "ff")];
              }
              if (t4.startsWith("rgb")) {
                const e6 = t4.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                if (e6) {
                  const [t5, r6, n3, i4, s4, a3, o3, l4, u3, c3, h2, p4] = e6, f2 = [i4 || " ", o3 || " ", c3].join("");
                  if ("  " === f2 || "  /" === f2 || ",," === f2 || ",,," === f2) {
                    const t6 = [n3, a3, u3].join(""), e7 = "%%%" === t6 ? 100 : "" === t6 ? 255 : 0;
                    if (e7) {
                      const t7 = [Zt(+r6 / e7, 0, 1), Zt(+s4 / e7, 0, 1), Zt(+l4 / e7, 0, 1), h2 ? Nt(+h2, p4) : 1];
                      if (Kt(t7))
                        return t7;
                    }
                  }
                  return;
                }
              }
              const r5 = t4.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (r5) {
                const [t5, e6, n3, i4, s4, a3, o3, l4, u3] = r5, c3 = [n3 || " ", s4 || " ", o3].join("");
                if ("  " === c3 || "  /" === c3 || ",," === c3 || ",,," === c3) {
                  const t6 = [+e6, Zt(+i4, 0, 100), Zt(+a3, 0, 100), l4 ? Nt(+l4, u3) : 1];
                  if (Kt(t6))
                    return function([t7, e7, r6, n4]) {
                      function i5(n5) {
                        const i6 = (n5 + t7 / 30) % 12, s5 = e7 * Math.min(r6, 1 - r6);
                        return r6 - s5 * Math.max(-1, Math.min(i6 - 3, 9 - i6, 1));
                      }
                      return t7 = $t(t7), e7 /= 100, r6 /= 100, [i5(0), i5(8), i5(4), n4];
                    }(t6);
                }
              }
            }(t3);
            return e4 ? new Jt(...e4, false) : void 0;
          }
          get rgb() {
            const { r: t3, g: e4, b: r5, a: n3 } = this, i4 = n3 || 1 / 0;
            return this.overwriteGetter("rgb", [t3 / i4, e4 / i4, r5 / i4, n3]);
          }
          get hcl() {
            return this.overwriteGetter("hcl", function(t3) {
              const [e4, r5, n3, i4] = Dt(t3), s4 = Math.sqrt(r5 * r5 + n3 * n3);
              return [Math.round(1e4 * s4) ? $t(Math.atan2(n3, r5) * Tt) : NaN, s4, e4, i4];
            }(this.rgb));
          }
          get lab() {
            return this.overwriteGetter("lab", Dt(this.rgb));
          }
          overwriteGetter(t3, e4) {
            return Object.defineProperty(this, t3, { value: e4 }), e4;
          }
          toString() {
            const [t3, e4, r5, n3] = this.rgb;
            return `rgba(${[t3, e4, r5].map((t4) => Math.round(255 * t4)).join(",")},${n3})`;
          }
        }
        Jt.black = new Jt(0, 0, 0, 1), Jt.white = new Jt(1, 1, 1, 1), Jt.transparent = new Jt(0, 0, 0, 0), Jt.red = new Jt(1, 0, 0, 1);
        class Xt {
          constructor(t3, e4, r5) {
            this.sensitivity = t3 ? e4 ? "variant" : "case" : e4 ? "accent" : "base", this.locale = r5, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
          }
          compare(t3, e4) {
            return this.collator.compare(t3, e4);
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
          }
        }
        class Ht {
          constructor(t3, e4, r5, n3, i4) {
            this.text = t3, this.image = e4, this.scale = r5, this.fontStack = n3, this.textColor = i4;
          }
        }
        class Yt {
          constructor(t3) {
            this.sections = t3;
          }
          static fromString(t3) {
            return new Yt([new Ht(t3, null, null, null, null)]);
          }
          isEmpty() {
            return 0 === this.sections.length || !this.sections.some((t3) => 0 !== t3.text.length || t3.image && 0 !== t3.image.name.length);
          }
          static factory(t3) {
            return t3 instanceof Yt ? t3 : Yt.fromString(t3);
          }
          toString() {
            return 0 === this.sections.length ? "" : this.sections.map((t3) => t3.text).join("");
          }
        }
        class Wt {
          constructor(t3) {
            this.values = t3.slice();
          }
          static parse(t3) {
            if (t3 instanceof Wt)
              return t3;
            if ("number" == typeof t3)
              return new Wt([t3, t3, t3, t3]);
            if (Array.isArray(t3) && !(t3.length < 1 || t3.length > 4)) {
              for (const e4 of t3)
                if ("number" != typeof e4)
                  return;
              switch (t3.length) {
                case 1:
                  t3 = [t3[0], t3[0], t3[0], t3[0]];
                  break;
                case 2:
                  t3 = [t3[0], t3[1], t3[0], t3[1]];
                  break;
                case 3:
                  t3 = [t3[0], t3[1], t3[2], t3[1]];
              }
              return new Wt(t3);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
        }
        const Qt = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
        class te2 {
          constructor(t3) {
            this.values = t3.slice();
          }
          static parse(t3) {
            if (t3 instanceof te2)
              return t3;
            if (Array.isArray(t3) && !(t3.length < 1) && t3.length % 2 == 0) {
              for (let e4 = 0; e4 < t3.length; e4 += 2) {
                const r5 = t3[e4], n3 = t3[e4 + 1];
                if ("string" != typeof r5 || !Qt.has(r5))
                  return;
                if (!Array.isArray(n3) || 2 !== n3.length || "number" != typeof n3[0] || "number" != typeof n3[1])
                  return;
              }
              return new te2(t3);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
        }
        class ee2 {
          constructor(t3) {
            this.name = t3.name, this.available = t3.available;
          }
          toString() {
            return this.name;
          }
          static fromString(t3) {
            return t3 ? new ee2({ name: t3, available: false }) : null;
          }
        }
        function re2(t3, e4, r5, n3) {
          return "number" == typeof t3 && t3 >= 0 && t3 <= 255 && "number" == typeof e4 && e4 >= 0 && e4 <= 255 && "number" == typeof r5 && r5 >= 0 && r5 <= 255 ? void 0 === n3 || "number" == typeof n3 && n3 >= 0 && n3 <= 1 ? null : `Invalid rgba value [${[t3, e4, r5, n3].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n3 ? [t3, e4, r5, n3] : [t3, e4, r5]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        function ne(t3) {
          if (null === t3 || "string" == typeof t3 || "boolean" == typeof t3 || "number" == typeof t3 || t3 instanceof Jt || t3 instanceof Xt || t3 instanceof Yt || t3 instanceof Wt || t3 instanceof te2 || t3 instanceof ee2)
            return true;
          if (Array.isArray(t3)) {
            for (const e4 of t3)
              if (!ne(e4))
                return false;
            return true;
          }
          if ("object" == typeof t3) {
            for (const e4 in t3)
              if (!ne(t3[e4]))
                return false;
            return true;
          }
          return false;
        }
        function ie3(t3) {
          if (null === t3)
            return ut;
          if ("string" == typeof t3)
            return ht;
          if ("boolean" == typeof t3)
            return pt2;
          if ("number" == typeof t3)
            return ct;
          if (t3 instanceof Jt)
            return ft;
          if (t3 instanceof Xt)
            return mt;
          if (t3 instanceof Yt)
            return gt;
          if (t3 instanceof Wt)
            return xt;
          if (t3 instanceof te2)
            return bt;
          if (t3 instanceof ee2)
            return vt;
          if (Array.isArray(t3)) {
            const e4 = t3.length;
            let r5;
            for (const e5 of t3) {
              const t4 = ie3(e5);
              if (r5) {
                if (r5 === t4)
                  continue;
                r5 = yt;
                break;
              }
              r5 = t4;
            }
            return wt(r5 || yt, e4);
          }
          return dt;
        }
        function se2(t3) {
          const e4 = typeof t3;
          return null === t3 ? "" : "string" === e4 || "number" === e4 || "boolean" === e4 ? String(t3) : t3 instanceof Jt || t3 instanceof Yt || t3 instanceof Wt || t3 instanceof te2 || t3 instanceof ee2 ? t3.toString() : JSON.stringify(t3);
        }
        class ae3 {
          constructor(t3, e4) {
            this.type = t3, this.value = e4;
          }
          static parse(t3, e4) {
            if (2 !== t3.length)
              return e4.error(`'literal' expression requires exactly one argument, but found ${t3.length - 1} instead.`);
            if (!ne(t3[1]))
              return e4.error("invalid value");
            const r5 = t3[1];
            let n3 = ie3(r5);
            const i4 = e4.expectedType;
            return "array" !== n3.kind || 0 !== n3.N || !i4 || "array" !== i4.kind || "number" == typeof i4.N && 0 !== i4.N || (n3 = i4), new ae3(n3, r5);
          }
          evaluate() {
            return this.value;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
        }
        class oe2 {
          constructor(t3) {
            this.name = "ExpressionEvaluationError", this.message = t3;
          }
          toJSON() {
            return this.message;
          }
        }
        const le2 = { string: ht, number: ct, boolean: pt2, object: dt };
        class ue2 {
          constructor(t3, e4) {
            this.type = t3, this.args = e4;
          }
          static parse(t3, e4) {
            if (t3.length < 2)
              return e4.error("Expected at least one argument.");
            let r5, n3 = 1;
            const i4 = t3[0];
            if ("array" === i4) {
              let i5, s5;
              if (t3.length > 2) {
                const r6 = t3[1];
                if ("string" != typeof r6 || !(r6 in le2) || "object" === r6)
                  return e4.error('The item type argument of "array" must be one of string, number, boolean', 1);
                i5 = le2[r6], n3++;
              } else
                i5 = yt;
              if (t3.length > 3) {
                if (null !== t3[2] && ("number" != typeof t3[2] || t3[2] < 0 || t3[2] !== Math.floor(t3[2])))
                  return e4.error('The length argument to "array" must be a positive integer literal', 2);
                s5 = t3[2], n3++;
              }
              r5 = wt(i5, s5);
            } else {
              if (!le2[i4])
                throw new Error(`Types doesn't contain name = ${i4}`);
              r5 = le2[i4];
            }
            const s4 = [];
            for (; n3 < t3.length; n3++) {
              const r6 = e4.parse(t3[n3], n3, yt);
              if (!r6)
                return null;
              s4.push(r6);
            }
            return new ue2(r5, s4);
          }
          evaluate(t3) {
            for (let e4 = 0; e4 < this.args.length; e4++) {
              const r5 = this.args[e4].evaluate(t3);
              if (!St(this.type, ie3(r5)))
                return r5;
              if (e4 === this.args.length - 1)
                throw new oe2(`Expected value to be of type ${_t(this.type)}, but found ${_t(ie3(r5))} instead.`);
            }
            throw new Error();
          }
          eachChild(t3) {
            this.args.forEach(t3);
          }
          outputDefined() {
            return this.args.every((t3) => t3.outputDefined());
          }
        }
        const ce3 = { "to-boolean": pt2, "to-color": ft, "to-number": ct, "to-string": ht };
        class he2 {
          constructor(t3, e4) {
            this.type = t3, this.args = e4;
          }
          static parse(t3, e4) {
            if (t3.length < 2)
              return e4.error("Expected at least one argument.");
            const r5 = t3[0];
            if (!ce3[r5])
              throw new Error(`Can't parse ${r5} as it is not part of the known types`);
            if (("to-boolean" === r5 || "to-string" === r5) && 2 !== t3.length)
              return e4.error("Expected one argument.");
            const n3 = ce3[r5], i4 = [];
            for (let r6 = 1; r6 < t3.length; r6++) {
              const n4 = e4.parse(t3[r6], r6, yt);
              if (!n4)
                return null;
              i4.push(n4);
            }
            return new he2(n3, i4);
          }
          evaluate(t3) {
            switch (this.type.kind) {
              case "boolean":
                return Boolean(this.args[0].evaluate(t3));
              case "color": {
                let e4, r5;
                for (const n3 of this.args) {
                  if (e4 = n3.evaluate(t3), r5 = null, e4 instanceof Jt)
                    return e4;
                  if ("string" == typeof e4) {
                    const r6 = t3.parseColor(e4);
                    if (r6)
                      return r6;
                  } else if (Array.isArray(e4) && (r5 = e4.length < 3 || e4.length > 4 ? `Invalid rbga value ${JSON.stringify(e4)}: expected an array containing either three or four numeric values.` : re2(e4[0], e4[1], e4[2], e4[3]), !r5))
                    return new Jt(e4[0] / 255, e4[1] / 255, e4[2] / 255, e4[3]);
                }
                throw new oe2(r5 || `Could not parse color from value '${"string" == typeof e4 ? e4 : JSON.stringify(e4)}'`);
              }
              case "padding": {
                let e4;
                for (const r5 of this.args) {
                  e4 = r5.evaluate(t3);
                  const n3 = Wt.parse(e4);
                  if (n3)
                    return n3;
                }
                throw new oe2(`Could not parse padding from value '${"string" == typeof e4 ? e4 : JSON.stringify(e4)}'`);
              }
              case "variableAnchorOffsetCollection": {
                let e4;
                for (const r5 of this.args) {
                  e4 = r5.evaluate(t3);
                  const n3 = te2.parse(e4);
                  if (n3)
                    return n3;
                }
                throw new oe2(`Could not parse variableAnchorOffsetCollection from value '${"string" == typeof e4 ? e4 : JSON.stringify(e4)}'`);
              }
              case "number": {
                let e4 = null;
                for (const r5 of this.args) {
                  if (e4 = r5.evaluate(t3), null === e4)
                    return 0;
                  const n3 = Number(e4);
                  if (!isNaN(n3))
                    return n3;
                }
                throw new oe2(`Could not convert ${JSON.stringify(e4)} to number.`);
              }
              case "formatted":
                return Yt.fromString(se2(this.args[0].evaluate(t3)));
              case "resolvedImage":
                return ee2.fromString(se2(this.args[0].evaluate(t3)));
              default:
                return se2(this.args[0].evaluate(t3));
            }
          }
          eachChild(t3) {
            this.args.forEach(t3);
          }
          outputDefined() {
            return this.args.every((t3) => t3.outputDefined());
          }
        }
        const pe2 = ["Unknown", "Point", "LineString", "Polygon"];
        class fe {
          constructor() {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
          }
          id() {
            return this.feature && "id" in this.feature ? this.feature.id : null;
          }
          geometryType() {
            return this.feature ? "number" == typeof this.feature.type ? pe2[this.feature.type] : this.feature.type : null;
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
          }
          canonicalID() {
            return this.canonical;
          }
          properties() {
            return this.feature && this.feature.properties || {};
          }
          parseColor(t3) {
            let e4 = this._parseColorCache[t3];
            return e4 || (e4 = this._parseColorCache[t3] = Jt.parse(t3)), e4;
          }
        }
        class de {
          constructor(t3, e4, r5 = [], n3, i4 = new lt(), s4 = []) {
            this.registry = t3, this.path = r5, this.key = r5.map((t4) => `[${t4}]`).join(""), this.scope = i4, this.errors = s4, this.expectedType = n3, this._isConstant = e4;
          }
          parse(t3, e4, r5, n3, i4 = {}) {
            return e4 ? this.concat(e4, r5, n3)._parse(t3, i4) : this._parse(t3, i4);
          }
          _parse(t3, e4) {
            function r5(t4, e5, r6) {
              return "assert" === r6 ? new ue2(e5, [t4]) : "coerce" === r6 ? new he2(e5, [t4]) : t4;
            }
            if (null !== t3 && "string" != typeof t3 && "boolean" != typeof t3 && "number" != typeof t3 || (t3 = ["literal", t3]), Array.isArray(t3)) {
              if (0 === t3.length)
                return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const n3 = t3[0];
              if ("string" != typeof n3)
                return this.error(`Expression name must be a string, but found ${typeof n3} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
              const i4 = this.registry[n3];
              if (i4) {
                let n4 = i4.parse(t3, this);
                if (!n4)
                  return null;
                if (this.expectedType) {
                  const t4 = this.expectedType, i5 = n4.type;
                  if ("string" !== t4.kind && "number" !== t4.kind && "boolean" !== t4.kind && "object" !== t4.kind && "array" !== t4.kind || "value" !== i5.kind)
                    if ("color" !== t4.kind && "formatted" !== t4.kind && "resolvedImage" !== t4.kind || "value" !== i5.kind && "string" !== i5.kind)
                      if ("padding" !== t4.kind || "value" !== i5.kind && "number" !== i5.kind && "array" !== i5.kind)
                        if ("variableAnchorOffsetCollection" !== t4.kind || "value" !== i5.kind && "array" !== i5.kind) {
                          if (this.checkSubtype(t4, i5))
                            return null;
                        } else
                          n4 = r5(n4, t4, e4.typeAnnotation || "coerce");
                      else
                        n4 = r5(n4, t4, e4.typeAnnotation || "coerce");
                    else
                      n4 = r5(n4, t4, e4.typeAnnotation || "coerce");
                  else
                    n4 = r5(n4, t4, e4.typeAnnotation || "assert");
                }
                if (!(n4 instanceof ae3) && "resolvedImage" !== n4.type.kind && this._isConstant(n4)) {
                  const t4 = new fe();
                  try {
                    n4 = new ae3(n4.type, n4.evaluate(t4));
                  } catch (t5) {
                    return this.error(t5.message), null;
                  }
                }
                return n4;
              }
              return this.error(`Unknown expression "${n3}". If you wanted a literal array, use ["literal", [...]].`, 0);
            }
            return this.error(void 0 === t3 ? "'undefined' value invalid. Use null instead." : "object" == typeof t3 ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t3} instead.`);
          }
          concat(t3, e4, r5) {
            const n3 = "number" == typeof t3 ? this.path.concat(t3) : this.path, i4 = r5 ? this.scope.concat(r5) : this.scope;
            return new de(this.registry, this._isConstant, n3, e4 || null, i4, this.errors);
          }
          error(t3, ...e4) {
            const r5 = `${this.key}${e4.map((t4) => `[${t4}]`).join("")}`;
            this.errors.push(new ot(r5, t3));
          }
          checkSubtype(t3, e4) {
            const r5 = St(t3, e4);
            return r5 && this.error(r5), r5;
          }
        }
        class ye {
          constructor(t3, e4, r5) {
            this.type = mt, this.locale = r5, this.caseSensitive = t3, this.diacriticSensitive = e4;
          }
          static parse(t3, e4) {
            if (2 !== t3.length)
              return e4.error("Expected one argument.");
            const r5 = t3[1];
            if ("object" != typeof r5 || Array.isArray(r5))
              return e4.error("Collator options argument must be an object.");
            const n3 = e4.parse(void 0 !== r5["case-sensitive"] && r5["case-sensitive"], 1, pt2);
            if (!n3)
              return null;
            const i4 = e4.parse(void 0 !== r5["diacritic-sensitive"] && r5["diacritic-sensitive"], 1, pt2);
            if (!i4)
              return null;
            let s4 = null;
            return r5.locale && (s4 = e4.parse(r5.locale, 1, ht), !s4) ? null : new ye(n3, i4, s4);
          }
          evaluate(t3) {
            return new Xt(this.caseSensitive.evaluate(t3), this.diacriticSensitive.evaluate(t3), this.locale ? this.locale.evaluate(t3) : null);
          }
          eachChild(t3) {
            t3(this.caseSensitive), t3(this.diacriticSensitive), this.locale && t3(this.locale);
          }
          outputDefined() {
            return false;
          }
        }
        const me2 = 8192;
        function ge2(t3, e4) {
          t3[0] = Math.min(t3[0], e4[0]), t3[1] = Math.min(t3[1], e4[1]), t3[2] = Math.max(t3[2], e4[0]), t3[3] = Math.max(t3[3], e4[1]);
        }
        function xe(t3, e4) {
          return !(t3[0] <= e4[0] || t3[2] >= e4[2] || t3[1] <= e4[1] || t3[3] >= e4[3]);
        }
        function ve(t3, e4) {
          const r5 = (180 + t3[0]) / 360, n3 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t3[1] * Math.PI / 360))) / 360, i4 = Math.pow(2, e4.z);
          return [Math.round(r5 * i4 * me2), Math.round(n3 * i4 * me2)];
        }
        function be2(t3, e4, r5) {
          const n3 = t3[0] - e4[0], i4 = t3[1] - e4[1], s4 = t3[0] - r5[0], a3 = t3[1] - r5[1];
          return n3 * a3 - s4 * i4 == 0 && n3 * s4 <= 0 && i4 * a3 <= 0;
        }
        function we(t3, e4) {
          let r5 = false;
          for (let a3 = 0, o3 = e4.length; a3 < o3; a3++) {
            const o4 = e4[a3];
            for (let e5 = 0, a4 = o4.length; e5 < a4 - 1; e5++) {
              if (be2(t3, o4[e5], o4[e5 + 1]))
                return false;
              (i4 = o4[e5])[1] > (n3 = t3)[1] != (s4 = o4[e5 + 1])[1] > n3[1] && n3[0] < (s4[0] - i4[0]) * (n3[1] - i4[1]) / (s4[1] - i4[1]) + i4[0] && (r5 = !r5);
            }
          }
          var n3, i4, s4;
          return r5;
        }
        function _e2(t3, e4) {
          for (let r5 = 0; r5 < e4.length; r5++)
            if (we(t3, e4[r5]))
              return true;
          return false;
        }
        function Ae2(t3, e4, r5, n3) {
          const i4 = n3[0] - r5[0], s4 = n3[1] - r5[1], a3 = (t3[0] - r5[0]) * s4 - i4 * (t3[1] - r5[1]), o3 = (e4[0] - r5[0]) * s4 - i4 * (e4[1] - r5[1]);
          return a3 > 0 && o3 < 0 || a3 < 0 && o3 > 0;
        }
        function Se(t3, e4, r5) {
          for (const u3 of r5)
            for (let r6 = 0; r6 < u3.length - 1; ++r6)
              if (0 != (o3 = [(a3 = u3[r6 + 1])[0] - (s4 = u3[r6])[0], a3[1] - s4[1]])[0] * (l4 = [(i4 = e4)[0] - (n3 = t3)[0], i4[1] - n3[1]])[1] - o3[1] * l4[0] && Ae2(n3, i4, s4, a3) && Ae2(s4, a3, n3, i4))
                return true;
          var n3, i4, s4, a3, o3, l4;
          return false;
        }
        function ke(t3, e4) {
          for (let r5 = 0; r5 < t3.length; ++r5)
            if (!we(t3[r5], e4))
              return false;
          for (let r5 = 0; r5 < t3.length - 1; ++r5)
            if (Se(t3[r5], t3[r5 + 1], e4))
              return false;
          return true;
        }
        function Ie2(t3, e4) {
          for (let r5 = 0; r5 < e4.length; r5++)
            if (ke(t3, e4[r5]))
              return true;
          return false;
        }
        function ze(t3, e4, r5) {
          const n3 = [];
          for (let i4 = 0; i4 < t3.length; i4++) {
            const s4 = [];
            for (let n4 = 0; n4 < t3[i4].length; n4++) {
              const a3 = ve(t3[i4][n4], r5);
              ge2(e4, a3), s4.push(a3);
            }
            n3.push(s4);
          }
          return n3;
        }
        function Me(t3, e4, r5) {
          const n3 = [];
          for (let i4 = 0; i4 < t3.length; i4++) {
            const s4 = ze(t3[i4], e4, r5);
            n3.push(s4);
          }
          return n3;
        }
        function Be(t3, e4, r5, n3) {
          if (t3[0] < r5[0] || t3[0] > r5[2]) {
            const e5 = 0.5 * n3;
            let i4 = t3[0] - r5[0] > e5 ? -n3 : r5[0] - t3[0] > e5 ? n3 : 0;
            0 === i4 && (i4 = t3[0] - r5[2] > e5 ? -n3 : r5[2] - t3[0] > e5 ? n3 : 0), t3[0] += i4;
          }
          ge2(e4, t3);
        }
        function Ce(t3, e4, r5, n3) {
          const i4 = Math.pow(2, n3.z) * me2, s4 = [n3.x * me2, n3.y * me2], a3 = [];
          for (const n4 of t3)
            for (const t4 of n4) {
              const n5 = [t4.x + s4[0], t4.y + s4[1]];
              Be(n5, e4, r5, i4), a3.push(n5);
            }
          return a3;
        }
        function Pe2(t3, e4, r5, n3) {
          const i4 = Math.pow(2, n3.z) * me2, s4 = [n3.x * me2, n3.y * me2], a3 = [];
          for (const r6 of t3) {
            const t4 = [];
            for (const n4 of r6) {
              const r7 = [n4.x + s4[0], n4.y + s4[1]];
              ge2(e4, r7), t4.push(r7);
            }
            a3.push(t4);
          }
          if (e4[2] - e4[0] <= i4 / 2) {
            (o3 = e4)[0] = o3[1] = 1 / 0, o3[2] = o3[3] = -1 / 0;
            for (const t4 of a3)
              for (const n4 of t4)
                Be(n4, e4, r5, i4);
          }
          var o3;
          return a3;
        }
        class Ve2 {
          constructor(t3, e4) {
            this.type = pt2, this.geojson = t3, this.geometries = e4;
          }
          static parse(t3, e4) {
            if (2 !== t3.length)
              return e4.error(`'within' expression requires exactly one argument, but found ${t3.length - 1} instead.`);
            if (ne(t3[1])) {
              const e5 = t3[1];
              if ("FeatureCollection" === e5.type) {
                const t4 = [];
                for (const r5 of e5.features) {
                  const { type: e6, coordinates: n3 } = r5.geometry;
                  "Polygon" === e6 && t4.push(n3), "MultiPolygon" === e6 && t4.push(...n3);
                }
                if (t4.length)
                  return new Ve2(e5, { type: "MultiPolygon", coordinates: t4 });
              } else if ("Feature" === e5.type) {
                const t4 = e5.geometry.type;
                if ("Polygon" === t4 || "MultiPolygon" === t4)
                  return new Ve2(e5, e5.geometry);
              } else if ("Polygon" === e5.type || "MultiPolygon" === e5.type)
                return new Ve2(e5, e5);
            }
            return e4.error("'within' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(t3) {
            if (null != t3.geometry() && null != t3.canonicalID()) {
              if ("Point" === t3.geometryType())
                return function(t4, e4) {
                  const r5 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i4 = t4.canonicalID();
                  if ("Polygon" === e4.type) {
                    const s4 = ze(e4.coordinates, n3, i4), a3 = Ce(t4.geometry(), r5, n3, i4);
                    if (!xe(r5, n3))
                      return false;
                    for (const t5 of a3)
                      if (!we(t5, s4))
                        return false;
                  }
                  if ("MultiPolygon" === e4.type) {
                    const s4 = Me(e4.coordinates, n3, i4), a3 = Ce(t4.geometry(), r5, n3, i4);
                    if (!xe(r5, n3))
                      return false;
                    for (const t5 of a3)
                      if (!_e2(t5, s4))
                        return false;
                  }
                  return true;
                }(t3, this.geometries);
              if ("LineString" === t3.geometryType())
                return function(t4, e4) {
                  const r5 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i4 = t4.canonicalID();
                  if ("Polygon" === e4.type) {
                    const s4 = ze(e4.coordinates, n3, i4), a3 = Pe2(t4.geometry(), r5, n3, i4);
                    if (!xe(r5, n3))
                      return false;
                    for (const t5 of a3)
                      if (!ke(t5, s4))
                        return false;
                  }
                  if ("MultiPolygon" === e4.type) {
                    const s4 = Me(e4.coordinates, n3, i4), a3 = Pe2(t4.geometry(), r5, n3, i4);
                    if (!xe(r5, n3))
                      return false;
                    for (const t5 of a3)
                      if (!Ie2(t5, s4))
                        return false;
                  }
                  return true;
                }(t3, this.geometries);
            }
            return false;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
        }
        class Ee {
          constructor(t3, e4) {
            this.type = e4.type, this.name = t3, this.boundExpression = e4;
          }
          static parse(t3, e4) {
            if (2 !== t3.length || "string" != typeof t3[1])
              return e4.error("'var' expression requires exactly one string literal argument.");
            const r5 = t3[1];
            return e4.scope.has(r5) ? new Ee(r5, e4.scope.get(r5)) : e4.error(`Unknown variable "${r5}". Make sure "${r5}" has been bound in an enclosing "let" expression before using it.`, 1);
          }
          evaluate(t3) {
            return this.boundExpression.evaluate(t3);
          }
          eachChild() {
          }
          outputDefined() {
            return false;
          }
        }
        class Fe {
          constructor(t3, e4, r5, n3) {
            this.name = t3, this.type = e4, this._evaluate = r5, this.args = n3;
          }
          evaluate(t3) {
            return this._evaluate(t3, this.args);
          }
          eachChild(t3) {
            this.args.forEach(t3);
          }
          outputDefined() {
            return false;
          }
          static parse(t3, e4) {
            const r5 = t3[0], n3 = Fe.definitions[r5];
            if (!n3)
              return e4.error(`Unknown expression "${r5}". If you wanted a literal array, use ["literal", [...]].`, 0);
            const i4 = Array.isArray(n3) ? n3[0] : n3.type, s4 = Array.isArray(n3) ? [[n3[1], n3[2]]] : n3.overloads, a3 = s4.filter(([e5]) => !Array.isArray(e5) || e5.length === t3.length - 1);
            let o3 = null;
            for (const [n4, s5] of a3) {
              o3 = new de(e4.registry, Te2, e4.path, null, e4.scope);
              const a4 = [];
              let l4 = false;
              for (let e5 = 1; e5 < t3.length; e5++) {
                const r6 = t3[e5], i5 = Array.isArray(n4) ? n4[e5 - 1] : n4.type, s6 = o3.parse(r6, 1 + a4.length, i5);
                if (!s6) {
                  l4 = true;
                  break;
                }
                a4.push(s6);
              }
              if (!l4)
                if (Array.isArray(n4) && n4.length !== a4.length)
                  o3.error(`Expected ${n4.length} arguments, but found ${a4.length} instead.`);
                else {
                  for (let t4 = 0; t4 < a4.length; t4++) {
                    const e5 = Array.isArray(n4) ? n4[t4] : n4.type, r6 = a4[t4];
                    o3.concat(t4 + 1).checkSubtype(e5, r6.type);
                  }
                  if (0 === o3.errors.length)
                    return new Fe(r5, i4, s5, a4);
                }
            }
            if (1 === a3.length)
              e4.errors.push(...o3.errors);
            else {
              const r6 = (a3.length ? a3 : s4).map(([t4]) => {
                return e5 = t4, Array.isArray(e5) ? `(${e5.map(_t).join(", ")})` : `(${_t(e5.type)}...)`;
                var e5;
              }).join(" | "), n4 = [];
              for (let r7 = 1; r7 < t3.length; r7++) {
                const i5 = e4.parse(t3[r7], 1 + n4.length);
                if (!i5)
                  return null;
                n4.push(_t(i5.type));
              }
              e4.error(`Expected arguments of type ${r6}, but found (${n4.join(", ")}) instead.`);
            }
            return null;
          }
          static register(t3, e4) {
            Fe.definitions = e4;
            for (const r5 in e4)
              t3[r5] = Fe;
          }
        }
        function Te2(t3) {
          if (t3 instanceof Ee)
            return Te2(t3.boundExpression);
          if (t3 instanceof Fe && "error" === t3.name)
            return false;
          if (t3 instanceof ye)
            return false;
          if (t3 instanceof Ve2)
            return false;
          const e4 = t3 instanceof he2 || t3 instanceof ue2;
          let r5 = true;
          return t3.eachChild((t4) => {
            r5 = e4 ? r5 && Te2(t4) : r5 && t4 instanceof ae3;
          }), !!r5 && $e(t3) && Le(t3, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);
        }
        function $e(t3) {
          if (t3 instanceof Fe) {
            if ("get" === t3.name && 1 === t3.args.length)
              return false;
            if ("feature-state" === t3.name)
              return false;
            if ("has" === t3.name && 1 === t3.args.length)
              return false;
            if ("properties" === t3.name || "geometry-type" === t3.name || "id" === t3.name)
              return false;
            if (/^filter-/.test(t3.name))
              return false;
          }
          if (t3 instanceof Ve2)
            return false;
          let e4 = true;
          return t3.eachChild((t4) => {
            e4 && !$e(t4) && (e4 = false);
          }), e4;
        }
        function De(t3) {
          if (t3 instanceof Fe && "feature-state" === t3.name)
            return false;
          let e4 = true;
          return t3.eachChild((t4) => {
            e4 && !De(t4) && (e4 = false);
          }), e4;
        }
        function Le(t3, e4) {
          if (t3 instanceof Fe && e4.indexOf(t3.name) >= 0)
            return false;
          let r5 = true;
          return t3.eachChild((t4) => {
            r5 && !Le(t4, e4) && (r5 = false);
          }), r5;
        }
        function Oe(t3, e4) {
          const r5 = t3.length - 1;
          let n3, i4, s4 = 0, a3 = r5, o3 = 0;
          for (; s4 <= a3; )
            if (o3 = Math.floor((s4 + a3) / 2), n3 = t3[o3], i4 = t3[o3 + 1], n3 <= e4) {
              if (o3 === r5 || e4 < i4)
                return o3;
              s4 = o3 + 1;
            } else {
              if (!(n3 > e4))
                throw new oe2("Input is not a number.");
              a3 = o3 - 1;
            }
          return 0;
        }
        class Re2 {
          constructor(t3, e4, r5) {
            this.type = t3, this.input = e4, this.labels = [], this.outputs = [];
            for (const [t4, e5] of r5)
              this.labels.push(t4), this.outputs.push(e5);
          }
          static parse(t3, e4) {
            if (t3.length - 1 < 4)
              return e4.error(`Expected at least 4 arguments, but found only ${t3.length - 1}.`);
            if ((t3.length - 1) % 2 != 0)
              return e4.error("Expected an even number of arguments.");
            const r5 = e4.parse(t3[1], 1, ct);
            if (!r5)
              return null;
            const n3 = [];
            let i4 = null;
            e4.expectedType && "value" !== e4.expectedType.kind && (i4 = e4.expectedType);
            for (let r6 = 1; r6 < t3.length; r6 += 2) {
              const s4 = 1 === r6 ? -1 / 0 : t3[r6], a3 = t3[r6 + 1], o3 = r6, l4 = r6 + 1;
              if ("number" != typeof s4)
                return e4.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o3);
              if (n3.length && n3[n3.length - 1][0] >= s4)
                return e4.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o3);
              const u3 = e4.parse(a3, l4, i4);
              if (!u3)
                return null;
              i4 = i4 || u3.type, n3.push([s4, u3]);
            }
            return new Re2(i4, r5, n3);
          }
          evaluate(t3) {
            const e4 = this.labels, r5 = this.outputs;
            if (1 === e4.length)
              return r5[0].evaluate(t3);
            const n3 = this.input.evaluate(t3);
            if (n3 <= e4[0])
              return r5[0].evaluate(t3);
            const i4 = e4.length;
            return n3 >= e4[i4 - 1] ? r5[i4 - 1].evaluate(t3) : r5[Oe(e4, n3)].evaluate(t3);
          }
          eachChild(t3) {
            t3(this.input);
            for (const e4 of this.outputs)
              t3(e4);
          }
          outputDefined() {
            return this.outputs.every((t3) => t3.outputDefined());
          }
        }
        function Ue(t3) {
          return t3 && t3.__esModule && Object.prototype.hasOwnProperty.call(t3, "default") ? t3.default : t3;
        }
        var je = qe;
        function qe(t3, e4, r5, n3) {
          this.cx = 3 * t3, this.bx = 3 * (r5 - t3) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e4, this.by = 3 * (n3 - e4) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t3, this.p1y = e4, this.p2x = r5, this.p2y = n3;
        }
        qe.prototype = { sampleCurveX: function(t3) {
          return ((this.ax * t3 + this.bx) * t3 + this.cx) * t3;
        }, sampleCurveY: function(t3) {
          return ((this.ay * t3 + this.by) * t3 + this.cy) * t3;
        }, sampleCurveDerivativeX: function(t3) {
          return (3 * this.ax * t3 + 2 * this.bx) * t3 + this.cx;
        }, solveCurveX: function(t3, e4) {
          if (void 0 === e4 && (e4 = 1e-6), t3 < 0)
            return 0;
          if (t3 > 1)
            return 1;
          for (var r5 = t3, n3 = 0; n3 < 8; n3++) {
            var i4 = this.sampleCurveX(r5) - t3;
            if (Math.abs(i4) < e4)
              return r5;
            var s4 = this.sampleCurveDerivativeX(r5);
            if (Math.abs(s4) < 1e-6)
              break;
            r5 -= i4 / s4;
          }
          var a3 = 0, o3 = 1;
          for (r5 = t3, n3 = 0; n3 < 20 && (i4 = this.sampleCurveX(r5), !(Math.abs(i4 - t3) < e4)); n3++)
            t3 > i4 ? a3 = r5 : o3 = r5, r5 = 0.5 * (o3 - a3) + a3;
          return r5;
        }, solve: function(t3, e4) {
          return this.sampleCurveY(this.solveCurveX(t3, e4));
        } };
        var Ne = Ue(je);
        function Ze(t3, e4, r5) {
          return t3 + r5 * (e4 - t3);
        }
        function Ke(t3, e4, r5) {
          return t3.map((t4, n3) => Ze(t4, e4[n3], r5));
        }
        const Ge = { number: Ze, color: function(t3, e4, r5, n3 = "rgb") {
          switch (n3) {
            case "rgb": {
              const [n4, i4, s4, a3] = Ke(t3.rgb, e4.rgb, r5);
              return new Jt(n4, i4, s4, a3, false);
            }
            case "hcl": {
              const [n4, i4, s4, a3] = t3.hcl, [o3, l4, u3, c3] = e4.hcl;
              let h2, p4;
              if (isNaN(n4) || isNaN(o3))
                isNaN(n4) ? isNaN(o3) ? h2 = NaN : (h2 = o3, 1 !== s4 && 0 !== s4 || (p4 = l4)) : (h2 = n4, 1 !== u3 && 0 !== u3 || (p4 = i4));
              else {
                let t4 = o3 - n4;
                o3 > n4 && t4 > 180 ? t4 -= 360 : o3 < n4 && n4 - o3 > 180 && (t4 += 360), h2 = n4 + r5 * t4;
              }
              const [f2, d2, y4, m2] = function([t4, e5, r6, n5]) {
                return t4 = isNaN(t4) ? 0 : t4 * Ft, Rt([r6, Math.cos(t4) * e5, Math.sin(t4) * e5, n5]);
              }([h2, null != p4 ? p4 : Ze(i4, l4, r5), Ze(s4, u3, r5), Ze(a3, c3, r5)]);
              return new Jt(f2, d2, y4, m2, false);
            }
            case "lab": {
              const [n4, i4, s4, a3] = Rt(Ke(t3.lab, e4.lab, r5));
              return new Jt(n4, i4, s4, a3, false);
            }
          }
        }, array: Ke, padding: function(t3, e4, r5) {
          return new Wt(Ke(t3.values, e4.values, r5));
        }, variableAnchorOffsetCollection: function(t3, e4, r5) {
          const n3 = t3.values, i4 = e4.values;
          if (n3.length !== i4.length)
            throw new oe2(`Cannot interpolate values of different length. from: ${t3.toString()}, to: ${e4.toString()}`);
          const s4 = [];
          for (let t4 = 0; t4 < n3.length; t4 += 2) {
            if (n3[t4] !== i4[t4])
              throw new oe2(`Cannot interpolate values containing mismatched anchors. from[${t4}]: ${n3[t4]}, to[${t4}]: ${i4[t4]}`);
            s4.push(n3[t4]);
            const [e5, a3] = n3[t4 + 1], [o3, l4] = i4[t4 + 1];
            s4.push([Ze(e5, o3, r5), Ze(a3, l4, r5)]);
          }
          return new te2(s4);
        } };
        class Je {
          constructor(t3, e4, r5, n3, i4) {
            this.type = t3, this.operator = e4, this.interpolation = r5, this.input = n3, this.labels = [], this.outputs = [];
            for (const [t4, e5] of i4)
              this.labels.push(t4), this.outputs.push(e5);
          }
          static interpolationFactor(t3, e4, r5, n3) {
            let i4 = 0;
            if ("exponential" === t3.name)
              i4 = Xe(e4, t3.base, r5, n3);
            else if ("linear" === t3.name)
              i4 = Xe(e4, 1, r5, n3);
            else if ("cubic-bezier" === t3.name) {
              const s4 = t3.controlPoints;
              i4 = new Ne(s4[0], s4[1], s4[2], s4[3]).solve(Xe(e4, 1, r5, n3));
            }
            return i4;
          }
          static parse(t3, e4) {
            let [r5, n3, i4, ...s4] = t3;
            if (!Array.isArray(n3) || 0 === n3.length)
              return e4.error("Expected an interpolation type expression.", 1);
            if ("linear" === n3[0])
              n3 = { name: "linear" };
            else if ("exponential" === n3[0]) {
              const t4 = n3[1];
              if ("number" != typeof t4)
                return e4.error("Exponential interpolation requires a numeric base.", 1, 1);
              n3 = { name: "exponential", base: t4 };
            } else {
              if ("cubic-bezier" !== n3[0])
                return e4.error(`Unknown interpolation type ${String(n3[0])}`, 1, 0);
              {
                const t4 = n3.slice(1);
                if (4 !== t4.length || t4.some((t5) => "number" != typeof t5 || t5 < 0 || t5 > 1))
                  return e4.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                n3 = { name: "cubic-bezier", controlPoints: t4 };
              }
            }
            if (t3.length - 1 < 4)
              return e4.error(`Expected at least 4 arguments, but found only ${t3.length - 1}.`);
            if ((t3.length - 1) % 2 != 0)
              return e4.error("Expected an even number of arguments.");
            if (i4 = e4.parse(i4, 2, ct), !i4)
              return null;
            const a3 = [];
            let o3 = null;
            "interpolate-hcl" === r5 || "interpolate-lab" === r5 ? o3 = ft : e4.expectedType && "value" !== e4.expectedType.kind && (o3 = e4.expectedType);
            for (let t4 = 0; t4 < s4.length; t4 += 2) {
              const r6 = s4[t4], n4 = s4[t4 + 1], i5 = t4 + 3, l4 = t4 + 4;
              if ("number" != typeof r6)
                return e4.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i5);
              if (a3.length && a3[a3.length - 1][0] >= r6)
                return e4.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i5);
              const u3 = e4.parse(n4, l4, o3);
              if (!u3)
                return null;
              o3 = o3 || u3.type, a3.push([r6, u3]);
            }
            return zt(o3, ct) || zt(o3, ft) || zt(o3, xt) || zt(o3, bt) || zt(o3, wt(ct)) ? new Je(o3, r5, n3, i4, a3) : e4.error(`Type ${_t(o3)} is not interpolatable.`);
          }
          evaluate(t3) {
            const e4 = this.labels, r5 = this.outputs;
            if (1 === e4.length)
              return r5[0].evaluate(t3);
            const n3 = this.input.evaluate(t3);
            if (n3 <= e4[0])
              return r5[0].evaluate(t3);
            const i4 = e4.length;
            if (n3 >= e4[i4 - 1])
              return r5[i4 - 1].evaluate(t3);
            const s4 = Oe(e4, n3), a3 = Je.interpolationFactor(this.interpolation, n3, e4[s4], e4[s4 + 1]), o3 = r5[s4].evaluate(t3), l4 = r5[s4 + 1].evaluate(t3);
            switch (this.operator) {
              case "interpolate":
                return Ge[this.type.kind](o3, l4, a3);
              case "interpolate-hcl":
                return Ge.color(o3, l4, a3, "hcl");
              case "interpolate-lab":
                return Ge.color(o3, l4, a3, "lab");
            }
          }
          eachChild(t3) {
            t3(this.input);
            for (const e4 of this.outputs)
              t3(e4);
          }
          outputDefined() {
            return this.outputs.every((t3) => t3.outputDefined());
          }
        }
        function Xe(t3, e4, r5, n3) {
          const i4 = n3 - r5, s4 = t3 - r5;
          return 0 === i4 ? 0 : 1 === e4 ? s4 / i4 : (Math.pow(e4, s4) - 1) / (Math.pow(e4, i4) - 1);
        }
        class He {
          constructor(t3, e4) {
            this.type = t3, this.args = e4;
          }
          static parse(t3, e4) {
            if (t3.length < 2)
              return e4.error("Expectected at least one argument.");
            let r5 = null;
            const n3 = e4.expectedType;
            n3 && "value" !== n3.kind && (r5 = n3);
            const i4 = [];
            for (const n4 of t3.slice(1)) {
              const t4 = e4.parse(n4, 1 + i4.length, r5, void 0, { typeAnnotation: "omit" });
              if (!t4)
                return null;
              r5 = r5 || t4.type, i4.push(t4);
            }
            if (!r5)
              throw new Error("No output type");
            const s4 = n3 && i4.some((t4) => St(n3, t4.type));
            return new He(s4 ? yt : r5, i4);
          }
          evaluate(t3) {
            let e4, r5 = null, n3 = 0;
            for (const i4 of this.args)
              if (n3++, r5 = i4.evaluate(t3), r5 && r5 instanceof ee2 && !r5.available && (e4 || (e4 = r5.name), r5 = null, n3 === this.args.length && (r5 = e4)), null !== r5)
                break;
            return r5;
          }
          eachChild(t3) {
            this.args.forEach(t3);
          }
          outputDefined() {
            return this.args.every((t3) => t3.outputDefined());
          }
        }
        class Ye {
          constructor(t3, e4) {
            this.type = e4.type, this.bindings = [].concat(t3), this.result = e4;
          }
          evaluate(t3) {
            return this.result.evaluate(t3);
          }
          eachChild(t3) {
            for (const e4 of this.bindings)
              t3(e4[1]);
            t3(this.result);
          }
          static parse(t3, e4) {
            if (t3.length < 4)
              return e4.error(`Expected at least 3 arguments, but found ${t3.length - 1} instead.`);
            const r5 = [];
            for (let n4 = 1; n4 < t3.length - 1; n4 += 2) {
              const i4 = t3[n4];
              if ("string" != typeof i4)
                return e4.error(`Expected string, but found ${typeof i4} instead.`, n4);
              if (/[^a-zA-Z0-9_]/.test(i4))
                return e4.error("Variable names must contain only alphanumeric characters or '_'.", n4);
              const s4 = e4.parse(t3[n4 + 1], n4 + 1);
              if (!s4)
                return null;
              r5.push([i4, s4]);
            }
            const n3 = e4.parse(t3[t3.length - 1], t3.length - 1, e4.expectedType, r5);
            return n3 ? new Ye(r5, n3) : null;
          }
          outputDefined() {
            return this.result.outputDefined();
          }
        }
        class We {
          constructor(t3, e4, r5) {
            this.type = t3, this.index = e4, this.input = r5;
          }
          static parse(t3, e4) {
            if (3 !== t3.length)
              return e4.error(`Expected 2 arguments, but found ${t3.length - 1} instead.`);
            const r5 = e4.parse(t3[1], 1, ct), n3 = e4.parse(t3[2], 2, wt(e4.expectedType || yt));
            return r5 && n3 ? new We(n3.type.itemType, r5, n3) : null;
          }
          evaluate(t3) {
            const e4 = this.index.evaluate(t3), r5 = this.input.evaluate(t3);
            if (e4 < 0)
              throw new oe2(`Array index out of bounds: ${e4} < 0.`);
            if (e4 >= r5.length)
              throw new oe2(`Array index out of bounds: ${e4} > ${r5.length - 1}.`);
            if (e4 !== Math.floor(e4))
              throw new oe2(`Array index must be an integer, but found ${e4} instead.`);
            return r5[e4];
          }
          eachChild(t3) {
            t3(this.index), t3(this.input);
          }
          outputDefined() {
            return false;
          }
        }
        class Qe {
          constructor(t3, e4) {
            this.type = pt2, this.needle = t3, this.haystack = e4;
          }
          static parse(t3, e4) {
            if (3 !== t3.length)
              return e4.error(`Expected 2 arguments, but found ${t3.length - 1} instead.`);
            const r5 = e4.parse(t3[1], 1, yt), n3 = e4.parse(t3[2], 2, yt);
            return r5 && n3 ? kt(r5.type, [pt2, ht, ct, ut, yt]) ? new Qe(r5, n3) : e4.error(`Expected first argument to be of type boolean, string, number or null, but found ${_t(r5.type)} instead`) : null;
          }
          evaluate(t3) {
            const e4 = this.needle.evaluate(t3), r5 = this.haystack.evaluate(t3);
            if (!r5)
              return false;
            if (!It(e4, ["boolean", "string", "number", "null"]))
              throw new oe2(`Expected first argument to be of type boolean, string, number or null, but found ${_t(ie3(e4))} instead.`);
            if (!It(r5, ["string", "array"]))
              throw new oe2(`Expected second argument to be of type array or string, but found ${_t(ie3(r5))} instead.`);
            return r5.indexOf(e4) >= 0;
          }
          eachChild(t3) {
            t3(this.needle), t3(this.haystack);
          }
          outputDefined() {
            return true;
          }
        }
        class tr {
          constructor(t3, e4, r5) {
            this.type = ct, this.needle = t3, this.haystack = e4, this.fromIndex = r5;
          }
          static parse(t3, e4) {
            if (t3.length <= 2 || t3.length >= 5)
              return e4.error(`Expected 3 or 4 arguments, but found ${t3.length - 1} instead.`);
            const r5 = e4.parse(t3[1], 1, yt), n3 = e4.parse(t3[2], 2, yt);
            if (!r5 || !n3)
              return null;
            if (!kt(r5.type, [pt2, ht, ct, ut, yt]))
              return e4.error(`Expected first argument to be of type boolean, string, number or null, but found ${_t(r5.type)} instead`);
            if (4 === t3.length) {
              const i4 = e4.parse(t3[3], 3, ct);
              return i4 ? new tr(r5, n3, i4) : null;
            }
            return new tr(r5, n3);
          }
          evaluate(t3) {
            const e4 = this.needle.evaluate(t3), r5 = this.haystack.evaluate(t3);
            if (!It(e4, ["boolean", "string", "number", "null"]))
              throw new oe2(`Expected first argument to be of type boolean, string, number or null, but found ${_t(ie3(e4))} instead.`);
            if (!It(r5, ["string", "array"]))
              throw new oe2(`Expected second argument to be of type array or string, but found ${_t(ie3(r5))} instead.`);
            if (this.fromIndex) {
              const n3 = this.fromIndex.evaluate(t3);
              return r5.indexOf(e4, n3);
            }
            return r5.indexOf(e4);
          }
          eachChild(t3) {
            t3(this.needle), t3(this.haystack), this.fromIndex && t3(this.fromIndex);
          }
          outputDefined() {
            return false;
          }
        }
        class er {
          constructor(t3, e4, r5, n3, i4, s4) {
            this.inputType = t3, this.type = e4, this.input = r5, this.cases = n3, this.outputs = i4, this.otherwise = s4;
          }
          static parse(t3, e4) {
            if (t3.length < 5)
              return e4.error(`Expected at least 4 arguments, but found only ${t3.length - 1}.`);
            if (t3.length % 2 != 1)
              return e4.error("Expected an even number of arguments.");
            let r5, n3;
            e4.expectedType && "value" !== e4.expectedType.kind && (n3 = e4.expectedType);
            const i4 = {}, s4 = [];
            for (let a4 = 2; a4 < t3.length - 1; a4 += 2) {
              let o4 = t3[a4];
              const l4 = t3[a4 + 1];
              Array.isArray(o4) || (o4 = [o4]);
              const u3 = e4.concat(a4);
              if (0 === o4.length)
                return u3.error("Expected at least one branch label.");
              for (const t4 of o4) {
                if ("number" != typeof t4 && "string" != typeof t4)
                  return u3.error("Branch labels must be numbers or strings.");
                if ("number" == typeof t4 && Math.abs(t4) > Number.MAX_SAFE_INTEGER)
                  return u3.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if ("number" == typeof t4 && Math.floor(t4) !== t4)
                  return u3.error("Numeric branch labels must be integer values.");
                if (r5) {
                  if (u3.checkSubtype(r5, ie3(t4)))
                    return null;
                } else
                  r5 = ie3(t4);
                if (void 0 !== i4[String(t4)])
                  return u3.error("Branch labels must be unique.");
                i4[String(t4)] = s4.length;
              }
              const c3 = e4.parse(l4, a4, n3);
              if (!c3)
                return null;
              n3 = n3 || c3.type, s4.push(c3);
            }
            const a3 = e4.parse(t3[1], 1, yt);
            if (!a3)
              return null;
            const o3 = e4.parse(t3[t3.length - 1], t3.length - 1, n3);
            return o3 ? "value" !== a3.type.kind && e4.concat(1).checkSubtype(r5, a3.type) ? null : new er(r5, n3, a3, i4, s4, o3) : null;
          }
          evaluate(t3) {
            const e4 = this.input.evaluate(t3);
            return (ie3(e4) === this.inputType && this.outputs[this.cases[e4]] || this.otherwise).evaluate(t3);
          }
          eachChild(t3) {
            t3(this.input), this.outputs.forEach(t3), t3(this.otherwise);
          }
          outputDefined() {
            return this.outputs.every((t3) => t3.outputDefined()) && this.otherwise.outputDefined();
          }
        }
        class rr {
          constructor(t3, e4, r5) {
            this.type = t3, this.branches = e4, this.otherwise = r5;
          }
          static parse(t3, e4) {
            if (t3.length < 4)
              return e4.error(`Expected at least 3 arguments, but found only ${t3.length - 1}.`);
            if (t3.length % 2 != 0)
              return e4.error("Expected an odd number of arguments.");
            let r5;
            e4.expectedType && "value" !== e4.expectedType.kind && (r5 = e4.expectedType);
            const n3 = [];
            for (let i5 = 1; i5 < t3.length - 1; i5 += 2) {
              const s4 = e4.parse(t3[i5], i5, pt2);
              if (!s4)
                return null;
              const a3 = e4.parse(t3[i5 + 1], i5 + 1, r5);
              if (!a3)
                return null;
              n3.push([s4, a3]), r5 = r5 || a3.type;
            }
            const i4 = e4.parse(t3[t3.length - 1], t3.length - 1, r5);
            if (!i4)
              return null;
            if (!r5)
              throw new Error("Can't infer output type");
            return new rr(r5, n3, i4);
          }
          evaluate(t3) {
            for (const [e4, r5] of this.branches)
              if (e4.evaluate(t3))
                return r5.evaluate(t3);
            return this.otherwise.evaluate(t3);
          }
          eachChild(t3) {
            for (const [e4, r5] of this.branches)
              t3(e4), t3(r5);
            t3(this.otherwise);
          }
          outputDefined() {
            return this.branches.every(([t3, e4]) => e4.outputDefined()) && this.otherwise.outputDefined();
          }
        }
        class nr {
          constructor(t3, e4, r5, n3) {
            this.type = t3, this.input = e4, this.beginIndex = r5, this.endIndex = n3;
          }
          static parse(t3, e4) {
            if (t3.length <= 2 || t3.length >= 5)
              return e4.error(`Expected 3 or 4 arguments, but found ${t3.length - 1} instead.`);
            const r5 = e4.parse(t3[1], 1, yt), n3 = e4.parse(t3[2], 2, ct);
            if (!r5 || !n3)
              return null;
            if (!kt(r5.type, [wt(yt), ht, yt]))
              return e4.error(`Expected first argument to be of type array or string, but found ${_t(r5.type)} instead`);
            if (4 === t3.length) {
              const i4 = e4.parse(t3[3], 3, ct);
              return i4 ? new nr(r5.type, r5, n3, i4) : null;
            }
            return new nr(r5.type, r5, n3);
          }
          evaluate(t3) {
            const e4 = this.input.evaluate(t3), r5 = this.beginIndex.evaluate(t3);
            if (!It(e4, ["string", "array"]))
              throw new oe2(`Expected first argument to be of type array or string, but found ${_t(ie3(e4))} instead.`);
            if (this.endIndex) {
              const n3 = this.endIndex.evaluate(t3);
              return e4.slice(r5, n3);
            }
            return e4.slice(r5);
          }
          eachChild(t3) {
            t3(this.input), t3(this.beginIndex), this.endIndex && t3(this.endIndex);
          }
          outputDefined() {
            return false;
          }
        }
        function ir(t3, e4) {
          return "==" === t3 || "!=" === t3 ? "boolean" === e4.kind || "string" === e4.kind || "number" === e4.kind || "null" === e4.kind || "value" === e4.kind : "string" === e4.kind || "number" === e4.kind || "value" === e4.kind;
        }
        function sr(t3, e4, r5, n3) {
          return 0 === n3.compare(e4, r5);
        }
        function ar(t3, e4, r5) {
          const n3 = "==" !== t3 && "!=" !== t3;
          return class i4 {
            constructor(t4, e5, r6) {
              this.type = pt2, this.lhs = t4, this.rhs = e5, this.collator = r6, this.hasUntypedArgument = "value" === t4.type.kind || "value" === e5.type.kind;
            }
            static parse(t4, e5) {
              if (3 !== t4.length && 4 !== t4.length)
                return e5.error("Expected two or three arguments.");
              const r6 = t4[0];
              let s4 = e5.parse(t4[1], 1, yt);
              if (!s4)
                return null;
              if (!ir(r6, s4.type))
                return e5.concat(1).error(`"${r6}" comparisons are not supported for type '${_t(s4.type)}'.`);
              let a3 = e5.parse(t4[2], 2, yt);
              if (!a3)
                return null;
              if (!ir(r6, a3.type))
                return e5.concat(2).error(`"${r6}" comparisons are not supported for type '${_t(a3.type)}'.`);
              if (s4.type.kind !== a3.type.kind && "value" !== s4.type.kind && "value" !== a3.type.kind)
                return e5.error(`Cannot compare types '${_t(s4.type)}' and '${_t(a3.type)}'.`);
              n3 && ("value" === s4.type.kind && "value" !== a3.type.kind ? s4 = new ue2(a3.type, [s4]) : "value" !== s4.type.kind && "value" === a3.type.kind && (a3 = new ue2(s4.type, [a3])));
              let o3 = null;
              if (4 === t4.length) {
                if ("string" !== s4.type.kind && "string" !== a3.type.kind && "value" !== s4.type.kind && "value" !== a3.type.kind)
                  return e5.error("Cannot use collator to compare non-string types.");
                if (o3 = e5.parse(t4[3], 3, mt), !o3)
                  return null;
              }
              return new i4(s4, a3, o3);
            }
            evaluate(i5) {
              const s4 = this.lhs.evaluate(i5), a3 = this.rhs.evaluate(i5);
              if (n3 && this.hasUntypedArgument) {
                const e5 = ie3(s4), r6 = ie3(a3);
                if (e5.kind !== r6.kind || "string" !== e5.kind && "number" !== e5.kind)
                  throw new oe2(`Expected arguments for "${t3}" to be (string, string) or (number, number), but found (${e5.kind}, ${r6.kind}) instead.`);
              }
              if (this.collator && !n3 && this.hasUntypedArgument) {
                const t4 = ie3(s4), r6 = ie3(a3);
                if ("string" !== t4.kind || "string" !== r6.kind)
                  return e4(i5, s4, a3);
              }
              return this.collator ? r5(i5, s4, a3, this.collator.evaluate(i5)) : e4(i5, s4, a3);
            }
            eachChild(t4) {
              t4(this.lhs), t4(this.rhs), this.collator && t4(this.collator);
            }
            outputDefined() {
              return true;
            }
          };
        }
        const or = ar("==", function(t3, e4, r5) {
          return e4 === r5;
        }, sr), lr = ar("!=", function(t3, e4, r5) {
          return e4 !== r5;
        }, function(t3, e4, r5, n3) {
          return !sr(0, e4, r5, n3);
        }), ur = ar("<", function(t3, e4, r5) {
          return e4 < r5;
        }, function(t3, e4, r5, n3) {
          return n3.compare(e4, r5) < 0;
        }), cr = ar(">", function(t3, e4, r5) {
          return e4 > r5;
        }, function(t3, e4, r5, n3) {
          return n3.compare(e4, r5) > 0;
        }), hr = ar("<=", function(t3, e4, r5) {
          return e4 <= r5;
        }, function(t3, e4, r5, n3) {
          return n3.compare(e4, r5) <= 0;
        }), pr = ar(">=", function(t3, e4, r5) {
          return e4 >= r5;
        }, function(t3, e4, r5, n3) {
          return n3.compare(e4, r5) >= 0;
        });
        class fr {
          constructor(t3, e4, r5, n3, i4) {
            this.type = ht, this.number = t3, this.locale = e4, this.currency = r5, this.minFractionDigits = n3, this.maxFractionDigits = i4;
          }
          static parse(t3, e4) {
            if (3 !== t3.length)
              return e4.error("Expected two arguments.");
            const r5 = e4.parse(t3[1], 1, ct);
            if (!r5)
              return null;
            const n3 = t3[2];
            if ("object" != typeof n3 || Array.isArray(n3))
              return e4.error("NumberFormat options argument must be an object.");
            let i4 = null;
            if (n3.locale && (i4 = e4.parse(n3.locale, 1, ht), !i4))
              return null;
            let s4 = null;
            if (n3.currency && (s4 = e4.parse(n3.currency, 1, ht), !s4))
              return null;
            let a3 = null;
            if (n3["min-fraction-digits"] && (a3 = e4.parse(n3["min-fraction-digits"], 1, ct), !a3))
              return null;
            let o3 = null;
            return n3["max-fraction-digits"] && (o3 = e4.parse(n3["max-fraction-digits"], 1, ct), !o3) ? null : new fr(r5, i4, s4, a3, o3);
          }
          evaluate(t3) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t3) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(t3) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t3) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t3) : void 0 }).format(this.number.evaluate(t3));
          }
          eachChild(t3) {
            t3(this.number), this.locale && t3(this.locale), this.currency && t3(this.currency), this.minFractionDigits && t3(this.minFractionDigits), this.maxFractionDigits && t3(this.maxFractionDigits);
          }
          outputDefined() {
            return false;
          }
        }
        class dr {
          constructor(t3) {
            this.type = gt, this.sections = t3;
          }
          static parse(t3, e4) {
            if (t3.length < 2)
              return e4.error("Expected at least one argument.");
            const r5 = t3[1];
            if (!Array.isArray(r5) && "object" == typeof r5)
              return e4.error("First argument must be an image or text section.");
            const n3 = [];
            let i4 = false;
            for (let r6 = 1; r6 <= t3.length - 1; ++r6) {
              const s4 = t3[r6];
              if (i4 && "object" == typeof s4 && !Array.isArray(s4)) {
                i4 = false;
                let t4 = null;
                if (s4["font-scale"] && (t4 = e4.parse(s4["font-scale"], 1, ct), !t4))
                  return null;
                let r7 = null;
                if (s4["text-font"] && (r7 = e4.parse(s4["text-font"], 1, wt(ht)), !r7))
                  return null;
                let a3 = null;
                if (s4["text-color"] && (a3 = e4.parse(s4["text-color"], 1, ft), !a3))
                  return null;
                const o3 = n3[n3.length - 1];
                o3.scale = t4, o3.font = r7, o3.textColor = a3;
              } else {
                const s5 = e4.parse(t3[r6], 1, yt);
                if (!s5)
                  return null;
                const a3 = s5.type.kind;
                if ("string" !== a3 && "value" !== a3 && "null" !== a3 && "resolvedImage" !== a3)
                  return e4.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                i4 = true, n3.push({ content: s5, scale: null, font: null, textColor: null });
              }
            }
            return new dr(n3);
          }
          evaluate(t3) {
            return new Yt(this.sections.map((e4) => {
              const r5 = e4.content.evaluate(t3);
              return ie3(r5) === vt ? new Ht("", r5, null, null, null) : new Ht(se2(r5), null, e4.scale ? e4.scale.evaluate(t3) : null, e4.font ? e4.font.evaluate(t3).join(",") : null, e4.textColor ? e4.textColor.evaluate(t3) : null);
            }));
          }
          eachChild(t3) {
            for (const e4 of this.sections)
              t3(e4.content), e4.scale && t3(e4.scale), e4.font && t3(e4.font), e4.textColor && t3(e4.textColor);
          }
          outputDefined() {
            return false;
          }
        }
        class yr {
          constructor(t3) {
            this.type = vt, this.input = t3;
          }
          static parse(t3, e4) {
            if (2 !== t3.length)
              return e4.error("Expected two arguments.");
            const r5 = e4.parse(t3[1], 1, ht);
            return r5 ? new yr(r5) : e4.error("No image name provided.");
          }
          evaluate(t3) {
            const e4 = this.input.evaluate(t3), r5 = ee2.fromString(e4);
            return r5 && t3.availableImages && (r5.available = t3.availableImages.indexOf(e4) > -1), r5;
          }
          eachChild(t3) {
            t3(this.input);
          }
          outputDefined() {
            return false;
          }
        }
        class mr {
          constructor(t3) {
            this.type = ct, this.input = t3;
          }
          static parse(t3, e4) {
            if (2 !== t3.length)
              return e4.error(`Expected 1 argument, but found ${t3.length - 1} instead.`);
            const r5 = e4.parse(t3[1], 1);
            return r5 ? "array" !== r5.type.kind && "string" !== r5.type.kind && "value" !== r5.type.kind ? e4.error(`Expected argument of type string or array, but found ${_t(r5.type)} instead.`) : new mr(r5) : null;
          }
          evaluate(t3) {
            const e4 = this.input.evaluate(t3);
            if ("string" == typeof e4)
              return e4.length;
            if (Array.isArray(e4))
              return e4.length;
            throw new oe2(`Expected value to be of type string or array, but found ${_t(ie3(e4))} instead.`);
          }
          eachChild(t3) {
            t3(this.input);
          }
          outputDefined() {
            return false;
          }
        }
        const gr = { "==": or, "!=": lr, ">": cr, "<": ur, ">=": pr, "<=": hr, array: ue2, at: We, boolean: ue2, case: rr, coalesce: He, collator: ye, format: dr, image: yr, in: Qe, "index-of": tr, interpolate: Je, "interpolate-hcl": Je, "interpolate-lab": Je, length: mr, let: Ye, literal: ae3, match: er, number: ue2, "number-format": fr, object: ue2, slice: nr, step: Re2, string: ue2, "to-boolean": he2, "to-color": he2, "to-number": he2, "to-string": he2, var: Ee, within: Ve2 };
        function xr(t3, [e4, r5, n3, i4]) {
          e4 = e4.evaluate(t3), r5 = r5.evaluate(t3), n3 = n3.evaluate(t3);
          const s4 = i4 ? i4.evaluate(t3) : 1, a3 = re2(e4, r5, n3, s4);
          if (a3)
            throw new oe2(a3);
          return new Jt(e4 / 255, r5 / 255, n3 / 255, s4, false);
        }
        function vr(t3, e4) {
          return t3 in e4;
        }
        function br(t3, e4) {
          const r5 = e4[t3];
          return void 0 === r5 ? null : r5;
        }
        function wr(t3) {
          return { type: t3 };
        }
        function _r(t3) {
          return { result: "success", value: t3 };
        }
        function Ar(t3) {
          return { result: "error", value: t3 };
        }
        function Sr(t3) {
          return "data-driven" === t3["property-type"] || "cross-faded-data-driven" === t3["property-type"];
        }
        function kr(t3) {
          return !!t3.expression && t3.expression.parameters.indexOf("zoom") > -1;
        }
        function Ir(t3) {
          return !!t3.expression && t3.expression.interpolated;
        }
        function zr(t3) {
          return t3 instanceof Number ? "number" : t3 instanceof String ? "string" : t3 instanceof Boolean ? "boolean" : Array.isArray(t3) ? "array" : null === t3 ? "null" : typeof t3;
        }
        function Mr(t3) {
          return "object" == typeof t3 && null !== t3 && !Array.isArray(t3);
        }
        function Br(t3) {
          return t3;
        }
        function Cr(t3, e4) {
          const r5 = "color" === e4.type, n3 = t3.stops && "object" == typeof t3.stops[0][0], i4 = n3 || !(n3 || void 0 !== t3.property), s4 = t3.type || (Ir(e4) ? "exponential" : "interval");
          if (r5 || "padding" === e4.type) {
            const n4 = r5 ? Jt.parse : Wt.parse;
            (t3 = at({}, t3)).stops && (t3.stops = t3.stops.map((t4) => [t4[0], n4(t4[1])])), t3.default = n4(t3.default ? t3.default : e4.default);
          }
          if (t3.colorSpace && "rgb" !== (a3 = t3.colorSpace) && "hcl" !== a3 && "lab" !== a3)
            throw new Error(`Unknown color space: "${t3.colorSpace}"`);
          var a3;
          let o3, l4, u3;
          if ("exponential" === s4)
            o3 = Fr;
          else if ("interval" === s4)
            o3 = Er;
          else if ("categorical" === s4) {
            o3 = Vr, l4 = /* @__PURE__ */ Object.create(null);
            for (const e5 of t3.stops)
              l4[e5[0]] = e5[1];
            u3 = typeof t3.stops[0][0];
          } else {
            if ("identity" !== s4)
              throw new Error(`Unknown function type "${s4}"`);
            o3 = Tr;
          }
          if (n3) {
            const r6 = {}, n4 = [];
            for (let e5 = 0; e5 < t3.stops.length; e5++) {
              const i6 = t3.stops[e5], s6 = i6[0].zoom;
              void 0 === r6[s6] && (r6[s6] = { zoom: s6, type: t3.type, property: t3.property, default: t3.default, stops: [] }, n4.push(s6)), r6[s6].stops.push([i6[0].value, i6[1]]);
            }
            const i5 = [];
            for (const t4 of n4)
              i5.push([r6[t4].zoom, Cr(r6[t4], e4)]);
            const s5 = { name: "linear" };
            return { kind: "composite", interpolationType: s5, interpolationFactor: Je.interpolationFactor.bind(void 0, s5), zoomStops: i5.map((t4) => t4[0]), evaluate: ({ zoom: r7 }, n5) => Fr({ stops: i5, base: t3.base }, e4, r7).evaluate(r7, n5) };
          }
          if (i4) {
            const r6 = "exponential" === s4 ? { name: "exponential", base: void 0 !== t3.base ? t3.base : 1 } : null;
            return { kind: "camera", interpolationType: r6, interpolationFactor: Je.interpolationFactor.bind(void 0, r6), zoomStops: t3.stops.map((t4) => t4[0]), evaluate: ({ zoom: r7 }) => o3(t3, e4, r7, l4, u3) };
          }
          return { kind: "source", evaluate(r6, n4) {
            const i5 = n4 && n4.properties ? n4.properties[t3.property] : void 0;
            return void 0 === i5 ? Pr(t3.default, e4.default) : o3(t3, e4, i5, l4, u3);
          } };
        }
        function Pr(t3, e4, r5) {
          return void 0 !== t3 ? t3 : void 0 !== e4 ? e4 : void 0 !== r5 ? r5 : void 0;
        }
        function Vr(t3, e4, r5, n3, i4) {
          return Pr(typeof r5 === i4 ? n3[r5] : void 0, t3.default, e4.default);
        }
        function Er(t3, e4, r5) {
          if ("number" !== zr(r5))
            return Pr(t3.default, e4.default);
          const n3 = t3.stops.length;
          if (1 === n3)
            return t3.stops[0][1];
          if (r5 <= t3.stops[0][0])
            return t3.stops[0][1];
          if (r5 >= t3.stops[n3 - 1][0])
            return t3.stops[n3 - 1][1];
          const i4 = Oe(t3.stops.map((t4) => t4[0]), r5);
          return t3.stops[i4][1];
        }
        function Fr(t3, e4, r5) {
          const n3 = void 0 !== t3.base ? t3.base : 1;
          if ("number" !== zr(r5))
            return Pr(t3.default, e4.default);
          const i4 = t3.stops.length;
          if (1 === i4)
            return t3.stops[0][1];
          if (r5 <= t3.stops[0][0])
            return t3.stops[0][1];
          if (r5 >= t3.stops[i4 - 1][0])
            return t3.stops[i4 - 1][1];
          const s4 = Oe(t3.stops.map((t4) => t4[0]), r5), a3 = function(t4, e5, r6, n4) {
            const i5 = n4 - r6, s5 = t4 - r6;
            return 0 === i5 ? 0 : 1 === e5 ? s5 / i5 : (Math.pow(e5, s5) - 1) / (Math.pow(e5, i5) - 1);
          }(r5, n3, t3.stops[s4][0], t3.stops[s4 + 1][0]), o3 = t3.stops[s4][1], l4 = t3.stops[s4 + 1][1], u3 = Ge[e4.type] || Br;
          return "function" == typeof o3.evaluate ? { evaluate(...e5) {
            const r6 = o3.evaluate.apply(void 0, e5), n4 = l4.evaluate.apply(void 0, e5);
            if (void 0 !== r6 && void 0 !== n4)
              return u3(r6, n4, a3, t3.colorSpace);
          } } : u3(o3, l4, a3, t3.colorSpace);
        }
        function Tr(t3, e4, r5) {
          switch (e4.type) {
            case "color":
              r5 = Jt.parse(r5);
              break;
            case "formatted":
              r5 = Yt.fromString(r5.toString());
              break;
            case "resolvedImage":
              r5 = ee2.fromString(r5.toString());
              break;
            case "padding":
              r5 = Wt.parse(r5);
              break;
            default:
              zr(r5) === e4.type || "enum" === e4.type && e4.values[r5] || (r5 = void 0);
          }
          return Pr(r5, t3.default, e4.default);
        }
        Fe.register(gr, { error: [{ kind: "error" }, [ht], (t3, [e4]) => {
          throw new oe2(e4.evaluate(t3));
        }], typeof: [ht, [yt], (t3, [e4]) => _t(ie3(e4.evaluate(t3)))], "to-rgba": [wt(ct, 4), [ft], (t3, [e4]) => {
          const [r5, n3, i4, s4] = e4.evaluate(t3).rgb;
          return [255 * r5, 255 * n3, 255 * i4, s4];
        }], rgb: [ft, [ct, ct, ct], xr], rgba: [ft, [ct, ct, ct, ct], xr], has: { type: pt2, overloads: [[[ht], (t3, [e4]) => vr(e4.evaluate(t3), t3.properties())], [[ht, dt], (t3, [e4, r5]) => vr(e4.evaluate(t3), r5.evaluate(t3))]] }, get: { type: yt, overloads: [[[ht], (t3, [e4]) => br(e4.evaluate(t3), t3.properties())], [[ht, dt], (t3, [e4, r5]) => br(e4.evaluate(t3), r5.evaluate(t3))]] }, "feature-state": [yt, [ht], (t3, [e4]) => br(e4.evaluate(t3), t3.featureState || {})], properties: [dt, [], (t3) => t3.properties()], "geometry-type": [ht, [], (t3) => t3.geometryType()], id: [yt, [], (t3) => t3.id()], zoom: [ct, [], (t3) => t3.globals.zoom], "heatmap-density": [ct, [], (t3) => t3.globals.heatmapDensity || 0], "line-progress": [ct, [], (t3) => t3.globals.lineProgress || 0], accumulated: [yt, [], (t3) => void 0 === t3.globals.accumulated ? null : t3.globals.accumulated], "+": [ct, wr(ct), (t3, e4) => {
          let r5 = 0;
          for (const n3 of e4)
            r5 += n3.evaluate(t3);
          return r5;
        }], "*": [ct, wr(ct), (t3, e4) => {
          let r5 = 1;
          for (const n3 of e4)
            r5 *= n3.evaluate(t3);
          return r5;
        }], "-": { type: ct, overloads: [[[ct, ct], (t3, [e4, r5]) => e4.evaluate(t3) - r5.evaluate(t3)], [[ct], (t3, [e4]) => -e4.evaluate(t3)]] }, "/": [ct, [ct, ct], (t3, [e4, r5]) => e4.evaluate(t3) / r5.evaluate(t3)], "%": [ct, [ct, ct], (t3, [e4, r5]) => e4.evaluate(t3) % r5.evaluate(t3)], ln2: [ct, [], () => Math.LN2], pi: [ct, [], () => Math.PI], e: [ct, [], () => Math.E], "^": [ct, [ct, ct], (t3, [e4, r5]) => Math.pow(e4.evaluate(t3), r5.evaluate(t3))], sqrt: [ct, [ct], (t3, [e4]) => Math.sqrt(e4.evaluate(t3))], log10: [ct, [ct], (t3, [e4]) => Math.log(e4.evaluate(t3)) / Math.LN10], ln: [ct, [ct], (t3, [e4]) => Math.log(e4.evaluate(t3))], log2: [ct, [ct], (t3, [e4]) => Math.log(e4.evaluate(t3)) / Math.LN2], sin: [ct, [ct], (t3, [e4]) => Math.sin(e4.evaluate(t3))], cos: [ct, [ct], (t3, [e4]) => Math.cos(e4.evaluate(t3))], tan: [ct, [ct], (t3, [e4]) => Math.tan(e4.evaluate(t3))], asin: [ct, [ct], (t3, [e4]) => Math.asin(e4.evaluate(t3))], acos: [ct, [ct], (t3, [e4]) => Math.acos(e4.evaluate(t3))], atan: [ct, [ct], (t3, [e4]) => Math.atan(e4.evaluate(t3))], min: [ct, wr(ct), (t3, e4) => Math.min(...e4.map((e5) => e5.evaluate(t3)))], max: [ct, wr(ct), (t3, e4) => Math.max(...e4.map((e5) => e5.evaluate(t3)))], abs: [ct, [ct], (t3, [e4]) => Math.abs(e4.evaluate(t3))], round: [ct, [ct], (t3, [e4]) => {
          const r5 = e4.evaluate(t3);
          return r5 < 0 ? -Math.round(-r5) : Math.round(r5);
        }], floor: [ct, [ct], (t3, [e4]) => Math.floor(e4.evaluate(t3))], ceil: [ct, [ct], (t3, [e4]) => Math.ceil(e4.evaluate(t3))], "filter-==": [pt2, [ht, yt], (t3, [e4, r5]) => t3.properties()[e4.value] === r5.value], "filter-id-==": [pt2, [yt], (t3, [e4]) => t3.id() === e4.value], "filter-type-==": [pt2, [ht], (t3, [e4]) => t3.geometryType() === e4.value], "filter-<": [pt2, [ht, yt], (t3, [e4, r5]) => {
          const n3 = t3.properties()[e4.value], i4 = r5.value;
          return typeof n3 == typeof i4 && n3 < i4;
        }], "filter-id-<": [pt2, [yt], (t3, [e4]) => {
          const r5 = t3.id(), n3 = e4.value;
          return typeof r5 == typeof n3 && r5 < n3;
        }], "filter->": [pt2, [ht, yt], (t3, [e4, r5]) => {
          const n3 = t3.properties()[e4.value], i4 = r5.value;
          return typeof n3 == typeof i4 && n3 > i4;
        }], "filter-id->": [pt2, [yt], (t3, [e4]) => {
          const r5 = t3.id(), n3 = e4.value;
          return typeof r5 == typeof n3 && r5 > n3;
        }], "filter-<=": [pt2, [ht, yt], (t3, [e4, r5]) => {
          const n3 = t3.properties()[e4.value], i4 = r5.value;
          return typeof n3 == typeof i4 && n3 <= i4;
        }], "filter-id-<=": [pt2, [yt], (t3, [e4]) => {
          const r5 = t3.id(), n3 = e4.value;
          return typeof r5 == typeof n3 && r5 <= n3;
        }], "filter->=": [pt2, [ht, yt], (t3, [e4, r5]) => {
          const n3 = t3.properties()[e4.value], i4 = r5.value;
          return typeof n3 == typeof i4 && n3 >= i4;
        }], "filter-id->=": [pt2, [yt], (t3, [e4]) => {
          const r5 = t3.id(), n3 = e4.value;
          return typeof r5 == typeof n3 && r5 >= n3;
        }], "filter-has": [pt2, [yt], (t3, [e4]) => e4.value in t3.properties()], "filter-has-id": [pt2, [], (t3) => null !== t3.id() && void 0 !== t3.id()], "filter-type-in": [pt2, [wt(ht)], (t3, [e4]) => e4.value.indexOf(t3.geometryType()) >= 0], "filter-id-in": [pt2, [wt(yt)], (t3, [e4]) => e4.value.indexOf(t3.id()) >= 0], "filter-in-small": [pt2, [ht, wt(yt)], (t3, [e4, r5]) => r5.value.indexOf(t3.properties()[e4.value]) >= 0], "filter-in-large": [pt2, [ht, wt(yt)], (t3, [e4, r5]) => function(t4, e5, r6, n3) {
          for (; r6 <= n3; ) {
            const i4 = r6 + n3 >> 1;
            if (e5[i4] === t4)
              return true;
            e5[i4] > t4 ? n3 = i4 - 1 : r6 = i4 + 1;
          }
          return false;
        }(t3.properties()[e4.value], r5.value, 0, r5.value.length - 1)], all: { type: pt2, overloads: [[[pt2, pt2], (t3, [e4, r5]) => e4.evaluate(t3) && r5.evaluate(t3)], [wr(pt2), (t3, e4) => {
          for (const r5 of e4)
            if (!r5.evaluate(t3))
              return false;
          return true;
        }]] }, any: { type: pt2, overloads: [[[pt2, pt2], (t3, [e4, r5]) => e4.evaluate(t3) || r5.evaluate(t3)], [wr(pt2), (t3, e4) => {
          for (const r5 of e4)
            if (r5.evaluate(t3))
              return true;
          return false;
        }]] }, "!": [pt2, [pt2], (t3, [e4]) => !e4.evaluate(t3)], "is-supported-script": [pt2, [ht], (t3, [e4]) => {
          const r5 = t3.globals && t3.globals.isSupportedScript;
          return !r5 || r5(e4.evaluate(t3));
        }], upcase: [ht, [ht], (t3, [e4]) => e4.evaluate(t3).toUpperCase()], downcase: [ht, [ht], (t3, [e4]) => e4.evaluate(t3).toLowerCase()], concat: [ht, wr(yt), (t3, e4) => e4.map((e5) => se2(e5.evaluate(t3))).join("")], "resolved-locale": [ht, [mt], (t3, [e4]) => e4.evaluate(t3).resolvedLocale()] });
        class $r {
          constructor(t3, e4) {
            var r5;
            this.expression = t3, this._warningHistory = {}, this._evaluator = new fe(), this._defaultValue = e4 ? "color" === (r5 = e4).type && Mr(r5.default) ? new Jt(0, 0, 0, 0) : "color" === r5.type ? Jt.parse(r5.default) || null : "padding" === r5.type ? Wt.parse(r5.default) || null : "variableAnchorOffsetCollection" === r5.type ? te2.parse(r5.default) || null : void 0 === r5.default ? null : r5.default : null, this._enumValues = e4 && "enum" === e4.type ? e4.values : null;
          }
          evaluateWithoutErrorHandling(t3, e4, r5, n3, i4, s4) {
            return this._evaluator.globals = t3, this._evaluator.feature = e4, this._evaluator.featureState = r5, this._evaluator.canonical = n3, this._evaluator.availableImages = i4 || null, this._evaluator.formattedSection = s4, this.expression.evaluate(this._evaluator);
          }
          evaluate(t3, e4, r5, n3, i4, s4) {
            this._evaluator.globals = t3, this._evaluator.feature = e4 || null, this._evaluator.featureState = r5 || null, this._evaluator.canonical = n3, this._evaluator.availableImages = i4 || null, this._evaluator.formattedSection = s4 || null;
            try {
              const t4 = this.expression.evaluate(this._evaluator);
              if (null == t4 || "number" == typeof t4 && t4 != t4)
                return this._defaultValue;
              if (this._enumValues && !(t4 in this._enumValues))
                throw new oe2(`Expected value to be one of ${Object.keys(this._enumValues).map((t5) => JSON.stringify(t5)).join(", ")}, but found ${JSON.stringify(t4)} instead.`);
              return t4;
            } catch (t4) {
              return this._warningHistory[t4.message] || (this._warningHistory[t4.message] = true, "undefined" != typeof console && console.warn(t4.message)), this._defaultValue;
            }
          }
        }
        function Dr(t3) {
          return Array.isArray(t3) && t3.length > 0 && "string" == typeof t3[0] && t3[0] in gr;
        }
        function Lr(t3, e4) {
          const r5 = new de(gr, Te2, [], e4 ? function(t4) {
            const e5 = { color: ft, string: ht, number: ct, enum: ht, boolean: pt2, formatted: gt, padding: xt, resolvedImage: vt, variableAnchorOffsetCollection: bt };
            return "array" === t4.type ? wt(e5[t4.value] || yt, t4.length) : e5[t4.type];
          }(e4) : void 0), n3 = r5.parse(t3, void 0, void 0, void 0, e4 && "string" === e4.type ? { typeAnnotation: "coerce" } : void 0);
          return n3 ? _r(new $r(n3, e4)) : Ar(r5.errors);
        }
        class Or {
          constructor(t3, e4) {
            this.kind = t3, this._styleExpression = e4, this.isStateDependent = "constant" !== t3 && !De(e4.expression);
          }
          evaluateWithoutErrorHandling(t3, e4, r5, n3, i4, s4) {
            return this._styleExpression.evaluateWithoutErrorHandling(t3, e4, r5, n3, i4, s4);
          }
          evaluate(t3, e4, r5, n3, i4, s4) {
            return this._styleExpression.evaluate(t3, e4, r5, n3, i4, s4);
          }
        }
        class Rr {
          constructor(t3, e4, r5, n3) {
            this.kind = t3, this.zoomStops = r5, this._styleExpression = e4, this.isStateDependent = "camera" !== t3 && !De(e4.expression), this.interpolationType = n3;
          }
          evaluateWithoutErrorHandling(t3, e4, r5, n3, i4, s4) {
            return this._styleExpression.evaluateWithoutErrorHandling(t3, e4, r5, n3, i4, s4);
          }
          evaluate(t3, e4, r5, n3, i4, s4) {
            return this._styleExpression.evaluate(t3, e4, r5, n3, i4, s4);
          }
          interpolationFactor(t3, e4, r5) {
            return this.interpolationType ? Je.interpolationFactor(this.interpolationType, t3, e4, r5) : 0;
          }
        }
        function Ur(t3, e4) {
          const r5 = Lr(t3, e4);
          if ("error" === r5.result)
            return r5;
          const n3 = r5.value.expression, i4 = $e(n3);
          if (!i4 && !Sr(e4))
            return Ar([new ot("", "data expressions not supported")]);
          const s4 = Le(n3, ["zoom"]);
          if (!s4 && !kr(e4))
            return Ar([new ot("", "zoom expressions not supported")]);
          const a3 = qr(n3);
          return a3 || s4 ? a3 instanceof ot ? Ar([a3]) : a3 instanceof Je && !Ir(e4) ? Ar([new ot("", '"interpolate" expressions cannot be used with this property')]) : _r(a3 ? new Rr(i4 ? "camera" : "composite", r5.value, a3.labels, a3 instanceof Je ? a3.interpolation : void 0) : new Or(i4 ? "constant" : "source", r5.value)) : Ar([new ot("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
        }
        class jr {
          constructor(t3, e4) {
            this._parameters = t3, this._specification = e4, at(this, Cr(this._parameters, this._specification));
          }
          static deserialize(t3) {
            return new jr(t3._parameters, t3._specification);
          }
          static serialize(t3) {
            return { _parameters: t3._parameters, _specification: t3._specification };
          }
        }
        function qr(t3) {
          let e4 = null;
          if (t3 instanceof Ye)
            e4 = qr(t3.result);
          else if (t3 instanceof He) {
            for (const r5 of t3.args)
              if (e4 = qr(r5), e4)
                break;
          } else
            (t3 instanceof Re2 || t3 instanceof Je) && t3.input instanceof Fe && "zoom" === t3.input.name && (e4 = t3);
          return e4 instanceof ot || t3.eachChild((t4) => {
            const r5 = qr(t4);
            r5 instanceof ot ? e4 = r5 : !e4 && r5 ? e4 = new ot("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e4 && r5 && e4 !== r5 && (e4 = new ot("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
          }), e4;
        }
        function Nr(t3) {
          if (true === t3 || false === t3)
            return true;
          if (!Array.isArray(t3) || 0 === t3.length)
            return false;
          switch (t3[0]) {
            case "has":
              return t3.length >= 2 && "$id" !== t3[1] && "$type" !== t3[1];
            case "in":
              return t3.length >= 3 && ("string" != typeof t3[1] || Array.isArray(t3[2]));
            case "!in":
            case "!has":
            case "none":
              return false;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return 3 !== t3.length || Array.isArray(t3[1]) || Array.isArray(t3[2]);
            case "any":
            case "all":
              for (const e4 of t3.slice(1))
                if (!Nr(e4) && "boolean" != typeof e4)
                  return false;
              return true;
            default:
              return true;
          }
        }
        const Zr = { type: "boolean", default: false, transition: false, "property-type": "data-driven", expression: { interpolated: false, parameters: ["zoom", "feature"] } };
        function Kr(t3) {
          if (null == t3)
            return { filter: () => true, needGeometry: false };
          Nr(t3) || (t3 = Xr(t3));
          const e4 = Lr(t3, Zr);
          if ("error" === e4.result)
            throw new Error(e4.value.map((t4) => `${t4.key}: ${t4.message}`).join(", "));
          return { filter: (t4, r5, n3) => e4.value.evaluate(t4, r5, {}, n3), needGeometry: Jr(t3) };
        }
        function Gr(t3, e4) {
          return t3 < e4 ? -1 : t3 > e4 ? 1 : 0;
        }
        function Jr(t3) {
          if (!Array.isArray(t3))
            return false;
          if ("within" === t3[0])
            return true;
          for (let e4 = 1; e4 < t3.length; e4++)
            if (Jr(t3[e4]))
              return true;
          return false;
        }
        function Xr(t3) {
          if (!t3)
            return true;
          const e4 = t3[0];
          return t3.length <= 1 ? "any" !== e4 : "==" === e4 ? Hr(t3[1], t3[2], "==") : "!=" === e4 ? Qr(Hr(t3[1], t3[2], "==")) : "<" === e4 || ">" === e4 || "<=" === e4 || ">=" === e4 ? Hr(t3[1], t3[2], e4) : "any" === e4 ? (r5 = t3.slice(1), ["any"].concat(r5.map(Xr))) : "all" === e4 ? ["all"].concat(t3.slice(1).map(Xr)) : "none" === e4 ? ["all"].concat(t3.slice(1).map(Xr).map(Qr)) : "in" === e4 ? Yr(t3[1], t3.slice(2)) : "!in" === e4 ? Qr(Yr(t3[1], t3.slice(2))) : "has" === e4 ? Wr(t3[1]) : "!has" === e4 ? Qr(Wr(t3[1])) : "within" !== e4 || t3;
          var r5;
        }
        function Hr(t3, e4, r5) {
          switch (t3) {
            case "$type":
              return [`filter-type-${r5}`, e4];
            case "$id":
              return [`filter-id-${r5}`, e4];
            default:
              return [`filter-${r5}`, t3, e4];
          }
        }
        function Yr(t3, e4) {
          if (0 === e4.length)
            return false;
          switch (t3) {
            case "$type":
              return ["filter-type-in", ["literal", e4]];
            case "$id":
              return ["filter-id-in", ["literal", e4]];
            default:
              return e4.length > 200 && !e4.some((t4) => typeof t4 != typeof e4[0]) ? ["filter-in-large", t3, ["literal", e4.sort(Gr)]] : ["filter-in-small", t3, ["literal", e4]];
          }
        }
        function Wr(t3) {
          switch (t3) {
            case "$type":
              return true;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", t3];
          }
        }
        function Qr(t3) {
          return ["!", t3];
        }
        function tn(t3) {
          const e4 = typeof t3;
          if ("number" === e4 || "boolean" === e4 || "string" === e4 || null == t3)
            return JSON.stringify(t3);
          if (Array.isArray(t3)) {
            let e5 = "[";
            for (const r6 of t3)
              e5 += `${tn(r6)},`;
            return `${e5}]`;
          }
          const r5 = Object.keys(t3).sort();
          let n3 = "{";
          for (let e5 = 0; e5 < r5.length; e5++)
            n3 += `${JSON.stringify(r5[e5])}:${tn(t3[r5[e5]])},`;
          return `${n3}}`;
        }
        function en(t3) {
          let e4 = "";
          for (const r5 of J3)
            e4 += `/${tn(t3[r5])}`;
          return e4;
        }
        function rn(t3) {
          const e4 = t3.value;
          return e4 ? [new st(t3.key, e4, "constants have been deprecated as of v8")] : [];
        }
        function nn(t3) {
          return t3 instanceof Number || t3 instanceof String || t3 instanceof Boolean ? t3.valueOf() : t3;
        }
        function sn(t3) {
          if (Array.isArray(t3))
            return t3.map(sn);
          if (t3 instanceof Object && !(t3 instanceof Number || t3 instanceof String || t3 instanceof Boolean)) {
            const e4 = {};
            for (const r5 in t3)
              e4[r5] = sn(t3[r5]);
            return e4;
          }
          return nn(t3);
        }
        function an(t3) {
          const e4 = t3.key, r5 = t3.value, n3 = t3.valueSpec || {}, i4 = t3.objectElementValidators || {}, s4 = t3.style, a3 = t3.styleSpec, o3 = t3.validateSpec;
          let l4 = [];
          const u3 = zr(r5);
          if ("object" !== u3)
            return [new st(e4, r5, `object expected, ${u3} found`)];
          for (const t4 in r5) {
            const u4 = t4.split(".")[0], c3 = n3[u4] || n3["*"];
            let h2;
            if (i4[u4])
              h2 = i4[u4];
            else if (n3[u4])
              h2 = o3;
            else if (i4["*"])
              h2 = i4["*"];
            else {
              if (!n3["*"]) {
                l4.push(new st(e4, r5[t4], `unknown property "${t4}"`));
                continue;
              }
              h2 = o3;
            }
            l4 = l4.concat(h2({ key: (e4 ? `${e4}.` : e4) + t4, value: r5[t4], valueSpec: c3, style: s4, styleSpec: a3, object: r5, objectKey: t4, validateSpec: o3 }, r5));
          }
          for (const t4 in n3)
            i4[t4] || n3[t4].required && void 0 === n3[t4].default && void 0 === r5[t4] && l4.push(new st(e4, r5, `missing required property "${t4}"`));
          return l4;
        }
        function on(t3) {
          const e4 = t3.value, r5 = t3.valueSpec, n3 = t3.style, i4 = t3.styleSpec, s4 = t3.key, a3 = t3.arrayElementValidator || t3.validateSpec;
          if ("array" !== zr(e4))
            return [new st(s4, e4, `array expected, ${zr(e4)} found`)];
          if (r5.length && e4.length !== r5.length)
            return [new st(s4, e4, `array length ${r5.length} expected, length ${e4.length} found`)];
          if (r5["min-length"] && e4.length < r5["min-length"])
            return [new st(s4, e4, `array length at least ${r5["min-length"]} expected, length ${e4.length} found`)];
          let o3 = { type: r5.value, values: r5.values };
          i4.$version < 7 && (o3.function = r5.function), "object" === zr(r5.value) && (o3 = r5.value);
          let l4 = [];
          for (let r6 = 0; r6 < e4.length; r6++)
            l4 = l4.concat(a3({ array: e4, arrayIndex: r6, value: e4[r6], valueSpec: o3, validateSpec: t3.validateSpec, style: n3, styleSpec: i4, key: `${s4}[${r6}]` }));
          return l4;
        }
        function ln(t3) {
          const e4 = t3.key, r5 = t3.value, n3 = t3.valueSpec;
          let i4 = zr(r5);
          return "number" === i4 && r5 != r5 && (i4 = "NaN"), "number" !== i4 ? [new st(e4, r5, `number expected, ${i4} found`)] : "minimum" in n3 && r5 < n3.minimum ? [new st(e4, r5, `${r5} is less than the minimum value ${n3.minimum}`)] : "maximum" in n3 && r5 > n3.maximum ? [new st(e4, r5, `${r5} is greater than the maximum value ${n3.maximum}`)] : [];
        }
        function un(t3) {
          const e4 = t3.valueSpec, r5 = nn(t3.value.type);
          let n3, i4, s4, a3 = {};
          const o3 = "categorical" !== r5 && void 0 === t3.value.property, l4 = !o3, u3 = "array" === zr(t3.value.stops) && "array" === zr(t3.value.stops[0]) && "object" === zr(t3.value.stops[0][0]), c3 = an({ key: t3.key, value: t3.value, valueSpec: t3.styleSpec.function, validateSpec: t3.validateSpec, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { stops: function(t4) {
            if ("identity" === r5)
              return [new st(t4.key, t4.value, 'identity function may not have a "stops" property')];
            let e5 = [];
            const n4 = t4.value;
            return e5 = e5.concat(on({ key: t4.key, value: n4, valueSpec: t4.valueSpec, validateSpec: t4.validateSpec, style: t4.style, styleSpec: t4.styleSpec, arrayElementValidator: h2 })), "array" === zr(n4) && 0 === n4.length && e5.push(new st(t4.key, n4, "array must have at least one stop")), e5;
          }, default: function(t4) {
            return t4.validateSpec({ key: t4.key, value: t4.value, valueSpec: e4, validateSpec: t4.validateSpec, style: t4.style, styleSpec: t4.styleSpec });
          } } });
          return "identity" === r5 && o3 && c3.push(new st(t3.key, t3.value, 'missing required property "property"')), "identity" === r5 || t3.value.stops || c3.push(new st(t3.key, t3.value, 'missing required property "stops"')), "exponential" === r5 && t3.valueSpec.expression && !Ir(t3.valueSpec) && c3.push(new st(t3.key, t3.value, "exponential functions not supported")), t3.styleSpec.$version >= 8 && (l4 && !Sr(t3.valueSpec) ? c3.push(new st(t3.key, t3.value, "property functions not supported")) : o3 && !kr(t3.valueSpec) && c3.push(new st(t3.key, t3.value, "zoom functions not supported"))), "categorical" !== r5 && !u3 || void 0 !== t3.value.property || c3.push(new st(t3.key, t3.value, '"property" property is required')), c3;
          function h2(t4) {
            let r6 = [];
            const n4 = t4.value, o4 = t4.key;
            if ("array" !== zr(n4))
              return [new st(o4, n4, `array expected, ${zr(n4)} found`)];
            if (2 !== n4.length)
              return [new st(o4, n4, `array length 2 expected, length ${n4.length} found`)];
            if (u3) {
              if ("object" !== zr(n4[0]))
                return [new st(o4, n4, `object expected, ${zr(n4[0])} found`)];
              if (void 0 === n4[0].zoom)
                return [new st(o4, n4, "object stop key must have zoom")];
              if (void 0 === n4[0].value)
                return [new st(o4, n4, "object stop key must have value")];
              if (s4 && s4 > nn(n4[0].zoom))
                return [new st(o4, n4[0].zoom, "stop zoom values must appear in ascending order")];
              nn(n4[0].zoom) !== s4 && (s4 = nn(n4[0].zoom), i4 = void 0, a3 = {}), r6 = r6.concat(an({ key: `${o4}[0]`, value: n4[0], valueSpec: { zoom: {} }, validateSpec: t4.validateSpec, style: t4.style, styleSpec: t4.styleSpec, objectElementValidators: { zoom: ln, value: p4 } }));
            } else
              r6 = r6.concat(p4({ key: `${o4}[0]`, value: n4[0], valueSpec: {}, validateSpec: t4.validateSpec, style: t4.style, styleSpec: t4.styleSpec }, n4));
            return Dr(sn(n4[1])) ? r6.concat([new st(`${o4}[1]`, n4[1], "expressions are not allowed in function stops.")]) : r6.concat(t4.validateSpec({ key: `${o4}[1]`, value: n4[1], valueSpec: e4, validateSpec: t4.validateSpec, style: t4.style, styleSpec: t4.styleSpec }));
          }
          function p4(t4, s5) {
            const o4 = zr(t4.value), l5 = nn(t4.value), u4 = null !== t4.value ? t4.value : s5;
            if (n3) {
              if (o4 !== n3)
                return [new st(t4.key, u4, `${o4} stop domain type must match previous stop domain type ${n3}`)];
            } else
              n3 = o4;
            if ("number" !== o4 && "string" !== o4 && "boolean" !== o4)
              return [new st(t4.key, u4, "stop domain value must be a number, string, or boolean")];
            if ("number" !== o4 && "categorical" !== r5) {
              let n4 = `number expected, ${o4} found`;
              return Sr(e4) && void 0 === r5 && (n4 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new st(t4.key, u4, n4)];
            }
            return "categorical" !== r5 || "number" !== o4 || isFinite(l5) && Math.floor(l5) === l5 ? "categorical" !== r5 && "number" === o4 && void 0 !== i4 && l5 < i4 ? [new st(t4.key, u4, "stop domain values must appear in ascending order")] : (i4 = l5, "categorical" === r5 && l5 in a3 ? [new st(t4.key, u4, "stop domain values must be unique")] : (a3[l5] = true, [])) : [new st(t4.key, u4, `integer expected, found ${l5}`)];
          }
        }
        function cn2(t3) {
          const e4 = ("property" === t3.expressionContext ? Ur : Lr)(sn(t3.value), t3.valueSpec);
          if ("error" === e4.result)
            return e4.value.map((e5) => new st(`${t3.key}${e5.key}`, t3.value, e5.message));
          const r5 = e4.value.expression || e4.value._styleExpression.expression;
          if ("property" === t3.expressionContext && "text-font" === t3.propertyKey && !r5.outputDefined())
            return [new st(t3.key, t3.value, `Invalid data expression for "${t3.propertyKey}". Output values must be contained as literals within the expression.`)];
          if ("property" === t3.expressionContext && "layout" === t3.propertyType && !De(r5))
            return [new st(t3.key, t3.value, '"feature-state" data expressions are not supported with layout properties.')];
          if ("filter" === t3.expressionContext && !De(r5))
            return [new st(t3.key, t3.value, '"feature-state" data expressions are not supported with filters.')];
          if (t3.expressionContext && 0 === t3.expressionContext.indexOf("cluster")) {
            if (!Le(r5, ["zoom", "feature-state"]))
              return [new st(t3.key, t3.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if ("cluster-initial" === t3.expressionContext && !$e(r5))
              return [new st(t3.key, t3.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
          }
          return [];
        }
        function hn(t3) {
          const e4 = t3.key, r5 = t3.value, n3 = t3.valueSpec, i4 = [];
          return Array.isArray(n3.values) ? -1 === n3.values.indexOf(nn(r5)) && i4.push(new st(e4, r5, `expected one of [${n3.values.join(", ")}], ${JSON.stringify(r5)} found`)) : -1 === Object.keys(n3.values).indexOf(nn(r5)) && i4.push(new st(e4, r5, `expected one of [${Object.keys(n3.values).join(", ")}], ${JSON.stringify(r5)} found`)), i4;
        }
        function pn(t3) {
          return Nr(sn(t3.value)) ? cn2(at({}, t3, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : fn(t3);
        }
        function fn(t3) {
          const e4 = t3.value, r5 = t3.key;
          if ("array" !== zr(e4))
            return [new st(r5, e4, `array expected, ${zr(e4)} found`)];
          const n3 = t3.styleSpec;
          let i4, s4 = [];
          if (e4.length < 1)
            return [new st(r5, e4, "filter array must have at least 1 element")];
          switch (s4 = s4.concat(hn({ key: `${r5}[0]`, value: e4[0], valueSpec: n3.filter_operator, style: t3.style, styleSpec: t3.styleSpec })), nn(e4[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              e4.length >= 2 && "$type" === nn(e4[1]) && s4.push(new st(r5, e4, `"$type" cannot be use with operator "${e4[0]}"`));
            case "==":
            case "!=":
              3 !== e4.length && s4.push(new st(r5, e4, `filter array for operator "${e4[0]}" must have 3 elements`));
            case "in":
            case "!in":
              e4.length >= 2 && (i4 = zr(e4[1]), "string" !== i4 && s4.push(new st(`${r5}[1]`, e4[1], `string expected, ${i4} found`)));
              for (let a3 = 2; a3 < e4.length; a3++)
                i4 = zr(e4[a3]), "$type" === nn(e4[1]) ? s4 = s4.concat(hn({ key: `${r5}[${a3}]`, value: e4[a3], valueSpec: n3.geometry_type, style: t3.style, styleSpec: t3.styleSpec })) : "string" !== i4 && "number" !== i4 && "boolean" !== i4 && s4.push(new st(`${r5}[${a3}]`, e4[a3], `string, number, or boolean expected, ${i4} found`));
              break;
            case "any":
            case "all":
            case "none":
              for (let n4 = 1; n4 < e4.length; n4++)
                s4 = s4.concat(fn({ key: `${r5}[${n4}]`, value: e4[n4], style: t3.style, styleSpec: t3.styleSpec }));
              break;
            case "has":
            case "!has":
              i4 = zr(e4[1]), 2 !== e4.length ? s4.push(new st(r5, e4, `filter array for "${e4[0]}" operator must have 2 elements`)) : "string" !== i4 && s4.push(new st(`${r5}[1]`, e4[1], `string expected, ${i4} found`));
              break;
            case "within":
              i4 = zr(e4[1]), 2 !== e4.length ? s4.push(new st(r5, e4, `filter array for "${e4[0]}" operator must have 2 elements`)) : "object" !== i4 && s4.push(new st(`${r5}[1]`, e4[1], `object expected, ${i4} found`));
          }
          return s4;
        }
        function dn(t3, e4) {
          const r5 = t3.key, n3 = t3.validateSpec, i4 = t3.style, s4 = t3.styleSpec, a3 = t3.value, o3 = t3.objectKey, l4 = s4[`${e4}_${t3.layerType}`];
          if (!l4)
            return [];
          const u3 = o3.match(/^(.*)-transition$/);
          if ("paint" === e4 && u3 && l4[u3[1]] && l4[u3[1]].transition)
            return n3({ key: r5, value: a3, valueSpec: s4.transition, style: i4, styleSpec: s4 });
          const c3 = t3.valueSpec || l4[o3];
          if (!c3)
            return [new st(r5, a3, `unknown property "${o3}"`)];
          let h2;
          if ("string" === zr(a3) && Sr(c3) && !c3.tokens && (h2 = /^{([^}]+)}$/.exec(a3)))
            return [new st(r5, a3, `"${o3}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(h2[1])} }\`.`)];
          const p4 = [];
          return "symbol" === t3.layerType && ("text-field" === o3 && i4 && !i4.glyphs && p4.push(new st(r5, a3, 'use of "text-field" requires a style "glyphs" property')), "text-font" === o3 && Mr(sn(a3)) && "identity" === nn(a3.type) && p4.push(new st(r5, a3, '"text-font" does not support identity functions'))), p4.concat(n3({ key: t3.key, value: a3, valueSpec: c3, style: i4, styleSpec: s4, expressionContext: "property", propertyType: e4, propertyKey: o3 }));
        }
        function yn(t3) {
          return dn(t3, "paint");
        }
        function mn(t3) {
          return dn(t3, "layout");
        }
        function gn(t3) {
          let e4 = [];
          const r5 = t3.value, n3 = t3.key, i4 = t3.style, s4 = t3.styleSpec;
          r5.type || r5.ref || e4.push(new st(n3, r5, 'either "type" or "ref" is required'));
          let a3 = nn(r5.type);
          const o3 = nn(r5.ref);
          if (r5.id) {
            const s5 = nn(r5.id);
            for (let a4 = 0; a4 < t3.arrayIndex; a4++) {
              const t4 = i4.layers[a4];
              nn(t4.id) === s5 && e4.push(new st(n3, r5.id, `duplicate layer id "${r5.id}", previously used at line ${t4.id.__line__}`));
            }
          }
          if ("ref" in r5) {
            let t4;
            ["type", "source", "source-layer", "filter", "layout"].forEach((t5) => {
              t5 in r5 && e4.push(new st(n3, r5[t5], `"${t5}" is prohibited for ref layers`));
            }), i4.layers.forEach((e5) => {
              nn(e5.id) === o3 && (t4 = e5);
            }), t4 ? t4.ref ? e4.push(new st(n3, r5.ref, "ref cannot reference another ref layer")) : a3 = nn(t4.type) : e4.push(new st(n3, r5.ref, `ref layer "${o3}" not found`));
          } else if ("background" !== a3)
            if (r5.source) {
              const t4 = i4.sources && i4.sources[r5.source], s5 = t4 && nn(t4.type);
              t4 ? "vector" === s5 && "raster" === a3 ? e4.push(new st(n3, r5.source, `layer "${r5.id}" requires a raster source`)) : "raster-dem" !== s5 && "hillshade" === a3 ? e4.push(new st(n3, r5.source, `layer "${r5.id}" requires a raster-dem source`)) : "raster" === s5 && "raster" !== a3 ? e4.push(new st(n3, r5.source, `layer "${r5.id}" requires a vector source`)) : "vector" !== s5 || r5["source-layer"] ? "raster-dem" === s5 && "hillshade" !== a3 ? e4.push(new st(n3, r5.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "line" !== a3 || !r5.paint || !r5.paint["line-gradient"] || "geojson" === s5 && t4.lineMetrics || e4.push(new st(n3, r5, `layer "${r5.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e4.push(new st(n3, r5, `layer "${r5.id}" must specify a "source-layer"`)) : e4.push(new st(n3, r5.source, `source "${r5.source}" not found`));
            } else
              e4.push(new st(n3, r5, 'missing required property "source"'));
          return e4 = e4.concat(an({ key: n3, value: r5, valueSpec: s4.layer, style: t3.style, styleSpec: t3.styleSpec, validateSpec: t3.validateSpec, objectElementValidators: { "*": () => [], type: () => t3.validateSpec({ key: `${n3}.type`, value: r5.type, valueSpec: s4.layer.type, style: t3.style, styleSpec: t3.styleSpec, validateSpec: t3.validateSpec, object: r5, objectKey: "type" }), filter: pn, layout: (t4) => an({ layer: r5, key: t4.key, value: t4.value, style: t4.style, styleSpec: t4.styleSpec, validateSpec: t4.validateSpec, objectElementValidators: { "*": (t5) => mn(at({ layerType: a3 }, t5)) } }), paint: (t4) => an({ layer: r5, key: t4.key, value: t4.value, style: t4.style, styleSpec: t4.styleSpec, validateSpec: t4.validateSpec, objectElementValidators: { "*": (t5) => yn(at({ layerType: a3 }, t5)) } }) } })), e4;
        }
        function xn(t3) {
          const e4 = t3.value, r5 = t3.key, n3 = zr(e4);
          return "string" !== n3 ? [new st(r5, e4, `string expected, ${n3} found`)] : [];
        }
        const vn = { promoteId: function({ key: t3, value: e4 }) {
          if ("string" === zr(e4))
            return xn({ key: t3, value: e4 });
          {
            const r5 = [];
            for (const n3 in e4)
              r5.push(...xn({ key: `${t3}.${n3}`, value: e4[n3] }));
            return r5;
          }
        } };
        function bn(t3) {
          const e4 = t3.value, r5 = t3.key, n3 = t3.styleSpec, i4 = t3.style, s4 = t3.validateSpec;
          if (!e4.type)
            return [new st(r5, e4, '"type" is required')];
          const a3 = nn(e4.type);
          let o3;
          switch (a3) {
            case "vector":
            case "raster":
              return o3 = an({ key: r5, value: e4, valueSpec: n3[`source_${a3.replace("-", "_")}`], style: t3.style, styleSpec: n3, objectElementValidators: vn, validateSpec: s4 }), o3;
            case "raster-dem":
              return o3 = function(t4) {
                var e5;
                const r6 = null !== (e5 = t4.sourceName) && void 0 !== e5 ? e5 : "", n4 = t4.value, i5 = t4.styleSpec, s5 = i5.source_raster_dem, a4 = t4.style;
                let o4 = [];
                const l4 = zr(n4);
                if (void 0 === n4)
                  return o4;
                if ("object" !== l4)
                  return o4.push(new st("source_raster_dem", n4, `object expected, ${l4} found`)), o4;
                const u3 = "custom" === nn(n4.encoding), c3 = ["redFactor", "greenFactor", "blueFactor", "baseShift"], h2 = t4.value.encoding ? `"${t4.value.encoding}"` : "Default";
                for (const e6 in n4)
                  !u3 && c3.includes(e6) ? o4.push(new st(e6, n4[e6], `In "${r6}": "${e6}" is only valid when "encoding" is set to "custom". ${h2} encoding found`)) : s5[e6] ? o4 = o4.concat(t4.validateSpec({ key: e6, value: n4[e6], valueSpec: s5[e6], validateSpec: t4.validateSpec, style: a4, styleSpec: i5 })) : o4.push(new st(e6, n4[e6], `unknown property "${e6}"`));
                return o4;
              }({ sourceName: r5, value: e4, style: t3.style, styleSpec: n3, validateSpec: s4 }), o3;
            case "geojson":
              if (o3 = an({ key: r5, value: e4, valueSpec: n3.source_geojson, style: i4, styleSpec: n3, validateSpec: s4, objectElementValidators: vn }), e4.cluster)
                for (const t4 in e4.clusterProperties) {
                  const [n4, i5] = e4.clusterProperties[t4], a4 = "string" == typeof n4 ? [n4, ["accumulated"], ["get", t4]] : n4;
                  o3.push(...cn2({ key: `${r5}.${t4}.map`, value: i5, validateSpec: s4, expressionContext: "cluster-map" })), o3.push(...cn2({ key: `${r5}.${t4}.reduce`, value: a4, validateSpec: s4, expressionContext: "cluster-reduce" }));
                }
              return o3;
            case "video":
              return an({ key: r5, value: e4, valueSpec: n3.source_video, style: i4, validateSpec: s4, styleSpec: n3 });
            case "image":
              return an({ key: r5, value: e4, valueSpec: n3.source_image, style: i4, validateSpec: s4, styleSpec: n3 });
            case "canvas":
              return [new st(r5, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return hn({ key: `${r5}.type`, value: e4.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }, style: i4, validateSpec: s4, styleSpec: n3 });
          }
        }
        function wn(t3) {
          const e4 = t3.value, r5 = t3.styleSpec, n3 = r5.light, i4 = t3.style;
          let s4 = [];
          const a3 = zr(e4);
          if (void 0 === e4)
            return s4;
          if ("object" !== a3)
            return s4 = s4.concat([new st("light", e4, `object expected, ${a3} found`)]), s4;
          for (const a4 in e4) {
            const o3 = a4.match(/^(.*)-transition$/);
            s4 = s4.concat(o3 && n3[o3[1]] && n3[o3[1]].transition ? t3.validateSpec({ key: a4, value: e4[a4], valueSpec: r5.transition, validateSpec: t3.validateSpec, style: i4, styleSpec: r5 }) : n3[a4] ? t3.validateSpec({ key: a4, value: e4[a4], valueSpec: n3[a4], validateSpec: t3.validateSpec, style: i4, styleSpec: r5 }) : [new st(a4, e4[a4], `unknown property "${a4}"`)]);
          }
          return s4;
        }
        function _n(t3) {
          const e4 = t3.value, r5 = t3.styleSpec, n3 = r5.sky, i4 = t3.style, s4 = zr(e4);
          if (void 0 === e4)
            return [];
          if ("object" !== s4)
            return [new st("sky", e4, `object expected, ${s4} found`)];
          let a3 = [];
          for (const t4 in e4)
            a3 = a3.concat(n3[t4] ? In({ key: t4, value: e4[t4], valueSpec: n3[t4], style: i4, styleSpec: r5 }) : [new st(t4, e4[t4], `unknown property "${t4}"`)]);
          return a3;
        }
        function An(t3) {
          const e4 = t3.value, r5 = t3.styleSpec, n3 = r5.terrain, i4 = t3.style;
          let s4 = [];
          const a3 = zr(e4);
          if (void 0 === e4)
            return s4;
          if ("object" !== a3)
            return s4 = s4.concat([new st("terrain", e4, `object expected, ${a3} found`)]), s4;
          for (const a4 in e4)
            s4 = s4.concat(n3[a4] ? t3.validateSpec({ key: a4, value: e4[a4], valueSpec: n3[a4], validateSpec: t3.validateSpec, style: i4, styleSpec: r5 }) : [new st(a4, e4[a4], `unknown property "${a4}"`)]);
          return s4;
        }
        function Sn(t3) {
          let e4 = [];
          const r5 = t3.value, n3 = t3.key;
          if (Array.isArray(r5)) {
            const i4 = [], s4 = [];
            for (const a3 in r5)
              r5[a3].id && i4.includes(r5[a3].id) && e4.push(new st(n3, r5, `all the sprites' ids must be unique, but ${r5[a3].id} is duplicated`)), i4.push(r5[a3].id), r5[a3].url && s4.includes(r5[a3].url) && e4.push(new st(n3, r5, `all the sprites' URLs must be unique, but ${r5[a3].url} is duplicated`)), s4.push(r5[a3].url), e4 = e4.concat(an({ key: `${n3}[${a3}]`, value: r5[a3], valueSpec: { id: { type: "string", required: true }, url: { type: "string", required: true } }, validateSpec: t3.validateSpec }));
            return e4;
          }
          return xn({ key: n3, value: r5 });
        }
        const kn = { "*": () => [], array: on, boolean: function(t3) {
          const e4 = t3.value, r5 = t3.key, n3 = zr(e4);
          return "boolean" !== n3 ? [new st(r5, e4, `boolean expected, ${n3} found`)] : [];
        }, number: ln, color: function(t3) {
          const e4 = t3.key, r5 = t3.value, n3 = zr(r5);
          return "string" !== n3 ? [new st(e4, r5, `color expected, ${n3} found`)] : Jt.parse(String(r5)) ? [] : [new st(e4, r5, `color expected, "${r5}" found`)];
        }, constants: rn, enum: hn, filter: pn, function: un, layer: gn, object: an, source: bn, light: wn, sky: _n, terrain: An, string: xn, formatted: function(t3) {
          return 0 === xn(t3).length ? [] : cn2(t3);
        }, resolvedImage: function(t3) {
          return 0 === xn(t3).length ? [] : cn2(t3);
        }, padding: function(t3) {
          const e4 = t3.key, r5 = t3.value;
          if ("array" === zr(r5)) {
            if (r5.length < 1 || r5.length > 4)
              return [new st(e4, r5, `padding requires 1 to 4 values; ${r5.length} values found`)];
            const n3 = { type: "number" };
            let i4 = [];
            for (let s4 = 0; s4 < r5.length; s4++)
              i4 = i4.concat(t3.validateSpec({ key: `${e4}[${s4}]`, value: r5[s4], validateSpec: t3.validateSpec, valueSpec: n3 }));
            return i4;
          }
          return ln({ key: e4, value: r5, valueSpec: {} });
        }, variableAnchorOffsetCollection: function(t3) {
          const e4 = t3.key, r5 = t3.value, n3 = zr(r5), i4 = t3.styleSpec;
          if ("array" !== n3 || r5.length < 1 || r5.length % 2 != 0)
            return [new st(e4, r5, "variableAnchorOffsetCollection requires a non-empty array of even length")];
          let s4 = [];
          for (let n4 = 0; n4 < r5.length; n4 += 2)
            s4 = s4.concat(hn({ key: `${e4}[${n4}]`, value: r5[n4], valueSpec: i4.layout_symbol["text-anchor"] })), s4 = s4.concat(on({ key: `${e4}[${n4 + 1}]`, value: r5[n4 + 1], valueSpec: { length: 2, value: "number" }, validateSpec: t3.validateSpec, style: t3.style, styleSpec: i4 }));
          return s4;
        }, sprite: Sn };
        function In(t3) {
          const e4 = t3.value, r5 = t3.valueSpec, n3 = t3.styleSpec;
          return t3.validateSpec = In, r5.expression && Mr(nn(e4)) ? un(t3) : r5.expression && Dr(sn(e4)) ? cn2(t3) : r5.type && kn[r5.type] ? kn[r5.type](t3) : an(at({}, t3, { valueSpec: r5.type ? n3[r5.type] : r5 }));
        }
        function zn(t3) {
          const e4 = t3.value, r5 = t3.key, n3 = xn(t3);
          return n3.length || (-1 === e4.indexOf("{fontstack}") && n3.push(new st(r5, e4, '"glyphs" url must include a "{fontstack}" token')), -1 === e4.indexOf("{range}") && n3.push(new st(r5, e4, '"glyphs" url must include a "{range}" token'))), n3;
        }
        function Mn(t3, e4 = G2) {
          let r5 = [];
          return r5 = r5.concat(In({ key: "", value: t3, valueSpec: e4.$root, styleSpec: e4, style: t3, validateSpec: In, objectElementValidators: { glyphs: zn, "*": () => [] } })), t3.constants && (r5 = r5.concat(rn({ key: "constants", value: t3.constants, style: t3, styleSpec: e4, validateSpec: In }))), Cn(r5);
        }
        function Bn(t3) {
          return function(e4) {
            return t3({ ...e4, validateSpec: In });
          };
        }
        function Cn(t3) {
          return [].concat(t3).sort((t4, e4) => t4.line - e4.line);
        }
        function Pn(t3) {
          return function(...e4) {
            return Cn(t3.apply(this, e4));
          };
        }
        Mn.source = Pn(Bn(bn)), Mn.sprite = Pn(Bn(Sn)), Mn.glyphs = Pn(Bn(zn)), Mn.light = Pn(Bn(wn)), Mn.sky = Pn(Bn(_n)), Mn.terrain = Pn(Bn(An)), Mn.layer = Pn(Bn(gn)), Mn.filter = Pn(Bn(pn)), Mn.paintProperty = Pn(Bn(yn)), Mn.layoutProperty = Pn(Bn(mn));
        const Vn = Mn, En = Vn.light, Fn = Vn.paintProperty, Tn = Vn.layoutProperty;
        function $n(t3, e4) {
          let r5 = false;
          if (e4 && e4.length)
            for (const n3 of e4)
              t3.fire(new Z4(new Error(n3.message))), r5 = true;
          return r5;
        }
        class Dn {
          constructor(t3, e4, r5) {
            const n3 = this.cells = [];
            if (t3 instanceof ArrayBuffer) {
              this.arrayBuffer = t3;
              const i5 = new Int32Array(this.arrayBuffer);
              t3 = i5[0], this.d = (e4 = i5[1]) + 2 * (r5 = i5[2]);
              for (let t4 = 0; t4 < this.d * this.d; t4++) {
                const e5 = i5[3 + t4], r6 = i5[3 + t4 + 1];
                n3.push(e5 === r6 ? null : i5.subarray(e5, r6));
              }
              const s4 = i5[3 + n3.length + 1];
              this.keys = i5.subarray(i5[3 + n3.length], s4), this.bboxes = i5.subarray(s4), this.insert = this._insertReadonly;
            } else {
              this.d = e4 + 2 * r5;
              for (let t4 = 0; t4 < this.d * this.d; t4++)
                n3.push([]);
              this.keys = [], this.bboxes = [];
            }
            this.n = e4, this.extent = t3, this.padding = r5, this.scale = e4 / t3, this.uid = 0;
            const i4 = r5 / e4 * t3;
            this.min = -i4, this.max = t3 + i4;
          }
          insert(t3, e4, r5, n3, i4) {
            this._forEachCell(e4, r5, n3, i4, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t3), this.bboxes.push(e4), this.bboxes.push(r5), this.bboxes.push(n3), this.bboxes.push(i4);
          }
          _insertReadonly() {
            throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
          }
          _insertCell(t3, e4, r5, n3, i4, s4) {
            this.cells[i4].push(s4);
          }
          query(t3, e4, r5, n3, i4) {
            const s4 = this.min, a3 = this.max;
            if (t3 <= s4 && e4 <= s4 && a3 <= r5 && a3 <= n3 && !i4)
              return Array.prototype.slice.call(this.keys);
            {
              const s5 = [];
              return this._forEachCell(t3, e4, r5, n3, this._queryCell, s5, {}, i4), s5;
            }
          }
          _queryCell(t3, e4, r5, n3, i4, s4, a3, o3) {
            const l4 = this.cells[i4];
            if (null !== l4) {
              const i5 = this.keys, u3 = this.bboxes;
              for (let c3 = 0; c3 < l4.length; c3++) {
                const h2 = l4[c3];
                if (void 0 === a3[h2]) {
                  const l5 = 4 * h2;
                  (o3 ? o3(u3[l5 + 0], u3[l5 + 1], u3[l5 + 2], u3[l5 + 3]) : t3 <= u3[l5 + 2] && e4 <= u3[l5 + 3] && r5 >= u3[l5 + 0] && n3 >= u3[l5 + 1]) ? (a3[h2] = true, s4.push(i5[h2])) : a3[h2] = false;
                }
              }
            }
          }
          _forEachCell(t3, e4, r5, n3, i4, s4, a3, o3) {
            const l4 = this._convertToCellCoord(t3), u3 = this._convertToCellCoord(e4), c3 = this._convertToCellCoord(r5), h2 = this._convertToCellCoord(n3);
            for (let p4 = l4; p4 <= c3; p4++)
              for (let l5 = u3; l5 <= h2; l5++) {
                const u4 = this.d * l5 + p4;
                if ((!o3 || o3(this._convertFromCellCoord(p4), this._convertFromCellCoord(l5), this._convertFromCellCoord(p4 + 1), this._convertFromCellCoord(l5 + 1))) && i4.call(this, t3, e4, r5, n3, u4, s4, a3, o3))
                  return;
              }
          }
          _convertFromCellCoord(t3) {
            return (t3 - this.padding) / this.scale;
          }
          _convertToCellCoord(t3) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(t3 * this.scale) + this.padding));
          }
          toArrayBuffer() {
            if (this.arrayBuffer)
              return this.arrayBuffer;
            const t3 = this.cells, e4 = 3 + this.cells.length + 1 + 1;
            let r5 = 0;
            for (let t4 = 0; t4 < this.cells.length; t4++)
              r5 += this.cells[t4].length;
            const n3 = new Int32Array(e4 + r5 + this.keys.length + this.bboxes.length);
            n3[0] = this.extent, n3[1] = this.n, n3[2] = this.padding;
            let i4 = e4;
            for (let e5 = 0; e5 < t3.length; e5++) {
              const r6 = t3[e5];
              n3[3 + e5] = i4, n3.set(r6, i4), i4 += r6.length;
            }
            return n3[3 + t3.length] = i4, n3.set(this.keys, i4), i4 += this.keys.length, n3[3 + t3.length + 1] = i4, n3.set(this.bboxes, i4), i4 += this.bboxes.length, n3.buffer;
          }
          static serialize(t3, e4) {
            const r5 = t3.toArrayBuffer();
            return e4 && e4.push(r5), { buffer: r5 };
          }
          static deserialize(t3) {
            return new Dn(t3.buffer);
          }
        }
        const Ln = {};
        function On(t3, e4, r5 = {}) {
          if (Ln[t3])
            throw new Error(`${t3} is already registered.`);
          Object.defineProperty(e4, "_classRegistryKey", { value: t3, writeable: false }), Ln[t3] = { klass: e4, omit: r5.omit || [], shallow: r5.shallow || [] };
        }
        On("Object", Object), On("TransferableGridIndex", Dn), On("Color", Jt), On("Error", Error), On("AJAXError", L2), On("ResolvedImage", ee2), On("StylePropertyFunction", jr), On("StyleExpression", $r, { omit: ["_evaluator"] }), On("ZoomDependentExpression", Rr), On("ZoomConstantExpression", Or), On("CompoundExpression", Fe, { omit: ["_evaluate"] });
        for (const t3 in gr)
          gr[t3]._classRegistryKey || On(`Expression_${t3}`, gr[t3]);
        function Rn(t3) {
          return t3 && "undefined" != typeof ArrayBuffer && (t3 instanceof ArrayBuffer || t3.constructor && "ArrayBuffer" === t3.constructor.name);
        }
        function Un(t3, e4) {
          if (null == t3 || "boolean" == typeof t3 || "number" == typeof t3 || "string" == typeof t3 || t3 instanceof Boolean || t3 instanceof Number || t3 instanceof String || t3 instanceof Date || t3 instanceof RegExp || t3 instanceof Blob || t3 instanceof Error)
            return t3;
          if (Rn(t3))
            return e4 && e4.push(t3), t3;
          if (M2(t3))
            return e4 && e4.push(t3), t3;
          if (ArrayBuffer.isView(t3)) {
            const r5 = t3;
            return e4 && e4.push(r5.buffer), r5;
          }
          if (t3 instanceof ImageData)
            return e4 && e4.push(t3.data.buffer), t3;
          if (Array.isArray(t3)) {
            const r5 = [];
            for (const n3 of t3)
              r5.push(Un(n3, e4));
            return r5;
          }
          if ("object" == typeof t3) {
            const r5 = t3.constructor, n3 = r5._classRegistryKey;
            if (!n3)
              throw new Error(`can't serialize object of unregistered class ${r5.name}`);
            if (!Ln[n3])
              throw new Error(`${n3} is not registered.`);
            const i4 = r5.serialize ? r5.serialize(t3, e4) : {};
            if (r5.serialize) {
              if (e4 && i4 === e4[e4.length - 1])
                throw new Error("statically serialized object won't survive transfer of $name property");
            } else {
              for (const r6 in t3) {
                if (!t3.hasOwnProperty(r6))
                  continue;
                if (Ln[n3].omit.indexOf(r6) >= 0)
                  continue;
                const s4 = t3[r6];
                i4[r6] = Ln[n3].shallow.indexOf(r6) >= 0 ? s4 : Un(s4, e4);
              }
              t3 instanceof Error && (i4.message = t3.message);
            }
            if (i4.$name)
              throw new Error("$name property is reserved for worker serialization logic.");
            return "Object" !== n3 && (i4.$name = n3), i4;
          }
          throw new Error("can't serialize object of type " + typeof t3);
        }
        function jn(t3) {
          if (null == t3 || "boolean" == typeof t3 || "number" == typeof t3 || "string" == typeof t3 || t3 instanceof Boolean || t3 instanceof Number || t3 instanceof String || t3 instanceof Date || t3 instanceof RegExp || t3 instanceof Blob || t3 instanceof Error || Rn(t3) || M2(t3) || ArrayBuffer.isView(t3) || t3 instanceof ImageData)
            return t3;
          if (Array.isArray(t3))
            return t3.map(jn);
          if ("object" == typeof t3) {
            const e4 = t3.$name || "Object";
            if (!Ln[e4])
              throw new Error(`can't deserialize unregistered class ${e4}`);
            const { klass: r5 } = Ln[e4];
            if (!r5)
              throw new Error(`can't deserialize unregistered class ${e4}`);
            if (r5.deserialize)
              return r5.deserialize(t3);
            const n3 = Object.create(r5.prototype);
            for (const r6 of Object.keys(t3)) {
              if ("$name" === r6)
                continue;
              const i4 = t3[r6];
              n3[r6] = Ln[e4].shallow.indexOf(r6) >= 0 ? i4 : jn(i4);
            }
            return n3;
          }
          throw new Error("can't deserialize object of type " + typeof t3);
        }
        class qn {
          constructor() {
            this.first = true;
          }
          update(t3, e4) {
            const r5 = Math.floor(t3);
            return this.first ? (this.first = false, this.lastIntegerZoom = r5, this.lastIntegerZoomTime = 0, this.lastZoom = t3, this.lastFloorZoom = r5, true) : (this.lastFloorZoom > r5 ? (this.lastIntegerZoom = r5 + 1, this.lastIntegerZoomTime = e4) : this.lastFloorZoom < r5 && (this.lastIntegerZoom = r5, this.lastIntegerZoomTime = e4), t3 !== this.lastZoom && (this.lastZoom = t3, this.lastFloorZoom = r5, true));
          }
        }
        const Nn = { "Latin-1 Supplement": (t3) => t3 >= 128 && t3 <= 255, Arabic: (t3) => t3 >= 1536 && t3 <= 1791, "Arabic Supplement": (t3) => t3 >= 1872 && t3 <= 1919, "Arabic Extended-A": (t3) => t3 >= 2208 && t3 <= 2303, "Hangul Jamo": (t3) => t3 >= 4352 && t3 <= 4607, "Unified Canadian Aboriginal Syllabics": (t3) => t3 >= 5120 && t3 <= 5759, Khmer: (t3) => t3 >= 6016 && t3 <= 6143, "Unified Canadian Aboriginal Syllabics Extended": (t3) => t3 >= 6320 && t3 <= 6399, "General Punctuation": (t3) => t3 >= 8192 && t3 <= 8303, "Letterlike Symbols": (t3) => t3 >= 8448 && t3 <= 8527, "Number Forms": (t3) => t3 >= 8528 && t3 <= 8591, "Miscellaneous Technical": (t3) => t3 >= 8960 && t3 <= 9215, "Control Pictures": (t3) => t3 >= 9216 && t3 <= 9279, "Optical Character Recognition": (t3) => t3 >= 9280 && t3 <= 9311, "Enclosed Alphanumerics": (t3) => t3 >= 9312 && t3 <= 9471, "Geometric Shapes": (t3) => t3 >= 9632 && t3 <= 9727, "Miscellaneous Symbols": (t3) => t3 >= 9728 && t3 <= 9983, "Miscellaneous Symbols and Arrows": (t3) => t3 >= 11008 && t3 <= 11263, "CJK Radicals Supplement": (t3) => t3 >= 11904 && t3 <= 12031, "Kangxi Radicals": (t3) => t3 >= 12032 && t3 <= 12255, "Ideographic Description Characters": (t3) => t3 >= 12272 && t3 <= 12287, "CJK Symbols and Punctuation": (t3) => t3 >= 12288 && t3 <= 12351, Hiragana: (t3) => t3 >= 12352 && t3 <= 12447, Katakana: (t3) => t3 >= 12448 && t3 <= 12543, Bopomofo: (t3) => t3 >= 12544 && t3 <= 12591, "Hangul Compatibility Jamo": (t3) => t3 >= 12592 && t3 <= 12687, Kanbun: (t3) => t3 >= 12688 && t3 <= 12703, "Bopomofo Extended": (t3) => t3 >= 12704 && t3 <= 12735, "CJK Strokes": (t3) => t3 >= 12736 && t3 <= 12783, "Katakana Phonetic Extensions": (t3) => t3 >= 12784 && t3 <= 12799, "Enclosed CJK Letters and Months": (t3) => t3 >= 12800 && t3 <= 13055, "CJK Compatibility": (t3) => t3 >= 13056 && t3 <= 13311, "CJK Unified Ideographs Extension A": (t3) => t3 >= 13312 && t3 <= 19903, "Yijing Hexagram Symbols": (t3) => t3 >= 19904 && t3 <= 19967, "CJK Unified Ideographs": (t3) => t3 >= 19968 && t3 <= 40959, "Yi Syllables": (t3) => t3 >= 40960 && t3 <= 42127, "Yi Radicals": (t3) => t3 >= 42128 && t3 <= 42191, "Hangul Jamo Extended-A": (t3) => t3 >= 43360 && t3 <= 43391, "Hangul Syllables": (t3) => t3 >= 44032 && t3 <= 55215, "Hangul Jamo Extended-B": (t3) => t3 >= 55216 && t3 <= 55295, "Private Use Area": (t3) => t3 >= 57344 && t3 <= 63743, "CJK Compatibility Ideographs": (t3) => t3 >= 63744 && t3 <= 64255, "Arabic Presentation Forms-A": (t3) => t3 >= 64336 && t3 <= 65023, "Vertical Forms": (t3) => t3 >= 65040 && t3 <= 65055, "CJK Compatibility Forms": (t3) => t3 >= 65072 && t3 <= 65103, "Small Form Variants": (t3) => t3 >= 65104 && t3 <= 65135, "Arabic Presentation Forms-B": (t3) => t3 >= 65136 && t3 <= 65279, "Halfwidth and Fullwidth Forms": (t3) => t3 >= 65280 && t3 <= 65519 };
        function Zn(t3) {
          for (const e4 of t3)
            if (Jn(e4.charCodeAt(0)))
              return true;
          return false;
        }
        function Kn(t3) {
          for (const e4 of t3)
            if (!Gn(e4.charCodeAt(0)))
              return false;
          return true;
        }
        function Gn(t3) {
          return !(Nn.Arabic(t3) || Nn["Arabic Supplement"](t3) || Nn["Arabic Extended-A"](t3) || Nn["Arabic Presentation Forms-A"](t3) || Nn["Arabic Presentation Forms-B"](t3));
        }
        function Jn(t3) {
          return !(746 !== t3 && 747 !== t3 && (t3 < 4352 || !(Nn["Bopomofo Extended"](t3) || Nn.Bopomofo(t3) || Nn["CJK Compatibility Forms"](t3) && !(t3 >= 65097 && t3 <= 65103) || Nn["CJK Compatibility Ideographs"](t3) || Nn["CJK Compatibility"](t3) || Nn["CJK Radicals Supplement"](t3) || Nn["CJK Strokes"](t3) || !(!Nn["CJK Symbols and Punctuation"](t3) || t3 >= 12296 && t3 <= 12305 || t3 >= 12308 && t3 <= 12319 || 12336 === t3) || Nn["CJK Unified Ideographs Extension A"](t3) || Nn["CJK Unified Ideographs"](t3) || Nn["Enclosed CJK Letters and Months"](t3) || Nn["Hangul Compatibility Jamo"](t3) || Nn["Hangul Jamo Extended-A"](t3) || Nn["Hangul Jamo Extended-B"](t3) || Nn["Hangul Jamo"](t3) || Nn["Hangul Syllables"](t3) || Nn.Hiragana(t3) || Nn["Ideographic Description Characters"](t3) || Nn.Kanbun(t3) || Nn["Kangxi Radicals"](t3) || Nn["Katakana Phonetic Extensions"](t3) || Nn.Katakana(t3) && 12540 !== t3 || !(!Nn["Halfwidth and Fullwidth Forms"](t3) || 65288 === t3 || 65289 === t3 || 65293 === t3 || t3 >= 65306 && t3 <= 65310 || 65339 === t3 || 65341 === t3 || 65343 === t3 || t3 >= 65371 && t3 <= 65503 || 65507 === t3 || t3 >= 65512 && t3 <= 65519) || !(!Nn["Small Form Variants"](t3) || t3 >= 65112 && t3 <= 65118 || t3 >= 65123 && t3 <= 65126) || Nn["Unified Canadian Aboriginal Syllabics"](t3) || Nn["Unified Canadian Aboriginal Syllabics Extended"](t3) || Nn["Vertical Forms"](t3) || Nn["Yijing Hexagram Symbols"](t3) || Nn["Yi Syllables"](t3) || Nn["Yi Radicals"](t3))));
        }
        function Xn(t3) {
          return !(Jn(t3) || function(t4) {
            return !!(Nn["Latin-1 Supplement"](t4) && (167 === t4 || 169 === t4 || 174 === t4 || 177 === t4 || 188 === t4 || 189 === t4 || 190 === t4 || 215 === t4 || 247 === t4) || Nn["General Punctuation"](t4) && (8214 === t4 || 8224 === t4 || 8225 === t4 || 8240 === t4 || 8241 === t4 || 8251 === t4 || 8252 === t4 || 8258 === t4 || 8263 === t4 || 8264 === t4 || 8265 === t4 || 8273 === t4) || Nn["Letterlike Symbols"](t4) || Nn["Number Forms"](t4) || Nn["Miscellaneous Technical"](t4) && (t4 >= 8960 && t4 <= 8967 || t4 >= 8972 && t4 <= 8991 || t4 >= 8996 && t4 <= 9e3 || 9003 === t4 || t4 >= 9085 && t4 <= 9114 || t4 >= 9150 && t4 <= 9165 || 9167 === t4 || t4 >= 9169 && t4 <= 9179 || t4 >= 9186 && t4 <= 9215) || Nn["Control Pictures"](t4) && 9251 !== t4 || Nn["Optical Character Recognition"](t4) || Nn["Enclosed Alphanumerics"](t4) || Nn["Geometric Shapes"](t4) || Nn["Miscellaneous Symbols"](t4) && !(t4 >= 9754 && t4 <= 9759) || Nn["Miscellaneous Symbols and Arrows"](t4) && (t4 >= 11026 && t4 <= 11055 || t4 >= 11088 && t4 <= 11097 || t4 >= 11192 && t4 <= 11243) || Nn["CJK Symbols and Punctuation"](t4) || Nn.Katakana(t4) || Nn["Private Use Area"](t4) || Nn["CJK Compatibility Forms"](t4) || Nn["Small Form Variants"](t4) || Nn["Halfwidth and Fullwidth Forms"](t4) || 8734 === t4 || 8756 === t4 || 8757 === t4 || t4 >= 9984 && t4 <= 10087 || t4 >= 10102 && t4 <= 10131 || 65532 === t4 || 65533 === t4);
          }(t3));
        }
        function Hn(t3) {
          return t3 >= 1424 && t3 <= 2303 || Nn["Arabic Presentation Forms-A"](t3) || Nn["Arabic Presentation Forms-B"](t3);
        }
        function Yn(t3, e4) {
          return !(!e4 && Hn(t3) || t3 >= 2304 && t3 <= 3583 || t3 >= 3840 && t3 <= 4255 || Nn.Khmer(t3));
        }
        function Wn(t3) {
          for (const e4 of t3)
            if (Hn(e4.charCodeAt(0)))
              return true;
          return false;
        }
        const Qn = new class {
          constructor() {
            this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null;
          }
          setState(t3) {
            this.pluginStatus = t3.pluginStatus, this.pluginURL = t3.pluginURL;
          }
          setMethods(t3) {
            this.applyArabicShaping = t3.applyArabicShaping, this.processBidirectionalText = t3.processBidirectionalText, this.processStyledBidirectionalText = t3.processStyledBidirectionalText;
          }
          isParsed() {
            return null != this.applyArabicShaping && null != this.processBidirectionalText && null != this.processStyledBidirectionalText;
          }
          getPluginURL() {
            return this.pluginURL;
          }
          getRTLTextPluginStatus() {
            return this.pluginStatus;
          }
        }();
        class ti {
          constructor(t3, e4) {
            this.zoom = t3, e4 ? (this.now = e4.now, this.fadeDuration = e4.fadeDuration, this.zoomHistory = e4.zoomHistory, this.transition = e4.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new qn(), this.transition = {});
          }
          isSupportedScript(t3) {
            return function(t4, e4) {
              for (const r5 of t4)
                if (!Yn(r5.charCodeAt(0), e4))
                  return false;
              return true;
            }(t3, "loaded" === Qn.getRTLTextPluginStatus());
          }
          crossFadingFactor() {
            return 0 === this.fadeDuration ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
          }
          getCrossfadeParameters() {
            const t3 = this.zoom, e4 = t3 - Math.floor(t3), r5 = this.crossFadingFactor();
            return t3 > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: e4 + (1 - e4) * r5 } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - r5) * e4 };
          }
        }
        class ei {
          constructor(t3, e4) {
            this.property = t3, this.value = e4, this.expression = function(t4, e5) {
              if (Mr(t4))
                return new jr(t4, e5);
              if (Dr(t4)) {
                const r5 = Ur(t4, e5);
                if ("error" === r5.result)
                  throw new Error(r5.value.map((t5) => `${t5.key}: ${t5.message}`).join(", "));
                return r5.value;
              }
              {
                let r5 = t4;
                return "color" === e5.type && "string" == typeof t4 ? r5 = Jt.parse(t4) : "padding" !== e5.type || "number" != typeof t4 && !Array.isArray(t4) ? "variableAnchorOffsetCollection" === e5.type && Array.isArray(t4) && (r5 = te2.parse(t4)) : r5 = Wt.parse(t4), { kind: "constant", evaluate: () => r5 };
              }
            }(void 0 === e4 ? t3.specification.default : e4, t3.specification);
          }
          isDataDriven() {
            return "source" === this.expression.kind || "composite" === this.expression.kind;
          }
          possiblyEvaluate(t3, e4, r5) {
            return this.property.possiblyEvaluate(this, t3, e4, r5);
          }
        }
        class ri {
          constructor(t3) {
            this.property = t3, this.value = new ei(t3, void 0);
          }
          transitioned(t3, e4) {
            return new ii(this.property, this.value, e4, g2({}, t3.transition, this.transition), t3.now);
          }
          untransitioned() {
            return new ii(this.property, this.value, null, {}, 0);
          }
        }
        class ni {
          constructor(t3) {
            this._properties = t3, this._values = Object.create(t3.defaultTransitionablePropertyValues);
          }
          getValue(t3) {
            return w3(this._values[t3].value.value);
          }
          setValue(t3, e4) {
            Object.prototype.hasOwnProperty.call(this._values, t3) || (this._values[t3] = new ri(this._values[t3].property)), this._values[t3].value = new ei(this._values[t3].property, null === e4 ? void 0 : w3(e4));
          }
          getTransition(t3) {
            return w3(this._values[t3].transition);
          }
          setTransition(t3, e4) {
            Object.prototype.hasOwnProperty.call(this._values, t3) || (this._values[t3] = new ri(this._values[t3].property)), this._values[t3].transition = w3(e4) || void 0;
          }
          serialize() {
            const t3 = {};
            for (const e4 of Object.keys(this._values)) {
              const r5 = this.getValue(e4);
              void 0 !== r5 && (t3[e4] = r5);
              const n3 = this.getTransition(e4);
              void 0 !== n3 && (t3[`${e4}-transition`] = n3);
            }
            return t3;
          }
          transitioned(t3, e4) {
            const r5 = new si(this._properties);
            for (const n3 of Object.keys(this._values))
              r5._values[n3] = this._values[n3].transitioned(t3, e4._values[n3]);
            return r5;
          }
          untransitioned() {
            const t3 = new si(this._properties);
            for (const e4 of Object.keys(this._values))
              t3._values[e4] = this._values[e4].untransitioned();
            return t3;
          }
        }
        class ii {
          constructor(t3, e4, r5, n3, i4) {
            this.property = t3, this.value = e4, this.begin = i4 + n3.delay || 0, this.end = this.begin + n3.duration || 0, t3.specification.transition && (n3.delay || n3.duration) && (this.prior = r5);
          }
          possiblyEvaluate(t3, e4, r5) {
            const n3 = t3.now || 0, i4 = this.value.possiblyEvaluate(t3, e4, r5), s4 = this.prior;
            if (s4) {
              if (n3 > this.end)
                return this.prior = null, i4;
              if (this.value.isDataDriven())
                return this.prior = null, i4;
              if (n3 < this.begin)
                return s4.possiblyEvaluate(t3, e4, r5);
              {
                const a3 = (n3 - this.begin) / (this.end - this.begin);
                return this.property.interpolate(s4.possiblyEvaluate(t3, e4, r5), i4, function(t4) {
                  if (t4 <= 0)
                    return 0;
                  if (t4 >= 1)
                    return 1;
                  const e5 = t4 * t4, r6 = e5 * t4;
                  return 4 * (t4 < 0.5 ? r6 : 3 * (t4 - e5) + r6 - 0.75);
                }(a3));
              }
            }
            return i4;
          }
        }
        class si {
          constructor(t3) {
            this._properties = t3, this._values = Object.create(t3.defaultTransitioningPropertyValues);
          }
          possiblyEvaluate(t3, e4, r5) {
            const n3 = new li(this._properties);
            for (const i4 of Object.keys(this._values))
              n3._values[i4] = this._values[i4].possiblyEvaluate(t3, e4, r5);
            return n3;
          }
          hasTransition() {
            for (const t3 of Object.keys(this._values))
              if (this._values[t3].prior)
                return true;
            return false;
          }
        }
        class ai {
          constructor(t3) {
            this._properties = t3, this._values = Object.create(t3.defaultPropertyValues);
          }
          hasValue(t3) {
            return void 0 !== this._values[t3].value;
          }
          getValue(t3) {
            return w3(this._values[t3].value);
          }
          setValue(t3, e4) {
            this._values[t3] = new ei(this._values[t3].property, null === e4 ? void 0 : w3(e4));
          }
          serialize() {
            const t3 = {};
            for (const e4 of Object.keys(this._values)) {
              const r5 = this.getValue(e4);
              void 0 !== r5 && (t3[e4] = r5);
            }
            return t3;
          }
          possiblyEvaluate(t3, e4, r5) {
            const n3 = new li(this._properties);
            for (const i4 of Object.keys(this._values))
              n3._values[i4] = this._values[i4].possiblyEvaluate(t3, e4, r5);
            return n3;
          }
        }
        class oi {
          constructor(t3, e4, r5) {
            this.property = t3, this.value = e4, this.parameters = r5;
          }
          isConstant() {
            return "constant" === this.value.kind;
          }
          constantOr(t3) {
            return "constant" === this.value.kind ? this.value.value : t3;
          }
          evaluate(t3, e4, r5, n3) {
            return this.property.evaluate(this.value, this.parameters, t3, e4, r5, n3);
          }
        }
        class li {
          constructor(t3) {
            this._properties = t3, this._values = Object.create(t3.defaultPossiblyEvaluatedValues);
          }
          get(t3) {
            return this._values[t3];
          }
        }
        class ui {
          constructor(t3) {
            this.specification = t3;
          }
          possiblyEvaluate(t3, e4) {
            if (t3.isDataDriven())
              throw new Error("Value should not be data driven");
            return t3.expression.evaluate(e4);
          }
          interpolate(t3, e4, r5) {
            const n3 = Ge[this.specification.type];
            return n3 ? n3(t3, e4, r5) : t3;
          }
        }
        class ci {
          constructor(t3, e4) {
            this.specification = t3, this.overrides = e4;
          }
          possiblyEvaluate(t3, e4, r5, n3) {
            return new oi(this, "constant" === t3.expression.kind || "camera" === t3.expression.kind ? { kind: "constant", value: t3.expression.evaluate(e4, null, {}, r5, n3) } : t3.expression, e4);
          }
          interpolate(t3, e4, r5) {
            if ("constant" !== t3.value.kind || "constant" !== e4.value.kind)
              return t3;
            if (void 0 === t3.value.value || void 0 === e4.value.value)
              return new oi(this, { kind: "constant", value: void 0 }, t3.parameters);
            const n3 = Ge[this.specification.type];
            if (n3) {
              const i4 = n3(t3.value.value, e4.value.value, r5);
              return new oi(this, { kind: "constant", value: i4 }, t3.parameters);
            }
            return t3;
          }
          evaluate(t3, e4, r5, n3, i4, s4) {
            return "constant" === t3.kind ? t3.value : t3.evaluate(e4, r5, n3, i4, s4);
          }
        }
        class hi extends ci {
          possiblyEvaluate(t3, e4, r5, n3) {
            if (void 0 === t3.value)
              return new oi(this, { kind: "constant", value: void 0 }, e4);
            if ("constant" === t3.expression.kind) {
              const i4 = t3.expression.evaluate(e4, null, {}, r5, n3), s4 = "resolvedImage" === t3.property.specification.type && "string" != typeof i4 ? i4.name : i4, a3 = this._calculate(s4, s4, s4, e4);
              return new oi(this, { kind: "constant", value: a3 }, e4);
            }
            if ("camera" === t3.expression.kind) {
              const r6 = this._calculate(t3.expression.evaluate({ zoom: e4.zoom - 1 }), t3.expression.evaluate({ zoom: e4.zoom }), t3.expression.evaluate({ zoom: e4.zoom + 1 }), e4);
              return new oi(this, { kind: "constant", value: r6 }, e4);
            }
            return new oi(this, t3.expression, e4);
          }
          evaluate(t3, e4, r5, n3, i4, s4) {
            if ("source" === t3.kind) {
              const a3 = t3.evaluate(e4, r5, n3, i4, s4);
              return this._calculate(a3, a3, a3, e4);
            }
            return "composite" === t3.kind ? this._calculate(t3.evaluate({ zoom: Math.floor(e4.zoom) - 1 }, r5, n3), t3.evaluate({ zoom: Math.floor(e4.zoom) }, r5, n3), t3.evaluate({ zoom: Math.floor(e4.zoom) + 1 }, r5, n3), e4) : t3.value;
          }
          _calculate(t3, e4, r5, n3) {
            return n3.zoom > n3.zoomHistory.lastIntegerZoom ? { from: t3, to: e4 } : { from: r5, to: e4 };
          }
          interpolate(t3) {
            return t3;
          }
        }
        class pi {
          constructor(t3) {
            this.specification = t3;
          }
          possiblyEvaluate(t3, e4, r5, n3) {
            if (void 0 !== t3.value) {
              if ("constant" === t3.expression.kind) {
                const i4 = t3.expression.evaluate(e4, null, {}, r5, n3);
                return this._calculate(i4, i4, i4, e4);
              }
              return this._calculate(t3.expression.evaluate(new ti(Math.floor(e4.zoom - 1), e4)), t3.expression.evaluate(new ti(Math.floor(e4.zoom), e4)), t3.expression.evaluate(new ti(Math.floor(e4.zoom + 1), e4)), e4);
            }
          }
          _calculate(t3, e4, r5, n3) {
            return n3.zoom > n3.zoomHistory.lastIntegerZoom ? { from: t3, to: e4 } : { from: r5, to: e4 };
          }
          interpolate(t3) {
            return t3;
          }
        }
        class fi {
          constructor(t3) {
            this.specification = t3;
          }
          possiblyEvaluate(t3, e4, r5, n3) {
            return !!t3.expression.evaluate(e4, null, {}, r5, n3);
          }
          interpolate() {
            return false;
          }
        }
        class di {
          constructor(t3) {
            this.properties = t3, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            for (const e4 in t3) {
              const r5 = t3[e4];
              r5.specification.overridable && this.overridableProperties.push(e4);
              const n3 = this.defaultPropertyValues[e4] = new ei(r5, void 0), i4 = this.defaultTransitionablePropertyValues[e4] = new ri(r5);
              this.defaultTransitioningPropertyValues[e4] = i4.untransitioned(), this.defaultPossiblyEvaluatedValues[e4] = n3.possiblyEvaluate({});
            }
          }
        }
        On("DataDrivenProperty", ci), On("DataConstantProperty", ui), On("CrossFadedDataDrivenProperty", hi), On("CrossFadedProperty", pi), On("ColorRampProperty", fi);
        const yi = "-transition";
        class mi extends K2 {
          constructor(t3, e4) {
            if (super(), this.id = t3.id, this.type = t3.type, this._featureFilter = { filter: () => true, needGeometry: false }, "custom" !== t3.type && (this.metadata = t3.metadata, this.minzoom = t3.minzoom, this.maxzoom = t3.maxzoom, "background" !== t3.type && (this.source = t3.source, this.sourceLayer = t3["source-layer"], this.filter = t3.filter), e4.layout && (this._unevaluatedLayout = new ai(e4.layout)), e4.paint)) {
              this._transitionablePaint = new ni(e4.paint);
              for (const e5 in t3.paint)
                this.setPaintProperty(e5, t3.paint[e5], { validate: false });
              for (const e5 in t3.layout)
                this.setLayoutProperty(e5, t3.layout[e5], { validate: false });
              this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new li(e4.paint);
            }
          }
          getCrossfadeParameters() {
            return this._crossfadeParameters;
          }
          getLayoutProperty(t3) {
            return "visibility" === t3 ? this.visibility : this._unevaluatedLayout.getValue(t3);
          }
          setLayoutProperty(t3, e4, r5 = {}) {
            null != e4 && this._validate(Tn, `layers.${this.id}.layout.${t3}`, t3, e4, r5) || ("visibility" !== t3 ? this._unevaluatedLayout.setValue(t3, e4) : this.visibility = e4);
          }
          getPaintProperty(t3) {
            return t3.endsWith(yi) ? this._transitionablePaint.getTransition(t3.slice(0, -11)) : this._transitionablePaint.getValue(t3);
          }
          setPaintProperty(t3, e4, r5 = {}) {
            if (null != e4 && this._validate(Fn, `layers.${this.id}.paint.${t3}`, t3, e4, r5))
              return false;
            if (t3.endsWith(yi))
              return this._transitionablePaint.setTransition(t3.slice(0, -11), e4 || void 0), false;
            {
              const r6 = this._transitionablePaint._values[t3], n3 = "cross-faded-data-driven" === r6.property.specification["property-type"], i4 = r6.value.isDataDriven(), s4 = r6.value;
              this._transitionablePaint.setValue(t3, e4), this._handleSpecialPaintPropertyUpdate(t3);
              const a3 = this._transitionablePaint._values[t3].value;
              return a3.isDataDriven() || i4 || n3 || this._handleOverridablePaintPropertyUpdate(t3, s4, a3);
            }
          }
          _handleSpecialPaintPropertyUpdate(t3) {
          }
          _handleOverridablePaintPropertyUpdate(t3, e4, r5) {
            return false;
          }
          isHidden(t3) {
            return !!(this.minzoom && t3 < this.minzoom) || !!(this.maxzoom && t3 >= this.maxzoom) || "none" === this.visibility;
          }
          updateTransitions(t3) {
            this._transitioningPaint = this._transitionablePaint.transitioned(t3, this._transitioningPaint);
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition();
          }
          recalculate(t3, e4) {
            t3.getCrossfadeParameters && (this._crossfadeParameters = t3.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t3, void 0, e4)), this.paint = this._transitioningPaint.possiblyEvaluate(t3, void 0, e4);
          }
          serialize() {
            const t3 = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
            return this.visibility && (t3.layout = t3.layout || {}, t3.layout.visibility = this.visibility), b2(t3, (t4, e4) => !(void 0 === t4 || "layout" === e4 && !Object.keys(t4).length || "paint" === e4 && !Object.keys(t4).length));
          }
          _validate(t3, e4, r5, n3, i4 = {}) {
            return (!i4 || false !== i4.validate) && $n(this, t3.call(Vn, { key: e4, layerType: this.type, objectKey: r5, value: n3, styleSpec: G2, style: { glyphs: true, sprite: true } }));
          }
          is3D() {
            return false;
          }
          isTileClipped() {
            return false;
          }
          hasOffscreenPass() {
            return false;
          }
          resize() {
          }
          isStateDependent() {
            for (const t3 in this.paint._values) {
              const e4 = this.paint.get(t3);
              if (e4 instanceof oi && Sr(e4.property.specification) && ("source" === e4.value.kind || "composite" === e4.value.kind) && e4.value.isStateDependent)
                return true;
            }
            return false;
          }
        }
        const gi = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
        class xi {
          constructor(t3, e4) {
            this._structArray = t3, this._pos1 = e4 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
          }
        }
        class vi {
          constructor() {
            this.isTransferred = false, this.capacity = -1, this.resize(0);
          }
          static serialize(t3, e4) {
            return t3._trim(), e4 && (t3.isTransferred = true, e4.push(t3.arrayBuffer)), { length: t3.length, arrayBuffer: t3.arrayBuffer };
          }
          static deserialize(t3) {
            const e4 = Object.create(this.prototype);
            return e4.arrayBuffer = t3.arrayBuffer, e4.length = t3.length, e4.capacity = t3.arrayBuffer.byteLength / e4.bytesPerElement, e4._refreshViews(), e4;
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
          }
          clear() {
            this.length = 0;
          }
          resize(t3) {
            this.reserve(t3), this.length = t3;
          }
          reserve(t3) {
            if (t3 > this.capacity) {
              this.capacity = Math.max(t3, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const e4 = this.uint8;
              this._refreshViews(), e4 && this.uint8.set(e4);
            }
          }
          _refreshViews() {
            throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
          }
        }
        function bi(t3, e4 = 1) {
          let r5 = 0, n3 = 0;
          return { members: t3.map((t4) => {
            const i4 = gi[t4.type].BYTES_PER_ELEMENT, s4 = r5 = wi(r5, Math.max(e4, i4)), a3 = t4.components || 1;
            return n3 = Math.max(n3, i4), r5 += i4 * a3, { name: t4.name, type: t4.type, components: a3, offset: s4 };
          }), size: wi(r5, Math.max(n3, e4)), alignment: e4 };
        }
        function wi(t3, e4) {
          return Math.ceil(t3 / e4) * e4;
        }
        class _i extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4) {
            const r5 = this.length;
            return this.resize(r5 + 1), this.emplace(r5, t3, e4);
          }
          emplace(t3, e4, r5) {
            const n3 = 2 * t3;
            return this.int16[n3 + 0] = e4, this.int16[n3 + 1] = r5, t3;
          }
        }
        _i.prototype.bytesPerElement = 4, On("StructArrayLayout2i4", _i);
        class Ai extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4, r5) {
            const n3 = this.length;
            return this.resize(n3 + 1), this.emplace(n3, t3, e4, r5);
          }
          emplace(t3, e4, r5, n3) {
            const i4 = 3 * t3;
            return this.int16[i4 + 0] = e4, this.int16[i4 + 1] = r5, this.int16[i4 + 2] = n3, t3;
          }
        }
        Ai.prototype.bytesPerElement = 6, On("StructArrayLayout3i6", Ai);
        class Si extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4, r5, n3) {
            const i4 = this.length;
            return this.resize(i4 + 1), this.emplace(i4, t3, e4, r5, n3);
          }
          emplace(t3, e4, r5, n3, i4) {
            const s4 = 4 * t3;
            return this.int16[s4 + 0] = e4, this.int16[s4 + 1] = r5, this.int16[s4 + 2] = n3, this.int16[s4 + 3] = i4, t3;
          }
        }
        Si.prototype.bytesPerElement = 8, On("StructArrayLayout4i8", Si);
        class ki extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4, r5, n3, i4, s4) {
            const a3 = this.length;
            return this.resize(a3 + 1), this.emplace(a3, t3, e4, r5, n3, i4, s4);
          }
          emplace(t3, e4, r5, n3, i4, s4, a3) {
            const o3 = 6 * t3;
            return this.int16[o3 + 0] = e4, this.int16[o3 + 1] = r5, this.int16[o3 + 2] = n3, this.int16[o3 + 3] = i4, this.int16[o3 + 4] = s4, this.int16[o3 + 5] = a3, t3;
          }
        }
        ki.prototype.bytesPerElement = 12, On("StructArrayLayout2i4i12", ki);
        class Ii extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4, r5, n3, i4, s4) {
            const a3 = this.length;
            return this.resize(a3 + 1), this.emplace(a3, t3, e4, r5, n3, i4, s4);
          }
          emplace(t3, e4, r5, n3, i4, s4, a3) {
            const o3 = 4 * t3, l4 = 8 * t3;
            return this.int16[o3 + 0] = e4, this.int16[o3 + 1] = r5, this.uint8[l4 + 4] = n3, this.uint8[l4 + 5] = i4, this.uint8[l4 + 6] = s4, this.uint8[l4 + 7] = a3, t3;
          }
        }
        Ii.prototype.bytesPerElement = 8, On("StructArrayLayout2i4ub8", Ii);
        class zi extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4) {
            const r5 = this.length;
            return this.resize(r5 + 1), this.emplace(r5, t3, e4);
          }
          emplace(t3, e4, r5) {
            const n3 = 2 * t3;
            return this.float32[n3 + 0] = e4, this.float32[n3 + 1] = r5, t3;
          }
        }
        zi.prototype.bytesPerElement = 8, On("StructArrayLayout2f8", zi);
        class Mi extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4, r5, n3, i4, s4, a3, o3, l4, u3) {
            const c3 = this.length;
            return this.resize(c3 + 1), this.emplace(c3, t3, e4, r5, n3, i4, s4, a3, o3, l4, u3);
          }
          emplace(t3, e4, r5, n3, i4, s4, a3, o3, l4, u3, c3) {
            const h2 = 10 * t3;
            return this.uint16[h2 + 0] = e4, this.uint16[h2 + 1] = r5, this.uint16[h2 + 2] = n3, this.uint16[h2 + 3] = i4, this.uint16[h2 + 4] = s4, this.uint16[h2 + 5] = a3, this.uint16[h2 + 6] = o3, this.uint16[h2 + 7] = l4, this.uint16[h2 + 8] = u3, this.uint16[h2 + 9] = c3, t3;
          }
        }
        Mi.prototype.bytesPerElement = 20, On("StructArrayLayout10ui20", Mi);
        class Bi extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4, r5, n3, i4, s4, a3, o3, l4, u3, c3, h2) {
            const p4 = this.length;
            return this.resize(p4 + 1), this.emplace(p4, t3, e4, r5, n3, i4, s4, a3, o3, l4, u3, c3, h2);
          }
          emplace(t3, e4, r5, n3, i4, s4, a3, o3, l4, u3, c3, h2, p4) {
            const f2 = 12 * t3;
            return this.int16[f2 + 0] = e4, this.int16[f2 + 1] = r5, this.int16[f2 + 2] = n3, this.int16[f2 + 3] = i4, this.uint16[f2 + 4] = s4, this.uint16[f2 + 5] = a3, this.uint16[f2 + 6] = o3, this.uint16[f2 + 7] = l4, this.int16[f2 + 8] = u3, this.int16[f2 + 9] = c3, this.int16[f2 + 10] = h2, this.int16[f2 + 11] = p4, t3;
          }
        }
        Bi.prototype.bytesPerElement = 24, On("StructArrayLayout4i4ui4i24", Bi);
        class Ci extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4, r5) {
            const n3 = this.length;
            return this.resize(n3 + 1), this.emplace(n3, t3, e4, r5);
          }
          emplace(t3, e4, r5, n3) {
            const i4 = 3 * t3;
            return this.float32[i4 + 0] = e4, this.float32[i4 + 1] = r5, this.float32[i4 + 2] = n3, t3;
          }
        }
        Ci.prototype.bytesPerElement = 12, On("StructArrayLayout3f12", Ci);
        class Pi extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(t3) {
            const e4 = this.length;
            return this.resize(e4 + 1), this.emplace(e4, t3);
          }
          emplace(t3, e4) {
            return this.uint32[1 * t3 + 0] = e4, t3;
          }
        }
        Pi.prototype.bytesPerElement = 4, On("StructArrayLayout1ul4", Pi);
        class Vi extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4, r5, n3, i4, s4, a3, o3, l4) {
            const u3 = this.length;
            return this.resize(u3 + 1), this.emplace(u3, t3, e4, r5, n3, i4, s4, a3, o3, l4);
          }
          emplace(t3, e4, r5, n3, i4, s4, a3, o3, l4, u3) {
            const c3 = 10 * t3, h2 = 5 * t3;
            return this.int16[c3 + 0] = e4, this.int16[c3 + 1] = r5, this.int16[c3 + 2] = n3, this.int16[c3 + 3] = i4, this.int16[c3 + 4] = s4, this.int16[c3 + 5] = a3, this.uint32[h2 + 3] = o3, this.uint16[c3 + 8] = l4, this.uint16[c3 + 9] = u3, t3;
          }
        }
        Vi.prototype.bytesPerElement = 20, On("StructArrayLayout6i1ul2ui20", Vi);
        class Ei extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4, r5, n3, i4, s4) {
            const a3 = this.length;
            return this.resize(a3 + 1), this.emplace(a3, t3, e4, r5, n3, i4, s4);
          }
          emplace(t3, e4, r5, n3, i4, s4, a3) {
            const o3 = 6 * t3;
            return this.int16[o3 + 0] = e4, this.int16[o3 + 1] = r5, this.int16[o3 + 2] = n3, this.int16[o3 + 3] = i4, this.int16[o3 + 4] = s4, this.int16[o3 + 5] = a3, t3;
          }
        }
        Ei.prototype.bytesPerElement = 12, On("StructArrayLayout2i2i2i12", Ei);
        class Fi extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4, r5, n3, i4) {
            const s4 = this.length;
            return this.resize(s4 + 1), this.emplace(s4, t3, e4, r5, n3, i4);
          }
          emplace(t3, e4, r5, n3, i4, s4) {
            const a3 = 4 * t3, o3 = 8 * t3;
            return this.float32[a3 + 0] = e4, this.float32[a3 + 1] = r5, this.float32[a3 + 2] = n3, this.int16[o3 + 6] = i4, this.int16[o3 + 7] = s4, t3;
          }
        }
        Fi.prototype.bytesPerElement = 16, On("StructArrayLayout2f1f2i16", Fi);
        class Ti extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4, r5, n3) {
            const i4 = this.length;
            return this.resize(i4 + 1), this.emplace(i4, t3, e4, r5, n3);
          }
          emplace(t3, e4, r5, n3, i4) {
            const s4 = 12 * t3, a3 = 3 * t3;
            return this.uint8[s4 + 0] = e4, this.uint8[s4 + 1] = r5, this.float32[a3 + 1] = n3, this.float32[a3 + 2] = i4, t3;
          }
        }
        Ti.prototype.bytesPerElement = 12, On("StructArrayLayout2ub2f12", Ti);
        class $i extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4, r5) {
            const n3 = this.length;
            return this.resize(n3 + 1), this.emplace(n3, t3, e4, r5);
          }
          emplace(t3, e4, r5, n3) {
            const i4 = 3 * t3;
            return this.uint16[i4 + 0] = e4, this.uint16[i4 + 1] = r5, this.uint16[i4 + 2] = n3, t3;
          }
        }
        $i.prototype.bytesPerElement = 6, On("StructArrayLayout3ui6", $i);
        class Di extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4, r5, n3, i4, s4, a3, o3, l4, u3, c3, h2, p4, f2, d2, y4, m2) {
            const g3 = this.length;
            return this.resize(g3 + 1), this.emplace(g3, t3, e4, r5, n3, i4, s4, a3, o3, l4, u3, c3, h2, p4, f2, d2, y4, m2);
          }
          emplace(t3, e4, r5, n3, i4, s4, a3, o3, l4, u3, c3, h2, p4, f2, d2, y4, m2, g3) {
            const x5 = 24 * t3, v4 = 12 * t3, b3 = 48 * t3;
            return this.int16[x5 + 0] = e4, this.int16[x5 + 1] = r5, this.uint16[x5 + 2] = n3, this.uint16[x5 + 3] = i4, this.uint32[v4 + 2] = s4, this.uint32[v4 + 3] = a3, this.uint32[v4 + 4] = o3, this.uint16[x5 + 10] = l4, this.uint16[x5 + 11] = u3, this.uint16[x5 + 12] = c3, this.float32[v4 + 7] = h2, this.float32[v4 + 8] = p4, this.uint8[b3 + 36] = f2, this.uint8[b3 + 37] = d2, this.uint8[b3 + 38] = y4, this.uint32[v4 + 10] = m2, this.int16[x5 + 22] = g3, t3;
          }
        }
        Di.prototype.bytesPerElement = 48, On("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", Di);
        class Li extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4, r5, n3, i4, s4, a3, o3, l4, u3, c3, h2, p4, f2, d2, y4, m2, g3, x5, v4, b3, w4, _2, A3, S4, k3, I3, z4) {
            const M3 = this.length;
            return this.resize(M3 + 1), this.emplace(M3, t3, e4, r5, n3, i4, s4, a3, o3, l4, u3, c3, h2, p4, f2, d2, y4, m2, g3, x5, v4, b3, w4, _2, A3, S4, k3, I3, z4);
          }
          emplace(t3, e4, r5, n3, i4, s4, a3, o3, l4, u3, c3, h2, p4, f2, d2, y4, m2, g3, x5, v4, b3, w4, _2, A3, S4, k3, I3, z4, M3) {
            const B3 = 32 * t3, C5 = 16 * t3;
            return this.int16[B3 + 0] = e4, this.int16[B3 + 1] = r5, this.int16[B3 + 2] = n3, this.int16[B3 + 3] = i4, this.int16[B3 + 4] = s4, this.int16[B3 + 5] = a3, this.int16[B3 + 6] = o3, this.int16[B3 + 7] = l4, this.uint16[B3 + 8] = u3, this.uint16[B3 + 9] = c3, this.uint16[B3 + 10] = h2, this.uint16[B3 + 11] = p4, this.uint16[B3 + 12] = f2, this.uint16[B3 + 13] = d2, this.uint16[B3 + 14] = y4, this.uint16[B3 + 15] = m2, this.uint16[B3 + 16] = g3, this.uint16[B3 + 17] = x5, this.uint16[B3 + 18] = v4, this.uint16[B3 + 19] = b3, this.uint16[B3 + 20] = w4, this.uint16[B3 + 21] = _2, this.uint16[B3 + 22] = A3, this.uint32[C5 + 12] = S4, this.float32[C5 + 13] = k3, this.float32[C5 + 14] = I3, this.uint16[B3 + 30] = z4, this.uint16[B3 + 31] = M3, t3;
          }
        }
        Li.prototype.bytesPerElement = 64, On("StructArrayLayout8i15ui1ul2f2ui64", Li);
        class Oi extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3) {
            const e4 = this.length;
            return this.resize(e4 + 1), this.emplace(e4, t3);
          }
          emplace(t3, e4) {
            return this.float32[1 * t3 + 0] = e4, t3;
          }
        }
        Oi.prototype.bytesPerElement = 4, On("StructArrayLayout1f4", Oi);
        class Ri extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4, r5) {
            const n3 = this.length;
            return this.resize(n3 + 1), this.emplace(n3, t3, e4, r5);
          }
          emplace(t3, e4, r5, n3) {
            const i4 = 3 * t3;
            return this.uint16[6 * t3 + 0] = e4, this.float32[i4 + 1] = r5, this.float32[i4 + 2] = n3, t3;
          }
        }
        Ri.prototype.bytesPerElement = 12, On("StructArrayLayout1ui2f12", Ri);
        class Ui extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4, r5) {
            const n3 = this.length;
            return this.resize(n3 + 1), this.emplace(n3, t3, e4, r5);
          }
          emplace(t3, e4, r5, n3) {
            const i4 = 4 * t3;
            return this.uint32[2 * t3 + 0] = e4, this.uint16[i4 + 2] = r5, this.uint16[i4 + 3] = n3, t3;
          }
        }
        Ui.prototype.bytesPerElement = 8, On("StructArrayLayout1ul2ui8", Ui);
        class ji extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4) {
            const r5 = this.length;
            return this.resize(r5 + 1), this.emplace(r5, t3, e4);
          }
          emplace(t3, e4, r5) {
            const n3 = 2 * t3;
            return this.uint16[n3 + 0] = e4, this.uint16[n3 + 1] = r5, t3;
          }
        }
        ji.prototype.bytesPerElement = 4, On("StructArrayLayout2ui4", ji);
        class qi extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t3) {
            const e4 = this.length;
            return this.resize(e4 + 1), this.emplace(e4, t3);
          }
          emplace(t3, e4) {
            return this.uint16[1 * t3 + 0] = e4, t3;
          }
        }
        qi.prototype.bytesPerElement = 2, On("StructArrayLayout1ui2", qi);
        class Ni extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e4, r5, n3) {
            const i4 = this.length;
            return this.resize(i4 + 1), this.emplace(i4, t3, e4, r5, n3);
          }
          emplace(t3, e4, r5, n3, i4) {
            const s4 = 4 * t3;
            return this.float32[s4 + 0] = e4, this.float32[s4 + 1] = r5, this.float32[s4 + 2] = n3, this.float32[s4 + 3] = i4, t3;
          }
        }
        Ni.prototype.bytesPerElement = 16, On("StructArrayLayout4f16", Ni);
        class Zi extends xi {
          get anchorPointX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorPointY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get x1() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get y1() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get x2() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get y2() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get anchorPoint() {
            return new s3(this.anchorPointX, this.anchorPointY);
          }
        }
        Zi.prototype.size = 20;
        class Ki extends Vi {
          get(t3) {
            return new Zi(this, t3);
          }
        }
        On("CollisionBoxArray", Ki);
        class Gi extends xi {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 3];
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 2];
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 4];
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 7];
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 8];
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 36];
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 37];
          }
          set placedOrientation(t3) {
            this._structArray.uint8[this._pos1 + 37] = t3;
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 38];
          }
          set hidden(t3) {
            this._structArray.uint8[this._pos1 + 38] = t3;
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 10];
          }
          set crossTileID(t3) {
            this._structArray.uint32[this._pos4 + 10] = t3;
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 22];
          }
        }
        Gi.prototype.size = 48;
        class Ji extends Di {
          get(t3) {
            return new Gi(this, t3);
          }
        }
        On("PlacedSymbolArray", Ji);
        class Xi extends xi {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 6];
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 7];
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 13];
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 14];
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 15];
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 19];
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 20];
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 21];
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 22];
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 12];
          }
          set crossTileID(t3) {
            this._structArray.uint32[this._pos4 + 12] = t3;
          }
          get textBoxScale() {
            return this._structArray.float32[this._pos4 + 13];
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 14];
          }
          get textAnchorOffsetStartIndex() {
            return this._structArray.uint16[this._pos2 + 30];
          }
          get textAnchorOffsetEndIndex() {
            return this._structArray.uint16[this._pos2 + 31];
          }
        }
        Xi.prototype.size = 64;
        class Hi extends Li {
          get(t3) {
            return new Xi(this, t3);
          }
        }
        On("SymbolInstanceArray", Hi);
        class Yi extends Oi {
          getoffsetX(t3) {
            return this.float32[1 * t3 + 0];
          }
        }
        On("GlyphOffsetArray", Yi);
        class Wi extends Ai {
          getx(t3) {
            return this.int16[3 * t3 + 0];
          }
          gety(t3) {
            return this.int16[3 * t3 + 1];
          }
          gettileUnitDistanceFromAnchor(t3) {
            return this.int16[3 * t3 + 2];
          }
        }
        On("SymbolLineVertexArray", Wi);
        class Qi extends xi {
          get textAnchor() {
            return this._structArray.uint16[this._pos2 + 0];
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 1];
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 2];
          }
        }
        Qi.prototype.size = 12;
        class ts extends Ri {
          get(t3) {
            return new Qi(this, t3);
          }
        }
        On("TextAnchorOffsetArray", ts);
        class es extends xi {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3];
          }
        }
        es.prototype.size = 8;
        class rs extends Ui {
          get(t3) {
            return new es(this, t3);
          }
        }
        On("FeatureIndexArray", rs);
        class ns extends _i {
        }
        class is extends _i {
        }
        class ss extends _i {
        }
        class as extends ki {
        }
        class os extends Ii {
        }
        class ls extends zi {
        }
        class us extends Mi {
        }
        class cs extends Bi {
        }
        class hs extends Ci {
        }
        class ps extends Pi {
        }
        class fs extends Ei {
        }
        class ds extends Ti {
        }
        class ys extends $i {
        }
        class ms extends ji {
        }
        const gs = bi([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: xs } = gs;
        class vs {
          constructor(t3 = []) {
            this.segments = t3;
          }
          prepareSegment(t3, e4, r5, n3) {
            let i4 = this.segments[this.segments.length - 1];
            return t3 > vs.MAX_VERTEX_ARRAY_LENGTH && A2(`Max vertices per segment is ${vs.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t3}`), (!i4 || i4.vertexLength + t3 > vs.MAX_VERTEX_ARRAY_LENGTH || i4.sortKey !== n3) && (i4 = { vertexOffset: e4.length, primitiveOffset: r5.length, vertexLength: 0, primitiveLength: 0 }, void 0 !== n3 && (i4.sortKey = n3), this.segments.push(i4)), i4;
          }
          get() {
            return this.segments;
          }
          destroy() {
            for (const t3 of this.segments)
              for (const e4 in t3.vaos)
                t3.vaos[e4].destroy();
          }
          static simpleSegment(t3, e4, r5, n3) {
            return new vs([{ vertexOffset: t3, primitiveOffset: e4, vertexLength: r5, primitiveLength: n3, vaos: {}, sortKey: 0 }]);
          }
        }
        function bs(t3, e4) {
          return 256 * (t3 = y3(Math.floor(t3), 0, 255)) + y3(Math.floor(e4), 0, 255);
        }
        vs.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, On("SegmentVector", vs);
        const ws = bi([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]);
        var _s = { exports: {} }, As = { exports: {} };
        As.exports = function(t3, e4) {
          var r5, n3, i4, s4, a3, o3, l4, u3;
          for (n3 = t3.length - (r5 = 3 & t3.length), i4 = e4, a3 = 3432918353, o3 = 461845907, u3 = 0; u3 < n3; )
            l4 = 255 & t3.charCodeAt(u3) | (255 & t3.charCodeAt(++u3)) << 8 | (255 & t3.charCodeAt(++u3)) << 16 | (255 & t3.charCodeAt(++u3)) << 24, ++u3, i4 = 27492 + (65535 & (s4 = 5 * (65535 & (i4 = (i4 ^= l4 = (65535 & (l4 = (l4 = (65535 & l4) * a3 + (((l4 >>> 16) * a3 & 65535) << 16) & 4294967295) << 15 | l4 >>> 17)) * o3 + (((l4 >>> 16) * o3 & 65535) << 16) & 4294967295) << 13 | i4 >>> 19)) + ((5 * (i4 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s4 >>> 16) & 65535) << 16);
          switch (l4 = 0, r5) {
            case 3:
              l4 ^= (255 & t3.charCodeAt(u3 + 2)) << 16;
            case 2:
              l4 ^= (255 & t3.charCodeAt(u3 + 1)) << 8;
            case 1:
              i4 ^= l4 = (65535 & (l4 = (l4 = (65535 & (l4 ^= 255 & t3.charCodeAt(u3))) * a3 + (((l4 >>> 16) * a3 & 65535) << 16) & 4294967295) << 15 | l4 >>> 17)) * o3 + (((l4 >>> 16) * o3 & 65535) << 16) & 4294967295;
          }
          return i4 ^= t3.length, i4 = 2246822507 * (65535 & (i4 ^= i4 >>> 16)) + ((2246822507 * (i4 >>> 16) & 65535) << 16) & 4294967295, i4 = 3266489909 * (65535 & (i4 ^= i4 >>> 13)) + ((3266489909 * (i4 >>> 16) & 65535) << 16) & 4294967295, (i4 ^= i4 >>> 16) >>> 0;
        };
        var Ss = As.exports, ks = { exports: {} };
        ks.exports = function(t3, e4) {
          for (var r5, n3 = t3.length, i4 = e4 ^ n3, s4 = 0; n3 >= 4; )
            r5 = 1540483477 * (65535 & (r5 = 255 & t3.charCodeAt(s4) | (255 & t3.charCodeAt(++s4)) << 8 | (255 & t3.charCodeAt(++s4)) << 16 | (255 & t3.charCodeAt(++s4)) << 24)) + ((1540483477 * (r5 >>> 16) & 65535) << 16), i4 = 1540483477 * (65535 & i4) + ((1540483477 * (i4 >>> 16) & 65535) << 16) ^ (r5 = 1540483477 * (65535 & (r5 ^= r5 >>> 24)) + ((1540483477 * (r5 >>> 16) & 65535) << 16)), n3 -= 4, ++s4;
          switch (n3) {
            case 3:
              i4 ^= (255 & t3.charCodeAt(s4 + 2)) << 16;
            case 2:
              i4 ^= (255 & t3.charCodeAt(s4 + 1)) << 8;
            case 1:
              i4 = 1540483477 * (65535 & (i4 ^= 255 & t3.charCodeAt(s4))) + ((1540483477 * (i4 >>> 16) & 65535) << 16);
          }
          return i4 = 1540483477 * (65535 & (i4 ^= i4 >>> 13)) + ((1540483477 * (i4 >>> 16) & 65535) << 16), (i4 ^= i4 >>> 15) >>> 0;
        };
        var Is = Ss, zs = ks.exports;
        _s.exports = Is, _s.exports.murmur3 = Is, _s.exports.murmur2 = zs;
        var Ms = r4(_s.exports);
        class Bs {
          constructor() {
            this.ids = [], this.positions = [], this.indexed = false;
          }
          add(t3, e4, r5, n3) {
            this.ids.push(Cs(t3)), this.positions.push(e4, r5, n3);
          }
          getPositions(t3) {
            if (!this.indexed)
              throw new Error("Trying to get index, but feature positions are not indexed");
            const e4 = Cs(t3);
            let r5 = 0, n3 = this.ids.length - 1;
            for (; r5 < n3; ) {
              const t4 = r5 + n3 >> 1;
              this.ids[t4] >= e4 ? n3 = t4 : r5 = t4 + 1;
            }
            const i4 = [];
            for (; this.ids[r5] === e4; )
              i4.push({ index: this.positions[3 * r5], start: this.positions[3 * r5 + 1], end: this.positions[3 * r5 + 2] }), r5++;
            return i4;
          }
          static serialize(t3, e4) {
            const r5 = new Float64Array(t3.ids), n3 = new Uint32Array(t3.positions);
            return Ps(r5, n3, 0, r5.length - 1), e4 && e4.push(r5.buffer, n3.buffer), { ids: r5, positions: n3 };
          }
          static deserialize(t3) {
            const e4 = new Bs();
            return e4.ids = t3.ids, e4.positions = t3.positions, e4.indexed = true, e4;
          }
        }
        function Cs(t3) {
          const e4 = +t3;
          return !isNaN(e4) && e4 <= Number.MAX_SAFE_INTEGER ? e4 : Ms(String(t3));
        }
        function Ps(t3, e4, r5, n3) {
          for (; r5 < n3; ) {
            const i4 = t3[r5 + n3 >> 1];
            let s4 = r5 - 1, a3 = n3 + 1;
            for (; ; ) {
              do {
                s4++;
              } while (t3[s4] < i4);
              do {
                a3--;
              } while (t3[a3] > i4);
              if (s4 >= a3)
                break;
              Vs(t3, s4, a3), Vs(e4, 3 * s4, 3 * a3), Vs(e4, 3 * s4 + 1, 3 * a3 + 1), Vs(e4, 3 * s4 + 2, 3 * a3 + 2);
            }
            a3 - r5 < n3 - a3 ? (Ps(t3, e4, r5, a3), r5 = a3 + 1) : (Ps(t3, e4, a3 + 1, n3), n3 = a3);
          }
        }
        function Vs(t3, e4, r5) {
          const n3 = t3[e4];
          t3[e4] = t3[r5], t3[r5] = n3;
        }
        On("FeaturePositionMap", Bs);
        class Es {
          constructor(t3, e4) {
            this.gl = t3.gl, this.location = e4;
          }
        }
        class Fs extends Es {
          constructor(t3, e4) {
            super(t3, e4), this.current = 0;
          }
          set(t3) {
            this.current !== t3 && (this.current = t3, this.gl.uniform1f(this.location, t3));
          }
        }
        class Ts extends Es {
          constructor(t3, e4) {
            super(t3, e4), this.current = [0, 0, 0, 0];
          }
          set(t3) {
            t3[0] === this.current[0] && t3[1] === this.current[1] && t3[2] === this.current[2] && t3[3] === this.current[3] || (this.current = t3, this.gl.uniform4f(this.location, t3[0], t3[1], t3[2], t3[3]));
          }
        }
        class $s extends Es {
          constructor(t3, e4) {
            super(t3, e4), this.current = Jt.transparent;
          }
          set(t3) {
            t3.r === this.current.r && t3.g === this.current.g && t3.b === this.current.b && t3.a === this.current.a || (this.current = t3, this.gl.uniform4f(this.location, t3.r, t3.g, t3.b, t3.a));
          }
        }
        const Ds = new Float32Array(16);
        function Ls(t3) {
          return [bs(255 * t3.r, 255 * t3.g), bs(255 * t3.b, 255 * t3.a)];
        }
        class Os {
          constructor(t3, e4, r5) {
            this.value = t3, this.uniformNames = e4.map((t4) => `u_${t4}`), this.type = r5;
          }
          setUniform(t3, e4, r5) {
            t3.set(r5.constantOr(this.value));
          }
          getBinding(t3, e4, r5) {
            return "color" === this.type ? new $s(t3, e4) : new Fs(t3, e4);
          }
        }
        class Rs {
          constructor(t3, e4) {
            this.uniformNames = e4.map((t4) => `u_${t4}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
          }
          setConstantPatternPositions(t3, e4) {
            this.pixelRatioFrom = e4.pixelRatio, this.pixelRatioTo = t3.pixelRatio, this.patternFrom = e4.tlbr, this.patternTo = t3.tlbr;
          }
          setUniform(t3, e4, r5, n3) {
            const i4 = "u_pattern_to" === n3 ? this.patternTo : "u_pattern_from" === n3 ? this.patternFrom : "u_pixel_ratio_to" === n3 ? this.pixelRatioTo : "u_pixel_ratio_from" === n3 ? this.pixelRatioFrom : null;
            i4 && t3.set(i4);
          }
          getBinding(t3, e4, r5) {
            return "u_pattern" === r5.substr(0, 9) ? new Ts(t3, e4) : new Fs(t3, e4);
          }
        }
        class Us {
          constructor(t3, e4, r5, n3) {
            this.expression = t3, this.type = r5, this.maxValue = 0, this.paintVertexAttributes = e4.map((t4) => ({ name: `a_${t4}`, type: "Float32", components: "color" === r5 ? 2 : 1, offset: 0 })), this.paintVertexArray = new n3();
          }
          populatePaintArray(t3, e4, r5, n3, i4) {
            const s4 = this.paintVertexArray.length, a3 = this.expression.evaluate(new ti(0), e4, {}, n3, [], i4);
            this.paintVertexArray.resize(t3), this._setPaintValue(s4, t3, a3);
          }
          updatePaintArray(t3, e4, r5, n3) {
            const i4 = this.expression.evaluate({ zoom: 0 }, r5, n3);
            this._setPaintValue(t3, e4, i4);
          }
          _setPaintValue(t3, e4, r5) {
            if ("color" === this.type) {
              const n3 = Ls(r5);
              for (let r6 = t3; r6 < e4; r6++)
                this.paintVertexArray.emplace(r6, n3[0], n3[1]);
            } else {
              for (let n3 = t3; n3 < e4; n3++)
                this.paintVertexArray.emplace(n3, r5);
              this.maxValue = Math.max(this.maxValue, Math.abs(r5));
            }
          }
          upload(t3) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t3.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
        }
        class js {
          constructor(t3, e4, r5, n3, i4, s4) {
            this.expression = t3, this.uniformNames = e4.map((t4) => `u_${t4}_t`), this.type = r5, this.useIntegerZoom = n3, this.zoom = i4, this.maxValue = 0, this.paintVertexAttributes = e4.map((t4) => ({ name: `a_${t4}`, type: "Float32", components: "color" === r5 ? 4 : 2, offset: 0 })), this.paintVertexArray = new s4();
          }
          populatePaintArray(t3, e4, r5, n3, i4) {
            const s4 = this.expression.evaluate(new ti(this.zoom), e4, {}, n3, [], i4), a3 = this.expression.evaluate(new ti(this.zoom + 1), e4, {}, n3, [], i4), o3 = this.paintVertexArray.length;
            this.paintVertexArray.resize(t3), this._setPaintValue(o3, t3, s4, a3);
          }
          updatePaintArray(t3, e4, r5, n3) {
            const i4 = this.expression.evaluate({ zoom: this.zoom }, r5, n3), s4 = this.expression.evaluate({ zoom: this.zoom + 1 }, r5, n3);
            this._setPaintValue(t3, e4, i4, s4);
          }
          _setPaintValue(t3, e4, r5, n3) {
            if ("color" === this.type) {
              const i4 = Ls(r5), s4 = Ls(n3);
              for (let r6 = t3; r6 < e4; r6++)
                this.paintVertexArray.emplace(r6, i4[0], i4[1], s4[0], s4[1]);
            } else {
              for (let i4 = t3; i4 < e4; i4++)
                this.paintVertexArray.emplace(i4, r5, n3);
              this.maxValue = Math.max(this.maxValue, Math.abs(r5), Math.abs(n3));
            }
          }
          upload(t3) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t3.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
          setUniform(t3, e4) {
            const r5 = this.useIntegerZoom ? Math.floor(e4.zoom) : e4.zoom, n3 = y3(this.expression.interpolationFactor(r5, this.zoom, this.zoom + 1), 0, 1);
            t3.set(n3);
          }
          getBinding(t3, e4, r5) {
            return new Fs(t3, e4);
          }
        }
        class qs {
          constructor(t3, e4, r5, n3, i4, s4) {
            this.expression = t3, this.type = e4, this.useIntegerZoom = r5, this.zoom = n3, this.layerId = s4, this.zoomInPaintVertexArray = new i4(), this.zoomOutPaintVertexArray = new i4();
          }
          populatePaintArray(t3, e4, r5) {
            const n3 = this.zoomInPaintVertexArray.length;
            this.zoomInPaintVertexArray.resize(t3), this.zoomOutPaintVertexArray.resize(t3), this._setPaintValues(n3, t3, e4.patterns && e4.patterns[this.layerId], r5);
          }
          updatePaintArray(t3, e4, r5, n3, i4) {
            this._setPaintValues(t3, e4, r5.patterns && r5.patterns[this.layerId], i4);
          }
          _setPaintValues(t3, e4, r5, n3) {
            if (!n3 || !r5)
              return;
            const { min: i4, mid: s4, max: a3 } = r5, o3 = n3[i4], l4 = n3[s4], u3 = n3[a3];
            if (o3 && l4 && u3)
              for (let r6 = t3; r6 < e4; r6++)
                this.zoomInPaintVertexArray.emplace(r6, l4.tl[0], l4.tl[1], l4.br[0], l4.br[1], o3.tl[0], o3.tl[1], o3.br[0], o3.br[1], l4.pixelRatio, o3.pixelRatio), this.zoomOutPaintVertexArray.emplace(r6, l4.tl[0], l4.tl[1], l4.br[0], l4.br[1], u3.tl[0], u3.tl[1], u3.br[0], u3.br[1], l4.pixelRatio, u3.pixelRatio);
          }
          upload(t3) {
            this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t3.createVertexBuffer(this.zoomInPaintVertexArray, ws.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t3.createVertexBuffer(this.zoomOutPaintVertexArray, ws.members, this.expression.isStateDependent));
          }
          destroy() {
            this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
          }
        }
        class Ns {
          constructor(t3, e4, r5) {
            this.binders = {}, this._buffers = [];
            const n3 = [];
            for (const i4 in t3.paint._values) {
              if (!r5(i4))
                continue;
              const s4 = t3.paint.get(i4);
              if (!(s4 instanceof oi && Sr(s4.property.specification)))
                continue;
              const a3 = Ks(i4, t3.type), o3 = s4.value, l4 = s4.property.specification.type, u3 = s4.property.useIntegerZoom, c3 = s4.property.specification["property-type"], h2 = "cross-faded" === c3 || "cross-faded-data-driven" === c3;
              if ("constant" === o3.kind)
                this.binders[i4] = h2 ? new Rs(o3.value, a3) : new Os(o3.value, a3, l4), n3.push(`/u_${i4}`);
              else if ("source" === o3.kind || h2) {
                const r6 = Gs(i4, l4, "source");
                this.binders[i4] = h2 ? new qs(o3, l4, u3, e4, r6, t3.id) : new Us(o3, a3, l4, r6), n3.push(`/a_${i4}`);
              } else {
                const t4 = Gs(i4, l4, "composite");
                this.binders[i4] = new js(o3, a3, l4, u3, e4, t4), n3.push(`/z_${i4}`);
              }
            }
            this.cacheKey = n3.sort().join("");
          }
          getMaxValue(t3) {
            const e4 = this.binders[t3];
            return e4 instanceof Us || e4 instanceof js ? e4.maxValue : 0;
          }
          populatePaintArrays(t3, e4, r5, n3, i4) {
            for (const s4 in this.binders) {
              const a3 = this.binders[s4];
              (a3 instanceof Us || a3 instanceof js || a3 instanceof qs) && a3.populatePaintArray(t3, e4, r5, n3, i4);
            }
          }
          setConstantPatternPositions(t3, e4) {
            for (const r5 in this.binders) {
              const n3 = this.binders[r5];
              n3 instanceof Rs && n3.setConstantPatternPositions(t3, e4);
            }
          }
          updatePaintArrays(t3, e4, r5, n3, i4) {
            let s4 = false;
            for (const a3 in t3) {
              const o3 = e4.getPositions(a3);
              for (const e5 of o3) {
                const o4 = r5.feature(e5.index);
                for (const r6 in this.binders) {
                  const l4 = this.binders[r6];
                  if ((l4 instanceof Us || l4 instanceof js || l4 instanceof qs) && true === l4.expression.isStateDependent) {
                    const u3 = n3.paint.get(r6);
                    l4.expression = u3.value, l4.updatePaintArray(e5.start, e5.end, o4, t3[a3], i4), s4 = true;
                  }
                }
              }
            }
            return s4;
          }
          defines() {
            const t3 = [];
            for (const e4 in this.binders) {
              const r5 = this.binders[e4];
              (r5 instanceof Os || r5 instanceof Rs) && t3.push(...r5.uniformNames.map((t4) => `#define HAS_UNIFORM_${t4}`));
            }
            return t3;
          }
          getBinderAttributes() {
            const t3 = [];
            for (const e4 in this.binders) {
              const r5 = this.binders[e4];
              if (r5 instanceof Us || r5 instanceof js)
                for (let e5 = 0; e5 < r5.paintVertexAttributes.length; e5++)
                  t3.push(r5.paintVertexAttributes[e5].name);
              else if (r5 instanceof qs)
                for (let e5 = 0; e5 < ws.members.length; e5++)
                  t3.push(ws.members[e5].name);
            }
            return t3;
          }
          getBinderUniforms() {
            const t3 = [];
            for (const e4 in this.binders) {
              const r5 = this.binders[e4];
              if (r5 instanceof Os || r5 instanceof Rs || r5 instanceof js)
                for (const e5 of r5.uniformNames)
                  t3.push(e5);
            }
            return t3;
          }
          getPaintVertexBuffers() {
            return this._buffers;
          }
          getUniforms(t3, e4) {
            const r5 = [];
            for (const n3 in this.binders) {
              const i4 = this.binders[n3];
              if (i4 instanceof Os || i4 instanceof Rs || i4 instanceof js) {
                for (const s4 of i4.uniformNames)
                  if (e4[s4]) {
                    const a3 = i4.getBinding(t3, e4[s4], s4);
                    r5.push({ name: s4, property: n3, binding: a3 });
                  }
              }
            }
            return r5;
          }
          setUniforms(t3, e4, r5, n3) {
            for (const { name: t4, property: i4, binding: s4 } of e4)
              this.binders[i4].setUniform(s4, n3, r5.get(i4), t4);
          }
          updatePaintBuffers(t3) {
            this._buffers = [];
            for (const e4 in this.binders) {
              const r5 = this.binders[e4];
              if (t3 && r5 instanceof qs) {
                const e5 = 2 === t3.fromScale ? r5.zoomInPaintVertexBuffer : r5.zoomOutPaintVertexBuffer;
                e5 && this._buffers.push(e5);
              } else
                (r5 instanceof Us || r5 instanceof js) && r5.paintVertexBuffer && this._buffers.push(r5.paintVertexBuffer);
            }
          }
          upload(t3) {
            for (const e4 in this.binders) {
              const r5 = this.binders[e4];
              (r5 instanceof Us || r5 instanceof js || r5 instanceof qs) && r5.upload(t3);
            }
            this.updatePaintBuffers();
          }
          destroy() {
            for (const t3 in this.binders) {
              const e4 = this.binders[t3];
              (e4 instanceof Us || e4 instanceof js || e4 instanceof qs) && e4.destroy();
            }
          }
        }
        class Zs {
          constructor(t3, e4, r5 = () => true) {
            this.programConfigurations = {};
            for (const n3 of t3)
              this.programConfigurations[n3.id] = new Ns(n3, e4, r5);
            this.needsUpload = false, this._featureMap = new Bs(), this._bufferOffset = 0;
          }
          populatePaintArrays(t3, e4, r5, n3, i4, s4) {
            for (const r6 in this.programConfigurations)
              this.programConfigurations[r6].populatePaintArrays(t3, e4, n3, i4, s4);
            void 0 !== e4.id && this._featureMap.add(e4.id, r5, this._bufferOffset, t3), this._bufferOffset = t3, this.needsUpload = true;
          }
          updatePaintArrays(t3, e4, r5, n3) {
            for (const i4 of r5)
              this.needsUpload = this.programConfigurations[i4.id].updatePaintArrays(t3, this._featureMap, e4, i4, n3) || this.needsUpload;
          }
          get(t3) {
            return this.programConfigurations[t3];
          }
          upload(t3) {
            if (this.needsUpload) {
              for (const e4 in this.programConfigurations)
                this.programConfigurations[e4].upload(t3);
              this.needsUpload = false;
            }
          }
          destroy() {
            for (const t3 in this.programConfigurations)
              this.programConfigurations[t3].destroy();
          }
        }
        function Ks(t3, e4) {
          return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[t3] || [t3.replace(`${e4}-`, "").replace(/-/g, "_")];
        }
        function Gs(t3, e4, r5) {
          const n3 = { color: { source: zi, composite: Ni }, number: { source: Oi, composite: zi } }, i4 = function(t4) {
            return { "line-pattern": { source: us, composite: us }, "fill-pattern": { source: us, composite: us }, "fill-extrusion-pattern": { source: us, composite: us } }[t4];
          }(t3);
          return i4 && i4[r5] || n3[e4][r5];
        }
        On("ConstantBinder", Os), On("CrossFadedConstantBinder", Rs), On("SourceExpressionBinder", Us), On("CrossFadedCompositeBinder", qs), On("CompositeExpressionBinder", js), On("ProgramConfiguration", Ns, { omit: ["_buffers"] }), On("ProgramConfigurationSet", Zs);
        const Js = 8192, Xs = Math.pow(2, 14) - 1, Hs = -Xs - 1;
        function Ys(t3) {
          const e4 = Js / t3.extent, r5 = t3.loadGeometry();
          for (let t4 = 0; t4 < r5.length; t4++) {
            const n3 = r5[t4];
            for (let t5 = 0; t5 < n3.length; t5++) {
              const r6 = n3[t5], i4 = Math.round(r6.x * e4), s4 = Math.round(r6.y * e4);
              r6.x = y3(i4, Hs, Xs), r6.y = y3(s4, Hs, Xs), (i4 < r6.x || i4 > r6.x + 1 || s4 < r6.y || s4 > r6.y + 1) && A2("Geometry exceeds allowed extent, reduce your vector tile buffer size");
            }
          }
          return r5;
        }
        function Ws(t3, e4) {
          return { type: t3.type, id: t3.id, properties: t3.properties, geometry: e4 ? Ys(t3) : [] };
        }
        function Qs(t3, e4, r5, n3, i4) {
          t3.emplaceBack(2 * e4 + (n3 + 1) / 2, 2 * r5 + (i4 + 1) / 2);
        }
        class ta2 {
          constructor(t3) {
            this.zoom = t3.zoom, this.overscaling = t3.overscaling, this.layers = t3.layers, this.layerIds = this.layers.map((t4) => t4.id), this.index = t3.index, this.hasPattern = false, this.layoutVertexArray = new is(), this.indexArray = new ys(), this.segments = new vs(), this.programConfigurations = new Zs(t3.layers, t3.zoom), this.stateDependentLayerIds = this.layers.filter((t4) => t4.isStateDependent()).map((t4) => t4.id);
          }
          populate(t3, e4, r5) {
            const n3 = this.layers[0], i4 = [];
            let s4 = null, a3 = false;
            "circle" === n3.type && (s4 = n3.layout.get("circle-sort-key"), a3 = !s4.isConstant());
            for (const { feature: e5, id: n4, index: o3, sourceLayerIndex: l4 } of t3) {
              const t4 = this.layers[0]._featureFilter.needGeometry, u3 = Ws(e5, t4);
              if (!this.layers[0]._featureFilter.filter(new ti(this.zoom), u3, r5))
                continue;
              const c3 = a3 ? s4.evaluate(u3, {}, r5) : void 0, h2 = { id: n4, properties: e5.properties, type: e5.type, sourceLayerIndex: l4, index: o3, geometry: t4 ? u3.geometry : Ys(e5), patterns: {}, sortKey: c3 };
              i4.push(h2);
            }
            a3 && i4.sort((t4, e5) => t4.sortKey - e5.sortKey);
            for (const n4 of i4) {
              const { geometry: i5, index: s5, sourceLayerIndex: a4 } = n4, o3 = t3[s5].feature;
              this.addFeature(n4, i5, s5, r5), e4.featureIndex.insert(o3, i5, s5, a4, this.index);
            }
          }
          update(t3, e4, r5) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t3, e4, this.stateDependentLayers, r5);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t3) {
            this.uploaded || (this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, xs), this.indexBuffer = t3.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t3), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          addFeature(t3, e4, r5, n3) {
            for (const r6 of e4)
              for (const e5 of r6) {
                const r7 = e5.x, n4 = e5.y;
                if (r7 < 0 || r7 >= Js || n4 < 0 || n4 >= Js)
                  continue;
                const i4 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t3.sortKey), s4 = i4.vertexLength;
                Qs(this.layoutVertexArray, r7, n4, -1, -1), Qs(this.layoutVertexArray, r7, n4, 1, -1), Qs(this.layoutVertexArray, r7, n4, 1, 1), Qs(this.layoutVertexArray, r7, n4, -1, 1), this.indexArray.emplaceBack(s4, s4 + 1, s4 + 2), this.indexArray.emplaceBack(s4, s4 + 3, s4 + 2), i4.vertexLength += 4, i4.primitiveLength += 2;
              }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t3, r5, {}, n3);
          }
        }
        function ea2(t3, e4) {
          for (let r5 = 0; r5 < t3.length; r5++)
            if (ca2(e4, t3[r5]))
              return true;
          for (let r5 = 0; r5 < e4.length; r5++)
            if (ca2(t3, e4[r5]))
              return true;
          return !!sa2(t3, e4);
        }
        function ra2(t3, e4, r5) {
          return !!ca2(t3, e4) || !!oa2(e4, t3, r5);
        }
        function na2(t3, e4) {
          if (1 === t3.length)
            return ua2(e4, t3[0]);
          for (let r5 = 0; r5 < e4.length; r5++) {
            const n3 = e4[r5];
            for (let e5 = 0; e5 < n3.length; e5++)
              if (ca2(t3, n3[e5]))
                return true;
          }
          for (let r5 = 0; r5 < t3.length; r5++)
            if (ua2(e4, t3[r5]))
              return true;
          for (let r5 = 0; r5 < e4.length; r5++)
            if (sa2(t3, e4[r5]))
              return true;
          return false;
        }
        function ia2(t3, e4, r5) {
          if (t3.length > 1) {
            if (sa2(t3, e4))
              return true;
            for (let n3 = 0; n3 < e4.length; n3++)
              if (oa2(e4[n3], t3, r5))
                return true;
          }
          for (let n3 = 0; n3 < t3.length; n3++)
            if (oa2(t3[n3], e4, r5))
              return true;
          return false;
        }
        function sa2(t3, e4) {
          if (0 === t3.length || 0 === e4.length)
            return false;
          for (let r5 = 0; r5 < t3.length - 1; r5++) {
            const n3 = t3[r5], i4 = t3[r5 + 1];
            for (let t4 = 0; t4 < e4.length - 1; t4++)
              if (aa2(n3, i4, e4[t4], e4[t4 + 1]))
                return true;
          }
          return false;
        }
        function aa2(t3, e4, r5, n3) {
          return S3(t3, r5, n3) !== S3(e4, r5, n3) && S3(t3, e4, r5) !== S3(t3, e4, n3);
        }
        function oa2(t3, e4, r5) {
          const n3 = r5 * r5;
          if (1 === e4.length)
            return t3.distSqr(e4[0]) < n3;
          for (let r6 = 1; r6 < e4.length; r6++)
            if (la(t3, e4[r6 - 1], e4[r6]) < n3)
              return true;
          return false;
        }
        function la(t3, e4, r5) {
          const n3 = e4.distSqr(r5);
          if (0 === n3)
            return t3.distSqr(e4);
          const i4 = ((t3.x - e4.x) * (r5.x - e4.x) + (t3.y - e4.y) * (r5.y - e4.y)) / n3;
          return t3.distSqr(i4 < 0 ? e4 : i4 > 1 ? r5 : r5.sub(e4)._mult(i4)._add(e4));
        }
        function ua2(t3, e4) {
          let r5, n3, i4, s4 = false;
          for (let a3 = 0; a3 < t3.length; a3++) {
            r5 = t3[a3];
            for (let t4 = 0, a4 = r5.length - 1; t4 < r5.length; a4 = t4++)
              n3 = r5[t4], i4 = r5[a4], n3.y > e4.y != i4.y > e4.y && e4.x < (i4.x - n3.x) * (e4.y - n3.y) / (i4.y - n3.y) + n3.x && (s4 = !s4);
          }
          return s4;
        }
        function ca2(t3, e4) {
          let r5 = false;
          for (let n3 = 0, i4 = t3.length - 1; n3 < t3.length; i4 = n3++) {
            const s4 = t3[n3], a3 = t3[i4];
            s4.y > e4.y != a3.y > e4.y && e4.x < (a3.x - s4.x) * (e4.y - s4.y) / (a3.y - s4.y) + s4.x && (r5 = !r5);
          }
          return r5;
        }
        function ha2(t3, e4, r5) {
          const n3 = r5[0], i4 = r5[2];
          if (t3.x < n3.x && e4.x < n3.x || t3.x > i4.x && e4.x > i4.x || t3.y < n3.y && e4.y < n3.y || t3.y > i4.y && e4.y > i4.y)
            return false;
          const s4 = S3(t3, e4, r5[0]);
          return s4 !== S3(t3, e4, r5[1]) || s4 !== S3(t3, e4, r5[2]) || s4 !== S3(t3, e4, r5[3]);
        }
        function pa2(t3, e4, r5) {
          const n3 = e4.paint.get(t3).value;
          return "constant" === n3.kind ? n3.value : r5.programConfigurations.get(e4.id).getMaxValue(t3);
        }
        function fa2(t3) {
          return Math.sqrt(t3[0] * t3[0] + t3[1] * t3[1]);
        }
        function da2(t3, e4, r5, n3, i4) {
          if (!e4[0] && !e4[1])
            return t3;
          const a3 = s3.convert(e4)._mult(i4);
          "viewport" === r5 && a3._rotate(-n3);
          const o3 = [];
          for (let e5 = 0; e5 < t3.length; e5++)
            o3.push(t3[e5].sub(a3));
          return o3;
        }
        let ya2, ma2;
        On("CircleBucket", ta2, { omit: ["layers"] });
        var ga = { get paint() {
          return ma2 = ma2 || new di({ "circle-radius": new ci(G2.paint_circle["circle-radius"]), "circle-color": new ci(G2.paint_circle["circle-color"]), "circle-blur": new ci(G2.paint_circle["circle-blur"]), "circle-opacity": new ci(G2.paint_circle["circle-opacity"]), "circle-translate": new ui(G2.paint_circle["circle-translate"]), "circle-translate-anchor": new ui(G2.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new ui(G2.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new ui(G2.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new ci(G2.paint_circle["circle-stroke-width"]), "circle-stroke-color": new ci(G2.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new ci(G2.paint_circle["circle-stroke-opacity"]) });
        }, get layout() {
          return ya2 = ya2 || new di({ "circle-sort-key": new ci(G2.layout_circle["circle-sort-key"]) });
        } }, xa2 = 1e-6, va2 = "undefined" != typeof Float32Array ? Float32Array : Array;
        function ba2(t3) {
          return t3[0] = 1, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = 1, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = 1, t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0, t3[15] = 1, t3;
        }
        function wa2(t3, e4, r5) {
          var n3 = e4[0], i4 = e4[1], s4 = e4[2], a3 = e4[3], o3 = e4[4], l4 = e4[5], u3 = e4[6], c3 = e4[7], h2 = e4[8], p4 = e4[9], f2 = e4[10], d2 = e4[11], y4 = e4[12], m2 = e4[13], g3 = e4[14], x5 = e4[15], v4 = r5[0], b3 = r5[1], w4 = r5[2], _2 = r5[3];
          return t3[0] = v4 * n3 + b3 * o3 + w4 * h2 + _2 * y4, t3[1] = v4 * i4 + b3 * l4 + w4 * p4 + _2 * m2, t3[2] = v4 * s4 + b3 * u3 + w4 * f2 + _2 * g3, t3[3] = v4 * a3 + b3 * c3 + w4 * d2 + _2 * x5, t3[4] = (v4 = r5[4]) * n3 + (b3 = r5[5]) * o3 + (w4 = r5[6]) * h2 + (_2 = r5[7]) * y4, t3[5] = v4 * i4 + b3 * l4 + w4 * p4 + _2 * m2, t3[6] = v4 * s4 + b3 * u3 + w4 * f2 + _2 * g3, t3[7] = v4 * a3 + b3 * c3 + w4 * d2 + _2 * x5, t3[8] = (v4 = r5[8]) * n3 + (b3 = r5[9]) * o3 + (w4 = r5[10]) * h2 + (_2 = r5[11]) * y4, t3[9] = v4 * i4 + b3 * l4 + w4 * p4 + _2 * m2, t3[10] = v4 * s4 + b3 * u3 + w4 * f2 + _2 * g3, t3[11] = v4 * a3 + b3 * c3 + w4 * d2 + _2 * x5, t3[12] = (v4 = r5[12]) * n3 + (b3 = r5[13]) * o3 + (w4 = r5[14]) * h2 + (_2 = r5[15]) * y4, t3[13] = v4 * i4 + b3 * l4 + w4 * p4 + _2 * m2, t3[14] = v4 * s4 + b3 * u3 + w4 * f2 + _2 * g3, t3[15] = v4 * a3 + b3 * c3 + w4 * d2 + _2 * x5, t3;
        }
        Math.hypot || (Math.hypot = function() {
          for (var t3 = 0, e4 = arguments.length; e4--; )
            t3 += arguments[e4] * arguments[e4];
          return Math.sqrt(t3);
        });
        var _a2, Aa2 = wa2;
        function Sa2(t3, e4, r5) {
          var n3 = e4[0], i4 = e4[1], s4 = e4[2], a3 = e4[3];
          return t3[0] = r5[0] * n3 + r5[4] * i4 + r5[8] * s4 + r5[12] * a3, t3[1] = r5[1] * n3 + r5[5] * i4 + r5[9] * s4 + r5[13] * a3, t3[2] = r5[2] * n3 + r5[6] * i4 + r5[10] * s4 + r5[14] * a3, t3[3] = r5[3] * n3 + r5[7] * i4 + r5[11] * s4 + r5[15] * a3, t3;
        }
        _a2 = new va2(4), va2 != Float32Array && (_a2[0] = 0, _a2[1] = 0, _a2[2] = 0, _a2[3] = 0);
        class ka2 extends mi {
          constructor(t3) {
            super(t3, ga);
          }
          createBucket(t3) {
            return new ta2(t3);
          }
          queryRadius(t3) {
            const e4 = t3;
            return pa2("circle-radius", this, e4) + pa2("circle-stroke-width", this, e4) + fa2(this.paint.get("circle-translate"));
          }
          queryIntersectsFeature(t3, e4, r5, n3, i4, s4, a3, o3) {
            const l4 = da2(t3, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), s4.angle, a3), u3 = this.paint.get("circle-radius").evaluate(e4, r5) + this.paint.get("circle-stroke-width").evaluate(e4, r5), c3 = "map" === this.paint.get("circle-pitch-alignment"), h2 = c3 ? l4 : function(t4, e5) {
              return t4.map((t5) => Ia2(t5, e5));
            }(l4, o3), p4 = c3 ? u3 * a3 : u3;
            for (const t4 of n3)
              for (const e5 of t4) {
                const t5 = c3 ? e5 : Ia2(e5, o3);
                let r6 = p4;
                const n4 = Sa2([], [e5.x, e5.y, 0, 1], o3);
                if ("viewport" === this.paint.get("circle-pitch-scale") && "map" === this.paint.get("circle-pitch-alignment") ? r6 *= n4[3] / s4.cameraToCenterDistance : "map" === this.paint.get("circle-pitch-scale") && "viewport" === this.paint.get("circle-pitch-alignment") && (r6 *= s4.cameraToCenterDistance / n4[3]), ra2(h2, t5, r6))
                  return true;
              }
            return false;
          }
        }
        function Ia2(t3, e4) {
          const r5 = Sa2([], [t3.x, t3.y, 0, 1], e4);
          return new s3(r5[0] / r5[3], r5[1] / r5[3]);
        }
        class za2 extends ta2 {
        }
        let Ma2;
        On("HeatmapBucket", za2, { omit: ["layers"] });
        var Ba2 = { get paint() {
          return Ma2 = Ma2 || new di({ "heatmap-radius": new ci(G2.paint_heatmap["heatmap-radius"]), "heatmap-weight": new ci(G2.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new ui(G2.paint_heatmap["heatmap-intensity"]), "heatmap-color": new fi(G2.paint_heatmap["heatmap-color"]), "heatmap-opacity": new ui(G2.paint_heatmap["heatmap-opacity"]) });
        } };
        function Ca2(t3, { width: e4, height: r5 }, n3, i4) {
          if (i4) {
            if (i4 instanceof Uint8ClampedArray)
              i4 = new Uint8Array(i4.buffer);
            else if (i4.length !== e4 * r5 * n3)
              throw new RangeError(`mismatched image size. expected: ${i4.length} but got: ${e4 * r5 * n3}`);
          } else
            i4 = new Uint8Array(e4 * r5 * n3);
          return t3.width = e4, t3.height = r5, t3.data = i4, t3;
        }
        function Pa2(t3, { width: e4, height: r5 }, n3) {
          if (e4 === t3.width && r5 === t3.height)
            return;
          const i4 = Ca2({}, { width: e4, height: r5 }, n3);
          Va2(t3, i4, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t3.width, e4), height: Math.min(t3.height, r5) }, n3), t3.width = e4, t3.height = r5, t3.data = i4.data;
        }
        function Va2(t3, e4, r5, n3, i4, s4) {
          if (0 === i4.width || 0 === i4.height)
            return e4;
          if (i4.width > t3.width || i4.height > t3.height || r5.x > t3.width - i4.width || r5.y > t3.height - i4.height)
            throw new RangeError("out of range source coordinates for image copy");
          if (i4.width > e4.width || i4.height > e4.height || n3.x > e4.width - i4.width || n3.y > e4.height - i4.height)
            throw new RangeError("out of range destination coordinates for image copy");
          const a3 = t3.data, o3 = e4.data;
          if (a3 === o3)
            throw new Error("srcData equals dstData, so image is already copied");
          for (let l4 = 0; l4 < i4.height; l4++) {
            const u3 = ((r5.y + l4) * t3.width + r5.x) * s4, c3 = ((n3.y + l4) * e4.width + n3.x) * s4;
            for (let t4 = 0; t4 < i4.width * s4; t4++)
              o3[c3 + t4] = a3[u3 + t4];
          }
          return e4;
        }
        class Ea2 {
          constructor(t3, e4) {
            Ca2(this, t3, 1, e4);
          }
          resize(t3) {
            Pa2(this, t3, 1);
          }
          clone() {
            return new Ea2({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t3, e4, r5, n3, i4) {
            Va2(t3, e4, r5, n3, i4, 1);
          }
        }
        class Fa2 {
          constructor(t3, e4) {
            Ca2(this, t3, 4, e4);
          }
          resize(t3) {
            Pa2(this, t3, 4);
          }
          replace(t3, e4) {
            e4 ? this.data.set(t3) : this.data = t3 instanceof Uint8ClampedArray ? new Uint8Array(t3.buffer) : t3;
          }
          clone() {
            return new Fa2({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t3, e4, r5, n3, i4) {
            Va2(t3, e4, r5, n3, i4, 4);
          }
        }
        function Ta2(t3) {
          const e4 = {}, r5 = t3.resolution || 256, n3 = t3.clips ? t3.clips.length : 1, i4 = t3.image || new Fa2({ width: r5, height: n3 });
          if (Math.log(r5) / Math.LN2 % 1 != 0)
            throw new Error(`width is not a power of 2 - ${r5}`);
          const s4 = (r6, n4, s5) => {
            e4[t3.evaluationKey] = s5;
            const a3 = t3.expression.evaluate(e4);
            i4.data[r6 + n4 + 0] = Math.floor(255 * a3.r / a3.a), i4.data[r6 + n4 + 1] = Math.floor(255 * a3.g / a3.a), i4.data[r6 + n4 + 2] = Math.floor(255 * a3.b / a3.a), i4.data[r6 + n4 + 3] = Math.floor(255 * a3.a);
          };
          if (t3.clips)
            for (let e5 = 0, i5 = 0; e5 < n3; ++e5, i5 += 4 * r5)
              for (let n4 = 0, a3 = 0; n4 < r5; n4++, a3 += 4) {
                const o3 = n4 / (r5 - 1), { start: l4, end: u3 } = t3.clips[e5];
                s4(i5, a3, l4 * (1 - o3) + u3 * o3);
              }
          else
            for (let t4 = 0, e5 = 0; t4 < r5; t4++, e5 += 4)
              s4(0, e5, t4 / (r5 - 1));
          return i4;
        }
        On("AlphaImage", Ea2), On("RGBAImage", Fa2);
        class $a2 extends mi {
          createBucket(t3) {
            return new za2(t3);
          }
          constructor(t3) {
            super(t3, Ba2), this._updateColorRamp();
          }
          _handleSpecialPaintPropertyUpdate(t3) {
            "heatmap-color" === t3 && this._updateColorRamp();
          }
          _updateColorRamp() {
            this.colorRamp = Ta2({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
          }
          resize() {
            this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            return false;
          }
          hasOffscreenPass() {
            return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
          }
        }
        let Da2;
        var La = { get paint() {
          return Da2 = Da2 || new di({ "hillshade-illumination-direction": new ui(G2.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new ui(G2.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new ui(G2.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new ui(G2.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new ui(G2.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new ui(G2.paint_hillshade["hillshade-accent-color"]) });
        } };
        class Oa2 extends mi {
          constructor(t3) {
            super(t3, La);
          }
          hasOffscreenPass() {
            return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
          }
        }
        const Ra2 = bi([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Ua2 } = Ra2;
        var ja = { exports: {} };
        function qa2(t3, e4, r5) {
          r5 = r5 || 2;
          var n3, i4, s4, a3, o3, l4, u3, c3 = e4 && e4.length, h2 = c3 ? e4[0] * r5 : t3.length, p4 = Na2(t3, 0, h2, r5, true), f2 = [];
          if (!p4 || p4.next === p4.prev)
            return f2;
          if (c3 && (p4 = function(t4, e5, r6, n4) {
            var i5, s5, a4, o4 = [];
            for (i5 = 0, s5 = e5.length; i5 < s5; i5++)
              (a4 = Na2(t4, e5[i5] * n4, i5 < s5 - 1 ? e5[i5 + 1] * n4 : t4.length, n4, false)) === a4.next && (a4.steiner = true), o4.push(eo(a4));
            for (o4.sort(Ya2), i5 = 0; i5 < o4.length; i5++)
              r6 = Wa2(o4[i5], r6);
            return r6;
          }(t3, e4, p4, r5)), t3.length > 80 * r5) {
            n3 = s4 = t3[0], i4 = a3 = t3[1];
            for (var d2 = r5; d2 < h2; d2 += r5)
              (o3 = t3[d2]) < n3 && (n3 = o3), (l4 = t3[d2 + 1]) < i4 && (i4 = l4), o3 > s4 && (s4 = o3), l4 > a3 && (a3 = l4);
            u3 = 0 !== (u3 = Math.max(s4 - n3, a3 - i4)) ? 32767 / u3 : 0;
          }
          return Ka(p4, f2, r5, n3, i4, u3, 0), f2;
        }
        function Na2(t3, e4, r5, n3, i4) {
          var s4, a3;
          if (i4 === yo(t3, e4, r5, n3) > 0)
            for (s4 = e4; s4 < r5; s4 += n3)
              a3 = ho(s4, t3[s4], t3[s4 + 1], a3);
          else
            for (s4 = r5 - n3; s4 >= e4; s4 -= n3)
              a3 = ho(s4, t3[s4], t3[s4 + 1], a3);
          return a3 && so(a3, a3.next) && (po(a3), a3 = a3.next), a3;
        }
        function Za2(t3, e4) {
          if (!t3)
            return t3;
          e4 || (e4 = t3);
          var r5, n3 = t3;
          do {
            if (r5 = false, n3.steiner || !so(n3, n3.next) && 0 !== io(n3.prev, n3, n3.next))
              n3 = n3.next;
            else {
              if (po(n3), (n3 = e4 = n3.prev) === n3.next)
                break;
              r5 = true;
            }
          } while (r5 || n3 !== e4);
          return e4;
        }
        function Ka(t3, e4, r5, n3, i4, s4, a3) {
          if (t3) {
            !a3 && s4 && function(t4, e5, r6, n4) {
              var i5 = t4;
              do {
                0 === i5.z && (i5.z = to(i5.x, i5.y, e5, r6, n4)), i5.prevZ = i5.prev, i5.nextZ = i5.next, i5 = i5.next;
              } while (i5 !== t4);
              i5.prevZ.nextZ = null, i5.prevZ = null, function(t5) {
                var e6, r7, n5, i6, s5, a4, o4, l5, u4 = 1;
                do {
                  for (r7 = t5, t5 = null, s5 = null, a4 = 0; r7; ) {
                    for (a4++, n5 = r7, o4 = 0, e6 = 0; e6 < u4 && (o4++, n5 = n5.nextZ); e6++)
                      ;
                    for (l5 = u4; o4 > 0 || l5 > 0 && n5; )
                      0 !== o4 && (0 === l5 || !n5 || r7.z <= n5.z) ? (i6 = r7, r7 = r7.nextZ, o4--) : (i6 = n5, n5 = n5.nextZ, l5--), s5 ? s5.nextZ = i6 : t5 = i6, i6.prevZ = s5, s5 = i6;
                    r7 = n5;
                  }
                  s5.nextZ = null, u4 *= 2;
                } while (a4 > 1);
              }(i5);
            }(t3, n3, i4, s4);
            for (var o3, l4, u3 = t3; t3.prev !== t3.next; )
              if (o3 = t3.prev, l4 = t3.next, s4 ? Ja2(t3, n3, i4, s4) : Ga2(t3))
                e4.push(o3.i / r5 | 0), e4.push(t3.i / r5 | 0), e4.push(l4.i / r5 | 0), po(t3), t3 = l4.next, u3 = l4.next;
              else if ((t3 = l4) === u3) {
                a3 ? 1 === a3 ? Ka(t3 = Xa(Za2(t3), e4, r5), e4, r5, n3, i4, s4, 2) : 2 === a3 && Ha2(t3, e4, r5, n3, i4, s4) : Ka(Za2(t3), e4, r5, n3, i4, s4, 1);
                break;
              }
          }
        }
        function Ga2(t3) {
          var e4 = t3.prev, r5 = t3, n3 = t3.next;
          if (io(e4, r5, n3) >= 0)
            return false;
          for (var i4 = e4.x, s4 = r5.x, a3 = n3.x, o3 = e4.y, l4 = r5.y, u3 = n3.y, c3 = i4 < s4 ? i4 < a3 ? i4 : a3 : s4 < a3 ? s4 : a3, h2 = o3 < l4 ? o3 < u3 ? o3 : u3 : l4 < u3 ? l4 : u3, p4 = i4 > s4 ? i4 > a3 ? i4 : a3 : s4 > a3 ? s4 : a3, f2 = o3 > l4 ? o3 > u3 ? o3 : u3 : l4 > u3 ? l4 : u3, d2 = n3.next; d2 !== e4; ) {
            if (d2.x >= c3 && d2.x <= p4 && d2.y >= h2 && d2.y <= f2 && ro(i4, o3, s4, l4, a3, u3, d2.x, d2.y) && io(d2.prev, d2, d2.next) >= 0)
              return false;
            d2 = d2.next;
          }
          return true;
        }
        function Ja2(t3, e4, r5, n3) {
          var i4 = t3.prev, s4 = t3, a3 = t3.next;
          if (io(i4, s4, a3) >= 0)
            return false;
          for (var o3 = i4.x, l4 = s4.x, u3 = a3.x, c3 = i4.y, h2 = s4.y, p4 = a3.y, f2 = o3 < l4 ? o3 < u3 ? o3 : u3 : l4 < u3 ? l4 : u3, d2 = c3 < h2 ? c3 < p4 ? c3 : p4 : h2 < p4 ? h2 : p4, y4 = o3 > l4 ? o3 > u3 ? o3 : u3 : l4 > u3 ? l4 : u3, m2 = c3 > h2 ? c3 > p4 ? c3 : p4 : h2 > p4 ? h2 : p4, g3 = to(f2, d2, e4, r5, n3), x5 = to(y4, m2, e4, r5, n3), v4 = t3.prevZ, b3 = t3.nextZ; v4 && v4.z >= g3 && b3 && b3.z <= x5; ) {
            if (v4.x >= f2 && v4.x <= y4 && v4.y >= d2 && v4.y <= m2 && v4 !== i4 && v4 !== a3 && ro(o3, c3, l4, h2, u3, p4, v4.x, v4.y) && io(v4.prev, v4, v4.next) >= 0)
              return false;
            if (v4 = v4.prevZ, b3.x >= f2 && b3.x <= y4 && b3.y >= d2 && b3.y <= m2 && b3 !== i4 && b3 !== a3 && ro(o3, c3, l4, h2, u3, p4, b3.x, b3.y) && io(b3.prev, b3, b3.next) >= 0)
              return false;
            b3 = b3.nextZ;
          }
          for (; v4 && v4.z >= g3; ) {
            if (v4.x >= f2 && v4.x <= y4 && v4.y >= d2 && v4.y <= m2 && v4 !== i4 && v4 !== a3 && ro(o3, c3, l4, h2, u3, p4, v4.x, v4.y) && io(v4.prev, v4, v4.next) >= 0)
              return false;
            v4 = v4.prevZ;
          }
          for (; b3 && b3.z <= x5; ) {
            if (b3.x >= f2 && b3.x <= y4 && b3.y >= d2 && b3.y <= m2 && b3 !== i4 && b3 !== a3 && ro(o3, c3, l4, h2, u3, p4, b3.x, b3.y) && io(b3.prev, b3, b3.next) >= 0)
              return false;
            b3 = b3.nextZ;
          }
          return true;
        }
        function Xa(t3, e4, r5) {
          var n3 = t3;
          do {
            var i4 = n3.prev, s4 = n3.next.next;
            !so(i4, s4) && ao(i4, n3, n3.next, s4) && uo(i4, s4) && uo(s4, i4) && (e4.push(i4.i / r5 | 0), e4.push(n3.i / r5 | 0), e4.push(s4.i / r5 | 0), po(n3), po(n3.next), n3 = t3 = s4), n3 = n3.next;
          } while (n3 !== t3);
          return Za2(n3);
        }
        function Ha2(t3, e4, r5, n3, i4, s4) {
          var a3 = t3;
          do {
            for (var o3 = a3.next.next; o3 !== a3.prev; ) {
              if (a3.i !== o3.i && no(a3, o3)) {
                var l4 = co(a3, o3);
                return a3 = Za2(a3, a3.next), l4 = Za2(l4, l4.next), Ka(a3, e4, r5, n3, i4, s4, 0), void Ka(l4, e4, r5, n3, i4, s4, 0);
              }
              o3 = o3.next;
            }
            a3 = a3.next;
          } while (a3 !== t3);
        }
        function Ya2(t3, e4) {
          return t3.x - e4.x;
        }
        function Wa2(t3, e4) {
          var r5 = function(t4, e5) {
            var r6, n4 = e5, i4 = t4.x, s4 = t4.y, a3 = -1 / 0;
            do {
              if (s4 <= n4.y && s4 >= n4.next.y && n4.next.y !== n4.y) {
                var o3 = n4.x + (s4 - n4.y) * (n4.next.x - n4.x) / (n4.next.y - n4.y);
                if (o3 <= i4 && o3 > a3 && (a3 = o3, r6 = n4.x < n4.next.x ? n4 : n4.next, o3 === i4))
                  return r6;
              }
              n4 = n4.next;
            } while (n4 !== e5);
            if (!r6)
              return null;
            var l4, u3 = r6, c3 = r6.x, h2 = r6.y, p4 = 1 / 0;
            n4 = r6;
            do {
              i4 >= n4.x && n4.x >= c3 && i4 !== n4.x && ro(s4 < h2 ? i4 : a3, s4, c3, h2, s4 < h2 ? a3 : i4, s4, n4.x, n4.y) && (l4 = Math.abs(s4 - n4.y) / (i4 - n4.x), uo(n4, t4) && (l4 < p4 || l4 === p4 && (n4.x > r6.x || n4.x === r6.x && Qa2(r6, n4))) && (r6 = n4, p4 = l4)), n4 = n4.next;
            } while (n4 !== u3);
            return r6;
          }(t3, e4);
          if (!r5)
            return e4;
          var n3 = co(r5, t3);
          return Za2(n3, n3.next), Za2(r5, r5.next);
        }
        function Qa2(t3, e4) {
          return io(t3.prev, t3, e4.prev) < 0 && io(e4.next, t3, t3.next) < 0;
        }
        function to(t3, e4, r5, n3, i4) {
          return (t3 = 1431655765 & ((t3 = 858993459 & ((t3 = 252645135 & ((t3 = 16711935 & ((t3 = (t3 - r5) * i4 | 0) | t3 << 8)) | t3 << 4)) | t3 << 2)) | t3 << 1)) | (e4 = 1431655765 & ((e4 = 858993459 & ((e4 = 252645135 & ((e4 = 16711935 & ((e4 = (e4 - n3) * i4 | 0) | e4 << 8)) | e4 << 4)) | e4 << 2)) | e4 << 1)) << 1;
        }
        function eo(t3) {
          var e4 = t3, r5 = t3;
          do {
            (e4.x < r5.x || e4.x === r5.x && e4.y < r5.y) && (r5 = e4), e4 = e4.next;
          } while (e4 !== t3);
          return r5;
        }
        function ro(t3, e4, r5, n3, i4, s4, a3, o3) {
          return (i4 - a3) * (e4 - o3) >= (t3 - a3) * (s4 - o3) && (t3 - a3) * (n3 - o3) >= (r5 - a3) * (e4 - o3) && (r5 - a3) * (s4 - o3) >= (i4 - a3) * (n3 - o3);
        }
        function no(t3, e4) {
          return t3.next.i !== e4.i && t3.prev.i !== e4.i && !function(t4, e5) {
            var r5 = t4;
            do {
              if (r5.i !== t4.i && r5.next.i !== t4.i && r5.i !== e5.i && r5.next.i !== e5.i && ao(r5, r5.next, t4, e5))
                return true;
              r5 = r5.next;
            } while (r5 !== t4);
            return false;
          }(t3, e4) && (uo(t3, e4) && uo(e4, t3) && function(t4, e5) {
            var r5 = t4, n3 = false, i4 = (t4.x + e5.x) / 2, s4 = (t4.y + e5.y) / 2;
            do {
              r5.y > s4 != r5.next.y > s4 && r5.next.y !== r5.y && i4 < (r5.next.x - r5.x) * (s4 - r5.y) / (r5.next.y - r5.y) + r5.x && (n3 = !n3), r5 = r5.next;
            } while (r5 !== t4);
            return n3;
          }(t3, e4) && (io(t3.prev, t3, e4.prev) || io(t3, e4.prev, e4)) || so(t3, e4) && io(t3.prev, t3, t3.next) > 0 && io(e4.prev, e4, e4.next) > 0);
        }
        function io(t3, e4, r5) {
          return (e4.y - t3.y) * (r5.x - e4.x) - (e4.x - t3.x) * (r5.y - e4.y);
        }
        function so(t3, e4) {
          return t3.x === e4.x && t3.y === e4.y;
        }
        function ao(t3, e4, r5, n3) {
          var i4 = lo(io(t3, e4, r5)), s4 = lo(io(t3, e4, n3)), a3 = lo(io(r5, n3, t3)), o3 = lo(io(r5, n3, e4));
          return i4 !== s4 && a3 !== o3 || !(0 !== i4 || !oo(t3, r5, e4)) || !(0 !== s4 || !oo(t3, n3, e4)) || !(0 !== a3 || !oo(r5, t3, n3)) || !(0 !== o3 || !oo(r5, e4, n3));
        }
        function oo(t3, e4, r5) {
          return e4.x <= Math.max(t3.x, r5.x) && e4.x >= Math.min(t3.x, r5.x) && e4.y <= Math.max(t3.y, r5.y) && e4.y >= Math.min(t3.y, r5.y);
        }
        function lo(t3) {
          return t3 > 0 ? 1 : t3 < 0 ? -1 : 0;
        }
        function uo(t3, e4) {
          return io(t3.prev, t3, t3.next) < 0 ? io(t3, e4, t3.next) >= 0 && io(t3, t3.prev, e4) >= 0 : io(t3, e4, t3.prev) < 0 || io(t3, t3.next, e4) < 0;
        }
        function co(t3, e4) {
          var r5 = new fo(t3.i, t3.x, t3.y), n3 = new fo(e4.i, e4.x, e4.y), i4 = t3.next, s4 = e4.prev;
          return t3.next = e4, e4.prev = t3, r5.next = i4, i4.prev = r5, n3.next = r5, r5.prev = n3, s4.next = n3, n3.prev = s4, n3;
        }
        function ho(t3, e4, r5, n3) {
          var i4 = new fo(t3, e4, r5);
          return n3 ? (i4.next = n3.next, i4.prev = n3, n3.next.prev = i4, n3.next = i4) : (i4.prev = i4, i4.next = i4), i4;
        }
        function po(t3) {
          t3.next.prev = t3.prev, t3.prev.next = t3.next, t3.prevZ && (t3.prevZ.nextZ = t3.nextZ), t3.nextZ && (t3.nextZ.prevZ = t3.prevZ);
        }
        function fo(t3, e4, r5) {
          this.i = t3, this.x = e4, this.y = r5, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
        }
        function yo(t3, e4, r5, n3) {
          for (var i4 = 0, s4 = e4, a3 = r5 - n3; s4 < r5; s4 += n3)
            i4 += (t3[a3] - t3[s4]) * (t3[s4 + 1] + t3[a3 + 1]), a3 = s4;
          return i4;
        }
        ja.exports = qa2, ja.exports.default = qa2, qa2.deviation = function(t3, e4, r5, n3) {
          var i4 = e4 && e4.length, s4 = Math.abs(yo(t3, 0, i4 ? e4[0] * r5 : t3.length, r5));
          if (i4)
            for (var a3 = 0, o3 = e4.length; a3 < o3; a3++)
              s4 -= Math.abs(yo(t3, e4[a3] * r5, a3 < o3 - 1 ? e4[a3 + 1] * r5 : t3.length, r5));
          var l4 = 0;
          for (a3 = 0; a3 < n3.length; a3 += 3) {
            var u3 = n3[a3] * r5, c3 = n3[a3 + 1] * r5, h2 = n3[a3 + 2] * r5;
            l4 += Math.abs((t3[u3] - t3[h2]) * (t3[c3 + 1] - t3[u3 + 1]) - (t3[u3] - t3[c3]) * (t3[h2 + 1] - t3[u3 + 1]));
          }
          return 0 === s4 && 0 === l4 ? 0 : Math.abs((l4 - s4) / s4);
        }, qa2.flatten = function(t3) {
          for (var e4 = t3[0][0].length, r5 = { vertices: [], holes: [], dimensions: e4 }, n3 = 0, i4 = 0; i4 < t3.length; i4++) {
            for (var s4 = 0; s4 < t3[i4].length; s4++)
              for (var a3 = 0; a3 < e4; a3++)
                r5.vertices.push(t3[i4][s4][a3]);
            i4 > 0 && r5.holes.push(n3 += t3[i4 - 1].length);
          }
          return r5;
        };
        var mo = r4(ja.exports);
        function go(t3, e4, r5, n3, i4) {
          xo(t3, e4, r5 || 0, n3 || t3.length - 1, i4 || bo);
        }
        function xo(t3, e4, r5, n3, i4) {
          for (; n3 > r5; ) {
            if (n3 - r5 > 600) {
              var s4 = n3 - r5 + 1, a3 = e4 - r5 + 1, o3 = Math.log(s4), l4 = 0.5 * Math.exp(2 * o3 / 3), u3 = 0.5 * Math.sqrt(o3 * l4 * (s4 - l4) / s4) * (a3 - s4 / 2 < 0 ? -1 : 1);
              xo(t3, e4, Math.max(r5, Math.floor(e4 - a3 * l4 / s4 + u3)), Math.min(n3, Math.floor(e4 + (s4 - a3) * l4 / s4 + u3)), i4);
            }
            var c3 = t3[e4], h2 = r5, p4 = n3;
            for (vo(t3, r5, e4), i4(t3[n3], c3) > 0 && vo(t3, r5, n3); h2 < p4; ) {
              for (vo(t3, h2, p4), h2++, p4--; i4(t3[h2], c3) < 0; )
                h2++;
              for (; i4(t3[p4], c3) > 0; )
                p4--;
            }
            0 === i4(t3[r5], c3) ? vo(t3, r5, p4) : vo(t3, ++p4, n3), p4 <= e4 && (r5 = p4 + 1), e4 <= p4 && (n3 = p4 - 1);
          }
        }
        function vo(t3, e4, r5) {
          var n3 = t3[e4];
          t3[e4] = t3[r5], t3[r5] = n3;
        }
        function bo(t3, e4) {
          return t3 < e4 ? -1 : t3 > e4 ? 1 : 0;
        }
        function wo(t3, e4) {
          const r5 = t3.length;
          if (r5 <= 1)
            return [t3];
          const n3 = [];
          let i4, s4;
          for (let e5 = 0; e5 < r5; e5++) {
            const r6 = k2(t3[e5]);
            0 !== r6 && (t3[e5].area = Math.abs(r6), void 0 === s4 && (s4 = r6 < 0), s4 === r6 < 0 ? (i4 && n3.push(i4), i4 = [t3[e5]]) : i4.push(t3[e5]));
          }
          if (i4 && n3.push(i4), e4 > 1)
            for (let t4 = 0; t4 < n3.length; t4++)
              n3[t4].length <= e4 || (go(n3[t4], e4, 1, n3[t4].length - 1, _o), n3[t4] = n3[t4].slice(0, e4));
          return n3;
        }
        function _o(t3, e4) {
          return e4.area - t3.area;
        }
        function Ao(t3, e4, r5) {
          const n3 = r5.patternDependencies;
          let i4 = false;
          for (const r6 of e4) {
            const e5 = r6.paint.get(`${t3}-pattern`);
            e5.isConstant() || (i4 = true);
            const s4 = e5.constantOr(null);
            s4 && (i4 = true, n3[s4.to] = true, n3[s4.from] = true);
          }
          return i4;
        }
        function So(t3, e4, r5, n3, i4) {
          const s4 = i4.patternDependencies;
          for (const a3 of e4) {
            const e5 = a3.paint.get(`${t3}-pattern`).value;
            if ("constant" !== e5.kind) {
              let t4 = e5.evaluate({ zoom: n3 - 1 }, r5, {}, i4.availableImages), o3 = e5.evaluate({ zoom: n3 }, r5, {}, i4.availableImages), l4 = e5.evaluate({ zoom: n3 + 1 }, r5, {}, i4.availableImages);
              t4 = t4 && t4.name ? t4.name : t4, o3 = o3 && o3.name ? o3.name : o3, l4 = l4 && l4.name ? l4.name : l4, s4[t4] = true, s4[o3] = true, s4[l4] = true, r5.patterns[a3.id] = { min: t4, mid: o3, max: l4 };
            }
          }
          return r5;
        }
        class ko {
          constructor(t3) {
            this.zoom = t3.zoom, this.overscaling = t3.overscaling, this.layers = t3.layers, this.layerIds = this.layers.map((t4) => t4.id), this.index = t3.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new ss(), this.indexArray = new ys(), this.indexArray2 = new ms(), this.programConfigurations = new Zs(t3.layers, t3.zoom), this.segments = new vs(), this.segments2 = new vs(), this.stateDependentLayerIds = this.layers.filter((t4) => t4.isStateDependent()).map((t4) => t4.id);
          }
          populate(t3, e4, r5) {
            this.hasPattern = Ao("fill", this.layers, e4);
            const n3 = this.layers[0].layout.get("fill-sort-key"), i4 = !n3.isConstant(), s4 = [];
            for (const { feature: a3, id: o3, index: l4, sourceLayerIndex: u3 } of t3) {
              const t4 = this.layers[0]._featureFilter.needGeometry, c3 = Ws(a3, t4);
              if (!this.layers[0]._featureFilter.filter(new ti(this.zoom), c3, r5))
                continue;
              const h2 = i4 ? n3.evaluate(c3, {}, r5, e4.availableImages) : void 0, p4 = { id: o3, properties: a3.properties, type: a3.type, sourceLayerIndex: u3, index: l4, geometry: t4 ? c3.geometry : Ys(a3), patterns: {}, sortKey: h2 };
              s4.push(p4);
            }
            i4 && s4.sort((t4, e5) => t4.sortKey - e5.sortKey);
            for (const n4 of s4) {
              const { geometry: i5, index: s5, sourceLayerIndex: a3 } = n4;
              if (this.hasPattern) {
                const t4 = So("fill", this.layers, n4, this.zoom, e4);
                this.patternFeatures.push(t4);
              } else
                this.addFeature(n4, i5, s5, r5, {});
              e4.featureIndex.insert(t3[s5].feature, i5, s5, a3, this.index);
            }
          }
          update(t3, e4, r5) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t3, e4, this.stateDependentLayers, r5);
          }
          addFeatures(t3, e4, r5) {
            for (const t4 of this.patternFeatures)
              this.addFeature(t4, t4.geometry, t4.index, e4, r5);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t3) {
            this.uploaded || (this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, Ua2), this.indexBuffer = t3.createIndexBuffer(this.indexArray), this.indexBuffer2 = t3.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t3), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
          }
          addFeature(t3, e4, r5, n3, i4) {
            for (const t4 of wo(e4, 500)) {
              let e5 = 0;
              for (const r7 of t4)
                e5 += r7.length;
              const r6 = this.segments.prepareSegment(e5, this.layoutVertexArray, this.indexArray), n4 = r6.vertexLength, i5 = [], s4 = [];
              for (const e6 of t4) {
                if (0 === e6.length)
                  continue;
                e6 !== t4[0] && s4.push(i5.length / 2);
                const r7 = this.segments2.prepareSegment(e6.length, this.layoutVertexArray, this.indexArray2), n5 = r7.vertexLength;
                this.layoutVertexArray.emplaceBack(e6[0].x, e6[0].y), this.indexArray2.emplaceBack(n5 + e6.length - 1, n5), i5.push(e6[0].x), i5.push(e6[0].y);
                for (let t5 = 1; t5 < e6.length; t5++)
                  this.layoutVertexArray.emplaceBack(e6[t5].x, e6[t5].y), this.indexArray2.emplaceBack(n5 + t5 - 1, n5 + t5), i5.push(e6[t5].x), i5.push(e6[t5].y);
                r7.vertexLength += e6.length, r7.primitiveLength += e6.length;
              }
              const a3 = mo(i5, s4);
              for (let t5 = 0; t5 < a3.length; t5 += 3)
                this.indexArray.emplaceBack(n4 + a3[t5], n4 + a3[t5 + 1], n4 + a3[t5 + 2]);
              r6.vertexLength += e5, r6.primitiveLength += a3.length / 3;
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t3, r5, i4, n3);
          }
        }
        let Io, zo;
        On("FillBucket", ko, { omit: ["layers", "patternFeatures"] });
        var Mo = { get paint() {
          return zo = zo || new di({ "fill-antialias": new ui(G2.paint_fill["fill-antialias"]), "fill-opacity": new ci(G2.paint_fill["fill-opacity"]), "fill-color": new ci(G2.paint_fill["fill-color"]), "fill-outline-color": new ci(G2.paint_fill["fill-outline-color"]), "fill-translate": new ui(G2.paint_fill["fill-translate"]), "fill-translate-anchor": new ui(G2.paint_fill["fill-translate-anchor"]), "fill-pattern": new hi(G2.paint_fill["fill-pattern"]) });
        }, get layout() {
          return Io = Io || new di({ "fill-sort-key": new ci(G2.layout_fill["fill-sort-key"]) });
        } };
        class Bo extends mi {
          constructor(t3) {
            super(t3, Mo);
          }
          recalculate(t3, e4) {
            super.recalculate(t3, e4);
            const r5 = this.paint._values["fill-outline-color"];
            "constant" === r5.value.kind && void 0 === r5.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
          }
          createBucket(t3) {
            return new ko(t3);
          }
          queryRadius() {
            return fa2(this.paint.get("fill-translate"));
          }
          queryIntersectsFeature(t3, e4, r5, n3, i4, s4, a3) {
            return na2(da2(t3, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), s4.angle, a3), n3);
          }
          isTileClipped() {
            return true;
          }
        }
        const Co = bi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), Po = bi([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: Vo } = Co;
        var Eo = {}, Fo = n2, To = $o;
        function $o(t3, e4, r5, n3, i4) {
          this.properties = {}, this.extent = r5, this.type = 0, this._pbf = t3, this._geometry = -1, this._keys = n3, this._values = i4, t3.readFields(Do, this, e4);
        }
        function Do(t3, e4, r5) {
          1 == t3 ? e4.id = r5.readVarint() : 2 == t3 ? function(t4, e5) {
            for (var r6 = t4.readVarint() + t4.pos; t4.pos < r6; ) {
              var n3 = e5._keys[t4.readVarint()], i4 = e5._values[t4.readVarint()];
              e5.properties[n3] = i4;
            }
          }(r5, e4) : 3 == t3 ? e4.type = r5.readVarint() : 4 == t3 && (e4._geometry = r5.pos);
        }
        function Lo(t3) {
          for (var e4, r5, n3 = 0, i4 = 0, s4 = t3.length, a3 = s4 - 1; i4 < s4; a3 = i4++)
            n3 += ((r5 = t3[a3]).x - (e4 = t3[i4]).x) * (e4.y + r5.y);
          return n3;
        }
        $o.types = ["Unknown", "Point", "LineString", "Polygon"], $o.prototype.loadGeometry = function() {
          var t3 = this._pbf;
          t3.pos = this._geometry;
          for (var e4, r5 = t3.readVarint() + t3.pos, n3 = 1, i4 = 0, s4 = 0, a3 = 0, o3 = []; t3.pos < r5; ) {
            if (i4 <= 0) {
              var l4 = t3.readVarint();
              n3 = 7 & l4, i4 = l4 >> 3;
            }
            if (i4--, 1 === n3 || 2 === n3)
              s4 += t3.readSVarint(), a3 += t3.readSVarint(), 1 === n3 && (e4 && o3.push(e4), e4 = []), e4.push(new Fo(s4, a3));
            else {
              if (7 !== n3)
                throw new Error("unknown command " + n3);
              e4 && e4.push(e4[0].clone());
            }
          }
          return e4 && o3.push(e4), o3;
        }, $o.prototype.bbox = function() {
          var t3 = this._pbf;
          t3.pos = this._geometry;
          for (var e4 = t3.readVarint() + t3.pos, r5 = 1, n3 = 0, i4 = 0, s4 = 0, a3 = 1 / 0, o3 = -1 / 0, l4 = 1 / 0, u3 = -1 / 0; t3.pos < e4; ) {
            if (n3 <= 0) {
              var c3 = t3.readVarint();
              r5 = 7 & c3, n3 = c3 >> 3;
            }
            if (n3--, 1 === r5 || 2 === r5)
              (i4 += t3.readSVarint()) < a3 && (a3 = i4), i4 > o3 && (o3 = i4), (s4 += t3.readSVarint()) < l4 && (l4 = s4), s4 > u3 && (u3 = s4);
            else if (7 !== r5)
              throw new Error("unknown command " + r5);
          }
          return [a3, l4, o3, u3];
        }, $o.prototype.toGeoJSON = function(t3, e4, r5) {
          var n3, i4, s4 = this.extent * Math.pow(2, r5), a3 = this.extent * t3, o3 = this.extent * e4, l4 = this.loadGeometry(), u3 = $o.types[this.type];
          function c3(t4) {
            for (var e5 = 0; e5 < t4.length; e5++) {
              var r6 = t4[e5];
              t4[e5] = [360 * (r6.x + a3) / s4 - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r6.y + o3) / s4) * Math.PI / 180)) - 90];
            }
          }
          switch (this.type) {
            case 1:
              var h2 = [];
              for (n3 = 0; n3 < l4.length; n3++)
                h2[n3] = l4[n3][0];
              c3(l4 = h2);
              break;
            case 2:
              for (n3 = 0; n3 < l4.length; n3++)
                c3(l4[n3]);
              break;
            case 3:
              for (l4 = function(t4) {
                var e5 = t4.length;
                if (e5 <= 1)
                  return [t4];
                for (var r6, n4, i5 = [], s5 = 0; s5 < e5; s5++) {
                  var a4 = Lo(t4[s5]);
                  0 !== a4 && (void 0 === n4 && (n4 = a4 < 0), n4 === a4 < 0 ? (r6 && i5.push(r6), r6 = [t4[s5]]) : r6.push(t4[s5]));
                }
                return r6 && i5.push(r6), i5;
              }(l4), n3 = 0; n3 < l4.length; n3++)
                for (i4 = 0; i4 < l4[n3].length; i4++)
                  c3(l4[n3][i4]);
          }
          1 === l4.length ? l4 = l4[0] : u3 = "Multi" + u3;
          var p4 = { type: "Feature", geometry: { type: u3, coordinates: l4 }, properties: this.properties };
          return "id" in this && (p4.id = this.id), p4;
        };
        var Oo = To, Ro = Uo;
        function Uo(t3, e4) {
          this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t3, this._keys = [], this._values = [], this._features = [], t3.readFields(jo, this, e4), this.length = this._features.length;
        }
        function jo(t3, e4, r5) {
          15 === t3 ? e4.version = r5.readVarint() : 1 === t3 ? e4.name = r5.readString() : 5 === t3 ? e4.extent = r5.readVarint() : 2 === t3 ? e4._features.push(r5.pos) : 3 === t3 ? e4._keys.push(r5.readString()) : 4 === t3 && e4._values.push(function(t4) {
            for (var e5 = null, r6 = t4.readVarint() + t4.pos; t4.pos < r6; ) {
              var n3 = t4.readVarint() >> 3;
              e5 = 1 === n3 ? t4.readString() : 2 === n3 ? t4.readFloat() : 3 === n3 ? t4.readDouble() : 4 === n3 ? t4.readVarint64() : 5 === n3 ? t4.readVarint() : 6 === n3 ? t4.readSVarint() : 7 === n3 ? t4.readBoolean() : null;
            }
            return e5;
          }(r5));
        }
        Uo.prototype.feature = function(t3) {
          if (t3 < 0 || t3 >= this._features.length)
            throw new Error("feature index out of bounds");
          this._pbf.pos = this._features[t3];
          var e4 = this._pbf.readVarint() + this._pbf.pos;
          return new Oo(this._pbf, e4, this.extent, this._keys, this._values);
        };
        var qo = Ro;
        function No(t3, e4, r5) {
          if (3 === t3) {
            var n3 = new qo(r5, r5.readVarint() + r5.pos);
            n3.length && (e4[n3.name] = n3);
          }
        }
        Eo.VectorTile = function(t3, e4) {
          this.layers = t3.readFields(No, {}, e4);
        }, Eo.VectorTileFeature = To, Eo.VectorTileLayer = Ro;
        const Zo = Eo.VectorTileFeature.types, Ko = Math.pow(2, 13);
        function Go(t3, e4, r5, n3, i4, s4, a3, o3) {
          t3.emplaceBack(e4, r5, 2 * Math.floor(n3 * Ko) + a3, i4 * Ko * 2, s4 * Ko * 2, Math.round(o3));
        }
        class Jo {
          constructor(t3) {
            this.zoom = t3.zoom, this.overscaling = t3.overscaling, this.layers = t3.layers, this.layerIds = this.layers.map((t4) => t4.id), this.index = t3.index, this.hasPattern = false, this.layoutVertexArray = new as(), this.centroidVertexArray = new ns(), this.indexArray = new ys(), this.programConfigurations = new Zs(t3.layers, t3.zoom), this.segments = new vs(), this.stateDependentLayerIds = this.layers.filter((t4) => t4.isStateDependent()).map((t4) => t4.id);
          }
          populate(t3, e4, r5) {
            this.features = [], this.hasPattern = Ao("fill-extrusion", this.layers, e4);
            for (const { feature: n3, id: i4, index: s4, sourceLayerIndex: a3 } of t3) {
              const t4 = this.layers[0]._featureFilter.needGeometry, o3 = Ws(n3, t4);
              if (!this.layers[0]._featureFilter.filter(new ti(this.zoom), o3, r5))
                continue;
              const l4 = { id: i4, sourceLayerIndex: a3, index: s4, geometry: t4 ? o3.geometry : Ys(n3), properties: n3.properties, type: n3.type, patterns: {} };
              this.hasPattern ? this.features.push(So("fill-extrusion", this.layers, l4, this.zoom, e4)) : this.addFeature(l4, l4.geometry, s4, r5, {}), e4.featureIndex.insert(n3, l4.geometry, s4, a3, this.index, true);
            }
          }
          addFeatures(t3, e4, r5) {
            for (const t4 of this.features) {
              const { geometry: n3 } = t4;
              this.addFeature(t4, n3, t4.index, e4, r5);
            }
          }
          update(t3, e4, r5) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t3, e4, this.stateDependentLayers, r5);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length && 0 === this.centroidVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t3) {
            this.uploaded || (this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, Vo), this.centroidVertexBuffer = t3.createVertexBuffer(this.centroidVertexArray, Po.members, true), this.indexBuffer = t3.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t3), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
          }
          addFeature(t3, e4, r5, n3, i4) {
            const s4 = { x: 0, y: 0, vertexCount: 0 };
            for (const r6 of wo(e4, 500)) {
              let e5 = 0;
              for (const t4 of r6)
                e5 += t4.length;
              let n4 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);
              for (const t4 of r6) {
                if (0 === t4.length)
                  continue;
                if (Ho(t4))
                  continue;
                let e6 = 0;
                for (let r7 = 0; r7 < t4.length; r7++) {
                  const i6 = t4[r7];
                  if (r7 >= 1) {
                    const a4 = t4[r7 - 1];
                    if (!Xo(i6, a4)) {
                      n4.vertexLength + 4 > vs.MAX_VERTEX_ARRAY_LENGTH && (n4 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                      const t5 = i6.sub(a4)._perp()._unit(), r8 = a4.dist(i6);
                      e6 + r8 > 32768 && (e6 = 0), Go(this.layoutVertexArray, i6.x, i6.y, t5.x, t5.y, 0, 0, e6), Go(this.layoutVertexArray, i6.x, i6.y, t5.x, t5.y, 0, 1, e6), s4.x += 2 * i6.x, s4.y += 2 * i6.y, s4.vertexCount += 2, e6 += r8, Go(this.layoutVertexArray, a4.x, a4.y, t5.x, t5.y, 0, 0, e6), Go(this.layoutVertexArray, a4.x, a4.y, t5.x, t5.y, 0, 1, e6), s4.x += 2 * a4.x, s4.y += 2 * a4.y, s4.vertexCount += 2;
                      const o4 = n4.vertexLength;
                      this.indexArray.emplaceBack(o4, o4 + 2, o4 + 1), this.indexArray.emplaceBack(o4 + 1, o4 + 2, o4 + 3), n4.vertexLength += 4, n4.primitiveLength += 2;
                    }
                  }
                }
              }
              if (n4.vertexLength + e5 > vs.MAX_VERTEX_ARRAY_LENGTH && (n4 = this.segments.prepareSegment(e5, this.layoutVertexArray, this.indexArray)), "Polygon" !== Zo[t3.type])
                continue;
              const i5 = [], a3 = [], o3 = n4.vertexLength;
              for (const t4 of r6)
                if (0 !== t4.length) {
                  t4 !== r6[0] && a3.push(i5.length / 2);
                  for (let e6 = 0; e6 < t4.length; e6++) {
                    const r7 = t4[e6];
                    Go(this.layoutVertexArray, r7.x, r7.y, 0, 0, 1, 1, 0), s4.x += r7.x, s4.y += r7.y, s4.vertexCount += 1, i5.push(r7.x), i5.push(r7.y);
                  }
                }
              const l4 = mo(i5, a3);
              for (let t4 = 0; t4 < l4.length; t4 += 3)
                this.indexArray.emplaceBack(o3 + l4[t4], o3 + l4[t4 + 2], o3 + l4[t4 + 1]);
              n4.primitiveLength += l4.length / 3, n4.vertexLength += e5;
            }
            for (let t4 = 0; t4 < s4.vertexCount; t4++)
              this.centroidVertexArray.emplaceBack(Math.floor(s4.x / s4.vertexCount), Math.floor(s4.y / s4.vertexCount));
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t3, r5, i4, n3);
          }
        }
        function Xo(t3, e4) {
          return t3.x === e4.x && (t3.x < 0 || t3.x > Js) || t3.y === e4.y && (t3.y < 0 || t3.y > Js);
        }
        function Ho(t3) {
          return t3.every((t4) => t4.x < 0) || t3.every((t4) => t4.x > Js) || t3.every((t4) => t4.y < 0) || t3.every((t4) => t4.y > Js);
        }
        let Yo;
        On("FillExtrusionBucket", Jo, { omit: ["layers", "features"] });
        var Wo = { get paint() {
          return Yo = Yo || new di({ "fill-extrusion-opacity": new ui(G2["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new ci(G2["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new ui(G2["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new ui(G2["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new hi(G2["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new ci(G2["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new ci(G2["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new ui(G2["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
        } };
        class Qo extends mi {
          constructor(t3) {
            super(t3, Wo);
          }
          createBucket(t3) {
            return new Jo(t3);
          }
          queryRadius() {
            return fa2(this.paint.get("fill-extrusion-translate"));
          }
          is3D() {
            return true;
          }
          queryIntersectsFeature(t3, e4, r5, n3, i4, a3, o3, l4) {
            const u3 = da2(t3, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), a3.angle, o3), c3 = this.paint.get("fill-extrusion-height").evaluate(e4, r5), h2 = this.paint.get("fill-extrusion-base").evaluate(e4, r5), p4 = function(t4, e5, r6, n4) {
              const i5 = [];
              for (const r7 of t4) {
                const t5 = [r7.x, r7.y, 0, 1];
                Sa2(t5, t5, e5), i5.push(new s3(t5[0] / t5[3], t5[1] / t5[3]));
              }
              return i5;
            }(u3, l4), f2 = function(t4, e5, r6, n4) {
              const i5 = [], a4 = [], o4 = n4[8] * e5, l5 = n4[9] * e5, u4 = n4[10] * e5, c4 = n4[11] * e5, h3 = n4[8] * r6, p5 = n4[9] * r6, f3 = n4[10] * r6, d2 = n4[11] * r6;
              for (const e6 of t4) {
                const t5 = [], r7 = [];
                for (const i6 of e6) {
                  const e7 = i6.x, a5 = i6.y, y4 = n4[0] * e7 + n4[4] * a5 + n4[12], m2 = n4[1] * e7 + n4[5] * a5 + n4[13], g3 = n4[2] * e7 + n4[6] * a5 + n4[14], x5 = n4[3] * e7 + n4[7] * a5 + n4[15], v4 = g3 + u4, b3 = x5 + c4, w4 = y4 + h3, _2 = m2 + p5, A3 = g3 + f3, S4 = x5 + d2, k3 = new s3((y4 + o4) / b3, (m2 + l5) / b3);
                  k3.z = v4 / b3, t5.push(k3);
                  const I3 = new s3(w4 / S4, _2 / S4);
                  I3.z = A3 / S4, r7.push(I3);
                }
                i5.push(t5), a4.push(r7);
              }
              return [i5, a4];
            }(n3, h2, c3, l4);
            return function(t4, e5, r6) {
              let n4 = 1 / 0;
              na2(r6, e5) && (n4 = el(r6, e5[0]));
              for (let i5 = 0; i5 < e5.length; i5++) {
                const s4 = e5[i5], a4 = t4[i5];
                for (let t5 = 0; t5 < s4.length - 1; t5++) {
                  const e6 = s4[t5], i6 = [e6, s4[t5 + 1], a4[t5 + 1], a4[t5], e6];
                  ea2(r6, i6) && (n4 = Math.min(n4, el(r6, i6)));
                }
              }
              return n4 !== 1 / 0 && n4;
            }(f2[0], f2[1], p4);
          }
        }
        function tl(t3, e4) {
          return t3.x * e4.x + t3.y * e4.y;
        }
        function el(t3, e4) {
          if (1 === t3.length) {
            let r5 = 0;
            const n3 = e4[r5++];
            let i4;
            for (; !i4 || n3.equals(i4); )
              if (i4 = e4[r5++], !i4)
                return 1 / 0;
            for (; r5 < e4.length; r5++) {
              const s4 = e4[r5], a3 = t3[0], o3 = i4.sub(n3), l4 = s4.sub(n3), u3 = a3.sub(n3), c3 = tl(o3, o3), h2 = tl(o3, l4), p4 = tl(l4, l4), f2 = tl(u3, o3), d2 = tl(u3, l4), y4 = c3 * p4 - h2 * h2, m2 = (p4 * f2 - h2 * d2) / y4, g3 = (c3 * d2 - h2 * f2) / y4, x5 = n3.z * (1 - m2 - g3) + i4.z * m2 + s4.z * g3;
              if (isFinite(x5))
                return x5;
            }
            return 1 / 0;
          }
          {
            let t4 = 1 / 0;
            for (const r5 of e4)
              t4 = Math.min(t4, r5.z);
            return t4;
          }
        }
        const rl = bi([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: nl } = rl, il = bi([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: sl } = il, al = Eo.VectorTileFeature.types, ol = Math.cos(Math.PI / 180 * 37.5), ll = Math.pow(2, 14) / 0.5;
        class ul {
          constructor(t3) {
            this.zoom = t3.zoom, this.overscaling = t3.overscaling, this.layers = t3.layers, this.layerIds = this.layers.map((t4) => t4.id), this.index = t3.index, this.hasPattern = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t4) => {
              this.gradients[t4.id] = {};
            }), this.layoutVertexArray = new os(), this.layoutVertexArray2 = new ls(), this.indexArray = new ys(), this.programConfigurations = new Zs(t3.layers, t3.zoom), this.segments = new vs(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((t4) => t4.isStateDependent()).map((t4) => t4.id);
          }
          populate(t3, e4, r5) {
            this.hasPattern = Ao("line", this.layers, e4);
            const n3 = this.layers[0].layout.get("line-sort-key"), i4 = !n3.isConstant(), s4 = [];
            for (const { feature: e5, id: a3, index: o3, sourceLayerIndex: l4 } of t3) {
              const t4 = this.layers[0]._featureFilter.needGeometry, u3 = Ws(e5, t4);
              if (!this.layers[0]._featureFilter.filter(new ti(this.zoom), u3, r5))
                continue;
              const c3 = i4 ? n3.evaluate(u3, {}, r5) : void 0, h2 = { id: a3, properties: e5.properties, type: e5.type, sourceLayerIndex: l4, index: o3, geometry: t4 ? u3.geometry : Ys(e5), patterns: {}, sortKey: c3 };
              s4.push(h2);
            }
            i4 && s4.sort((t4, e5) => t4.sortKey - e5.sortKey);
            for (const n4 of s4) {
              const { geometry: i5, index: s5, sourceLayerIndex: a3 } = n4;
              if (this.hasPattern) {
                const t4 = So("line", this.layers, n4, this.zoom, e4);
                this.patternFeatures.push(t4);
              } else
                this.addFeature(n4, i5, s5, r5, {});
              e4.featureIndex.insert(t3[s5].feature, i5, s5, a3, this.index);
            }
          }
          update(t3, e4, r5) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t3, e4, this.stateDependentLayers, r5);
          }
          addFeatures(t3, e4, r5) {
            for (const t4 of this.patternFeatures)
              this.addFeature(t4, t4.geometry, t4.index, e4, r5);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t3) {
            this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t3.createVertexBuffer(this.layoutVertexArray2, sl)), this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, nl), this.indexBuffer = t3.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t3), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          lineFeatureClips(t3) {
            if (t3.properties && Object.prototype.hasOwnProperty.call(t3.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t3.properties, "mapbox_clip_end"))
              return { start: +t3.properties.mapbox_clip_start, end: +t3.properties.mapbox_clip_end };
          }
          addFeature(t3, e4, r5, n3, i4) {
            const s4 = this.layers[0].layout, a3 = s4.get("line-join").evaluate(t3, {}), o3 = s4.get("line-cap"), l4 = s4.get("line-miter-limit"), u3 = s4.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(t3);
            for (const r6 of e4)
              this.addLine(r6, t3, a3, o3, l4, u3);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t3, r5, i4, n3);
          }
          addLine(t3, e4, r5, n3, i4, s4) {
            if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let e5 = 0; e5 < t3.length - 1; e5++)
                this.totalDistance += t3[e5].dist(t3[e5 + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
            }
            const a3 = "Polygon" === al[e4.type];
            let o3 = t3.length;
            for (; o3 >= 2 && t3[o3 - 1].equals(t3[o3 - 2]); )
              o3--;
            let l4 = 0;
            for (; l4 < o3 - 1 && t3[l4].equals(t3[l4 + 1]); )
              l4++;
            if (o3 < (a3 ? 3 : 2))
              return;
            "bevel" === r5 && (i4 = 1.05);
            const u3 = this.overscaling <= 16 ? 15 * Js / (512 * this.overscaling) : 0, c3 = this.segments.prepareSegment(10 * o3, this.layoutVertexArray, this.indexArray);
            let h2, p4, f2, d2, y4;
            this.e1 = this.e2 = -1, a3 && (h2 = t3[o3 - 2], y4 = t3[l4].sub(h2)._unit()._perp());
            for (let e5 = l4; e5 < o3; e5++) {
              if (f2 = e5 === o3 - 1 ? a3 ? t3[l4 + 1] : void 0 : t3[e5 + 1], f2 && t3[e5].equals(f2))
                continue;
              y4 && (d2 = y4), h2 && (p4 = h2), h2 = t3[e5], y4 = f2 ? f2.sub(h2)._unit()._perp() : d2, d2 = d2 || y4;
              let m2 = d2.add(y4);
              0 === m2.x && 0 === m2.y || m2._unit();
              const g3 = d2.x * y4.x + d2.y * y4.y, x5 = m2.x * y4.x + m2.y * y4.y, v4 = 0 !== x5 ? 1 / x5 : 1 / 0, b3 = 2 * Math.sqrt(2 - 2 * x5), w4 = x5 < ol && p4 && f2, _2 = d2.x * y4.y - d2.y * y4.x > 0;
              if (w4 && e5 > l4) {
                const t4 = h2.dist(p4);
                if (t4 > 2 * u3) {
                  const e6 = h2.sub(h2.sub(p4)._mult(u3 / t4)._round());
                  this.updateDistance(p4, e6), this.addCurrentVertex(e6, d2, 0, 0, c3), p4 = e6;
                }
              }
              const A3 = p4 && f2;
              let S4 = A3 ? r5 : a3 ? "butt" : n3;
              if (A3 && "round" === S4 && (v4 < s4 ? S4 = "miter" : v4 <= 2 && (S4 = "fakeround")), "miter" === S4 && v4 > i4 && (S4 = "bevel"), "bevel" === S4 && (v4 > 2 && (S4 = "flipbevel"), v4 < i4 && (S4 = "miter")), p4 && this.updateDistance(p4, h2), "miter" === S4)
                m2._mult(v4), this.addCurrentVertex(h2, m2, 0, 0, c3);
              else if ("flipbevel" === S4) {
                if (v4 > 100)
                  m2 = y4.mult(-1);
                else {
                  const t4 = v4 * d2.add(y4).mag() / d2.sub(y4).mag();
                  m2._perp()._mult(t4 * (_2 ? -1 : 1));
                }
                this.addCurrentVertex(h2, m2, 0, 0, c3), this.addCurrentVertex(h2, m2.mult(-1), 0, 0, c3);
              } else if ("bevel" === S4 || "fakeround" === S4) {
                const t4 = -Math.sqrt(v4 * v4 - 1), e6 = _2 ? t4 : 0, r6 = _2 ? 0 : t4;
                if (p4 && this.addCurrentVertex(h2, d2, e6, r6, c3), "fakeround" === S4) {
                  const t5 = Math.round(180 * b3 / Math.PI / 20);
                  for (let e7 = 1; e7 < t5; e7++) {
                    let r7 = e7 / t5;
                    if (0.5 !== r7) {
                      const t6 = r7 - 0.5;
                      r7 += r7 * t6 * (r7 - 1) * ((1.0904 + g3 * (g3 * (3.55645 - 1.43519 * g3) - 3.2452)) * t6 * t6 + (0.848013 + g3 * (0.215638 * g3 - 1.06021)));
                    }
                    const n4 = y4.sub(d2)._mult(r7)._add(d2)._unit()._mult(_2 ? -1 : 1);
                    this.addHalfVertex(h2, n4.x, n4.y, false, _2, 0, c3);
                  }
                }
                f2 && this.addCurrentVertex(h2, y4, -e6, -r6, c3);
              } else if ("butt" === S4)
                this.addCurrentVertex(h2, m2, 0, 0, c3);
              else if ("square" === S4) {
                const t4 = p4 ? 1 : -1;
                this.addCurrentVertex(h2, m2, t4, t4, c3);
              } else
                "round" === S4 && (p4 && (this.addCurrentVertex(h2, d2, 0, 0, c3), this.addCurrentVertex(h2, d2, 1, 1, c3, true)), f2 && (this.addCurrentVertex(h2, y4, -1, -1, c3, true), this.addCurrentVertex(h2, y4, 0, 0, c3)));
              if (w4 && e5 < o3 - 1) {
                const t4 = h2.dist(f2);
                if (t4 > 2 * u3) {
                  const e6 = h2.add(f2.sub(h2)._mult(u3 / t4)._round());
                  this.updateDistance(h2, e6), this.addCurrentVertex(e6, y4, 0, 0, c3), h2 = e6;
                }
              }
            }
          }
          addCurrentVertex(t3, e4, r5, n3, i4, s4 = false) {
            const a3 = e4.y * n3 - e4.x, o3 = -e4.y - e4.x * n3;
            this.addHalfVertex(t3, e4.x + e4.y * r5, e4.y - e4.x * r5, s4, false, r5, i4), this.addHalfVertex(t3, a3, o3, s4, true, -n3, i4), this.distance > ll / 2 && 0 === this.totalDistance && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t3, e4, r5, n3, i4, s4));
          }
          addHalfVertex({ x: t3, y: e4 }, r5, n3, i4, s4, a3, o3) {
            const l4 = 0.5 * (this.lineClips ? this.scaledDistance * (ll - 1) : this.scaledDistance);
            this.layoutVertexArray.emplaceBack((t3 << 1) + (i4 ? 1 : 0), (e4 << 1) + (s4 ? 1 : 0), Math.round(63 * r5) + 128, Math.round(63 * n3) + 128, 1 + (0 === a3 ? 0 : a3 < 0 ? -1 : 1) | (63 & l4) << 2, l4 >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
            const u3 = o3.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, u3), o3.primitiveLength++), s4 ? this.e2 = u3 : this.e1 = u3;
          }
          updateScaledDistance() {
            this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
          }
          updateDistance(t3, e4) {
            this.distance += t3.dist(e4), this.updateScaledDistance();
          }
        }
        let cl, hl;
        On("LineBucket", ul, { omit: ["layers", "patternFeatures"] });
        var pl = { get paint() {
          return hl = hl || new di({ "line-opacity": new ci(G2.paint_line["line-opacity"]), "line-color": new ci(G2.paint_line["line-color"]), "line-translate": new ui(G2.paint_line["line-translate"]), "line-translate-anchor": new ui(G2.paint_line["line-translate-anchor"]), "line-width": new ci(G2.paint_line["line-width"]), "line-gap-width": new ci(G2.paint_line["line-gap-width"]), "line-offset": new ci(G2.paint_line["line-offset"]), "line-blur": new ci(G2.paint_line["line-blur"]), "line-dasharray": new pi(G2.paint_line["line-dasharray"]), "line-pattern": new hi(G2.paint_line["line-pattern"]), "line-gradient": new fi(G2.paint_line["line-gradient"]) });
        }, get layout() {
          return cl = cl || new di({ "line-cap": new ui(G2.layout_line["line-cap"]), "line-join": new ci(G2.layout_line["line-join"]), "line-miter-limit": new ui(G2.layout_line["line-miter-limit"]), "line-round-limit": new ui(G2.layout_line["line-round-limit"]), "line-sort-key": new ci(G2.layout_line["line-sort-key"]) });
        } };
        class fl2 extends ci {
          possiblyEvaluate(t3, e4) {
            return e4 = new ti(Math.floor(e4.zoom), { now: e4.now, fadeDuration: e4.fadeDuration, zoomHistory: e4.zoomHistory, transition: e4.transition }), super.possiblyEvaluate(t3, e4);
          }
          evaluate(t3, e4, r5, n3) {
            return e4 = g2({}, e4, { zoom: Math.floor(e4.zoom) }), super.evaluate(t3, e4, r5, n3);
          }
        }
        let dl;
        class yl extends mi {
          constructor(t3) {
            super(t3, pl), this.gradientVersion = 0, dl || (dl = new fl2(pl.paint.properties["line-width"].specification), dl.useIntegerZoom = true);
          }
          _handleSpecialPaintPropertyUpdate(t3) {
            if ("line-gradient" === t3) {
              const t4 = this.gradientExpression();
              this.stepInterpolant = !!function(t5) {
                return void 0 !== t5._styleExpression;
              }(t4) && t4._styleExpression.expression instanceof Re2, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression;
          }
          recalculate(t3, e4) {
            super.recalculate(t3, e4), this.paint._values["line-floorwidth"] = dl.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t3);
          }
          createBucket(t3) {
            return new ul(t3);
          }
          queryRadius(t3) {
            const e4 = t3, r5 = ml(pa2("line-width", this, e4), pa2("line-gap-width", this, e4)), n3 = pa2("line-offset", this, e4);
            return r5 / 2 + Math.abs(n3) + fa2(this.paint.get("line-translate"));
          }
          queryIntersectsFeature(t3, e4, r5, n3, i4, a3, o3) {
            const l4 = da2(t3, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), a3.angle, o3), u3 = o3 / 2 * ml(this.paint.get("line-width").evaluate(e4, r5), this.paint.get("line-gap-width").evaluate(e4, r5)), c3 = this.paint.get("line-offset").evaluate(e4, r5);
            return c3 && (n3 = function(t4, e5) {
              const r6 = [];
              for (let n4 = 0; n4 < t4.length; n4++) {
                const i5 = t4[n4], a4 = [];
                for (let t5 = 0; t5 < i5.length; t5++) {
                  const r7 = i5[t5 - 1], n5 = i5[t5], o4 = i5[t5 + 1], l5 = 0 === t5 ? new s3(0, 0) : n5.sub(r7)._unit()._perp(), u4 = t5 === i5.length - 1 ? new s3(0, 0) : o4.sub(n5)._unit()._perp(), c4 = l5._add(u4)._unit(), h2 = c4.x * u4.x + c4.y * u4.y;
                  0 !== h2 && c4._mult(1 / h2), a4.push(c4._mult(e5)._add(n5));
                }
                r6.push(a4);
              }
              return r6;
            }(n3, c3 * o3)), function(t4, e5, r6) {
              for (let n4 = 0; n4 < e5.length; n4++) {
                const i5 = e5[n4];
                if (t4.length >= 3) {
                  for (let e6 = 0; e6 < i5.length; e6++)
                    if (ca2(t4, i5[e6]))
                      return true;
                }
                if (ia2(t4, i5, r6))
                  return true;
              }
              return false;
            }(l4, n3, u3);
          }
          isTileClipped() {
            return true;
          }
        }
        function ml(t3, e4) {
          return e4 > 0 ? e4 + 2 * t3 : t3;
        }
        const gl = bi([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), xl = bi([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
        bi([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
        const vl = bi([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }]);
        bi([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
        const bl = bi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), wl = bi([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
        function _l(t3, e4, r5) {
          return t3.sections.forEach((t4) => {
            t4.text = function(t5, e5, r6) {
              const n3 = e5.layout.get("text-transform").evaluate(r6, {});
              return "uppercase" === n3 ? t5 = t5.toLocaleUpperCase() : "lowercase" === n3 && (t5 = t5.toLocaleLowerCase()), Qn.applyArabicShaping && (t5 = Qn.applyArabicShaping(t5)), t5;
            }(t4.text, e4, r5);
          }), t3;
        }
        bi([{ name: "triangle", components: 3, type: "Uint16" }]), bi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), bi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), bi([{ type: "Float32", name: "offsetX" }]), bi([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), bi([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
        const Al = { "!": "\uFE15", "#": "\uFF03", $: "\uFF04", "%": "\uFF05", "&": "\uFF06", "(": "\uFE35", ")": "\uFE36", "*": "\uFF0A", "+": "\uFF0B", ",": "\uFE10", "-": "\uFE32", ".": "\u30FB", "/": "\uFF0F", ":": "\uFE13", ";": "\uFE14", "<": "\uFE3F", "=": "\uFF1D", ">": "\uFE40", "?": "\uFE16", "@": "\uFF20", "[": "\uFE47", "\\": "\uFF3C", "]": "\uFE48", "^": "\uFF3E", _: "\uFE33", "`": "\uFF40", "{": "\uFE37", "|": "\u2015", "}": "\uFE38", "~": "\uFF5E", "\xA2": "\uFFE0", "\xA3": "\uFFE1", "\xA5": "\uFFE5", "\xA6": "\uFFE4", "\xAC": "\uFFE2", "\xAF": "\uFFE3", "\u2013": "\uFE32", "\u2014": "\uFE31", "\u2018": "\uFE43", "\u2019": "\uFE44", "\u201C": "\uFE41", "\u201D": "\uFE42", "\u2026": "\uFE19", "\u2027": "\u30FB", "\u20A9": "\uFFE6", "\u3001": "\uFE11", "\u3002": "\uFE12", "\u3008": "\uFE3F", "\u3009": "\uFE40", "\u300A": "\uFE3D", "\u300B": "\uFE3E", "\u300C": "\uFE41", "\u300D": "\uFE42", "\u300E": "\uFE43", "\u300F": "\uFE44", "\u3010": "\uFE3B", "\u3011": "\uFE3C", "\u3014": "\uFE39", "\u3015": "\uFE3A", "\u3016": "\uFE17", "\u3017": "\uFE18", "\uFF01": "\uFE15", "\uFF08": "\uFE35", "\uFF09": "\uFE36", "\uFF0C": "\uFE10", "\uFF0D": "\uFE32", "\uFF0E": "\u30FB", "\uFF1A": "\uFE13", "\uFF1B": "\uFE14", "\uFF1C": "\uFE3F", "\uFF1E": "\uFE40", "\uFF1F": "\uFE16", "\uFF3B": "\uFE47", "\uFF3D": "\uFE48", "\uFF3F": "\uFE33", "\uFF5B": "\uFE37", "\uFF5C": "\u2015", "\uFF5D": "\uFE38", "\uFF5F": "\uFE35", "\uFF60": "\uFE36", "\uFF61": "\uFE12", "\uFF62": "\uFE41", "\uFF63": "\uFE42" };
        var Sl = 24, kl = Ml, Il = function(t3, e4, r5, n3, i4) {
          var s4, a3, o3 = 8 * i4 - n3 - 1, l4 = (1 << o3) - 1, u3 = l4 >> 1, c3 = -7, h2 = r5 ? i4 - 1 : 0, p4 = r5 ? -1 : 1, f2 = t3[e4 + h2];
          for (h2 += p4, s4 = f2 & (1 << -c3) - 1, f2 >>= -c3, c3 += o3; c3 > 0; s4 = 256 * s4 + t3[e4 + h2], h2 += p4, c3 -= 8)
            ;
          for (a3 = s4 & (1 << -c3) - 1, s4 >>= -c3, c3 += n3; c3 > 0; a3 = 256 * a3 + t3[e4 + h2], h2 += p4, c3 -= 8)
            ;
          if (0 === s4)
            s4 = 1 - u3;
          else {
            if (s4 === l4)
              return a3 ? NaN : 1 / 0 * (f2 ? -1 : 1);
            a3 += Math.pow(2, n3), s4 -= u3;
          }
          return (f2 ? -1 : 1) * a3 * Math.pow(2, s4 - n3);
        }, zl = function(t3, e4, r5, n3, i4, s4) {
          var a3, o3, l4, u3 = 8 * s4 - i4 - 1, c3 = (1 << u3) - 1, h2 = c3 >> 1, p4 = 23 === i4 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f2 = n3 ? 0 : s4 - 1, d2 = n3 ? 1 : -1, y4 = e4 < 0 || 0 === e4 && 1 / e4 < 0 ? 1 : 0;
          for (e4 = Math.abs(e4), isNaN(e4) || e4 === 1 / 0 ? (o3 = isNaN(e4) ? 1 : 0, a3 = c3) : (a3 = Math.floor(Math.log(e4) / Math.LN2), e4 * (l4 = Math.pow(2, -a3)) < 1 && (a3--, l4 *= 2), (e4 += a3 + h2 >= 1 ? p4 / l4 : p4 * Math.pow(2, 1 - h2)) * l4 >= 2 && (a3++, l4 /= 2), a3 + h2 >= c3 ? (o3 = 0, a3 = c3) : a3 + h2 >= 1 ? (o3 = (e4 * l4 - 1) * Math.pow(2, i4), a3 += h2) : (o3 = e4 * Math.pow(2, h2 - 1) * Math.pow(2, i4), a3 = 0)); i4 >= 8; t3[r5 + f2] = 255 & o3, f2 += d2, o3 /= 256, i4 -= 8)
            ;
          for (a3 = a3 << i4 | o3, u3 += i4; u3 > 0; t3[r5 + f2] = 255 & a3, f2 += d2, a3 /= 256, u3 -= 8)
            ;
          t3[r5 + f2 - d2] |= 128 * y4;
        };
        function Ml(t3) {
          this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t3) ? t3 : new Uint8Array(t3 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
        }
        Ml.Varint = 0, Ml.Fixed64 = 1, Ml.Bytes = 2, Ml.Fixed32 = 5;
        var Bl = 4294967296, Cl = 1 / Bl, Pl = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");
        function Vl(t3) {
          return t3.type === Ml.Bytes ? t3.readVarint() + t3.pos : t3.pos + 1;
        }
        function El(t3, e4, r5) {
          return r5 ? 4294967296 * e4 + (t3 >>> 0) : 4294967296 * (e4 >>> 0) + (t3 >>> 0);
        }
        function Fl(t3, e4, r5) {
          var n3 = e4 <= 16383 ? 1 : e4 <= 2097151 ? 2 : e4 <= 268435455 ? 3 : Math.floor(Math.log(e4) / (7 * Math.LN2));
          r5.realloc(n3);
          for (var i4 = r5.pos - 1; i4 >= t3; i4--)
            r5.buf[i4 + n3] = r5.buf[i4];
        }
        function Tl(t3, e4) {
          for (var r5 = 0; r5 < t3.length; r5++)
            e4.writeVarint(t3[r5]);
        }
        function $l(t3, e4) {
          for (var r5 = 0; r5 < t3.length; r5++)
            e4.writeSVarint(t3[r5]);
        }
        function Dl(t3, e4) {
          for (var r5 = 0; r5 < t3.length; r5++)
            e4.writeFloat(t3[r5]);
        }
        function Ll(t3, e4) {
          for (var r5 = 0; r5 < t3.length; r5++)
            e4.writeDouble(t3[r5]);
        }
        function Ol(t3, e4) {
          for (var r5 = 0; r5 < t3.length; r5++)
            e4.writeBoolean(t3[r5]);
        }
        function Rl(t3, e4) {
          for (var r5 = 0; r5 < t3.length; r5++)
            e4.writeFixed32(t3[r5]);
        }
        function Ul(t3, e4) {
          for (var r5 = 0; r5 < t3.length; r5++)
            e4.writeSFixed32(t3[r5]);
        }
        function jl(t3, e4) {
          for (var r5 = 0; r5 < t3.length; r5++)
            e4.writeFixed64(t3[r5]);
        }
        function ql(t3, e4) {
          for (var r5 = 0; r5 < t3.length; r5++)
            e4.writeSFixed64(t3[r5]);
        }
        function Nl(t3, e4) {
          return (t3[e4] | t3[e4 + 1] << 8 | t3[e4 + 2] << 16) + 16777216 * t3[e4 + 3];
        }
        function Zl(t3, e4, r5) {
          t3[r5] = e4, t3[r5 + 1] = e4 >>> 8, t3[r5 + 2] = e4 >>> 16, t3[r5 + 3] = e4 >>> 24;
        }
        function Kl(t3, e4) {
          return (t3[e4] | t3[e4 + 1] << 8 | t3[e4 + 2] << 16) + (t3[e4 + 3] << 24);
        }
        Ml.prototype = { destroy: function() {
          this.buf = null;
        }, readFields: function(t3, e4, r5) {
          for (r5 = r5 || this.length; this.pos < r5; ) {
            var n3 = this.readVarint(), i4 = n3 >> 3, s4 = this.pos;
            this.type = 7 & n3, t3(i4, e4, this), this.pos === s4 && this.skip(n3);
          }
          return e4;
        }, readMessage: function(t3, e4) {
          return this.readFields(t3, e4, this.readVarint() + this.pos);
        }, readFixed32: function() {
          var t3 = Nl(this.buf, this.pos);
          return this.pos += 4, t3;
        }, readSFixed32: function() {
          var t3 = Kl(this.buf, this.pos);
          return this.pos += 4, t3;
        }, readFixed64: function() {
          var t3 = Nl(this.buf, this.pos) + Nl(this.buf, this.pos + 4) * Bl;
          return this.pos += 8, t3;
        }, readSFixed64: function() {
          var t3 = Nl(this.buf, this.pos) + Kl(this.buf, this.pos + 4) * Bl;
          return this.pos += 8, t3;
        }, readFloat: function() {
          var t3 = Il(this.buf, this.pos, true, 23, 4);
          return this.pos += 4, t3;
        }, readDouble: function() {
          var t3 = Il(this.buf, this.pos, true, 52, 8);
          return this.pos += 8, t3;
        }, readVarint: function(t3) {
          var e4, r5, n3 = this.buf;
          return e4 = 127 & (r5 = n3[this.pos++]), r5 < 128 ? e4 : (e4 |= (127 & (r5 = n3[this.pos++])) << 7, r5 < 128 ? e4 : (e4 |= (127 & (r5 = n3[this.pos++])) << 14, r5 < 128 ? e4 : (e4 |= (127 & (r5 = n3[this.pos++])) << 21, r5 < 128 ? e4 : function(t4, e5, r6) {
            var n4, i4, s4 = r6.buf;
            if (n4 = (112 & (i4 = s4[r6.pos++])) >> 4, i4 < 128)
              return El(t4, n4, e5);
            if (n4 |= (127 & (i4 = s4[r6.pos++])) << 3, i4 < 128)
              return El(t4, n4, e5);
            if (n4 |= (127 & (i4 = s4[r6.pos++])) << 10, i4 < 128)
              return El(t4, n4, e5);
            if (n4 |= (127 & (i4 = s4[r6.pos++])) << 17, i4 < 128)
              return El(t4, n4, e5);
            if (n4 |= (127 & (i4 = s4[r6.pos++])) << 24, i4 < 128)
              return El(t4, n4, e5);
            if (n4 |= (1 & (i4 = s4[r6.pos++])) << 31, i4 < 128)
              return El(t4, n4, e5);
            throw new Error("Expected varint not more than 10 bytes");
          }(e4 |= (15 & (r5 = n3[this.pos])) << 28, t3, this))));
        }, readVarint64: function() {
          return this.readVarint(true);
        }, readSVarint: function() {
          var t3 = this.readVarint();
          return t3 % 2 == 1 ? (t3 + 1) / -2 : t3 / 2;
        }, readBoolean: function() {
          return Boolean(this.readVarint());
        }, readString: function() {
          var t3 = this.readVarint() + this.pos, e4 = this.pos;
          return this.pos = t3, t3 - e4 >= 12 && Pl ? function(t4, e5, r5) {
            return Pl.decode(t4.subarray(e5, r5));
          }(this.buf, e4, t3) : function(t4, e5, r5) {
            for (var n3 = "", i4 = e5; i4 < r5; ) {
              var s4, a3, o3, l4 = t4[i4], u3 = null, c3 = l4 > 239 ? 4 : l4 > 223 ? 3 : l4 > 191 ? 2 : 1;
              if (i4 + c3 > r5)
                break;
              1 === c3 ? l4 < 128 && (u3 = l4) : 2 === c3 ? 128 == (192 & (s4 = t4[i4 + 1])) && (u3 = (31 & l4) << 6 | 63 & s4) <= 127 && (u3 = null) : 3 === c3 ? (a3 = t4[i4 + 2], 128 == (192 & (s4 = t4[i4 + 1])) && 128 == (192 & a3) && ((u3 = (15 & l4) << 12 | (63 & s4) << 6 | 63 & a3) <= 2047 || u3 >= 55296 && u3 <= 57343) && (u3 = null)) : 4 === c3 && (a3 = t4[i4 + 2], o3 = t4[i4 + 3], 128 == (192 & (s4 = t4[i4 + 1])) && 128 == (192 & a3) && 128 == (192 & o3) && ((u3 = (15 & l4) << 18 | (63 & s4) << 12 | (63 & a3) << 6 | 63 & o3) <= 65535 || u3 >= 1114112) && (u3 = null)), null === u3 ? (u3 = 65533, c3 = 1) : u3 > 65535 && (u3 -= 65536, n3 += String.fromCharCode(u3 >>> 10 & 1023 | 55296), u3 = 56320 | 1023 & u3), n3 += String.fromCharCode(u3), i4 += c3;
            }
            return n3;
          }(this.buf, e4, t3);
        }, readBytes: function() {
          var t3 = this.readVarint() + this.pos, e4 = this.buf.subarray(this.pos, t3);
          return this.pos = t3, e4;
        }, readPackedVarint: function(t3, e4) {
          if (this.type !== Ml.Bytes)
            return t3.push(this.readVarint(e4));
          var r5 = Vl(this);
          for (t3 = t3 || []; this.pos < r5; )
            t3.push(this.readVarint(e4));
          return t3;
        }, readPackedSVarint: function(t3) {
          if (this.type !== Ml.Bytes)
            return t3.push(this.readSVarint());
          var e4 = Vl(this);
          for (t3 = t3 || []; this.pos < e4; )
            t3.push(this.readSVarint());
          return t3;
        }, readPackedBoolean: function(t3) {
          if (this.type !== Ml.Bytes)
            return t3.push(this.readBoolean());
          var e4 = Vl(this);
          for (t3 = t3 || []; this.pos < e4; )
            t3.push(this.readBoolean());
          return t3;
        }, readPackedFloat: function(t3) {
          if (this.type !== Ml.Bytes)
            return t3.push(this.readFloat());
          var e4 = Vl(this);
          for (t3 = t3 || []; this.pos < e4; )
            t3.push(this.readFloat());
          return t3;
        }, readPackedDouble: function(t3) {
          if (this.type !== Ml.Bytes)
            return t3.push(this.readDouble());
          var e4 = Vl(this);
          for (t3 = t3 || []; this.pos < e4; )
            t3.push(this.readDouble());
          return t3;
        }, readPackedFixed32: function(t3) {
          if (this.type !== Ml.Bytes)
            return t3.push(this.readFixed32());
          var e4 = Vl(this);
          for (t3 = t3 || []; this.pos < e4; )
            t3.push(this.readFixed32());
          return t3;
        }, readPackedSFixed32: function(t3) {
          if (this.type !== Ml.Bytes)
            return t3.push(this.readSFixed32());
          var e4 = Vl(this);
          for (t3 = t3 || []; this.pos < e4; )
            t3.push(this.readSFixed32());
          return t3;
        }, readPackedFixed64: function(t3) {
          if (this.type !== Ml.Bytes)
            return t3.push(this.readFixed64());
          var e4 = Vl(this);
          for (t3 = t3 || []; this.pos < e4; )
            t3.push(this.readFixed64());
          return t3;
        }, readPackedSFixed64: function(t3) {
          if (this.type !== Ml.Bytes)
            return t3.push(this.readSFixed64());
          var e4 = Vl(this);
          for (t3 = t3 || []; this.pos < e4; )
            t3.push(this.readSFixed64());
          return t3;
        }, skip: function(t3) {
          var e4 = 7 & t3;
          if (e4 === Ml.Varint)
            for (; this.buf[this.pos++] > 127; )
              ;
          else if (e4 === Ml.Bytes)
            this.pos = this.readVarint() + this.pos;
          else if (e4 === Ml.Fixed32)
            this.pos += 4;
          else {
            if (e4 !== Ml.Fixed64)
              throw new Error("Unimplemented type: " + e4);
            this.pos += 8;
          }
        }, writeTag: function(t3, e4) {
          this.writeVarint(t3 << 3 | e4);
        }, realloc: function(t3) {
          for (var e4 = this.length || 16; e4 < this.pos + t3; )
            e4 *= 2;
          if (e4 !== this.length) {
            var r5 = new Uint8Array(e4);
            r5.set(this.buf), this.buf = r5, this.length = e4;
          }
        }, finish: function() {
          return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
        }, writeFixed32: function(t3) {
          this.realloc(4), Zl(this.buf, t3, this.pos), this.pos += 4;
        }, writeSFixed32: function(t3) {
          this.realloc(4), Zl(this.buf, t3, this.pos), this.pos += 4;
        }, writeFixed64: function(t3) {
          this.realloc(8), Zl(this.buf, -1 & t3, this.pos), Zl(this.buf, Math.floor(t3 * Cl), this.pos + 4), this.pos += 8;
        }, writeSFixed64: function(t3) {
          this.realloc(8), Zl(this.buf, -1 & t3, this.pos), Zl(this.buf, Math.floor(t3 * Cl), this.pos + 4), this.pos += 8;
        }, writeVarint: function(t3) {
          (t3 = +t3 || 0) > 268435455 || t3 < 0 ? function(t4, e4) {
            var r5, n3;
            if (t4 >= 0 ? (r5 = t4 % 4294967296 | 0, n3 = t4 / 4294967296 | 0) : (n3 = ~(-t4 / 4294967296), 4294967295 ^ (r5 = ~(-t4 % 4294967296)) ? r5 = r5 + 1 | 0 : (r5 = 0, n3 = n3 + 1 | 0)), t4 >= 18446744073709552e3 || t4 < -18446744073709552e3)
              throw new Error("Given varint doesn't fit into 10 bytes");
            e4.realloc(10), function(t5, e5, r6) {
              r6.buf[r6.pos++] = 127 & t5 | 128, t5 >>>= 7, r6.buf[r6.pos++] = 127 & t5 | 128, t5 >>>= 7, r6.buf[r6.pos++] = 127 & t5 | 128, t5 >>>= 7, r6.buf[r6.pos++] = 127 & t5 | 128, r6.buf[r6.pos] = 127 & (t5 >>>= 7);
            }(r5, 0, e4), function(t5, e5) {
              var r6 = (7 & t5) << 4;
              e5.buf[e5.pos++] |= r6 | ((t5 >>>= 3) ? 128 : 0), t5 && (e5.buf[e5.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e5.buf[e5.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e5.buf[e5.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e5.buf[e5.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e5.buf[e5.pos++] = 127 & t5)))));
            }(n3, e4);
          }(t3, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t3 | (t3 > 127 ? 128 : 0), t3 <= 127 || (this.buf[this.pos++] = 127 & (t3 >>>= 7) | (t3 > 127 ? 128 : 0), t3 <= 127 || (this.buf[this.pos++] = 127 & (t3 >>>= 7) | (t3 > 127 ? 128 : 0), t3 <= 127 || (this.buf[this.pos++] = t3 >>> 7 & 127))));
        }, writeSVarint: function(t3) {
          this.writeVarint(t3 < 0 ? 2 * -t3 - 1 : 2 * t3);
        }, writeBoolean: function(t3) {
          this.writeVarint(Boolean(t3));
        }, writeString: function(t3) {
          t3 = String(t3), this.realloc(4 * t3.length), this.pos++;
          var e4 = this.pos;
          this.pos = function(t4, e5, r6) {
            for (var n3, i4, s4 = 0; s4 < e5.length; s4++) {
              if ((n3 = e5.charCodeAt(s4)) > 55295 && n3 < 57344) {
                if (!i4) {
                  n3 > 56319 || s4 + 1 === e5.length ? (t4[r6++] = 239, t4[r6++] = 191, t4[r6++] = 189) : i4 = n3;
                  continue;
                }
                if (n3 < 56320) {
                  t4[r6++] = 239, t4[r6++] = 191, t4[r6++] = 189, i4 = n3;
                  continue;
                }
                n3 = i4 - 55296 << 10 | n3 - 56320 | 65536, i4 = null;
              } else
                i4 && (t4[r6++] = 239, t4[r6++] = 191, t4[r6++] = 189, i4 = null);
              n3 < 128 ? t4[r6++] = n3 : (n3 < 2048 ? t4[r6++] = n3 >> 6 | 192 : (n3 < 65536 ? t4[r6++] = n3 >> 12 | 224 : (t4[r6++] = n3 >> 18 | 240, t4[r6++] = n3 >> 12 & 63 | 128), t4[r6++] = n3 >> 6 & 63 | 128), t4[r6++] = 63 & n3 | 128);
            }
            return r6;
          }(this.buf, t3, this.pos);
          var r5 = this.pos - e4;
          r5 >= 128 && Fl(e4, r5, this), this.pos = e4 - 1, this.writeVarint(r5), this.pos += r5;
        }, writeFloat: function(t3) {
          this.realloc(4), zl(this.buf, t3, this.pos, true, 23, 4), this.pos += 4;
        }, writeDouble: function(t3) {
          this.realloc(8), zl(this.buf, t3, this.pos, true, 52, 8), this.pos += 8;
        }, writeBytes: function(t3) {
          var e4 = t3.length;
          this.writeVarint(e4), this.realloc(e4);
          for (var r5 = 0; r5 < e4; r5++)
            this.buf[this.pos++] = t3[r5];
        }, writeRawMessage: function(t3, e4) {
          this.pos++;
          var r5 = this.pos;
          t3(e4, this);
          var n3 = this.pos - r5;
          n3 >= 128 && Fl(r5, n3, this), this.pos = r5 - 1, this.writeVarint(n3), this.pos += n3;
        }, writeMessage: function(t3, e4, r5) {
          this.writeTag(t3, Ml.Bytes), this.writeRawMessage(e4, r5);
        }, writePackedVarint: function(t3, e4) {
          e4.length && this.writeMessage(t3, Tl, e4);
        }, writePackedSVarint: function(t3, e4) {
          e4.length && this.writeMessage(t3, $l, e4);
        }, writePackedBoolean: function(t3, e4) {
          e4.length && this.writeMessage(t3, Ol, e4);
        }, writePackedFloat: function(t3, e4) {
          e4.length && this.writeMessage(t3, Dl, e4);
        }, writePackedDouble: function(t3, e4) {
          e4.length && this.writeMessage(t3, Ll, e4);
        }, writePackedFixed32: function(t3, e4) {
          e4.length && this.writeMessage(t3, Rl, e4);
        }, writePackedSFixed32: function(t3, e4) {
          e4.length && this.writeMessage(t3, Ul, e4);
        }, writePackedFixed64: function(t3, e4) {
          e4.length && this.writeMessage(t3, jl, e4);
        }, writePackedSFixed64: function(t3, e4) {
          e4.length && this.writeMessage(t3, ql, e4);
        }, writeBytesField: function(t3, e4) {
          this.writeTag(t3, Ml.Bytes), this.writeBytes(e4);
        }, writeFixed32Field: function(t3, e4) {
          this.writeTag(t3, Ml.Fixed32), this.writeFixed32(e4);
        }, writeSFixed32Field: function(t3, e4) {
          this.writeTag(t3, Ml.Fixed32), this.writeSFixed32(e4);
        }, writeFixed64Field: function(t3, e4) {
          this.writeTag(t3, Ml.Fixed64), this.writeFixed64(e4);
        }, writeSFixed64Field: function(t3, e4) {
          this.writeTag(t3, Ml.Fixed64), this.writeSFixed64(e4);
        }, writeVarintField: function(t3, e4) {
          this.writeTag(t3, Ml.Varint), this.writeVarint(e4);
        }, writeSVarintField: function(t3, e4) {
          this.writeTag(t3, Ml.Varint), this.writeSVarint(e4);
        }, writeStringField: function(t3, e4) {
          this.writeTag(t3, Ml.Bytes), this.writeString(e4);
        }, writeFloatField: function(t3, e4) {
          this.writeTag(t3, Ml.Fixed32), this.writeFloat(e4);
        }, writeDoubleField: function(t3, e4) {
          this.writeTag(t3, Ml.Fixed64), this.writeDouble(e4);
        }, writeBooleanField: function(t3, e4) {
          this.writeVarintField(t3, Boolean(e4));
        } };
        var Gl = r4(kl);
        const Jl = 3;
        function Xl(t3, e4, r5) {
          1 === t3 && r5.readMessage(Hl, e4);
        }
        function Hl(t3, e4, r5) {
          if (3 === t3) {
            const { id: t4, bitmap: n3, width: i4, height: s4, left: a3, top: o3, advance: l4 } = r5.readMessage(Yl, {});
            e4.push({ id: t4, bitmap: new Ea2({ width: i4 + 2 * Jl, height: s4 + 2 * Jl }, n3), metrics: { width: i4, height: s4, left: a3, top: o3, advance: l4 } });
          }
        }
        function Yl(t3, e4, r5) {
          1 === t3 ? e4.id = r5.readVarint() : 2 === t3 ? e4.bitmap = r5.readBytes() : 3 === t3 ? e4.width = r5.readVarint() : 4 === t3 ? e4.height = r5.readVarint() : 5 === t3 ? e4.left = r5.readSVarint() : 6 === t3 ? e4.top = r5.readSVarint() : 7 === t3 && (e4.advance = r5.readVarint());
        }
        const Wl = Jl;
        function Ql(t3) {
          let e4 = 0, r5 = 0;
          for (const n4 of t3)
            e4 += n4.w * n4.h, r5 = Math.max(r5, n4.w);
          t3.sort((t4, e5) => e5.h - t4.h);
          const n3 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e4 / 0.95)), r5), h: 1 / 0 }];
          let i4 = 0, s4 = 0;
          for (const e5 of t3)
            for (let t4 = n3.length - 1; t4 >= 0; t4--) {
              const r6 = n3[t4];
              if (!(e5.w > r6.w || e5.h > r6.h)) {
                if (e5.x = r6.x, e5.y = r6.y, s4 = Math.max(s4, e5.y + e5.h), i4 = Math.max(i4, e5.x + e5.w), e5.w === r6.w && e5.h === r6.h) {
                  const e6 = n3.pop();
                  t4 < n3.length && (n3[t4] = e6);
                } else
                  e5.h === r6.h ? (r6.x += e5.w, r6.w -= e5.w) : e5.w === r6.w ? (r6.y += e5.h, r6.h -= e5.h) : (n3.push({ x: r6.x + e5.w, y: r6.y, w: r6.w - e5.w, h: e5.h }), r6.y += e5.h, r6.h -= e5.h);
                break;
              }
            }
          return { w: i4, h: s4, fill: e4 / (i4 * s4) || 0 };
        }
        const tu = 1;
        class eu {
          constructor(t3, { pixelRatio: e4, version: r5, stretchX: n3, stretchY: i4, content: s4 }) {
            this.paddedRect = t3, this.pixelRatio = e4, this.stretchX = n3, this.stretchY = i4, this.content = s4, this.version = r5;
          }
          get tl() {
            return [this.paddedRect.x + tu, this.paddedRect.y + tu];
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - tu, this.paddedRect.y + this.paddedRect.h - tu];
          }
          get tlbr() {
            return this.tl.concat(this.br);
          }
          get displaySize() {
            return [(this.paddedRect.w - 2 * tu) / this.pixelRatio, (this.paddedRect.h - 2 * tu) / this.pixelRatio];
          }
        }
        class ru {
          constructor(t3, e4) {
            const r5 = {}, n3 = {};
            this.haveRenderCallbacks = [];
            const i4 = [];
            this.addImages(t3, r5, i4), this.addImages(e4, n3, i4);
            const { w: s4, h: a3 } = Ql(i4), o3 = new Fa2({ width: s4 || 1, height: a3 || 1 });
            for (const e5 in t3) {
              const n4 = t3[e5], i5 = r5[e5].paddedRect;
              Fa2.copy(n4.data, o3, { x: 0, y: 0 }, { x: i5.x + tu, y: i5.y + tu }, n4.data);
            }
            for (const t4 in e4) {
              const r6 = e4[t4], i5 = n3[t4].paddedRect, s5 = i5.x + tu, a4 = i5.y + tu, l4 = r6.data.width, u3 = r6.data.height;
              Fa2.copy(r6.data, o3, { x: 0, y: 0 }, { x: s5, y: a4 }, r6.data), Fa2.copy(r6.data, o3, { x: 0, y: u3 - 1 }, { x: s5, y: a4 - 1 }, { width: l4, height: 1 }), Fa2.copy(r6.data, o3, { x: 0, y: 0 }, { x: s5, y: a4 + u3 }, { width: l4, height: 1 }), Fa2.copy(r6.data, o3, { x: l4 - 1, y: 0 }, { x: s5 - 1, y: a4 }, { width: 1, height: u3 }), Fa2.copy(r6.data, o3, { x: 0, y: 0 }, { x: s5 + l4, y: a4 }, { width: 1, height: u3 });
            }
            this.image = o3, this.iconPositions = r5, this.patternPositions = n3;
          }
          addImages(t3, e4, r5) {
            for (const n3 in t3) {
              const i4 = t3[n3], s4 = { x: 0, y: 0, w: i4.data.width + 2 * tu, h: i4.data.height + 2 * tu };
              r5.push(s4), e4[n3] = new eu(s4, i4), i4.hasRenderCallback && this.haveRenderCallbacks.push(n3);
            }
          }
          patchUpdatedImages(t3, e4) {
            t3.dispatchRenderCallbacks(this.haveRenderCallbacks);
            for (const r5 in t3.updatedImages)
              this.patchUpdatedImage(this.iconPositions[r5], t3.getImage(r5), e4), this.patchUpdatedImage(this.patternPositions[r5], t3.getImage(r5), e4);
          }
          patchUpdatedImage(t3, e4, r5) {
            if (!t3 || !e4)
              return;
            if (t3.version === e4.version)
              return;
            t3.version = e4.version;
            const [n3, i4] = t3.tl;
            r5.update(e4.data, void 0, { x: n3, y: i4 });
          }
        }
        var nu;
        On("ImagePosition", eu), On("ImageAtlas", ru), t2.ah = void 0, (nu = t2.ah || (t2.ah = {}))[nu.none = 0] = "none", nu[nu.horizontal = 1] = "horizontal", nu[nu.vertical = 2] = "vertical", nu[nu.horizontalOnly = 3] = "horizontalOnly";
        const iu = -17;
        class su {
          constructor() {
            this.scale = 1, this.fontStack = "", this.imageName = null;
          }
          static forText(t3, e4) {
            const r5 = new su();
            return r5.scale = t3 || 1, r5.fontStack = e4, r5;
          }
          static forImage(t3) {
            const e4 = new su();
            return e4.imageName = t3, e4;
          }
        }
        class au {
          constructor() {
            this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
          }
          static fromFeature(t3, e4) {
            const r5 = new au();
            for (let n3 = 0; n3 < t3.sections.length; n3++) {
              const i4 = t3.sections[n3];
              i4.image ? r5.addImageSection(i4) : r5.addTextSection(i4, e4);
            }
            return r5;
          }
          length() {
            return this.text.length;
          }
          getSection(t3) {
            return this.sections[this.sectionIndex[t3]];
          }
          getSectionIndex(t3) {
            return this.sectionIndex[t3];
          }
          getCharCode(t3) {
            return this.text.charCodeAt(t3);
          }
          verticalizePunctuation() {
            this.text = function(t3) {
              let e4 = "";
              for (let r5 = 0; r5 < t3.length; r5++) {
                const n3 = t3.charCodeAt(r5 + 1) || null, i4 = t3.charCodeAt(r5 - 1) || null;
                e4 += n3 && Xn(n3) && !Al[t3[r5 + 1]] || i4 && Xn(i4) && !Al[t3[r5 - 1]] || !Al[t3[r5]] ? t3[r5] : Al[t3[r5]];
              }
              return e4;
            }(this.text);
          }
          trim() {
            let t3 = 0;
            for (let e5 = 0; e5 < this.text.length && lu[this.text.charCodeAt(e5)]; e5++)
              t3++;
            let e4 = this.text.length;
            for (let r5 = this.text.length - 1; r5 >= 0 && r5 >= t3 && lu[this.text.charCodeAt(r5)]; r5--)
              e4--;
            this.text = this.text.substring(t3, e4), this.sectionIndex = this.sectionIndex.slice(t3, e4);
          }
          substring(t3, e4) {
            const r5 = new au();
            return r5.text = this.text.substring(t3, e4), r5.sectionIndex = this.sectionIndex.slice(t3, e4), r5.sections = this.sections, r5;
          }
          toString() {
            return this.text;
          }
          getMaxScale() {
            return this.sectionIndex.reduce((t3, e4) => Math.max(t3, this.sections[e4].scale), 0);
          }
          addTextSection(t3, e4) {
            this.text += t3.text, this.sections.push(su.forText(t3.scale, t3.fontStack || e4));
            const r5 = this.sections.length - 1;
            for (let e5 = 0; e5 < t3.text.length; ++e5)
              this.sectionIndex.push(r5);
          }
          addImageSection(t3) {
            const e4 = t3.image ? t3.image.name : "";
            if (0 === e4.length)
              return void A2("Can't add FormattedSection with an empty image.");
            const r5 = this.getNextImageSectionCharCode();
            r5 ? (this.text += String.fromCharCode(r5), this.sections.push(su.forImage(e4)), this.sectionIndex.push(this.sections.length - 1)) : A2("Reached maximum number of images 6401");
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
          }
        }
        function ou(e4, r5, n3, i4, s4, a3, o3, l4, u3, c3, h2, p4, f2, d2, y4, m2) {
          const g3 = au.fromFeature(e4, s4);
          let x5;
          p4 === t2.ah.vertical && g3.verticalizePunctuation();
          const { processBidirectionalText: v4, processStyledBidirectionalText: b3 } = Qn;
          if (v4 && 1 === g3.sections.length) {
            x5 = [];
            const t3 = v4(g3.toString(), yu(g3, c3, a3, r5, i4, d2, y4));
            for (const e5 of t3) {
              const t4 = new au();
              t4.text = e5, t4.sections = g3.sections;
              for (let r6 = 0; r6 < e5.length; r6++)
                t4.sectionIndex.push(0);
              x5.push(t4);
            }
          } else if (b3) {
            x5 = [];
            const t3 = b3(g3.text, g3.sectionIndex, yu(g3, c3, a3, r5, i4, d2, y4));
            for (const e5 of t3) {
              const t4 = new au();
              t4.text = e5[0], t4.sectionIndex = e5[1], t4.sections = g3.sections, x5.push(t4);
            }
          } else
            x5 = function(t3, e5) {
              const r6 = [], n4 = t3.text;
              let i5 = 0;
              for (const n5 of e5)
                r6.push(t3.substring(i5, n5)), i5 = n5;
              return i5 < n4.length && r6.push(t3.substring(i5, n4.length)), r6;
            }(g3, yu(g3, c3, a3, r5, i4, d2, y4));
          const w4 = [], _2 = { positionedLines: w4, text: g3.toString(), top: h2[1], bottom: h2[1], left: h2[0], right: h2[0], writingMode: p4, iconsInText: false, verticalizable: false };
          return function(e5, r6, n4, i5, s5, a4, o4, l5, u4, c4, h3, p5) {
            let f3 = 0, d3 = iu, y5 = 0, m3 = 0;
            const g4 = "right" === l5 ? 1 : "left" === l5 ? 0 : 0.5;
            let x6 = 0;
            for (const o5 of s5) {
              o5.trim();
              const s6 = o5.getMaxScale(), l6 = (s6 - 1) * Sl, b5 = { positionedGlyphs: [], lineOffset: 0 };
              e5.positionedLines[x6] = b5;
              const w6 = b5.positionedGlyphs;
              let _4 = 0;
              if (!o5.length()) {
                d3 += a4, ++x6;
                continue;
              }
              for (let a5 = 0; a5 < o5.length(); a5++) {
                const y6 = o5.getSection(a5), m4 = o5.getSectionIndex(a5), g5 = o5.getCharCode(a5);
                let x7 = 0, b6 = null, A4 = null, S4 = null, k3 = Sl;
                const I3 = !(u4 === t2.ah.horizontal || !h3 && !Jn(g5) || h3 && (lu[g5] || (v5 = g5, Nn.Arabic(v5) || Nn["Arabic Supplement"](v5) || Nn["Arabic Extended-A"](v5) || Nn["Arabic Presentation Forms-A"](v5) || Nn["Arabic Presentation Forms-B"](v5))));
                if (y6.imageName) {
                  const t3 = i5[y6.imageName];
                  if (!t3)
                    continue;
                  S4 = y6.imageName, e5.iconsInText = e5.iconsInText || true, A4 = t3.paddedRect;
                  const r7 = t3.displaySize;
                  y6.scale = y6.scale * Sl / p5, b6 = { width: r7[0], height: r7[1], left: tu, top: -Wl, advance: I3 ? r7[1] : r7[0] }, x7 = l6 + (Sl - r7[1] * y6.scale), k3 = b6.advance;
                  const n5 = I3 ? r7[0] * y6.scale - Sl * s6 : r7[1] * y6.scale - Sl * s6;
                  n5 > 0 && n5 > _4 && (_4 = n5);
                } else {
                  const t3 = n4[y6.fontStack], e6 = t3 && t3[g5];
                  if (e6 && e6.rect)
                    A4 = e6.rect, b6 = e6.metrics;
                  else {
                    const t4 = r6[y6.fontStack], e7 = t4 && t4[g5];
                    if (!e7)
                      continue;
                    b6 = e7.metrics;
                  }
                  x7 = (s6 - y6.scale) * Sl;
                }
                I3 ? (e5.verticalizable = true, w6.push({ glyph: g5, imageName: S4, x: f3, y: d3 + x7, vertical: I3, scale: y6.scale, fontStack: y6.fontStack, sectionIndex: m4, metrics: b6, rect: A4 }), f3 += k3 * y6.scale + c4) : (w6.push({ glyph: g5, imageName: S4, x: f3, y: d3 + x7, vertical: I3, scale: y6.scale, fontStack: y6.fontStack, sectionIndex: m4, metrics: b6, rect: A4 }), f3 += b6.advance * y6.scale + c4);
              }
              0 !== w6.length && (y5 = Math.max(f3 - c4, y5), gu(w6, 0, w6.length - 1, g4, _4)), f3 = 0;
              const A3 = a4 * s6 + _4;
              b5.lineOffset = Math.max(_4, l6), d3 += A3, m3 = Math.max(A3, m3), ++x6;
            }
            var v5;
            const b4 = d3 - iu, { horizontalAlign: w5, verticalAlign: _3 } = mu(o4);
            (function(t3, e6, r7, n5, i6, s6, a5, o5, l6) {
              const u5 = (e6 - r7) * i6;
              let c5 = 0;
              c5 = s6 !== a5 ? -o5 * n5 - iu : (-n5 * l6 + 0.5) * a5;
              for (const e7 of t3)
                for (const t4 of e7.positionedGlyphs)
                  t4.x += u5, t4.y += c5;
            })(e5.positionedLines, g4, w5, _3, y5, m3, a4, b4, s5.length), e5.top += -_3 * b4, e5.bottom = e5.top + b4, e5.left += -w5 * y5, e5.right = e5.left + y5;
          }(_2, r5, n3, i4, x5, o3, l4, u3, p4, c3, f2, m2), !function(t3) {
            for (const e5 of t3)
              if (0 !== e5.positionedGlyphs.length)
                return false;
            return true;
          }(w4) && _2;
        }
        const lu = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, uu = { 10: true, 32: true, 38: true, 40: true, 41: true, 43: true, 45: true, 47: true, 173: true, 183: true, 8203: true, 8208: true, 8211: true, 8231: true };
        function cu(t3, e4, r5, n3, i4, s4) {
          if (e4.imageName) {
            const t4 = n3[e4.imageName];
            return t4 ? t4.displaySize[0] * e4.scale * Sl / s4 + i4 : 0;
          }
          {
            const n4 = r5[e4.fontStack], s5 = n4 && n4[t3];
            return s5 ? s5.metrics.advance * e4.scale + i4 : 0;
          }
        }
        function hu(t3, e4, r5, n3) {
          const i4 = Math.pow(t3 - e4, 2);
          return n3 ? t3 < e4 ? i4 / 2 : 2 * i4 : i4 + Math.abs(r5) * r5;
        }
        function pu(t3, e4, r5) {
          let n3 = 0;
          return 10 === t3 && (n3 -= 1e4), r5 && (n3 += 150), 40 !== t3 && 65288 !== t3 || (n3 += 50), 41 !== e4 && 65289 !== e4 || (n3 += 50), n3;
        }
        function fu(t3, e4, r5, n3, i4, s4) {
          let a3 = null, o3 = hu(e4, r5, i4, s4);
          for (const t4 of n3) {
            const n4 = hu(e4 - t4.x, r5, i4, s4) + t4.badness;
            n4 <= o3 && (a3 = t4, o3 = n4);
          }
          return { index: t3, x: e4, priorBreak: a3, badness: o3 };
        }
        function du(t3) {
          return t3 ? du(t3.priorBreak).concat(t3.index) : [];
        }
        function yu(t3, e4, r5, n3, i4, s4, a3) {
          if ("point" !== s4)
            return [];
          if (!t3)
            return [];
          const o3 = [], l4 = function(t4, e5, r6, n4, i5, s5) {
            let a4 = 0;
            for (let r7 = 0; r7 < t4.length(); r7++) {
              const o4 = t4.getSection(r7);
              a4 += cu(t4.getCharCode(r7), o4, n4, i5, e5, s5);
            }
            return a4 / Math.max(1, Math.ceil(a4 / r6));
          }(t3, e4, r5, n3, i4, a3), u3 = t3.text.indexOf("\u200B") >= 0;
          let c3 = 0;
          for (let r6 = 0; r6 < t3.length(); r6++) {
            const s5 = t3.getSection(r6), p4 = t3.getCharCode(r6);
            if (lu[p4] || (c3 += cu(p4, s5, n3, i4, e4, a3)), r6 < t3.length() - 1) {
              const e5 = !((h2 = p4) < 11904 || !(Nn["Bopomofo Extended"](h2) || Nn.Bopomofo(h2) || Nn["CJK Compatibility Forms"](h2) || Nn["CJK Compatibility Ideographs"](h2) || Nn["CJK Compatibility"](h2) || Nn["CJK Radicals Supplement"](h2) || Nn["CJK Strokes"](h2) || Nn["CJK Symbols and Punctuation"](h2) || Nn["CJK Unified Ideographs Extension A"](h2) || Nn["CJK Unified Ideographs"](h2) || Nn["Enclosed CJK Letters and Months"](h2) || Nn["Halfwidth and Fullwidth Forms"](h2) || Nn.Hiragana(h2) || Nn["Ideographic Description Characters"](h2) || Nn["Kangxi Radicals"](h2) || Nn["Katakana Phonetic Extensions"](h2) || Nn.Katakana(h2) || Nn["Vertical Forms"](h2) || Nn["Yi Radicals"](h2) || Nn["Yi Syllables"](h2)));
              (uu[p4] || e5 || s5.imageName) && o3.push(fu(r6 + 1, c3, l4, o3, pu(p4, t3.getCharCode(r6 + 1), e5 && u3), false));
            }
          }
          var h2;
          return du(fu(t3.length(), c3, l4, o3, 0, true));
        }
        function mu(t3) {
          let e4 = 0.5, r5 = 0.5;
          switch (t3) {
            case "right":
            case "top-right":
            case "bottom-right":
              e4 = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              e4 = 0;
          }
          switch (t3) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              r5 = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              r5 = 0;
          }
          return { horizontalAlign: e4, verticalAlign: r5 };
        }
        function gu(t3, e4, r5, n3, i4) {
          if (!n3 && !i4)
            return;
          const s4 = t3[r5], a3 = (t3[r5].x + s4.metrics.advance * s4.scale) * n3;
          for (let n4 = e4; n4 <= r5; n4++)
            t3[n4].x -= a3, t3[n4].y += i4;
        }
        function xu(t3, e4, r5) {
          const { horizontalAlign: n3, verticalAlign: i4 } = mu(r5), s4 = e4[0] - t3.displaySize[0] * n3, a3 = e4[1] - t3.displaySize[1] * i4;
          return { image: t3, top: a3, bottom: a3 + t3.displaySize[1], left: s4, right: s4 + t3.displaySize[0] };
        }
        function vu(t3, e4, r5, n3, i4, s4) {
          const a3 = t3.image;
          let o3;
          if (a3.content) {
            const t4 = a3.content, e5 = a3.pixelRatio || 1;
            o3 = [t4[0] / e5, t4[1] / e5, a3.displaySize[0] - t4[2] / e5, a3.displaySize[1] - t4[3] / e5];
          }
          const l4 = e4.left * s4, u3 = e4.right * s4;
          let c3, h2, p4, f2;
          "width" === r5 || "both" === r5 ? (f2 = i4[0] + l4 - n3[3], h2 = i4[0] + u3 + n3[1]) : (f2 = i4[0] + (l4 + u3 - a3.displaySize[0]) / 2, h2 = f2 + a3.displaySize[0]);
          const d2 = e4.top * s4, y4 = e4.bottom * s4;
          return "height" === r5 || "both" === r5 ? (c3 = i4[1] + d2 - n3[0], p4 = i4[1] + y4 + n3[2]) : (c3 = i4[1] + (d2 + y4 - a3.displaySize[1]) / 2, p4 = c3 + a3.displaySize[1]), { image: a3, top: c3, right: h2, bottom: p4, left: f2, collisionPadding: o3 };
        }
        const bu = 255, wu = 128, _u = bu * wu;
        function Au(t3, e4) {
          const { expression: r5 } = e4;
          if ("constant" === r5.kind)
            return { kind: "constant", layoutSize: r5.evaluate(new ti(t3 + 1)) };
          if ("source" === r5.kind)
            return { kind: "source" };
          {
            const { zoomStops: e5, interpolationType: n3 } = r5;
            let i4 = 0;
            for (; i4 < e5.length && e5[i4] <= t3; )
              i4++;
            i4 = Math.max(0, i4 - 1);
            let s4 = i4;
            for (; s4 < e5.length && e5[s4] < t3 + 1; )
              s4++;
            s4 = Math.min(e5.length - 1, s4);
            const a3 = e5[i4], o3 = e5[s4];
            return "composite" === r5.kind ? { kind: "composite", minZoom: a3, maxZoom: o3, interpolationType: n3 } : { kind: "camera", minZoom: a3, maxZoom: o3, minSize: r5.evaluate(new ti(a3)), maxSize: r5.evaluate(new ti(o3)), interpolationType: n3 };
          }
        }
        function Su(t3, e4, r5) {
          let n3 = "never";
          const i4 = t3.get(e4);
          return i4 ? n3 = i4 : t3.get(r5) && (n3 = "always"), n3;
        }
        const ku = Eo.VectorTileFeature.types, Iu = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
        function zu(t3, e4, r5, n3, i4, s4, a3, o3, l4, u3, c3, h2, p4) {
          const f2 = o3 ? Math.min(_u, Math.round(o3[0])) : 0, d2 = o3 ? Math.min(_u, Math.round(o3[1])) : 0;
          t3.emplaceBack(e4, r5, Math.round(32 * n3), Math.round(32 * i4), s4, a3, (f2 << 1) + (l4 ? 1 : 0), d2, 16 * u3, 16 * c3, 256 * h2, 256 * p4);
        }
        function Mu(t3, e4, r5) {
          t3.emplaceBack(e4.x, e4.y, r5), t3.emplaceBack(e4.x, e4.y, r5), t3.emplaceBack(e4.x, e4.y, r5), t3.emplaceBack(e4.x, e4.y, r5);
        }
        function Bu(t3) {
          for (const e4 of t3.sections)
            if (Wn(e4.text))
              return true;
          return false;
        }
        class Cu {
          constructor(t3) {
            this.layoutVertexArray = new cs(), this.indexArray = new ys(), this.programConfigurations = t3, this.segments = new vs(), this.dynamicLayoutVertexArray = new hs(), this.opacityVertexArray = new ps(), this.hasVisibleVertices = false, this.placedSymbolArray = new Ji();
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;
          }
          upload(t3, e4, r5, n3) {
            this.isEmpty() || (r5 && (this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, gl.members), this.indexBuffer = t3.createIndexBuffer(this.indexArray, e4), this.dynamicLayoutVertexBuffer = t3.createVertexBuffer(this.dynamicLayoutVertexArray, xl.members, true), this.opacityVertexBuffer = t3.createVertexBuffer(this.opacityVertexArray, Iu, true), this.opacityVertexBuffer.itemSize = 1), (r5 || n3) && this.programConfigurations.upload(t3));
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
          }
        }
        On("SymbolBuffers", Cu);
        class Pu {
          constructor(t3, e4, r5) {
            this.layoutVertexArray = new t3(), this.layoutAttributes = e4, this.indexArray = new r5(), this.segments = new vs(), this.collisionVertexArray = new ds();
          }
          upload(t3) {
            this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t3.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t3.createVertexBuffer(this.collisionVertexArray, vl.members, true);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
          }
        }
        On("CollisionBuffers", Pu);
        class Vu {
          constructor(e4) {
            this.collisionBoxArray = e4.collisionBoxArray, this.zoom = e4.zoom, this.overscaling = e4.overscaling, this.layers = e4.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = e4.index, this.pixelRatio = e4.pixelRatio, this.sourceLayerIndex = e4.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = ba2([]), this.placementViewportMatrix = ba2([]);
            const r5 = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = Au(this.zoom, r5["text-size"]), this.iconSizeData = Au(this.zoom, r5["icon-size"]);
            const n3 = this.layers[0].layout, i4 = n3.get("symbol-sort-key"), s4 = n3.get("symbol-z-order");
            this.canOverlap = "never" !== Su(n3, "text-overlap", "text-allow-overlap") || "never" !== Su(n3, "icon-overlap", "icon-allow-overlap") || n3.get("text-ignore-placement") || n3.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== s4 && !i4.isConstant(), this.sortFeaturesByY = ("viewport-y" === s4 || "auto" === s4 && !this.sortFeaturesByKey) && this.canOverlap, "point" === n3.get("symbol-placement") && (this.writingModes = n3.get("text-writing-mode").map((e5) => t2.ah[e5])), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.sourceID = e4.sourceID;
          }
          createArrays() {
            this.text = new Cu(new Zs(this.layers, this.zoom, (t3) => /^text/.test(t3))), this.icon = new Cu(new Zs(this.layers, this.zoom, (t3) => /^icon/.test(t3))), this.glyphOffsetArray = new Yi(), this.lineVertexArray = new Wi(), this.symbolInstances = new Hi(), this.textAnchorOffsets = new ts();
          }
          calculateGlyphDependencies(t3, e4, r5, n3, i4) {
            for (let s4 = 0; s4 < t3.length; s4++)
              if (e4[t3.charCodeAt(s4)] = true, (r5 || n3) && i4) {
                const r6 = Al[t3.charAt(s4)];
                r6 && (e4[r6.charCodeAt(0)] = true);
              }
          }
          populate(e4, r5, n3) {
            const i4 = this.layers[0], s4 = i4.layout, a3 = s4.get("text-font"), o3 = s4.get("text-field"), l4 = s4.get("icon-image"), u3 = ("constant" !== o3.value.kind || o3.value.value instanceof Yt && !o3.value.value.isEmpty() || o3.value.value.toString().length > 0) && ("constant" !== a3.value.kind || a3.value.value.length > 0), c3 = "constant" !== l4.value.kind || !!l4.value.value || Object.keys(l4.parameters).length > 0, h2 = s4.get("symbol-sort-key");
            if (this.features = [], !u3 && !c3)
              return;
            const p4 = r5.iconDependencies, f2 = r5.glyphDependencies, d2 = r5.availableImages, y4 = new ti(this.zoom);
            for (const { feature: r6, id: o4, index: l5, sourceLayerIndex: m2 } of e4) {
              const e5 = i4._featureFilter.needGeometry, g3 = Ws(r6, e5);
              if (!i4._featureFilter.filter(y4, g3, n3))
                continue;
              let x5, v4;
              if (e5 || (g3.geometry = Ys(r6)), u3) {
                const t3 = i4.getValueAndResolveTokens("text-field", g3, n3, d2), e6 = Yt.factory(t3);
                Bu(e6) && (this.hasRTLText = true), (!this.hasRTLText || "unavailable" === Qn.getRTLTextPluginStatus() || this.hasRTLText && Qn.isParsed()) && (x5 = _l(e6, i4, g3));
              }
              if (c3) {
                const t3 = i4.getValueAndResolveTokens("icon-image", g3, n3, d2);
                v4 = t3 instanceof ee2 ? t3 : ee2.fromString(t3);
              }
              if (!x5 && !v4)
                continue;
              const b3 = this.sortFeaturesByKey ? h2.evaluate(g3, {}, n3) : void 0;
              if (this.features.push({ id: o4, text: x5, icon: v4, index: l5, sourceLayerIndex: m2, geometry: g3.geometry, properties: r6.properties, type: ku[r6.type], sortKey: b3 }), v4 && (p4[v4.name] = true), x5) {
                const e6 = a3.evaluate(g3, {}, n3).join(","), r7 = "viewport" !== s4.get("text-rotation-alignment") && "point" !== s4.get("symbol-placement");
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(t2.ah.vertical) >= 0;
                for (const t3 of x5.sections)
                  if (t3.image)
                    p4[t3.image.name] = true;
                  else {
                    const n4 = Zn(x5.toString()), i5 = t3.fontStack || e6, s5 = f2[i5] = f2[i5] || {};
                    this.calculateGlyphDependencies(t3.text, s5, r7, this.allowVerticalPlacement, n4);
                  }
              }
            }
            "line" === s4.get("symbol-placement") && (this.features = function(t3) {
              const e5 = {}, r6 = {}, n4 = [];
              let i5 = 0;
              function s5(e6) {
                n4.push(t3[e6]), i5++;
              }
              function a4(t4, e6, i6) {
                const s6 = r6[t4];
                return delete r6[t4], r6[e6] = s6, n4[s6].geometry[0].pop(), n4[s6].geometry[0] = n4[s6].geometry[0].concat(i6[0]), s6;
              }
              function o4(t4, r7, i6) {
                const s6 = e5[r7];
                return delete e5[r7], e5[t4] = s6, n4[s6].geometry[0].shift(), n4[s6].geometry[0] = i6[0].concat(n4[s6].geometry[0]), s6;
              }
              function l5(t4, e6, r7) {
                const n5 = r7 ? e6[0][e6[0].length - 1] : e6[0][0];
                return `${t4}:${n5.x}:${n5.y}`;
              }
              for (let u4 = 0; u4 < t3.length; u4++) {
                const c4 = t3[u4], h3 = c4.geometry, p5 = c4.text ? c4.text.toString() : null;
                if (!p5) {
                  s5(u4);
                  continue;
                }
                const f3 = l5(p5, h3), d3 = l5(p5, h3, true);
                if (f3 in r6 && d3 in e5 && r6[f3] !== e5[d3]) {
                  const t4 = o4(f3, d3, h3), i6 = a4(f3, d3, n4[t4].geometry);
                  delete e5[f3], delete r6[d3], r6[l5(p5, n4[i6].geometry, true)] = i6, n4[t4].geometry = null;
                } else
                  f3 in r6 ? a4(f3, d3, h3) : d3 in e5 ? o4(f3, d3, h3) : (s5(u4), e5[f3] = i5 - 1, r6[d3] = i5 - 1);
              }
              return n4.filter((t4) => t4.geometry);
            }(this.features)), this.sortFeaturesByKey && this.features.sort((t3, e5) => t3.sortKey - e5.sortKey);
          }
          update(t3, e4, r5) {
            this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t3, e4, this.layers, r5), this.icon.programConfigurations.updatePaintArrays(t3, e4, this.layers, r5));
          }
          isEmpty() {
            return 0 === this.symbolInstances.length && !this.hasRTLText;
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
          }
          upload(t3) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t3), this.iconCollisionBox.upload(t3)), this.text.upload(t3, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t3, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
          }
          addToLineVertexArray(t3, e4) {
            const r5 = this.lineVertexArray.length;
            if (void 0 !== t3.segment) {
              let r6 = t3.dist(e4[t3.segment + 1]), n3 = t3.dist(e4[t3.segment]);
              const i4 = {};
              for (let n4 = t3.segment + 1; n4 < e4.length; n4++)
                i4[n4] = { x: e4[n4].x, y: e4[n4].y, tileUnitDistanceFromAnchor: r6 }, n4 < e4.length - 1 && (r6 += e4[n4 + 1].dist(e4[n4]));
              for (let r7 = t3.segment || 0; r7 >= 0; r7--)
                i4[r7] = { x: e4[r7].x, y: e4[r7].y, tileUnitDistanceFromAnchor: n3 }, r7 > 0 && (n3 += e4[r7 - 1].dist(e4[r7]));
              for (let t4 = 0; t4 < e4.length; t4++) {
                const e5 = i4[t4];
                this.lineVertexArray.emplaceBack(e5.x, e5.y, e5.tileUnitDistanceFromAnchor);
              }
            }
            return { lineStartIndex: r5, lineLength: this.lineVertexArray.length - r5 };
          }
          addSymbols(e4, r5, n3, i4, s4, a3, o3, l4, u3, c3, h2, p4) {
            const f2 = e4.indexArray, d2 = e4.layoutVertexArray, y4 = e4.segments.prepareSegment(4 * r5.length, d2, f2, this.canOverlap ? a3.sortKey : void 0), m2 = this.glyphOffsetArray.length, g3 = y4.vertexLength, x5 = this.allowVerticalPlacement && o3 === t2.ah.vertical ? Math.PI / 2 : 0, v4 = a3.text && a3.text.sections;
            for (let t3 = 0; t3 < r5.length; t3++) {
              const { tl: i5, tr: s5, bl: o4, br: u4, tex: c4, pixelOffsetTL: h3, pixelOffsetBR: m3, minFontScaleX: g4, minFontScaleY: b3, glyphOffset: w4, isSDF: _2, sectionIndex: A3 } = r5[t3], S4 = y4.vertexLength, k3 = w4[1];
              zu(d2, l4.x, l4.y, i5.x, k3 + i5.y, c4.x, c4.y, n3, _2, h3.x, h3.y, g4, b3), zu(d2, l4.x, l4.y, s5.x, k3 + s5.y, c4.x + c4.w, c4.y, n3, _2, m3.x, h3.y, g4, b3), zu(d2, l4.x, l4.y, o4.x, k3 + o4.y, c4.x, c4.y + c4.h, n3, _2, h3.x, m3.y, g4, b3), zu(d2, l4.x, l4.y, u4.x, k3 + u4.y, c4.x + c4.w, c4.y + c4.h, n3, _2, m3.x, m3.y, g4, b3), Mu(e4.dynamicLayoutVertexArray, l4, x5), f2.emplaceBack(S4, S4 + 1, S4 + 2), f2.emplaceBack(S4 + 1, S4 + 2, S4 + 3), y4.vertexLength += 4, y4.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(w4[0]), t3 !== r5.length - 1 && A3 === r5[t3 + 1].sectionIndex || e4.programConfigurations.populatePaintArrays(d2.length, a3, a3.index, {}, p4, v4 && v4[A3]);
            }
            e4.placedSymbolArray.emplaceBack(l4.x, l4.y, m2, this.glyphOffsetArray.length - m2, g3, u3, c3, l4.segment, n3 ? n3[0] : 0, n3 ? n3[1] : 0, i4[0], i4[1], o3, 0, false, 0, h2);
          }
          _addCollisionDebugVertex(t3, e4, r5, n3, i4, s4) {
            return e4.emplaceBack(0, 0), t3.emplaceBack(r5.x, r5.y, n3, i4, Math.round(s4.x), Math.round(s4.y));
          }
          addCollisionDebugVertices(t3, e4, r5, n3, i4, a3, o3) {
            const l4 = i4.segments.prepareSegment(4, i4.layoutVertexArray, i4.indexArray), u3 = l4.vertexLength, c3 = i4.layoutVertexArray, h2 = i4.collisionVertexArray, p4 = o3.anchorX, f2 = o3.anchorY;
            this._addCollisionDebugVertex(c3, h2, a3, p4, f2, new s3(t3, e4)), this._addCollisionDebugVertex(c3, h2, a3, p4, f2, new s3(r5, e4)), this._addCollisionDebugVertex(c3, h2, a3, p4, f2, new s3(r5, n3)), this._addCollisionDebugVertex(c3, h2, a3, p4, f2, new s3(t3, n3)), l4.vertexLength += 4;
            const d2 = i4.indexArray;
            d2.emplaceBack(u3, u3 + 1), d2.emplaceBack(u3 + 1, u3 + 2), d2.emplaceBack(u3 + 2, u3 + 3), d2.emplaceBack(u3 + 3, u3), l4.primitiveLength += 4;
          }
          addDebugCollisionBoxes(t3, e4, r5, n3) {
            for (let i4 = t3; i4 < e4; i4++) {
              const t4 = this.collisionBoxArray.get(i4);
              this.addCollisionDebugVertices(t4.x1, t4.y1, t4.x2, t4.y2, n3 ? this.textCollisionBox : this.iconCollisionBox, t4.anchorPoint, r5);
            }
          }
          generateCollisionDebugBuffers() {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Pu(fs, bl.members, ms), this.iconCollisionBox = new Pu(fs, bl.members, ms);
            for (let t3 = 0; t3 < this.symbolInstances.length; t3++) {
              const e4 = this.symbolInstances.get(t3);
              this.addDebugCollisionBoxes(e4.textBoxStartIndex, e4.textBoxEndIndex, e4, true), this.addDebugCollisionBoxes(e4.verticalTextBoxStartIndex, e4.verticalTextBoxEndIndex, e4, true), this.addDebugCollisionBoxes(e4.iconBoxStartIndex, e4.iconBoxEndIndex, e4, false), this.addDebugCollisionBoxes(e4.verticalIconBoxStartIndex, e4.verticalIconBoxEndIndex, e4, false);
            }
          }
          _deserializeCollisionBoxesForSymbol(t3, e4, r5, n3, i4, s4, a3, o3, l4) {
            const u3 = {};
            for (let n4 = e4; n4 < r5; n4++) {
              const e5 = t3.get(n4);
              u3.textBox = { x1: e5.x1, y1: e5.y1, x2: e5.x2, y2: e5.y2, anchorPointX: e5.anchorPointX, anchorPointY: e5.anchorPointY }, u3.textFeatureIndex = e5.featureIndex;
              break;
            }
            for (let e5 = n3; e5 < i4; e5++) {
              const r6 = t3.get(e5);
              u3.verticalTextBox = { x1: r6.x1, y1: r6.y1, x2: r6.x2, y2: r6.y2, anchorPointX: r6.anchorPointX, anchorPointY: r6.anchorPointY }, u3.verticalTextFeatureIndex = r6.featureIndex;
              break;
            }
            for (let e5 = s4; e5 < a3; e5++) {
              const r6 = t3.get(e5);
              u3.iconBox = { x1: r6.x1, y1: r6.y1, x2: r6.x2, y2: r6.y2, anchorPointX: r6.anchorPointX, anchorPointY: r6.anchorPointY }, u3.iconFeatureIndex = r6.featureIndex;
              break;
            }
            for (let e5 = o3; e5 < l4; e5++) {
              const r6 = t3.get(e5);
              u3.verticalIconBox = { x1: r6.x1, y1: r6.y1, x2: r6.x2, y2: r6.y2, anchorPointX: r6.anchorPointX, anchorPointY: r6.anchorPointY }, u3.verticalIconFeatureIndex = r6.featureIndex;
              break;
            }
            return u3;
          }
          deserializeCollisionBoxes(t3) {
            this.collisionArrays = [];
            for (let e4 = 0; e4 < this.symbolInstances.length; e4++) {
              const r5 = this.symbolInstances.get(e4);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t3, r5.textBoxStartIndex, r5.textBoxEndIndex, r5.verticalTextBoxStartIndex, r5.verticalTextBoxEndIndex, r5.iconBoxStartIndex, r5.iconBoxEndIndex, r5.verticalIconBoxStartIndex, r5.verticalIconBoxEndIndex));
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0;
          }
          hasIconData() {
            return this.icon.segments.get().length > 0;
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox;
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
          }
          addIndicesForPlacedSymbol(t3, e4) {
            const r5 = t3.placedSymbolArray.get(e4), n3 = r5.vertexStartIndex + 4 * r5.numGlyphs;
            for (let e5 = r5.vertexStartIndex; e5 < n3; e5 += 4)
              t3.indexArray.emplaceBack(e5, e5 + 1, e5 + 2), t3.indexArray.emplaceBack(e5 + 1, e5 + 2, e5 + 3);
          }
          getSortedSymbolIndexes(t3) {
            if (this.sortedAngle === t3 && void 0 !== this.symbolInstanceIndexes)
              return this.symbolInstanceIndexes;
            const e4 = Math.sin(t3), r5 = Math.cos(t3), n3 = [], i4 = [], s4 = [];
            for (let t4 = 0; t4 < this.symbolInstances.length; ++t4) {
              s4.push(t4);
              const a3 = this.symbolInstances.get(t4);
              n3.push(0 | Math.round(e4 * a3.anchorX + r5 * a3.anchorY)), i4.push(a3.featureIndex);
            }
            return s4.sort((t4, e5) => n3[t4] - n3[e5] || i4[e5] - i4[t4]), s4;
          }
          addToSortKeyRanges(t3, e4) {
            const r5 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            r5 && r5.sortKey === e4 ? r5.symbolInstanceEnd = t3 + 1 : this.sortKeyRanges.push({ sortKey: e4, symbolInstanceStart: t3, symbolInstanceEnd: t3 + 1 });
          }
          sortFeatures(t3) {
            if (this.sortFeaturesByY && this.sortedAngle !== t3 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t3), this.sortedAngle = t3, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const t4 of this.symbolInstanceIndexes) {
                const e4 = this.symbolInstances.get(t4);
                this.featureSortOrder.push(e4.featureIndex), [e4.rightJustifiedTextSymbolIndex, e4.centerJustifiedTextSymbolIndex, e4.leftJustifiedTextSymbolIndex].forEach((t5, e5, r5) => {
                  t5 >= 0 && r5.indexOf(t5) === e5 && this.addIndicesForPlacedSymbol(this.text, t5);
                }), e4.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, e4.verticalPlacedTextSymbolIndex), e4.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e4.placedIconSymbolIndex), e4.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e4.verticalPlacedIconSymbolIndex);
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
            }
          }
        }
        let Eu, Fu;
        On("SymbolBucket", Vu, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), Vu.MAX_GLYPHS = 65535, Vu.addDynamicAttributes = Mu;
        var Tu = { get paint() {
          return Fu = Fu || new di({ "icon-opacity": new ci(G2.paint_symbol["icon-opacity"]), "icon-color": new ci(G2.paint_symbol["icon-color"]), "icon-halo-color": new ci(G2.paint_symbol["icon-halo-color"]), "icon-halo-width": new ci(G2.paint_symbol["icon-halo-width"]), "icon-halo-blur": new ci(G2.paint_symbol["icon-halo-blur"]), "icon-translate": new ui(G2.paint_symbol["icon-translate"]), "icon-translate-anchor": new ui(G2.paint_symbol["icon-translate-anchor"]), "text-opacity": new ci(G2.paint_symbol["text-opacity"]), "text-color": new ci(G2.paint_symbol["text-color"], { runtimeType: ft, getOverride: (t3) => t3.textColor, hasOverride: (t3) => !!t3.textColor }), "text-halo-color": new ci(G2.paint_symbol["text-halo-color"]), "text-halo-width": new ci(G2.paint_symbol["text-halo-width"]), "text-halo-blur": new ci(G2.paint_symbol["text-halo-blur"]), "text-translate": new ui(G2.paint_symbol["text-translate"]), "text-translate-anchor": new ui(G2.paint_symbol["text-translate-anchor"]) });
        }, get layout() {
          return Eu = Eu || new di({ "symbol-placement": new ui(G2.layout_symbol["symbol-placement"]), "symbol-spacing": new ui(G2.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new ui(G2.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new ci(G2.layout_symbol["symbol-sort-key"]), "symbol-z-order": new ui(G2.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new ui(G2.layout_symbol["icon-allow-overlap"]), "icon-overlap": new ui(G2.layout_symbol["icon-overlap"]), "icon-ignore-placement": new ui(G2.layout_symbol["icon-ignore-placement"]), "icon-optional": new ui(G2.layout_symbol["icon-optional"]), "icon-rotation-alignment": new ui(G2.layout_symbol["icon-rotation-alignment"]), "icon-size": new ci(G2.layout_symbol["icon-size"]), "icon-text-fit": new ui(G2.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new ui(G2.layout_symbol["icon-text-fit-padding"]), "icon-image": new ci(G2.layout_symbol["icon-image"]), "icon-rotate": new ci(G2.layout_symbol["icon-rotate"]), "icon-padding": new ci(G2.layout_symbol["icon-padding"]), "icon-keep-upright": new ui(G2.layout_symbol["icon-keep-upright"]), "icon-offset": new ci(G2.layout_symbol["icon-offset"]), "icon-anchor": new ci(G2.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new ui(G2.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new ui(G2.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new ui(G2.layout_symbol["text-rotation-alignment"]), "text-field": new ci(G2.layout_symbol["text-field"]), "text-font": new ci(G2.layout_symbol["text-font"]), "text-size": new ci(G2.layout_symbol["text-size"]), "text-max-width": new ci(G2.layout_symbol["text-max-width"]), "text-line-height": new ui(G2.layout_symbol["text-line-height"]), "text-letter-spacing": new ci(G2.layout_symbol["text-letter-spacing"]), "text-justify": new ci(G2.layout_symbol["text-justify"]), "text-radial-offset": new ci(G2.layout_symbol["text-radial-offset"]), "text-variable-anchor": new ui(G2.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new ci(G2.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new ci(G2.layout_symbol["text-anchor"]), "text-max-angle": new ui(G2.layout_symbol["text-max-angle"]), "text-writing-mode": new ui(G2.layout_symbol["text-writing-mode"]), "text-rotate": new ci(G2.layout_symbol["text-rotate"]), "text-padding": new ui(G2.layout_symbol["text-padding"]), "text-keep-upright": new ui(G2.layout_symbol["text-keep-upright"]), "text-transform": new ci(G2.layout_symbol["text-transform"]), "text-offset": new ci(G2.layout_symbol["text-offset"]), "text-allow-overlap": new ui(G2.layout_symbol["text-allow-overlap"]), "text-overlap": new ui(G2.layout_symbol["text-overlap"]), "text-ignore-placement": new ui(G2.layout_symbol["text-ignore-placement"]), "text-optional": new ui(G2.layout_symbol["text-optional"]) });
        } };
        class $u {
          constructor(t3) {
            if (void 0 === t3.property.overrides)
              throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
            this.type = t3.property.overrides ? t3.property.overrides.runtimeType : ut, this.defaultValue = t3;
          }
          evaluate(t3) {
            if (t3.formattedSection) {
              const e4 = this.defaultValue.property.overrides;
              if (e4 && e4.hasOverride(t3.formattedSection))
                return e4.getOverride(t3.formattedSection);
            }
            return t3.feature && t3.featureState ? this.defaultValue.evaluate(t3.feature, t3.featureState) : this.defaultValue.property.specification.default;
          }
          eachChild(t3) {
            this.defaultValue.isConstant() || t3(this.defaultValue.value._styleExpression.expression);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return null;
          }
        }
        On("FormatSectionOverride", $u, { omit: ["defaultValue"] });
        class Du extends mi {
          constructor(t3) {
            super(t3, Tu);
          }
          recalculate(t3, e4) {
            if (super.recalculate(t3, e4), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = "map" === this.layout.get("text-rotation-alignment") ? "map" : "viewport"), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), "point" === this.layout.get("symbol-placement")) {
              const t4 = this.layout.get("text-writing-mode");
              if (t4) {
                const e5 = [];
                for (const r5 of t4)
                  e5.indexOf(r5) < 0 && e5.push(r5);
                this.layout._values["text-writing-mode"] = e5;
              } else
                this.layout._values["text-writing-mode"] = ["horizontal"];
            }
            this._setPaintOverrides();
          }
          getValueAndResolveTokens(t3, e4, r5, n3) {
            const i4 = this.layout.get(t3).evaluate(e4, {}, r5, n3), s4 = this._unevaluatedLayout._values[t3];
            return s4.isDataDriven() || Dr(s4.value) || !i4 ? i4 : function(t4, e5) {
              return e5.replace(/{([^{}]+)}/g, (e6, r6) => t4 && r6 in t4 ? String(t4[r6]) : "");
            }(e4.properties, i4);
          }
          createBucket(t3) {
            return new Vu(t3);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            throw new Error("Should take a different path in FeatureIndex");
          }
          _setPaintOverrides() {
            for (const t3 of Tu.paint.overridableProperties) {
              if (!Du.hasPaintOverride(this.layout, t3))
                continue;
              const e4 = this.paint.get(t3), r5 = new $u(e4), n3 = new $r(r5, e4.property.specification);
              let i4 = null;
              i4 = "constant" === e4.value.kind || "source" === e4.value.kind ? new Or("source", n3) : new Rr("composite", n3, e4.value.zoomStops), this.paint._values[t3] = new oi(e4.property, i4, e4.parameters);
            }
          }
          _handleOverridablePaintPropertyUpdate(t3, e4, r5) {
            return !(!this.layout || e4.isDataDriven() || r5.isDataDriven()) && Du.hasPaintOverride(this.layout, t3);
          }
          static hasPaintOverride(t3, e4) {
            const r5 = t3.get("text-field"), n3 = Tu.paint.properties[e4];
            let i4 = false;
            const s4 = (t4) => {
              for (const e5 of t4)
                if (n3.overrides && n3.overrides.hasOverride(e5))
                  return void (i4 = true);
            };
            if ("constant" === r5.value.kind && r5.value.value instanceof Yt)
              s4(r5.value.value.sections);
            else if ("source" === r5.value.kind) {
              const t4 = (e6) => {
                i4 || (e6 instanceof ae3 && ie3(e6.value) === gt ? s4(e6.value.sections) : e6 instanceof dr ? s4(e6.sections) : e6.eachChild(t4));
              }, e5 = r5.value;
              e5._styleExpression && t4(e5._styleExpression.expression);
            }
            return i4;
          }
        }
        let Lu;
        var Ou = { get paint() {
          return Lu = Lu || new di({ "background-color": new ui(G2.paint_background["background-color"]), "background-pattern": new pi(G2.paint_background["background-pattern"]), "background-opacity": new ui(G2.paint_background["background-opacity"]) });
        } };
        class Ru extends mi {
          constructor(t3) {
            super(t3, Ou);
          }
        }
        let Uu;
        var ju = { get paint() {
          return Uu = Uu || new di({ "raster-opacity": new ui(G2.paint_raster["raster-opacity"]), "raster-hue-rotate": new ui(G2.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new ui(G2.paint_raster["raster-brightness-min"]), "raster-brightness-max": new ui(G2.paint_raster["raster-brightness-max"]), "raster-saturation": new ui(G2.paint_raster["raster-saturation"]), "raster-contrast": new ui(G2.paint_raster["raster-contrast"]), "raster-resampling": new ui(G2.paint_raster["raster-resampling"]), "raster-fade-duration": new ui(G2.paint_raster["raster-fade-duration"]) });
        } };
        class qu extends mi {
          constructor(t3) {
            super(t3, ju);
          }
        }
        class Nu extends mi {
          constructor(t3) {
            super(t3, {}), this.onAdd = (t4) => {
              this.implementation.onAdd && this.implementation.onAdd(t4, t4.painter.context.gl);
            }, this.onRemove = (t4) => {
              this.implementation.onRemove && this.implementation.onRemove(t4, t4.painter.context.gl);
            }, this.implementation = t3;
          }
          is3D() {
            return "3d" === this.implementation.renderingMode;
          }
          hasOffscreenPass() {
            return void 0 !== this.implementation.prerender;
          }
          recalculate() {
          }
          updateTransitions() {
          }
          hasTransition() {
            return false;
          }
          serialize() {
            throw new Error("Custom layers cannot be serialized");
          }
        }
        class Zu {
          constructor(t3) {
            this._methodToThrottle = t3, this._triggered = false, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
              this._triggered = false, this._methodToThrottle();
            });
          }
          trigger() {
            this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(() => {
              this._triggered = false, this._methodToThrottle();
            }, 0));
          }
          remove() {
            delete this._channel, this._methodToThrottle = () => {
            };
          }
        }
        const Ku = 63710088e-1;
        class Gu {
          constructor(t3, e4) {
            if (isNaN(t3) || isNaN(e4))
              throw new Error(`Invalid LngLat object: (${t3}, ${e4})`);
            if (this.lng = +t3, this.lat = +e4, this.lat > 90 || this.lat < -90)
              throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
          }
          wrap() {
            return new Gu(m(this.lng, -180, 180), this.lat);
          }
          toArray() {
            return [this.lng, this.lat];
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`;
          }
          distanceTo(t3) {
            const e4 = Math.PI / 180, r5 = this.lat * e4, n3 = t3.lat * e4, i4 = Math.sin(r5) * Math.sin(n3) + Math.cos(r5) * Math.cos(n3) * Math.cos((t3.lng - this.lng) * e4);
            return Ku * Math.acos(Math.min(i4, 1));
          }
          static convert(t3) {
            if (t3 instanceof Gu)
              return t3;
            if (Array.isArray(t3) && (2 === t3.length || 3 === t3.length))
              return new Gu(Number(t3[0]), Number(t3[1]));
            if (!Array.isArray(t3) && "object" == typeof t3 && null !== t3)
              return new Gu(Number("lng" in t3 ? t3.lng : t3.lon), Number(t3.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
          }
        }
        const Ju = 2 * Math.PI * Ku;
        function Xu(t3) {
          return Ju * Math.cos(t3 * Math.PI / 180);
        }
        function Hu(t3) {
          return (180 + t3) / 360;
        }
        function Yu(t3) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t3 * Math.PI / 360))) / 360;
        }
        function Wu(t3, e4) {
          return t3 / Xu(e4);
        }
        function Qu(t3) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t3) * Math.PI / 180)) - 90;
        }
        class tc2 {
          constructor(t3, e4, r5 = 0) {
            this.x = +t3, this.y = +e4, this.z = +r5;
          }
          static fromLngLat(t3, e4 = 0) {
            const r5 = Gu.convert(t3);
            return new tc2(Hu(r5.lng), Yu(r5.lat), Wu(e4, r5.lat));
          }
          toLngLat() {
            return new Gu(360 * this.x - 180, Qu(this.y));
          }
          toAltitude() {
            return this.z * Xu(Qu(this.y));
          }
          meterInMercatorCoordinateUnits() {
            return 1 / Ju * (t3 = Qu(this.y), 1 / Math.cos(t3 * Math.PI / 180));
            var t3;
          }
        }
        function ec2(t3, e4, r5) {
          var n3 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r5);
          return [t3 * n3 - 2 * Math.PI * 6378137 / 2, e4 * n3 - 2 * Math.PI * 6378137 / 2];
        }
        class rc2 {
          constructor(t3, e4, r5) {
            if (t3 < 0 || t3 > 25 || r5 < 0 || r5 >= Math.pow(2, t3) || e4 < 0 || e4 >= Math.pow(2, t3))
              throw new Error(`x=${e4}, y=${r5}, z=${t3} outside of bounds. 0<=x<${Math.pow(2, t3)}, 0<=y<${Math.pow(2, t3)} 0<=z<=25 `);
            this.z = t3, this.x = e4, this.y = r5, this.key = sc2(0, t3, t3, e4, r5);
          }
          equals(t3) {
            return this.z === t3.z && this.x === t3.x && this.y === t3.y;
          }
          url(t3, e4, r5) {
            const n3 = (s4 = this.y, a3 = this.z, o3 = ec2(256 * (i4 = this.x), 256 * (s4 = Math.pow(2, a3) - s4 - 1), a3), l4 = ec2(256 * (i4 + 1), 256 * (s4 + 1), a3), o3[0] + "," + o3[1] + "," + l4[0] + "," + l4[1]);
            var i4, s4, a3, o3, l4;
            const u3 = function(t4, e5, r6) {
              let n4, i5 = "";
              for (let s5 = t4; s5 > 0; s5--)
                n4 = 1 << s5 - 1, i5 += (e5 & n4 ? 1 : 0) + (r6 & n4 ? 2 : 0);
              return i5;
            }(this.z, this.x, this.y);
            return t3[(this.x + this.y) % t3.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === r5 ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, e4 > 1 ? "@2x" : "").replace(/{quadkey}/g, u3).replace(/{bbox-epsg-3857}/g, n3);
          }
          isChildOf(t3) {
            const e4 = this.z - t3.z;
            return e4 > 0 && t3.x === this.x >> e4 && t3.y === this.y >> e4;
          }
          getTilePoint(t3) {
            const e4 = Math.pow(2, this.z);
            return new s3((t3.x * e4 - this.x) * Js, (t3.y * e4 - this.y) * Js);
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`;
          }
        }
        class nc2 {
          constructor(t3, e4) {
            this.wrap = t3, this.canonical = e4, this.key = sc2(t3, e4.z, e4.z, e4.x, e4.y);
          }
        }
        class ic2 {
          constructor(t3, e4, r5, n3, i4) {
            if (t3 < r5)
              throw new Error(`overscaledZ should be >= z; overscaledZ = ${t3}; z = ${r5}`);
            this.overscaledZ = t3, this.wrap = e4, this.canonical = new rc2(r5, +n3, +i4), this.key = sc2(e4, t3, r5, n3, i4);
          }
          clone() {
            return new ic2(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          equals(t3) {
            return this.overscaledZ === t3.overscaledZ && this.wrap === t3.wrap && this.canonical.equals(t3.canonical);
          }
          scaledTo(t3) {
            if (t3 > this.overscaledZ)
              throw new Error(`targetZ > this.overscaledZ; targetZ = ${t3}; overscaledZ = ${this.overscaledZ}`);
            const e4 = this.canonical.z - t3;
            return t3 > this.canonical.z ? new ic2(t3, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new ic2(t3, this.wrap, t3, this.canonical.x >> e4, this.canonical.y >> e4);
          }
          calculateScaledKey(t3, e4) {
            if (t3 > this.overscaledZ)
              throw new Error(`targetZ > this.overscaledZ; targetZ = ${t3}; overscaledZ = ${this.overscaledZ}`);
            const r5 = this.canonical.z - t3;
            return t3 > this.canonical.z ? sc2(this.wrap * +e4, t3, this.canonical.z, this.canonical.x, this.canonical.y) : sc2(this.wrap * +e4, t3, t3, this.canonical.x >> r5, this.canonical.y >> r5);
          }
          isChildOf(t3) {
            if (t3.wrap !== this.wrap)
              return false;
            const e4 = this.canonical.z - t3.canonical.z;
            return 0 === t3.overscaledZ || t3.overscaledZ < this.overscaledZ && t3.canonical.x === this.canonical.x >> e4 && t3.canonical.y === this.canonical.y >> e4;
          }
          children(t3) {
            if (this.overscaledZ >= t3)
              return [new ic2(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const e4 = this.canonical.z + 1, r5 = 2 * this.canonical.x, n3 = 2 * this.canonical.y;
            return [new ic2(e4, this.wrap, e4, r5, n3), new ic2(e4, this.wrap, e4, r5 + 1, n3), new ic2(e4, this.wrap, e4, r5, n3 + 1), new ic2(e4, this.wrap, e4, r5 + 1, n3 + 1)];
          }
          isLessThan(t3) {
            return this.wrap < t3.wrap || !(this.wrap > t3.wrap) && (this.overscaledZ < t3.overscaledZ || !(this.overscaledZ > t3.overscaledZ) && (this.canonical.x < t3.canonical.x || !(this.canonical.x > t3.canonical.x) && this.canonical.y < t3.canonical.y));
          }
          wrapped() {
            return new ic2(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          unwrapTo(t3) {
            return new ic2(this.overscaledZ, t3, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z);
          }
          toUnwrapped() {
            return new nc2(this.wrap, this.canonical);
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
          }
          getTilePoint(t3) {
            return this.canonical.getTilePoint(new tc2(t3.x - this.wrap, t3.y));
          }
        }
        function sc2(t3, e4, r5, n3, i4) {
          (t3 *= 2) < 0 && (t3 = -1 * t3 - 1);
          const s4 = 1 << r5;
          return (s4 * s4 * t3 + s4 * i4 + n3).toString(36) + r5.toString(36) + e4.toString(36);
        }
        On("CanonicalTileID", rc2), On("OverscaledTileID", ic2, { omit: ["posMatrix"] });
        class ac2 {
          constructor(t3, e4, r5, n3 = 1, i4 = 1, s4 = 1, a3 = 0) {
            if (this.uid = t3, e4.height !== e4.width)
              throw new RangeError("DEM tiles must be square");
            if (r5 && !["mapbox", "terrarium", "custom"].includes(r5))
              return void A2(`"${r5}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
            this.stride = e4.height;
            const o3 = this.dim = e4.height - 2;
            switch (this.data = new Uint32Array(e4.data.buffer), r5) {
              case "terrarium":
                this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
                break;
              case "custom":
                this.redFactor = n3, this.greenFactor = i4, this.blueFactor = s4, this.baseShift = a3;
                break;
              default:
                this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
            }
            for (let t4 = 0; t4 < o3; t4++)
              this.data[this._idx(-1, t4)] = this.data[this._idx(0, t4)], this.data[this._idx(o3, t4)] = this.data[this._idx(o3 - 1, t4)], this.data[this._idx(t4, -1)] = this.data[this._idx(t4, 0)], this.data[this._idx(t4, o3)] = this.data[this._idx(t4, o3 - 1)];
            this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(o3, -1)] = this.data[this._idx(o3 - 1, 0)], this.data[this._idx(-1, o3)] = this.data[this._idx(0, o3 - 1)], this.data[this._idx(o3, o3)] = this.data[this._idx(o3 - 1, o3 - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
            for (let t4 = 0; t4 < o3; t4++)
              for (let e5 = 0; e5 < o3; e5++) {
                const r6 = this.get(t4, e5);
                r6 > this.max && (this.max = r6), r6 < this.min && (this.min = r6);
              }
          }
          get(t3, e4) {
            const r5 = new Uint8Array(this.data.buffer), n3 = 4 * this._idx(t3, e4);
            return this.unpack(r5[n3], r5[n3 + 1], r5[n3 + 2]);
          }
          getUnpackVector() {
            return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
          }
          _idx(t3, e4) {
            if (t3 < -1 || t3 >= this.dim + 1 || e4 < -1 || e4 >= this.dim + 1)
              throw new RangeError("out of range source coordinates for DEM data");
            return (e4 + 1) * this.stride + (t3 + 1);
          }
          unpack(t3, e4, r5) {
            return t3 * this.redFactor + e4 * this.greenFactor + r5 * this.blueFactor - this.baseShift;
          }
          getPixels() {
            return new Fa2({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
          }
          backfillBorder(t3, e4, r5) {
            if (this.dim !== t3.dim)
              throw new Error("dem dimension mismatch");
            let n3 = e4 * this.dim, i4 = e4 * this.dim + this.dim, s4 = r5 * this.dim, a3 = r5 * this.dim + this.dim;
            switch (e4) {
              case -1:
                n3 = i4 - 1;
                break;
              case 1:
                i4 = n3 + 1;
            }
            switch (r5) {
              case -1:
                s4 = a3 - 1;
                break;
              case 1:
                a3 = s4 + 1;
            }
            const o3 = -e4 * this.dim, l4 = -r5 * this.dim;
            for (let e5 = s4; e5 < a3; e5++)
              for (let r6 = n3; r6 < i4; r6++)
                this.data[this._idx(r6, e5)] = t3.data[this._idx(r6 + o3, e5 + l4)];
          }
        }
        On("DEMData", ac2);
        class oc2 {
          constructor(t3) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let e4 = 0; e4 < t3.length; e4++) {
              const r5 = t3[e4];
              this._stringToNumber[r5] = e4, this._numberToString[e4] = r5;
            }
          }
          encode(t3) {
            return this._stringToNumber[t3];
          }
          decode(t3) {
            if (t3 >= this._numberToString.length)
              throw new Error(`Out of bounds. Index requested n=${t3} can't be >= this._numberToString.length ${this._numberToString.length}`);
            return this._numberToString[t3];
          }
        }
        class lc2 {
          constructor(t3, e4, r5, n3, i4) {
            this.type = "Feature", this._vectorTileFeature = t3, t3._z = e4, t3._x = r5, t3._y = n3, this.properties = t3.properties, this.id = i4;
          }
          get geometry() {
            return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
          }
          set geometry(t3) {
            this._geometry = t3;
          }
          toJSON() {
            const t3 = { geometry: this.geometry };
            for (const e4 in this)
              "_geometry" !== e4 && "_vectorTileFeature" !== e4 && (t3[e4] = this[e4]);
            return t3;
          }
        }
        class uc2 {
          constructor(t3, e4) {
            this.tileID = t3, this.x = t3.canonical.x, this.y = t3.canonical.y, this.z = t3.canonical.z, this.grid = new Dn(Js, 16, 0), this.grid3D = new Dn(Js, 16, 0), this.featureIndexArray = new rs(), this.promoteId = e4;
          }
          insert(t3, e4, r5, n3, i4, s4) {
            const a3 = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(r5, n3, i4);
            const o3 = s4 ? this.grid3D : this.grid;
            for (let t4 = 0; t4 < e4.length; t4++) {
              const r6 = e4[t4], n4 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let t5 = 0; t5 < r6.length; t5++) {
                const e5 = r6[t5];
                n4[0] = Math.min(n4[0], e5.x), n4[1] = Math.min(n4[1], e5.y), n4[2] = Math.max(n4[2], e5.x), n4[3] = Math.max(n4[3], e5.y);
              }
              n4[0] < Js && n4[1] < Js && n4[2] >= 0 && n4[3] >= 0 && o3.insert(a3, n4[0], n4[1], n4[2], n4[3]);
            }
          }
          loadVTLayers() {
            return this.vtLayers || (this.vtLayers = new Eo.VectorTile(new Gl(this.rawTileData)).layers, this.sourceLayerCoder = new oc2(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
          }
          query(t3, e4, r5, n3) {
            this.loadVTLayers();
            const i4 = t3.params || {}, a3 = Js / t3.tileSize / t3.scale, o3 = Kr(i4.filter), l4 = t3.queryGeometry, u3 = t3.queryPadding * a3, c3 = hc2(l4), h2 = this.grid.query(c3.minX - u3, c3.minY - u3, c3.maxX + u3, c3.maxY + u3), p4 = hc2(t3.cameraQueryGeometry), f2 = this.grid3D.query(p4.minX - u3, p4.minY - u3, p4.maxX + u3, p4.maxY + u3, (e5, r6, n4, i5) => function(t4, e6, r7, n5, i6) {
              for (const s4 of t4)
                if (e6 <= s4.x && r7 <= s4.y && n5 >= s4.x && i6 >= s4.y)
                  return true;
              const a4 = [new s3(e6, r7), new s3(e6, i6), new s3(n5, i6), new s3(n5, r7)];
              if (t4.length > 2) {
                for (const e7 of a4)
                  if (ca2(t4, e7))
                    return true;
              }
              for (let e7 = 0; e7 < t4.length - 1; e7++)
                if (ha2(t4[e7], t4[e7 + 1], a4))
                  return true;
              return false;
            }(t3.cameraQueryGeometry, e5 - u3, r6 - u3, n4 + u3, i5 + u3));
            for (const t4 of f2)
              h2.push(t4);
            h2.sort(pc2);
            const d2 = {};
            let y4;
            for (let s4 = 0; s4 < h2.length; s4++) {
              const u4 = h2[s4];
              if (u4 === y4)
                continue;
              y4 = u4;
              const c4 = this.featureIndexArray.get(u4);
              let p5 = null;
              this.loadMatchingFeature(d2, c4.bucketIndex, c4.sourceLayerIndex, c4.featureIndex, o3, i4.layers, i4.availableImages, e4, r5, n3, (e5, r6, n4) => (p5 || (p5 = Ys(e5)), r6.queryIntersectsFeature(l4, e5, n4, p5, this.z, t3.transform, a3, t3.pixelPosMatrix)));
            }
            return d2;
          }
          loadMatchingFeature(t3, e4, r5, n3, i4, s4, a3, o3, l4, u3, c3) {
            const h2 = this.bucketLayerIDs[e4];
            if (s4 && !function(t4, e5) {
              for (let r6 = 0; r6 < t4.length; r6++)
                if (e5.indexOf(t4[r6]) >= 0)
                  return true;
              return false;
            }(s4, h2))
              return;
            const p4 = this.sourceLayerCoder.decode(r5), f2 = this.vtLayers[p4].feature(n3);
            if (i4.needGeometry) {
              const t4 = Ws(f2, true);
              if (!i4.filter(new ti(this.tileID.overscaledZ), t4, this.tileID.canonical))
                return;
            } else if (!i4.filter(new ti(this.tileID.overscaledZ), f2))
              return;
            const d2 = this.getId(f2, p4);
            for (let e5 = 0; e5 < h2.length; e5++) {
              const r6 = h2[e5];
              if (s4 && s4.indexOf(r6) < 0)
                continue;
              const i5 = o3[r6];
              if (!i5)
                continue;
              let p5 = {};
              d2 && u3 && (p5 = u3.getState(i5.sourceLayer || "_geojsonTileLayer", d2));
              const y4 = g2({}, l4[r6]);
              y4.paint = cc2(y4.paint, i5.paint, f2, p5, a3), y4.layout = cc2(y4.layout, i5.layout, f2, p5, a3);
              const m2 = !c3 || c3(f2, i5, p5);
              if (!m2)
                continue;
              const x5 = new lc2(f2, this.z, this.x, this.y, d2);
              x5.layer = y4;
              let v4 = t3[r6];
              void 0 === v4 && (v4 = t3[r6] = []), v4.push({ featureIndex: n3, feature: x5, intersectionZ: m2 });
            }
          }
          lookupSymbolFeatures(t3, e4, r5, n3, i4, s4, a3, o3) {
            const l4 = {};
            this.loadVTLayers();
            const u3 = Kr(i4);
            for (const i5 of t3)
              this.loadMatchingFeature(l4, r5, n3, i5, u3, s4, a3, o3, e4);
            return l4;
          }
          hasLayer(t3) {
            for (const e4 of this.bucketLayerIDs)
              for (const r5 of e4)
                if (t3 === r5)
                  return true;
            return false;
          }
          getId(t3, e4) {
            let r5 = t3.id;
            return this.promoteId && (r5 = t3.properties["string" == typeof this.promoteId ? this.promoteId : this.promoteId[e4]], "boolean" == typeof r5 && (r5 = Number(r5))), r5;
          }
        }
        function cc2(t3, e4, r5, n3, i4) {
          return v3(t3, (t4, s4) => {
            const a3 = e4 instanceof li ? e4.get(s4) : null;
            return a3 && a3.evaluate ? a3.evaluate(r5, n3, i4) : a3;
          });
        }
        function hc2(t3) {
          let e4 = 1 / 0, r5 = 1 / 0, n3 = -1 / 0, i4 = -1 / 0;
          for (const s4 of t3)
            e4 = Math.min(e4, s4.x), r5 = Math.min(r5, s4.y), n3 = Math.max(n3, s4.x), i4 = Math.max(i4, s4.y);
          return { minX: e4, minY: r5, maxX: n3, maxY: i4 };
        }
        function pc2(t3, e4) {
          return e4 - t3;
        }
        function fc2(t3, e4, r5, n3, i4) {
          const a3 = [];
          for (let o3 = 0; o3 < t3.length; o3++) {
            const l4 = t3[o3];
            let u3;
            for (let t4 = 0; t4 < l4.length - 1; t4++) {
              let o4 = l4[t4], c3 = l4[t4 + 1];
              o4.x < e4 && c3.x < e4 || (o4.x < e4 ? o4 = new s3(e4, o4.y + (e4 - o4.x) / (c3.x - o4.x) * (c3.y - o4.y))._round() : c3.x < e4 && (c3 = new s3(e4, o4.y + (e4 - o4.x) / (c3.x - o4.x) * (c3.y - o4.y))._round()), o4.y < r5 && c3.y < r5 || (o4.y < r5 ? o4 = new s3(o4.x + (r5 - o4.y) / (c3.y - o4.y) * (c3.x - o4.x), r5)._round() : c3.y < r5 && (c3 = new s3(o4.x + (r5 - o4.y) / (c3.y - o4.y) * (c3.x - o4.x), r5)._round()), o4.x >= n3 && c3.x >= n3 || (o4.x >= n3 ? o4 = new s3(n3, o4.y + (n3 - o4.x) / (c3.x - o4.x) * (c3.y - o4.y))._round() : c3.x >= n3 && (c3 = new s3(n3, o4.y + (n3 - o4.x) / (c3.x - o4.x) * (c3.y - o4.y))._round()), o4.y >= i4 && c3.y >= i4 || (o4.y >= i4 ? o4 = new s3(o4.x + (i4 - o4.y) / (c3.y - o4.y) * (c3.x - o4.x), i4)._round() : c3.y >= i4 && (c3 = new s3(o4.x + (i4 - o4.y) / (c3.y - o4.y) * (c3.x - o4.x), i4)._round()), u3 && o4.equals(u3[u3.length - 1]) || (u3 = [o4], a3.push(u3)), u3.push(c3)))));
            }
          }
          return a3;
        }
        On("FeatureIndex", uc2, { omit: ["rawTileData", "sourceLayerCoder"] });
        class dc2 extends s3 {
          constructor(t3, e4, r5, n3) {
            super(t3, e4), this.angle = r5, void 0 !== n3 && (this.segment = n3);
          }
          clone() {
            return new dc2(this.x, this.y, this.angle, this.segment);
          }
        }
        function yc2(t3, e4, r5, n3, i4) {
          if (void 0 === e4.segment || 0 === r5)
            return true;
          let s4 = e4, a3 = e4.segment + 1, o3 = 0;
          for (; o3 > -r5 / 2; ) {
            if (a3--, a3 < 0)
              return false;
            o3 -= t3[a3].dist(s4), s4 = t3[a3];
          }
          o3 += t3[a3].dist(t3[a3 + 1]), a3++;
          const l4 = [];
          let u3 = 0;
          for (; o3 < r5 / 2; ) {
            const e5 = t3[a3], r6 = t3[a3 + 1];
            if (!r6)
              return false;
            let s5 = t3[a3 - 1].angleTo(e5) - e5.angleTo(r6);
            for (s5 = Math.abs((s5 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l4.push({ distance: o3, angleDelta: s5 }), u3 += s5; o3 - l4[0].distance > n3; )
              u3 -= l4.shift().angleDelta;
            if (u3 > i4)
              return false;
            a3++, o3 += e5.dist(r6);
          }
          return true;
        }
        function mc2(t3) {
          let e4 = 0;
          for (let r5 = 0; r5 < t3.length - 1; r5++)
            e4 += t3[r5].dist(t3[r5 + 1]);
          return e4;
        }
        function gc2(t3, e4, r5) {
          return t3 ? 0.6 * e4 * r5 : 0;
        }
        function xc2(t3, e4) {
          return Math.max(t3 ? t3.right - t3.left : 0, e4 ? e4.right - e4.left : 0);
        }
        function vc2(t3, e4, r5, n3, i4, s4) {
          const a3 = gc2(r5, i4, s4), o3 = xc2(r5, n3) * s4;
          let l4 = 0;
          const u3 = mc2(t3) / 2;
          for (let r6 = 0; r6 < t3.length - 1; r6++) {
            const n4 = t3[r6], i5 = t3[r6 + 1], s5 = n4.dist(i5);
            if (l4 + s5 > u3) {
              const c3 = (u3 - l4) / s5, h2 = Ge.number(n4.x, i5.x, c3), p4 = Ge.number(n4.y, i5.y, c3), f2 = new dc2(h2, p4, i5.angleTo(n4), r6);
              return f2._round(), !a3 || yc2(t3, f2, o3, a3, e4) ? f2 : void 0;
            }
            l4 += s5;
          }
        }
        function bc2(t3, e4, r5, n3, i4, s4, a3, o3, l4) {
          const u3 = gc2(n3, s4, a3), c3 = xc2(n3, i4), h2 = c3 * a3, p4 = 0 === t3[0].x || t3[0].x === l4 || 0 === t3[0].y || t3[0].y === l4;
          return e4 - h2 < e4 / 4 && (e4 = h2 + e4 / 4), wc2(t3, p4 ? e4 / 2 * o3 % e4 : (c3 / 2 + 2 * s4) * a3 * o3 % e4, e4, u3, r5, h2, p4, false, l4);
        }
        function wc2(t3, e4, r5, n3, i4, s4, a3, o3, l4) {
          const u3 = s4 / 2, c3 = mc2(t3);
          let h2 = 0, p4 = e4 - r5, f2 = [];
          for (let e5 = 0; e5 < t3.length - 1; e5++) {
            const a4 = t3[e5], o4 = t3[e5 + 1], d2 = a4.dist(o4), y4 = o4.angleTo(a4);
            for (; p4 + r5 < h2 + d2; ) {
              p4 += r5;
              const m2 = (p4 - h2) / d2, g3 = Ge.number(a4.x, o4.x, m2), x5 = Ge.number(a4.y, o4.y, m2);
              if (g3 >= 0 && g3 < l4 && x5 >= 0 && x5 < l4 && p4 - u3 >= 0 && p4 + u3 <= c3) {
                const r6 = new dc2(g3, x5, y4, e5);
                r6._round(), n3 && !yc2(t3, r6, s4, n3, i4) || f2.push(r6);
              }
            }
            h2 += d2;
          }
          return o3 || f2.length || a3 || (f2 = wc2(t3, h2 / 2, r5, n3, i4, s4, a3, true, l4)), f2;
        }
        On("Anchor", dc2);
        const _c = tu;
        function Ac2(t3, e4, r5, n3) {
          const i4 = [], a3 = t3.image, o3 = a3.pixelRatio, l4 = a3.paddedRect.w - 2 * _c, u3 = a3.paddedRect.h - 2 * _c, c3 = t3.right - t3.left, h2 = t3.bottom - t3.top, p4 = a3.stretchX || [[0, l4]], f2 = a3.stretchY || [[0, u3]], d2 = (t4, e5) => t4 + e5[1] - e5[0], y4 = p4.reduce(d2, 0), m2 = f2.reduce(d2, 0), g3 = l4 - y4, x5 = u3 - m2;
          let v4 = 0, b3 = y4, w4 = 0, _2 = m2, A3 = 0, S4 = g3, k3 = 0, I3 = x5;
          if (a3.content && n3) {
            const t4 = a3.content;
            v4 = Sc2(p4, 0, t4[0]), w4 = Sc2(f2, 0, t4[1]), b3 = Sc2(p4, t4[0], t4[2]), _2 = Sc2(f2, t4[1], t4[3]), A3 = t4[0] - v4, k3 = t4[1] - w4, S4 = t4[2] - t4[0] - b3, I3 = t4[3] - t4[1] - _2;
          }
          const z4 = (n4, i5, l5, u4) => {
            const p5 = Ic2(n4.stretch - v4, b3, c3, t3.left), f3 = zc2(n4.fixed - A3, S4, n4.stretch, y4), d3 = Ic2(i5.stretch - w4, _2, h2, t3.top), g4 = zc2(i5.fixed - k3, I3, i5.stretch, m2), x6 = Ic2(l5.stretch - v4, b3, c3, t3.left), z5 = zc2(l5.fixed - A3, S4, l5.stretch, y4), M3 = Ic2(u4.stretch - w4, _2, h2, t3.top), B3 = zc2(u4.fixed - k3, I3, u4.stretch, m2), C5 = new s3(p5, d3), P3 = new s3(x6, d3), V3 = new s3(x6, M3), E3 = new s3(p5, M3), F4 = new s3(f3 / o3, g4 / o3), T3 = new s3(z5 / o3, B3 / o3), $2 = e4 * Math.PI / 180;
            if ($2) {
              const t4 = Math.sin($2), e5 = Math.cos($2), r6 = [e5, -t4, t4, e5];
              C5._matMult(r6), P3._matMult(r6), E3._matMult(r6), V3._matMult(r6);
            }
            const D4 = n4.stretch + n4.fixed, L3 = i5.stretch + i5.fixed;
            return { tl: C5, tr: P3, bl: E3, br: V3, tex: { x: a3.paddedRect.x + _c + D4, y: a3.paddedRect.y + _c + L3, w: l5.stretch + l5.fixed - D4, h: u4.stretch + u4.fixed - L3 }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: F4, pixelOffsetBR: T3, minFontScaleX: S4 / o3 / c3, minFontScaleY: I3 / o3 / h2, isSDF: r5 };
          };
          if (n3 && (a3.stretchX || a3.stretchY)) {
            const t4 = kc2(p4, g3, y4), e5 = kc2(f2, x5, m2);
            for (let r6 = 0; r6 < t4.length - 1; r6++) {
              const n4 = t4[r6], s4 = t4[r6 + 1];
              for (let t5 = 0; t5 < e5.length - 1; t5++)
                i4.push(z4(n4, e5[t5], s4, e5[t5 + 1]));
            }
          } else
            i4.push(z4({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: l4 + 1 }, { fixed: 0, stretch: u3 + 1 }));
          return i4;
        }
        function Sc2(t3, e4, r5) {
          let n3 = 0;
          for (const i4 of t3)
            n3 += Math.max(e4, Math.min(r5, i4[1])) - Math.max(e4, Math.min(r5, i4[0]));
          return n3;
        }
        function kc2(t3, e4, r5) {
          const n3 = [{ fixed: -_c, stretch: 0 }];
          for (const [e5, r6] of t3) {
            const t4 = n3[n3.length - 1];
            n3.push({ fixed: e5 - t4.stretch, stretch: t4.stretch }), n3.push({ fixed: e5 - t4.stretch, stretch: t4.stretch + (r6 - e5) });
          }
          return n3.push({ fixed: e4 + _c, stretch: r5 }), n3;
        }
        function Ic2(t3, e4, r5, n3) {
          return t3 / e4 * r5 + n3;
        }
        function zc2(t3, e4, r5, n3) {
          return t3 - e4 * r5 / n3;
        }
        class Mc2 {
          constructor(t3, e4, r5, n3, i4, a3, o3, l4, u3, c3) {
            if (this.boxStartIndex = t3.length, u3) {
              let t4 = a3.top, e5 = a3.bottom;
              const r6 = a3.collisionPadding;
              r6 && (t4 -= r6[1], e5 += r6[3]);
              let n4 = e5 - t4;
              n4 > 0 && (n4 = Math.max(10, n4), this.circleDiameter = n4);
            } else {
              let u4 = a3.top * o3 - l4[0], h2 = a3.bottom * o3 + l4[2], p4 = a3.left * o3 - l4[3], f2 = a3.right * o3 + l4[1];
              const d2 = a3.collisionPadding;
              if (d2 && (p4 -= d2[0] * o3, u4 -= d2[1] * o3, f2 += d2[2] * o3, h2 += d2[3] * o3), c3) {
                const t4 = new s3(p4, u4), e5 = new s3(f2, u4), r6 = new s3(p4, h2), n4 = new s3(f2, h2), i5 = c3 * Math.PI / 180;
                t4._rotate(i5), e5._rotate(i5), r6._rotate(i5), n4._rotate(i5), p4 = Math.min(t4.x, e5.x, r6.x, n4.x), f2 = Math.max(t4.x, e5.x, r6.x, n4.x), u4 = Math.min(t4.y, e5.y, r6.y, n4.y), h2 = Math.max(t4.y, e5.y, r6.y, n4.y);
              }
              t3.emplaceBack(e4.x, e4.y, p4, u4, f2, h2, r5, n3, i4);
            }
            this.boxEndIndex = t3.length;
          }
        }
        class Bc2 {
          constructor(t3 = [], e4 = Cc2) {
            if (this.data = t3, this.length = this.data.length, this.compare = e4, this.length > 0)
              for (let t4 = (this.length >> 1) - 1; t4 >= 0; t4--)
                this._down(t4);
          }
          push(t3) {
            this.data.push(t3), this.length++, this._up(this.length - 1);
          }
          pop() {
            if (0 === this.length)
              return;
            const t3 = this.data[0], e4 = this.data.pop();
            return this.length--, this.length > 0 && (this.data[0] = e4, this._down(0)), t3;
          }
          peek() {
            return this.data[0];
          }
          _up(t3) {
            const { data: e4, compare: r5 } = this, n3 = e4[t3];
            for (; t3 > 0; ) {
              const i4 = t3 - 1 >> 1, s4 = e4[i4];
              if (r5(n3, s4) >= 0)
                break;
              e4[t3] = s4, t3 = i4;
            }
            e4[t3] = n3;
          }
          _down(t3) {
            const { data: e4, compare: r5 } = this, n3 = this.length >> 1, i4 = e4[t3];
            for (; t3 < n3; ) {
              let n4 = 1 + (t3 << 1), s4 = e4[n4];
              const a3 = n4 + 1;
              if (a3 < this.length && r5(e4[a3], s4) < 0 && (n4 = a3, s4 = e4[a3]), r5(s4, i4) >= 0)
                break;
              e4[t3] = s4, t3 = n4;
            }
            e4[t3] = i4;
          }
        }
        function Cc2(t3, e4) {
          return t3 < e4 ? -1 : t3 > e4 ? 1 : 0;
        }
        function Pc2(t3, e4 = 1, r5 = false) {
          let n3 = 1 / 0, i4 = 1 / 0, a3 = -1 / 0, o3 = -1 / 0;
          const l4 = t3[0];
          for (let t4 = 0; t4 < l4.length; t4++) {
            const e5 = l4[t4];
            (!t4 || e5.x < n3) && (n3 = e5.x), (!t4 || e5.y < i4) && (i4 = e5.y), (!t4 || e5.x > a3) && (a3 = e5.x), (!t4 || e5.y > o3) && (o3 = e5.y);
          }
          const u3 = Math.min(a3 - n3, o3 - i4);
          let c3 = u3 / 2;
          const h2 = new Bc2([], Vc2);
          if (0 === u3)
            return new s3(n3, i4);
          for (let e5 = n3; e5 < a3; e5 += u3)
            for (let r6 = i4; r6 < o3; r6 += u3)
              h2.push(new Ec2(e5 + c3, r6 + c3, c3, t3));
          let p4 = function(t4) {
            let e5 = 0, r6 = 0, n4 = 0;
            const i5 = t4[0];
            for (let t5 = 0, s4 = i5.length, a4 = s4 - 1; t5 < s4; a4 = t5++) {
              const s5 = i5[t5], o4 = i5[a4], l5 = s5.x * o4.y - o4.x * s5.y;
              r6 += (s5.x + o4.x) * l5, n4 += (s5.y + o4.y) * l5, e5 += 3 * l5;
            }
            return new Ec2(r6 / e5, n4 / e5, 0, t4);
          }(t3), f2 = h2.length;
          for (; h2.length; ) {
            const n4 = h2.pop();
            (n4.d > p4.d || !p4.d) && (p4 = n4, r5 && console.log("found best %d after %d probes", Math.round(1e4 * n4.d) / 1e4, f2)), n4.max - p4.d <= e4 || (c3 = n4.h / 2, h2.push(new Ec2(n4.p.x - c3, n4.p.y - c3, c3, t3)), h2.push(new Ec2(n4.p.x + c3, n4.p.y - c3, c3, t3)), h2.push(new Ec2(n4.p.x - c3, n4.p.y + c3, c3, t3)), h2.push(new Ec2(n4.p.x + c3, n4.p.y + c3, c3, t3)), f2 += 4);
          }
          return r5 && (console.log(`num probes: ${f2}`), console.log(`best distance: ${p4.d}`)), p4.p;
        }
        function Vc2(t3, e4) {
          return e4.max - t3.max;
        }
        function Ec2(t3, e4, r5, n3) {
          this.p = new s3(t3, e4), this.h = r5, this.d = function(t4, e5) {
            let r6 = false, n4 = 1 / 0;
            for (let i4 = 0; i4 < e5.length; i4++) {
              const s4 = e5[i4];
              for (let e6 = 0, i5 = s4.length, a3 = i5 - 1; e6 < i5; a3 = e6++) {
                const i6 = s4[e6], o3 = s4[a3];
                i6.y > t4.y != o3.y > t4.y && t4.x < (o3.x - i6.x) * (t4.y - i6.y) / (o3.y - i6.y) + i6.x && (r6 = !r6), n4 = Math.min(n4, la(t4, i6, o3));
              }
            }
            return (r6 ? 1 : -1) * Math.sqrt(n4);
          }(this.p, n3), this.max = this.d + this.h * Math.SQRT2;
        }
        var Fc2;
        t2.ap = void 0, (Fc2 = t2.ap || (t2.ap = {}))[Fc2.center = 1] = "center", Fc2[Fc2.left = 2] = "left", Fc2[Fc2.right = 3] = "right", Fc2[Fc2.top = 4] = "top", Fc2[Fc2.bottom = 5] = "bottom", Fc2[Fc2["top-left"] = 6] = "top-left", Fc2[Fc2["top-right"] = 7] = "top-right", Fc2[Fc2["bottom-left"] = 8] = "bottom-left", Fc2[Fc2["bottom-right"] = 9] = "bottom-right";
        const Tc2 = 7, $c2 = Number.POSITIVE_INFINITY;
        function Dc2(t3, e4) {
          return e4[1] !== $c2 ? function(t4, e5, r5) {
            let n3 = 0, i4 = 0;
            switch (e5 = Math.abs(e5), r5 = Math.abs(r5), t4) {
              case "top-right":
              case "top-left":
              case "top":
                i4 = r5 - Tc2;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                i4 = -r5 + Tc2;
            }
            switch (t4) {
              case "top-right":
              case "bottom-right":
              case "right":
                n3 = -e5;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                n3 = e5;
            }
            return [n3, i4];
          }(t3, e4[0], e4[1]) : function(t4, e5) {
            let r5 = 0, n3 = 0;
            e5 < 0 && (e5 = 0);
            const i4 = e5 / Math.SQRT2;
            switch (t4) {
              case "top-right":
              case "top-left":
                n3 = i4 - Tc2;
                break;
              case "bottom-right":
              case "bottom-left":
                n3 = -i4 + Tc2;
                break;
              case "bottom":
                n3 = -e5 + Tc2;
                break;
              case "top":
                n3 = e5 - Tc2;
            }
            switch (t4) {
              case "top-right":
              case "bottom-right":
                r5 = -i4;
                break;
              case "top-left":
              case "bottom-left":
                r5 = i4;
                break;
              case "left":
                r5 = e5;
                break;
              case "right":
                r5 = -e5;
            }
            return [r5, n3];
          }(t3, e4[0]);
        }
        function Lc2(t3, e4, r5) {
          var n3;
          const i4 = t3.layout, s4 = null === (n3 = i4.get("text-variable-anchor-offset")) || void 0 === n3 ? void 0 : n3.evaluate(e4, {}, r5);
          if (s4) {
            const t4 = s4.values, e5 = [];
            for (let r6 = 0; r6 < t4.length; r6 += 2) {
              const n4 = e5[r6] = t4[r6], i5 = t4[r6 + 1].map((t5) => t5 * Sl);
              n4.startsWith("top") ? i5[1] -= Tc2 : n4.startsWith("bottom") && (i5[1] += Tc2), e5[r6 + 1] = i5;
            }
            return new te2(e5);
          }
          const a3 = i4.get("text-variable-anchor");
          if (a3) {
            let n4;
            n4 = void 0 !== t3._unevaluatedLayout.getValue("text-radial-offset") ? [i4.get("text-radial-offset").evaluate(e4, {}, r5) * Sl, $c2] : i4.get("text-offset").evaluate(e4, {}, r5).map((t4) => t4 * Sl);
            const s5 = [];
            for (const t4 of a3)
              s5.push(t4, Dc2(t4, n4));
            return new te2(s5);
          }
          return null;
        }
        function Oc2(t3) {
          switch (t3) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left";
          }
          return "center";
        }
        function Rc2(e4, r5, n3, i4, s4, a3, o3, l4, u3, c3, h2) {
          let p4 = a3.textMaxSize.evaluate(r5, {});
          void 0 === p4 && (p4 = o3);
          const f2 = e4.layers[0].layout, d2 = f2.get("icon-offset").evaluate(r5, {}, h2), y4 = jc2(n3.horizontal), m2 = o3 / 24, g3 = e4.tilePixelRatio * m2, x5 = e4.tilePixelRatio * p4 / 24, v4 = e4.tilePixelRatio * l4, b3 = e4.tilePixelRatio * f2.get("symbol-spacing"), w4 = f2.get("text-padding") * e4.tilePixelRatio, _2 = function(t3, e5, r6, n4 = 1) {
            const i5 = t3.get("icon-padding").evaluate(e5, {}, r6), s5 = i5 && i5.values;
            return [s5[0] * n4, s5[1] * n4, s5[2] * n4, s5[3] * n4];
          }(f2, r5, h2, e4.tilePixelRatio), S4 = f2.get("text-max-angle") / 180 * Math.PI, k3 = "viewport" !== f2.get("text-rotation-alignment") && "point" !== f2.get("symbol-placement"), I3 = "map" === f2.get("icon-rotation-alignment") && "point" !== f2.get("symbol-placement"), z4 = f2.get("symbol-placement"), M3 = b3 / 2, B3 = f2.get("icon-text-fit");
          let C5;
          i4 && "none" !== B3 && (e4.allowVerticalPlacement && n3.vertical && (C5 = vu(i4, n3.vertical, B3, f2.get("icon-text-fit-padding"), d2, m2)), y4 && (i4 = vu(i4, y4, B3, f2.get("icon-text-fit-padding"), d2, m2)));
          const P3 = (l5, p5) => {
            p5.x < 0 || p5.x >= Js || p5.y < 0 || p5.y >= Js || function(e5, r6, n4, i5, s5, a4, o4, l6, u4, c4, h3, p6, f3, d3, y5, m3, g4, x6, v5, b4, w5, _3, S5, k4, I4) {
              const z5 = e5.addToLineVertexArray(r6, n4);
              let M4, B4, C6, P4, V3 = 0, E3 = 0, F4 = 0, T3 = 0, $2 = -1, D4 = -1;
              const L3 = {};
              let O3 = Ms("");
              if (e5.allowVerticalPlacement && i5.vertical) {
                const t3 = l6.layout.get("text-rotate").evaluate(w5, {}, k4) + 90;
                C6 = new Mc2(u4, r6, c4, h3, p6, i5.vertical, f3, d3, y5, t3), o4 && (P4 = new Mc2(u4, r6, c4, h3, p6, o4, g4, x6, y5, t3));
              }
              if (s5) {
                const n5 = l6.layout.get("icon-rotate").evaluate(w5, {}), i6 = "none" !== l6.layout.get("icon-text-fit"), a5 = Ac2(s5, n5, S5, i6), f4 = o4 ? Ac2(o4, n5, S5, i6) : void 0;
                B4 = new Mc2(u4, r6, c4, h3, p6, s5, g4, x6, false, n5), V3 = 4 * a5.length;
                const d4 = e5.iconSizeData;
                let y6 = null;
                "source" === d4.kind ? (y6 = [wu * l6.layout.get("icon-size").evaluate(w5, {})], y6[0] > _u && A2(`${e5.layerIds[0]}: Value for "icon-size" is >= ${bu}. Reduce your "icon-size".`)) : "composite" === d4.kind && (y6 = [wu * _3.compositeIconSizes[0].evaluate(w5, {}, k4), wu * _3.compositeIconSizes[1].evaluate(w5, {}, k4)], (y6[0] > _u || y6[1] > _u) && A2(`${e5.layerIds[0]}: Value for "icon-size" is >= ${bu}. Reduce your "icon-size".`)), e5.addSymbols(e5.icon, a5, y6, b4, v5, w5, t2.ah.none, r6, z5.lineStartIndex, z5.lineLength, -1, k4), $2 = e5.icon.placedSymbolArray.length - 1, f4 && (E3 = 4 * f4.length, e5.addSymbols(e5.icon, f4, y6, b4, v5, w5, t2.ah.vertical, r6, z5.lineStartIndex, z5.lineLength, -1, k4), D4 = e5.icon.placedSymbolArray.length - 1);
              }
              const R4 = Object.keys(i5.horizontal);
              for (const n5 of R4) {
                const s6 = i5.horizontal[n5];
                if (!M4) {
                  O3 = Ms(s6.text);
                  const t3 = l6.layout.get("text-rotate").evaluate(w5, {}, k4);
                  M4 = new Mc2(u4, r6, c4, h3, p6, s6, f3, d3, y5, t3);
                }
                const o5 = 1 === s6.positionedLines.length;
                if (F4 += Uc2(e5, r6, s6, a4, l6, y5, w5, m3, z5, i5.vertical ? t2.ah.horizontal : t2.ah.horizontalOnly, o5 ? R4 : [n5], L3, $2, _3, k4), o5)
                  break;
              }
              i5.vertical && (T3 += Uc2(e5, r6, i5.vertical, a4, l6, y5, w5, m3, z5, t2.ah.vertical, ["vertical"], L3, D4, _3, k4));
              const U3 = M4 ? M4.boxStartIndex : e5.collisionBoxArray.length, j3 = M4 ? M4.boxEndIndex : e5.collisionBoxArray.length, q4 = C6 ? C6.boxStartIndex : e5.collisionBoxArray.length, N4 = C6 ? C6.boxEndIndex : e5.collisionBoxArray.length, Z5 = B4 ? B4.boxStartIndex : e5.collisionBoxArray.length, K3 = B4 ? B4.boxEndIndex : e5.collisionBoxArray.length, G3 = P4 ? P4.boxStartIndex : e5.collisionBoxArray.length, J4 = P4 ? P4.boxEndIndex : e5.collisionBoxArray.length;
              let X4 = -1;
              const H4 = (t3, e6) => t3 && t3.circleDiameter ? Math.max(t3.circleDiameter, e6) : e6;
              X4 = H4(M4, X4), X4 = H4(C6, X4), X4 = H4(B4, X4), X4 = H4(P4, X4);
              const Y5 = X4 > -1 ? 1 : 0;
              Y5 && (X4 *= I4 / Sl), e5.glyphOffsetArray.length >= Vu.MAX_GLYPHS && A2("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== w5.sortKey && e5.addToSortKeyRanges(e5.symbolInstances.length, w5.sortKey);
              const W3 = Lc2(l6, w5, k4), [Q3, tt2] = function(e6, r7) {
                const n5 = e6.length, i6 = null == r7 ? void 0 : r7.values;
                if ((null == i6 ? void 0 : i6.length) > 0)
                  for (let r8 = 0; r8 < i6.length; r8 += 2) {
                    const n6 = i6[r8 + 1];
                    e6.emplaceBack(t2.ap[i6[r8]], n6[0], n6[1]);
                  }
                return [n5, e6.length];
              }(e5.textAnchorOffsets, W3);
              e5.symbolInstances.emplaceBack(r6.x, r6.y, L3.right >= 0 ? L3.right : -1, L3.center >= 0 ? L3.center : -1, L3.left >= 0 ? L3.left : -1, L3.vertical || -1, $2, D4, O3, U3, j3, q4, N4, Z5, K3, G3, J4, c4, F4, T3, V3, E3, Y5, 0, f3, X4, Q3, tt2);
            }(e4, p5, l5, n3, i4, s4, C5, e4.layers[0], e4.collisionBoxArray, r5.index, r5.sourceLayerIndex, e4.index, g3, [w4, w4, w4, w4], k3, u3, v4, _2, I3, d2, r5, a3, c3, h2, o3);
          };
          if ("line" === z4)
            for (const t3 of fc2(r5.geometry, 0, 0, Js, Js)) {
              const r6 = bc2(t3, b3, S4, n3.vertical || y4, i4, 24, x5, e4.overscaling, Js);
              for (const n4 of r6)
                y4 && qc2(e4, y4.text, M3, n4) || P3(t3, n4);
            }
          else if ("line-center" === z4) {
            for (const t3 of r5.geometry)
              if (t3.length > 1) {
                const e5 = vc2(t3, S4, n3.vertical || y4, i4, 24, x5);
                e5 && P3(t3, e5);
              }
          } else if ("Polygon" === r5.type)
            for (const t3 of wo(r5.geometry, 0)) {
              const e5 = Pc2(t3, 16);
              P3(t3[0], new dc2(e5.x, e5.y, 0));
            }
          else if ("LineString" === r5.type)
            for (const t3 of r5.geometry)
              P3(t3, new dc2(t3[0].x, t3[0].y, 0));
          else if ("Point" === r5.type)
            for (const t3 of r5.geometry)
              for (const e5 of t3)
                P3([e5], new dc2(e5.x, e5.y, 0));
        }
        function Uc2(t3, e4, r5, n3, i4, a3, o3, l4, u3, c3, h2, p4, f2, d2, y4) {
          const m2 = function(t4, e5, r6, n4, i5, a4, o4, l5) {
            const u4 = n4.layout.get("text-rotate").evaluate(a4, {}) * Math.PI / 180, c4 = [];
            for (const t5 of e5.positionedLines)
              for (const n5 of t5.positionedGlyphs) {
                if (!n5.rect)
                  continue;
                const a5 = n5.rect || {};
                let h3 = Wl + 1, p5 = true, f3 = 1, d3 = 0;
                const y5 = (i5 || l5) && n5.vertical, m3 = n5.metrics.advance * n5.scale / 2;
                if (l5 && e5.verticalizable && (d3 = t5.lineOffset / 2 - (n5.imageName ? -(Sl - n5.metrics.width * n5.scale) / 2 : (n5.scale - 1) * Sl)), n5.imageName) {
                  const t6 = o4[n5.imageName];
                  p5 = t6.sdf, f3 = t6.pixelRatio, h3 = tu / f3;
                }
                const g4 = i5 ? [n5.x + m3, n5.y] : [0, 0];
                let x6 = i5 ? [0, 0] : [n5.x + m3 + r6[0], n5.y + r6[1] - d3], v4 = [0, 0];
                y5 && (v4 = x6, x6 = [0, 0]);
                const b3 = n5.metrics.isDoubleResolution ? 2 : 1, w4 = (n5.metrics.left - h3) * n5.scale - m3 + x6[0], _2 = (-n5.metrics.top - h3) * n5.scale + x6[1], A3 = w4 + a5.w / b3 * n5.scale / f3, S4 = _2 + a5.h / b3 * n5.scale / f3, k3 = new s3(w4, _2), I3 = new s3(A3, _2), z4 = new s3(w4, S4), M3 = new s3(A3, S4);
                if (y5) {
                  const t6 = new s3(-m3, m3 - iu), e6 = -Math.PI / 2, r7 = Sl / 2 - m3, i6 = new s3(5 - iu - r7, -(n5.imageName ? r7 : 0)), a6 = new s3(...v4);
                  k3._rotateAround(e6, t6)._add(i6)._add(a6), I3._rotateAround(e6, t6)._add(i6)._add(a6), z4._rotateAround(e6, t6)._add(i6)._add(a6), M3._rotateAround(e6, t6)._add(i6)._add(a6);
                }
                if (u4) {
                  const t6 = Math.sin(u4), e6 = Math.cos(u4), r7 = [e6, -t6, t6, e6];
                  k3._matMult(r7), I3._matMult(r7), z4._matMult(r7), M3._matMult(r7);
                }
                const B3 = new s3(0, 0), C5 = new s3(0, 0);
                c4.push({ tl: k3, tr: I3, bl: z4, br: M3, tex: a5, writingMode: e5.writingMode, glyphOffset: g4, sectionIndex: n5.sectionIndex, isSDF: p5, pixelOffsetTL: B3, pixelOffsetBR: C5, minFontScaleX: 0, minFontScaleY: 0 });
              }
            return c4;
          }(0, r5, l4, i4, a3, o3, n3, t3.allowVerticalPlacement), g3 = t3.textSizeData;
          let x5 = null;
          "source" === g3.kind ? (x5 = [wu * i4.layout.get("text-size").evaluate(o3, {})], x5[0] > _u && A2(`${t3.layerIds[0]}: Value for "text-size" is >= ${bu}. Reduce your "text-size".`)) : "composite" === g3.kind && (x5 = [wu * d2.compositeTextSizes[0].evaluate(o3, {}, y4), wu * d2.compositeTextSizes[1].evaluate(o3, {}, y4)], (x5[0] > _u || x5[1] > _u) && A2(`${t3.layerIds[0]}: Value for "text-size" is >= ${bu}. Reduce your "text-size".`)), t3.addSymbols(t3.text, m2, x5, l4, a3, o3, c3, e4, u3.lineStartIndex, u3.lineLength, f2, y4);
          for (const e5 of h2)
            p4[e5] = t3.text.placedSymbolArray.length - 1;
          return 4 * m2.length;
        }
        function jc2(t3) {
          for (const e4 in t3)
            return t3[e4];
          return null;
        }
        function qc2(t3, e4, r5, n3) {
          const i4 = t3.compareText;
          if (e4 in i4) {
            const t4 = i4[e4];
            for (let e5 = t4.length - 1; e5 >= 0; e5--)
              if (n3.dist(t4[e5]) < r5)
                return true;
          } else
            i4[e4] = [];
          return i4[e4].push(n3), false;
        }
        const Nc2 = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        class Zc2 {
          static from(t3) {
            if (!(t3 instanceof ArrayBuffer))
              throw new Error("Data must be an instance of ArrayBuffer.");
            const [e4, r5] = new Uint8Array(t3, 0, 2);
            if (219 !== e4)
              throw new Error("Data does not appear to be in a KDBush format.");
            const n3 = r5 >> 4;
            if (1 !== n3)
              throw new Error(`Got v${n3} data when expected v1.`);
            const i4 = Nc2[15 & r5];
            if (!i4)
              throw new Error("Unrecognized array type.");
            const [s4] = new Uint16Array(t3, 2, 1), [a3] = new Uint32Array(t3, 4, 1);
            return new Zc2(a3, s4, i4, t3);
          }
          constructor(t3, e4 = 64, r5 = Float64Array, n3) {
            if (isNaN(t3) || t3 < 0)
              throw new Error(`Unpexpected numItems value: ${t3}.`);
            this.numItems = +t3, this.nodeSize = Math.min(Math.max(+e4, 2), 65535), this.ArrayType = r5, this.IndexArrayType = t3 < 65536 ? Uint16Array : Uint32Array;
            const i4 = Nc2.indexOf(this.ArrayType), s4 = 2 * t3 * this.ArrayType.BYTES_PER_ELEMENT, a3 = t3 * this.IndexArrayType.BYTES_PER_ELEMENT, o3 = (8 - a3 % 8) % 8;
            if (i4 < 0)
              throw new Error(`Unexpected typed array class: ${r5}.`);
            n3 && n3 instanceof ArrayBuffer ? (this.data = n3, this.ids = new this.IndexArrayType(this.data, 8, t3), this.coords = new this.ArrayType(this.data, 8 + a3 + o3, 2 * t3), this._pos = 2 * t3, this._finished = true) : (this.data = new ArrayBuffer(8 + s4 + a3 + o3), this.ids = new this.IndexArrayType(this.data, 8, t3), this.coords = new this.ArrayType(this.data, 8 + a3 + o3, 2 * t3), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, 16 + i4]), new Uint16Array(this.data, 2, 1)[0] = e4, new Uint32Array(this.data, 4, 1)[0] = t3);
          }
          add(t3, e4) {
            const r5 = this._pos >> 1;
            return this.ids[r5] = r5, this.coords[this._pos++] = t3, this.coords[this._pos++] = e4, r5;
          }
          finish() {
            const t3 = this._pos >> 1;
            if (t3 !== this.numItems)
              throw new Error(`Added ${t3} items when expected ${this.numItems}.`);
            return Kc2(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
          }
          range(t3, e4, r5, n3) {
            if (!this._finished)
              throw new Error("Data not yet indexed - call index.finish().");
            const { ids: i4, coords: s4, nodeSize: a3 } = this, o3 = [0, i4.length - 1, 0], l4 = [];
            for (; o3.length; ) {
              const u3 = o3.pop() || 0, c3 = o3.pop() || 0, h2 = o3.pop() || 0;
              if (c3 - h2 <= a3) {
                for (let a4 = h2; a4 <= c3; a4++) {
                  const o4 = s4[2 * a4], u4 = s4[2 * a4 + 1];
                  o4 >= t3 && o4 <= r5 && u4 >= e4 && u4 <= n3 && l4.push(i4[a4]);
                }
                continue;
              }
              const p4 = h2 + c3 >> 1, f2 = s4[2 * p4], d2 = s4[2 * p4 + 1];
              f2 >= t3 && f2 <= r5 && d2 >= e4 && d2 <= n3 && l4.push(i4[p4]), (0 === u3 ? t3 <= f2 : e4 <= d2) && (o3.push(h2), o3.push(p4 - 1), o3.push(1 - u3)), (0 === u3 ? r5 >= f2 : n3 >= d2) && (o3.push(p4 + 1), o3.push(c3), o3.push(1 - u3));
            }
            return l4;
          }
          within(t3, e4, r5) {
            if (!this._finished)
              throw new Error("Data not yet indexed - call index.finish().");
            const { ids: n3, coords: i4, nodeSize: s4 } = this, a3 = [0, n3.length - 1, 0], o3 = [], l4 = r5 * r5;
            for (; a3.length; ) {
              const u3 = a3.pop() || 0, c3 = a3.pop() || 0, h2 = a3.pop() || 0;
              if (c3 - h2 <= s4) {
                for (let r6 = h2; r6 <= c3; r6++)
                  Hc2(i4[2 * r6], i4[2 * r6 + 1], t3, e4) <= l4 && o3.push(n3[r6]);
                continue;
              }
              const p4 = h2 + c3 >> 1, f2 = i4[2 * p4], d2 = i4[2 * p4 + 1];
              Hc2(f2, d2, t3, e4) <= l4 && o3.push(n3[p4]), (0 === u3 ? t3 - r5 <= f2 : e4 - r5 <= d2) && (a3.push(h2), a3.push(p4 - 1), a3.push(1 - u3)), (0 === u3 ? t3 + r5 >= f2 : e4 + r5 >= d2) && (a3.push(p4 + 1), a3.push(c3), a3.push(1 - u3));
            }
            return o3;
          }
        }
        function Kc2(t3, e4, r5, n3, i4, s4) {
          if (i4 - n3 <= r5)
            return;
          const a3 = n3 + i4 >> 1;
          Gc2(t3, e4, a3, n3, i4, s4), Kc2(t3, e4, r5, n3, a3 - 1, 1 - s4), Kc2(t3, e4, r5, a3 + 1, i4, 1 - s4);
        }
        function Gc2(t3, e4, r5, n3, i4, s4) {
          for (; i4 > n3; ) {
            if (i4 - n3 > 600) {
              const a4 = i4 - n3 + 1, o4 = r5 - n3 + 1, l5 = Math.log(a4), u3 = 0.5 * Math.exp(2 * l5 / 3), c3 = 0.5 * Math.sqrt(l5 * u3 * (a4 - u3) / a4) * (o4 - a4 / 2 < 0 ? -1 : 1);
              Gc2(t3, e4, r5, Math.max(n3, Math.floor(r5 - o4 * u3 / a4 + c3)), Math.min(i4, Math.floor(r5 + (a4 - o4) * u3 / a4 + c3)), s4);
            }
            const a3 = e4[2 * r5 + s4];
            let o3 = n3, l4 = i4;
            for (Jc2(t3, e4, n3, r5), e4[2 * i4 + s4] > a3 && Jc2(t3, e4, n3, i4); o3 < l4; ) {
              for (Jc2(t3, e4, o3, l4), o3++, l4--; e4[2 * o3 + s4] < a3; )
                o3++;
              for (; e4[2 * l4 + s4] > a3; )
                l4--;
            }
            e4[2 * n3 + s4] === a3 ? Jc2(t3, e4, n3, l4) : (l4++, Jc2(t3, e4, l4, i4)), l4 <= r5 && (n3 = l4 + 1), r5 <= l4 && (i4 = l4 - 1);
          }
        }
        function Jc2(t3, e4, r5, n3) {
          Xc2(t3, r5, n3), Xc2(e4, 2 * r5, 2 * n3), Xc2(e4, 2 * r5 + 1, 2 * n3 + 1);
        }
        function Xc2(t3, e4, r5) {
          const n3 = t3[e4];
          t3[e4] = t3[r5], t3[r5] = n3;
        }
        function Hc2(t3, e4, r5, n3) {
          const i4 = t3 - r5, s4 = e4 - n3;
          return i4 * i4 + s4 * s4;
        }
        var Yc2;
        t2.bc = void 0, (Yc2 = t2.bc || (t2.bc = {})).create = "create", Yc2.load = "load", Yc2.fullLoad = "fullLoad";
        let Wc2 = null, Qc2 = [];
        const th = 1e3 / 60, eh = "loadTime", rh = "fullLoadTime", nh = { mark(t3) {
          performance.mark(t3);
        }, frame(t3) {
          const e4 = t3;
          null != Wc2 && Qc2.push(e4 - Wc2), Wc2 = e4;
        }, clearMetrics() {
          Wc2 = null, Qc2 = [], performance.clearMeasures(eh), performance.clearMeasures(rh);
          for (const e4 in t2.bc)
            performance.clearMarks(t2.bc[e4]);
        }, getPerformanceMetrics() {
          performance.measure(eh, t2.bc.create, t2.bc.load), performance.measure(rh, t2.bc.create, t2.bc.fullLoad);
          const e4 = performance.getEntriesByName(eh)[0].duration, r5 = performance.getEntriesByName(rh)[0].duration, n3 = Qc2.length, i4 = 1 / (Qc2.reduce((t3, e5) => t3 + e5, 0) / n3 / 1e3), s4 = Qc2.filter((t3) => t3 > th).reduce((t3, e5) => t3 + (e5 - th) / th, 0);
          return { loadTime: e4, fullLoadTime: r5, fps: i4, percentDroppedFrames: s4 / (n3 + s4) * 100, totalFrames: n3 };
        } };
        t2.$ = vs, t2.A = va2, t2.B = function(t3) {
          if (null == z3) {
            const e4 = t3.navigator ? t3.navigator.userAgent : null;
            z3 = !!t3.safari || !(!e4 || !(/\b(iPad|iPhone|iPod)\b/.test(e4) || e4.match("Safari") && !e4.match("Chrome")));
          }
          return z3;
        }, t2.C = class {
          constructor(t3, e4) {
            this.target = t3, this.mapId = e4, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new Zu(() => this.process()), this.subscription = function(t4, e5, r5, n3) {
              return t4.addEventListener(e5, r5, false), { unsubscribe: () => {
                t4.removeEventListener(e5, r5, false);
              } };
            }(this.target, "message", (t4) => this.receive(t4)), this.globalScope = I2(self) ? t3 : window;
          }
          registerMessageHandler(t3, e4) {
            this.messageHandlers[t3] = e4;
          }
          sendAsync(t3, e4) {
            return new Promise((r5, n3) => {
              const i4 = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
              this.resolveRejects[i4] = { resolve: r5, reject: n3 }, e4 && e4.signal.addEventListener("abort", () => {
                delete this.resolveRejects[i4];
                const e5 = { id: i4, type: "<cancel>", origin: location.origin, targetMapId: t3.targetMapId, sourceMapId: this.mapId };
                this.target.postMessage(e5);
              }, { once: true });
              const s4 = [], a3 = Object.assign(Object.assign({}, t3), { id: i4, sourceMapId: this.mapId, origin: location.origin, data: Un(t3.data, s4) });
              this.target.postMessage(a3, { transfer: s4 });
            });
          }
          receive(t3) {
            const e4 = t3.data, r5 = e4.id;
            if (!("file://" !== e4.origin && "file://" !== location.origin && e4.origin !== location.origin || e4.targetMapId && this.mapId !== e4.targetMapId)) {
              if ("<cancel>" === e4.type) {
                delete this.tasks[r5];
                const t4 = this.abortControllers[r5];
                return delete this.abortControllers[r5], void (t4 && t4.abort());
              }
              if (I2(self) || e4.mustQueue)
                return this.tasks[r5] = e4, this.taskQueue.push(r5), void this.invoker.trigger();
              this.processTask(r5, e4);
            }
          }
          process() {
            if (0 === this.taskQueue.length)
              return;
            const t3 = this.taskQueue.shift(), e4 = this.tasks[t3];
            delete this.tasks[t3], this.taskQueue.length > 0 && this.invoker.trigger(), e4 && this.processTask(t3, e4);
          }
          processTask(t3, r5) {
            return e3(this, void 0, void 0, function* () {
              if ("<response>" === r5.type) {
                const e5 = this.resolveRejects[t3];
                if (delete this.resolveRejects[t3], !e5)
                  return;
                return void (r5.error ? e5.reject(jn(r5.error)) : e5.resolve(jn(r5.data)));
              }
              if (!this.messageHandlers[r5.type])
                return void this.completeTask(t3, new Error(`Could not find a registered handler for ${r5.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
              const e4 = jn(r5.data), n3 = new AbortController();
              this.abortControllers[t3] = n3;
              try {
                const i4 = yield this.messageHandlers[r5.type](r5.sourceMapId, e4, n3);
                this.completeTask(t3, null, i4);
              } catch (e5) {
                this.completeTask(t3, e5);
              }
            });
          }
          completeTask(t3, e4, r5) {
            const n3 = [];
            delete this.abortControllers[t3];
            const i4 = { id: t3, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: e4 ? Un(e4) : null, data: Un(r5, n3) };
            this.target.postMessage(i4, { transfer: n3 });
          }
          remove() {
            this.invoker.remove(), this.subscription.unsubscribe();
          }
        }, t2.D = ui, t2.E = K2, t2.F = function() {
          var t3 = new va2(16);
          return va2 != Float32Array && (t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0), t3[0] = 1, t3[5] = 1, t3[10] = 1, t3[15] = 1, t3;
        }, t2.G = D3, t2.H = function(t3, e4, r5) {
          var n3, i4, s4, a3, o3, l4, u3, c3, h2, p4, f2, d2, y4 = r5[0], m2 = r5[1], g3 = r5[2];
          return e4 === t3 ? (t3[12] = e4[0] * y4 + e4[4] * m2 + e4[8] * g3 + e4[12], t3[13] = e4[1] * y4 + e4[5] * m2 + e4[9] * g3 + e4[13], t3[14] = e4[2] * y4 + e4[6] * m2 + e4[10] * g3 + e4[14], t3[15] = e4[3] * y4 + e4[7] * m2 + e4[11] * g3 + e4[15]) : (i4 = e4[1], s4 = e4[2], a3 = e4[3], o3 = e4[4], l4 = e4[5], u3 = e4[6], c3 = e4[7], h2 = e4[8], p4 = e4[9], f2 = e4[10], d2 = e4[11], t3[0] = n3 = e4[0], t3[1] = i4, t3[2] = s4, t3[3] = a3, t3[4] = o3, t3[5] = l4, t3[6] = u3, t3[7] = c3, t3[8] = h2, t3[9] = p4, t3[10] = f2, t3[11] = d2, t3[12] = n3 * y4 + o3 * m2 + h2 * g3 + e4[12], t3[13] = i4 * y4 + l4 * m2 + p4 * g3 + e4[13], t3[14] = s4 * y4 + u3 * m2 + f2 * g3 + e4[14], t3[15] = a3 * y4 + c3 * m2 + d2 * g3 + e4[15]), t3;
        }, t2.I = eu, t2.J = function(t3, e4, r5) {
          var n3 = r5[0], i4 = r5[1], s4 = r5[2];
          return t3[0] = e4[0] * n3, t3[1] = e4[1] * n3, t3[2] = e4[2] * n3, t3[3] = e4[3] * n3, t3[4] = e4[4] * i4, t3[5] = e4[5] * i4, t3[6] = e4[6] * i4, t3[7] = e4[7] * i4, t3[8] = e4[8] * s4, t3[9] = e4[9] * s4, t3[10] = e4[10] * s4, t3[11] = e4[11] * s4, t3[12] = e4[12], t3[13] = e4[13], t3[14] = e4[14], t3[15] = e4[15], t3;
        }, t2.K = wa2, t2.L = function(t3, e4) {
          const r5 = {};
          for (let n3 = 0; n3 < e4.length; n3++) {
            const i4 = e4[n3];
            i4 in t3 && (r5[i4] = t3[i4]);
          }
          return r5;
        }, t2.M = Gu, t2.N = Hu, t2.O = Yu, t2.P = s3, t2.Q = ic2, t2.R = Fa2, t2.S = h, t2.T = ni, t2.U = p3, t2.V = C4, t2.W = Js, t2.X = bi, t2.Y = tc2, t2.Z = class extends Si {
        }, t2._ = e3, t2.a = T2, t2.a$ = function(t3, e4) {
          return t3[0] * e4[0] + t3[1] * e4[1] + t3[2] * e4[2] + t3[3] * e4[3];
        }, t2.a0 = rc2, t2.a1 = st, t2.a2 = (t3) => {
          const e4 = window.document.createElement("video");
          return e4.muted = true, new Promise((r5) => {
            e4.onloadstart = () => {
              r5(e4);
            };
            for (const r6 of t3) {
              const t4 = window.document.createElement("source");
              U2(r6) || (e4.crossOrigin = "Anonymous"), t4.src = r6, e4.appendChild(t4);
            }
          });
        }, t2.a3 = function() {
          return x4++;
        }, t2.a4 = Ki, t2.a5 = Vu, t2.a6 = Kr, t2.a7 = Ws, t2.a8 = ti, t2.a9 = lc2, t2.aA = w3, t2.aB = function(t3, e4) {
          if (!t3)
            return [{ command: "setStyle", args: [e4] }];
          let r5 = [];
          try {
            if (!H3(t3.version, e4.version))
              return [{ command: "setStyle", args: [e4] }];
            H3(t3.center, e4.center) || r5.push({ command: "setCenter", args: [e4.center] }), H3(t3.zoom, e4.zoom) || r5.push({ command: "setZoom", args: [e4.zoom] }), H3(t3.bearing, e4.bearing) || r5.push({ command: "setBearing", args: [e4.bearing] }), H3(t3.pitch, e4.pitch) || r5.push({ command: "setPitch", args: [e4.pitch] }), H3(t3.sprite, e4.sprite) || r5.push({ command: "setSprite", args: [e4.sprite] }), H3(t3.glyphs, e4.glyphs) || r5.push({ command: "setGlyphs", args: [e4.glyphs] }), H3(t3.transition, e4.transition) || r5.push({ command: "setTransition", args: [e4.transition] }), H3(t3.light, e4.light) || r5.push({ command: "setLight", args: [e4.light] }), H3(t3.terrain, e4.terrain) || r5.push({ command: "setTerrain", args: [e4.terrain] }), H3(t3.sky, e4.sky) || r5.push({ command: "setSky", args: [e4.sky] });
            const n3 = {}, i4 = [];
            !function(t4, e5, r6, n4) {
              let i5;
              for (i5 in e5 = e5 || {}, t4 = t4 || {})
                Object.prototype.hasOwnProperty.call(t4, i5) && (Object.prototype.hasOwnProperty.call(e5, i5) || Q2(i5, r6, n4));
              for (i5 in e5)
                Object.prototype.hasOwnProperty.call(e5, i5) && (Object.prototype.hasOwnProperty.call(t4, i5) ? H3(t4[i5], e5[i5]) || ("geojson" === t4[i5].type && "geojson" === e5[i5].type && et2(t4, e5, i5) ? Y4(r6, { command: "setGeoJSONSourceData", args: [i5, e5[i5].data] }) : tt(i5, e5, r6, n4)) : W2(i5, e5, r6));
            }(t3.sources, e4.sources, i4, n3);
            const s4 = [];
            t3.layers && t3.layers.forEach((t4) => {
              "source" in t4 && n3[t4.source] ? r5.push({ command: "removeLayer", args: [t4.id] }) : s4.push(t4);
            }), r5 = r5.concat(i4), function(t4, e5, r6) {
              e5 = e5 || [];
              const n4 = (t4 = t4 || []).map(nt), i5 = e5.map(nt), s5 = t4.reduce(it, {}), a3 = e5.reduce(it, {}), o3 = n4.slice(), l4 = /* @__PURE__ */ Object.create(null);
              let u3, c3, h2, p4, f2;
              for (let t5 = 0, e6 = 0; t5 < n4.length; t5++)
                u3 = n4[t5], Object.prototype.hasOwnProperty.call(a3, u3) ? e6++ : (Y4(r6, { command: "removeLayer", args: [u3] }), o3.splice(o3.indexOf(u3, e6), 1));
              for (let t5 = 0, e6 = 0; t5 < i5.length; t5++)
                u3 = i5[i5.length - 1 - t5], o3[o3.length - 1 - t5] !== u3 && (Object.prototype.hasOwnProperty.call(s5, u3) ? (Y4(r6, { command: "removeLayer", args: [u3] }), o3.splice(o3.lastIndexOf(u3, o3.length - e6), 1)) : e6++, p4 = o3[o3.length - t5], Y4(r6, { command: "addLayer", args: [a3[u3], p4] }), o3.splice(o3.length - t5, 0, u3), l4[u3] = true);
              for (let t5 = 0; t5 < i5.length; t5++)
                if (u3 = i5[t5], c3 = s5[u3], h2 = a3[u3], !l4[u3] && !H3(c3, h2))
                  if (H3(c3.source, h2.source) && H3(c3["source-layer"], h2["source-layer"]) && H3(c3.type, h2.type)) {
                    for (f2 in rt(c3.layout, h2.layout, r6, u3, null, "setLayoutProperty"), rt(c3.paint, h2.paint, r6, u3, null, "setPaintProperty"), H3(c3.filter, h2.filter) || Y4(r6, { command: "setFilter", args: [u3, h2.filter] }), H3(c3.minzoom, h2.minzoom) && H3(c3.maxzoom, h2.maxzoom) || Y4(r6, { command: "setLayerZoomRange", args: [u3, h2.minzoom, h2.maxzoom] }), c3)
                      Object.prototype.hasOwnProperty.call(c3, f2) && "layout" !== f2 && "paint" !== f2 && "filter" !== f2 && "metadata" !== f2 && "minzoom" !== f2 && "maxzoom" !== f2 && (0 === f2.indexOf("paint.") ? rt(c3[f2], h2[f2], r6, u3, f2.slice(6), "setPaintProperty") : H3(c3[f2], h2[f2]) || Y4(r6, { command: "setLayerProperty", args: [u3, f2, h2[f2]] }));
                    for (f2 in h2)
                      Object.prototype.hasOwnProperty.call(h2, f2) && !Object.prototype.hasOwnProperty.call(c3, f2) && "layout" !== f2 && "paint" !== f2 && "filter" !== f2 && "metadata" !== f2 && "minzoom" !== f2 && "maxzoom" !== f2 && (0 === f2.indexOf("paint.") ? rt(c3[f2], h2[f2], r6, u3, f2.slice(6), "setPaintProperty") : H3(c3[f2], h2[f2]) || Y4(r6, { command: "setLayerProperty", args: [u3, f2, h2[f2]] }));
                  } else
                    Y4(r6, { command: "removeLayer", args: [u3] }), p4 = o3[o3.lastIndexOf(u3) + 1], Y4(r6, { command: "addLayer", args: [h2, p4] });
            }(s4, e4.layers, r5);
          } catch (t4) {
            console.warn("Unable to compute style diff:", t4), r5 = [{ command: "setStyle", args: [e4] }];
          }
          return r5;
        }, t2.aC = function(t3) {
          const e4 = [], r5 = t3.id;
          return void 0 === r5 && e4.push({ message: `layers.${r5}: missing required property "id"` }), void 0 === t3.render && e4.push({ message: `layers.${r5}: missing required method "render"` }), t3.renderingMode && "2d" !== t3.renderingMode && "3d" !== t3.renderingMode && e4.push({ message: `layers.${r5}: property "renderingMode" must be either "2d" or "3d"` }), e4;
        }, t2.aD = function t3(e4, r5) {
          if (Array.isArray(e4)) {
            if (!Array.isArray(r5) || e4.length !== r5.length)
              return false;
            for (let n3 = 0; n3 < e4.length; n3++)
              if (!t3(e4[n3], r5[n3]))
                return false;
            return true;
          }
          if ("object" == typeof e4 && null !== e4 && null !== r5) {
            if ("object" != typeof r5)
              return false;
            if (Object.keys(e4).length !== Object.keys(r5).length)
              return false;
            for (const n3 in e4)
              if (!t3(e4[n3], r5[n3]))
                return false;
            return true;
          }
          return e4 === r5;
        }, t2.aE = v3, t2.aF = b2, t2.aG = class extends Es {
          constructor(t3, e4) {
            super(t3, e4), this.current = 0;
          }
          set(t3) {
            this.current !== t3 && (this.current = t3, this.gl.uniform1i(this.location, t3));
          }
        }, t2.aH = Fs, t2.aI = class extends Es {
          constructor(t3, e4) {
            super(t3, e4), this.current = Ds;
          }
          set(t3) {
            if (t3[12] !== this.current[12] || t3[0] !== this.current[0])
              return this.current = t3, void this.gl.uniformMatrix4fv(this.location, false, t3);
            for (let e4 = 1; e4 < 16; e4++)
              if (t3[e4] !== this.current[e4]) {
                this.current = t3, this.gl.uniformMatrix4fv(this.location, false, t3);
                break;
              }
          }
        }, t2.aJ = Ts, t2.aK = class extends Es {
          constructor(t3, e4) {
            super(t3, e4), this.current = [0, 0, 0];
          }
          set(t3) {
            t3[0] === this.current[0] && t3[1] === this.current[1] && t3[2] === this.current[2] || (this.current = t3, this.gl.uniform3f(this.location, t3[0], t3[1], t3[2]));
          }
        }, t2.aL = class extends Es {
          constructor(t3, e4) {
            super(t3, e4), this.current = [0, 0];
          }
          set(t3) {
            t3[0] === this.current[0] && t3[1] === this.current[1] || (this.current = t3, this.gl.uniform2f(this.location, t3[0], t3[1]));
          }
        }, t2.aM = $s, t2.aN = function(t3, e4, r5, n3, i4, s4, a3) {
          var o3 = 1 / (e4 - r5), l4 = 1 / (n3 - i4), u3 = 1 / (s4 - a3);
          return t3[0] = -2 * o3, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = -2 * l4, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = 2 * u3, t3[11] = 0, t3[12] = (e4 + r5) * o3, t3[13] = (i4 + n3) * l4, t3[14] = (a3 + s4) * u3, t3[15] = 1, t3;
        }, t2.aO = Jt, t2.aP = Aa2, t2.aQ = class extends Fi {
        }, t2.aR = wl, t2.aS = class extends $i {
        }, t2.aT = function(t3) {
          return t3 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t3) / Math.LN2));
        }, t2.aU = Ta2, t2.aV = ns, t2.aW = class extends qi {
        }, t2.aX = ys, t2.aY = function(t3, e4) {
          var r5 = t3[0], n3 = t3[1], i4 = t3[2], s4 = t3[3], a3 = t3[4], o3 = t3[5], l4 = t3[6], u3 = t3[7], c3 = t3[8], h2 = t3[9], p4 = t3[10], f2 = t3[11], d2 = t3[12], y4 = t3[13], m2 = t3[14], g3 = t3[15], x5 = e4[0], v4 = e4[1], b3 = e4[2], w4 = e4[3], _2 = e4[4], A3 = e4[5], S4 = e4[6], k3 = e4[7], I3 = e4[8], z4 = e4[9], M3 = e4[10], B3 = e4[11], C5 = e4[12], P3 = e4[13], V3 = e4[14], E3 = e4[15];
          return Math.abs(r5 - x5) <= xa2 * Math.max(1, Math.abs(r5), Math.abs(x5)) && Math.abs(n3 - v4) <= xa2 * Math.max(1, Math.abs(n3), Math.abs(v4)) && Math.abs(i4 - b3) <= xa2 * Math.max(1, Math.abs(i4), Math.abs(b3)) && Math.abs(s4 - w4) <= xa2 * Math.max(1, Math.abs(s4), Math.abs(w4)) && Math.abs(a3 - _2) <= xa2 * Math.max(1, Math.abs(a3), Math.abs(_2)) && Math.abs(o3 - A3) <= xa2 * Math.max(1, Math.abs(o3), Math.abs(A3)) && Math.abs(l4 - S4) <= xa2 * Math.max(1, Math.abs(l4), Math.abs(S4)) && Math.abs(u3 - k3) <= xa2 * Math.max(1, Math.abs(u3), Math.abs(k3)) && Math.abs(c3 - I3) <= xa2 * Math.max(1, Math.abs(c3), Math.abs(I3)) && Math.abs(h2 - z4) <= xa2 * Math.max(1, Math.abs(h2), Math.abs(z4)) && Math.abs(p4 - M3) <= xa2 * Math.max(1, Math.abs(p4), Math.abs(M3)) && Math.abs(f2 - B3) <= xa2 * Math.max(1, Math.abs(f2), Math.abs(B3)) && Math.abs(d2 - C5) <= xa2 * Math.max(1, Math.abs(d2), Math.abs(C5)) && Math.abs(y4 - P3) <= xa2 * Math.max(1, Math.abs(y4), Math.abs(P3)) && Math.abs(m2 - V3) <= xa2 * Math.max(1, Math.abs(m2), Math.abs(V3)) && Math.abs(g3 - E3) <= xa2 * Math.max(1, Math.abs(g3), Math.abs(E3));
        }, t2.aZ = function(t3, e4) {
          return t3[0] = e4[0], t3[1] = e4[1], t3[2] = e4[2], t3[3] = e4[3], t3[4] = e4[4], t3[5] = e4[5], t3[6] = e4[6], t3[7] = e4[7], t3[8] = e4[8], t3[9] = e4[9], t3[10] = e4[10], t3[11] = e4[11], t3[12] = e4[12], t3[13] = e4[13], t3[14] = e4[14], t3[15] = e4[15], t3;
        }, t2.a_ = function(t3, e4, r5) {
          return t3[0] = e4[0] * r5[0], t3[1] = e4[1] * r5[1], t3[2] = e4[2] * r5[2], t3[3] = e4[3] * r5[3], t3;
        }, t2.aa = function(t3) {
          const e4 = {};
          if (t3.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t4, r5, n3, i4) => {
            const s4 = n3 || i4;
            return e4[r5] = !s4 || s4.toLowerCase(), "";
          }), e4["max-age"]) {
            const t4 = parseInt(e4["max-age"], 10);
            isNaN(t4) ? delete e4["max-age"] : e4["max-age"] = t4;
          }
          return e4;
        }, t2.ab = function(t3, e4) {
          const r5 = [];
          for (const n3 in t3)
            n3 in e4 || r5.push(n3);
          return r5;
        }, t2.ac = y3, t2.ad = function(t3, e4, r5) {
          var n3 = Math.sin(r5), i4 = Math.cos(r5), s4 = e4[0], a3 = e4[1], o3 = e4[2], l4 = e4[3], u3 = e4[4], c3 = e4[5], h2 = e4[6], p4 = e4[7];
          return e4 !== t3 && (t3[8] = e4[8], t3[9] = e4[9], t3[10] = e4[10], t3[11] = e4[11], t3[12] = e4[12], t3[13] = e4[13], t3[14] = e4[14], t3[15] = e4[15]), t3[0] = s4 * i4 + u3 * n3, t3[1] = a3 * i4 + c3 * n3, t3[2] = o3 * i4 + h2 * n3, t3[3] = l4 * i4 + p4 * n3, t3[4] = u3 * i4 - s4 * n3, t3[5] = c3 * i4 - a3 * n3, t3[6] = h2 * i4 - o3 * n3, t3[7] = p4 * i4 - l4 * n3, t3;
        }, t2.ae = function(t3) {
          var e4 = new va2(16);
          return e4[0] = t3[0], e4[1] = t3[1], e4[2] = t3[2], e4[3] = t3[3], e4[4] = t3[4], e4[5] = t3[5], e4[6] = t3[6], e4[7] = t3[7], e4[8] = t3[8], e4[9] = t3[9], e4[10] = t3[10], e4[11] = t3[11], e4[12] = t3[12], e4[13] = t3[13], e4[14] = t3[14], e4[15] = t3[15], e4;
        }, t2.af = Sa2, t2.ag = function(t3, e4) {
          let r5 = 0, n3 = 0;
          if ("constant" === t3.kind)
            n3 = t3.layoutSize;
          else if ("source" !== t3.kind) {
            const { interpolationType: i4, minZoom: s4, maxZoom: a3 } = t3, o3 = i4 ? y3(Je.interpolationFactor(i4, e4, s4, a3), 0, 1) : 0;
            "camera" === t3.kind ? n3 = Ge.number(t3.minSize, t3.maxSize, o3) : r5 = o3;
          }
          return { uSizeT: r5, uSize: n3 };
        }, t2.ai = function(t3, { uSize: e4, uSizeT: r5 }, { lowerSize: n3, upperSize: i4 }) {
          return "source" === t3.kind ? n3 / wu : "composite" === t3.kind ? Ge.number(n3 / wu, i4 / wu, r5) : e4;
        }, t2.aj = Mu, t2.ak = function(t3, e4, r5, n3) {
          const i4 = e4.y - t3.y, a3 = e4.x - t3.x, o3 = n3.y - r5.y, l4 = n3.x - r5.x, u3 = o3 * a3 - l4 * i4;
          if (0 === u3)
            return null;
          const c3 = (l4 * (t3.y - r5.y) - o3 * (t3.x - r5.x)) / u3;
          return new s3(t3.x + c3 * a3, t3.y + c3 * i4);
        }, t2.al = fc2, t2.am = ea2, t2.an = ba2, t2.ao = Sl, t2.aq = Su, t2.ar = function(t3, e4) {
          var r5 = e4[0], n3 = e4[1], i4 = e4[2], s4 = e4[3], a3 = e4[4], o3 = e4[5], l4 = e4[6], u3 = e4[7], c3 = e4[8], h2 = e4[9], p4 = e4[10], f2 = e4[11], d2 = e4[12], y4 = e4[13], m2 = e4[14], g3 = e4[15], x5 = r5 * o3 - n3 * a3, v4 = r5 * l4 - i4 * a3, b3 = r5 * u3 - s4 * a3, w4 = n3 * l4 - i4 * o3, _2 = n3 * u3 - s4 * o3, A3 = i4 * u3 - s4 * l4, S4 = c3 * y4 - h2 * d2, k3 = c3 * m2 - p4 * d2, I3 = c3 * g3 - f2 * d2, z4 = h2 * m2 - p4 * y4, M3 = h2 * g3 - f2 * y4, B3 = p4 * g3 - f2 * m2, C5 = x5 * B3 - v4 * M3 + b3 * z4 + w4 * I3 - _2 * k3 + A3 * S4;
          return C5 ? (t3[0] = (o3 * B3 - l4 * M3 + u3 * z4) * (C5 = 1 / C5), t3[1] = (i4 * M3 - n3 * B3 - s4 * z4) * C5, t3[2] = (y4 * A3 - m2 * _2 + g3 * w4) * C5, t3[3] = (p4 * _2 - h2 * A3 - f2 * w4) * C5, t3[4] = (l4 * I3 - a3 * B3 - u3 * k3) * C5, t3[5] = (r5 * B3 - i4 * I3 + s4 * k3) * C5, t3[6] = (m2 * b3 - d2 * A3 - g3 * v4) * C5, t3[7] = (c3 * A3 - p4 * b3 + f2 * v4) * C5, t3[8] = (a3 * M3 - o3 * I3 + u3 * S4) * C5, t3[9] = (n3 * I3 - r5 * M3 - s4 * S4) * C5, t3[10] = (d2 * _2 - y4 * b3 + g3 * x5) * C5, t3[11] = (h2 * b3 - c3 * _2 - f2 * x5) * C5, t3[12] = (o3 * k3 - a3 * z4 - l4 * S4) * C5, t3[13] = (r5 * z4 - n3 * k3 + i4 * S4) * C5, t3[14] = (y4 * v4 - d2 * w4 - m2 * x5) * C5, t3[15] = (c3 * w4 - h2 * v4 + p4 * x5) * C5, t3) : null;
        }, t2.as = Oc2, t2.at = mu, t2.au = Zc2, t2.av = function() {
          const t3 = {}, e4 = G2.$version;
          for (const r5 in G2.$root) {
            const n3 = G2.$root[r5];
            if (n3.required) {
              let i4 = null;
              i4 = "version" === r5 ? e4 : "array" === n3.type ? [] : {}, null != i4 && (t3[r5] = i4);
            }
          }
          return t3;
        }, t2.aw = qn, t2.ax = O2, t2.ay = function(t3) {
          t3 = t3.slice();
          const e4 = /* @__PURE__ */ Object.create(null);
          for (let r5 = 0; r5 < t3.length; r5++)
            e4[t3[r5].id] = t3[r5];
          for (let r5 = 0; r5 < t3.length; r5++)
            "ref" in t3[r5] && (t3[r5] = X3(t3[r5], e4[t3[r5].ref]));
          return t3;
        }, t2.az = function(t3) {
          if ("custom" === t3.type)
            return new Nu(t3);
          switch (t3.type) {
            case "background":
              return new Ru(t3);
            case "circle":
              return new ka2(t3);
            case "fill":
              return new Bo(t3);
            case "fill-extrusion":
              return new Qo(t3);
            case "heatmap":
              return new $a2(t3);
            case "hillshade":
              return new Oa2(t3);
            case "line":
              return new yl(t3);
            case "raster":
              return new qu(t3);
            case "symbol":
              return new Du(t3);
          }
        }, t2.b = M2, t2.b0 = m, t2.b1 = nc2, t2.b2 = Wu, t2.b3 = function(t3, e4, r5, n3, i4) {
          var s4, a3 = 1 / Math.tan(e4 / 2);
          return t3[0] = a3 / r5, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = a3, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[11] = -1, t3[12] = 0, t3[13] = 0, t3[15] = 0, null != i4 && i4 !== 1 / 0 ? (t3[10] = (i4 + n3) * (s4 = 1 / (n3 - i4)), t3[14] = 2 * i4 * n3 * s4) : (t3[10] = -1, t3[14] = -2 * n3), t3;
        }, t2.b4 = function(t3, e4, r5) {
          var n3 = Math.sin(r5), i4 = Math.cos(r5), s4 = e4[4], a3 = e4[5], o3 = e4[6], l4 = e4[7], u3 = e4[8], c3 = e4[9], h2 = e4[10], p4 = e4[11];
          return e4 !== t3 && (t3[0] = e4[0], t3[1] = e4[1], t3[2] = e4[2], t3[3] = e4[3], t3[12] = e4[12], t3[13] = e4[13], t3[14] = e4[14], t3[15] = e4[15]), t3[4] = s4 * i4 + u3 * n3, t3[5] = a3 * i4 + c3 * n3, t3[6] = o3 * i4 + h2 * n3, t3[7] = l4 * i4 + p4 * n3, t3[8] = u3 * i4 - s4 * n3, t3[9] = c3 * i4 - a3 * n3, t3[10] = h2 * i4 - o3 * n3, t3[11] = p4 * i4 - l4 * n3, t3;
        }, t2.b5 = f, t2.b6 = d, t2.b7 = function(t3) {
          return t3 * Math.PI / 180;
        }, t2.b8 = function(t3, e4) {
          return t3[0] = e4[0], t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = e4[1], t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = e4[2], t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0, t3[15] = 1, t3;
        }, t2.b9 = class extends Ai {
        }, t2.ba = Ku, t2.bb = nh, t2.bd = L2, t2.be = function(t3, e4) {
          T2.REGISTERED_PROTOCOLS[t3] = e4;
        }, t2.bf = function(t3) {
          delete T2.REGISTERED_PROTOCOLS[t3];
        }, t2.bg = function(t3, e4) {
          const r5 = {};
          for (let n4 = 0; n4 < t3.length; n4++) {
            const i4 = e4 && e4[t3[n4].id] || en(t3[n4]);
            e4 && (e4[t3[n4].id] = i4);
            let s4 = r5[i4];
            s4 || (s4 = r5[i4] = []), s4.push(t3[n4]);
          }
          const n3 = [];
          for (const t4 in r5)
            n3.push(r5[t4]);
          return n3;
        }, t2.bh = On, t2.bi = oc2, t2.bj = uc2, t2.bk = ru, t2.bl = function(e4) {
          e4.bucket.createArrays(), e4.bucket.tilePixelRatio = Js / (512 * e4.bucket.overscaling), e4.bucket.compareText = {}, e4.bucket.iconsNeedLinear = false;
          const r5 = e4.bucket.layers[0], n3 = r5.layout, i4 = r5._unevaluatedLayout._values, s4 = { layoutIconSize: i4["icon-size"].possiblyEvaluate(new ti(e4.bucket.zoom + 1), e4.canonical), layoutTextSize: i4["text-size"].possiblyEvaluate(new ti(e4.bucket.zoom + 1), e4.canonical), textMaxSize: i4["text-size"].possiblyEvaluate(new ti(18)) };
          if ("composite" === e4.bucket.textSizeData.kind) {
            const { minZoom: t3, maxZoom: r6 } = e4.bucket.textSizeData;
            s4.compositeTextSizes = [i4["text-size"].possiblyEvaluate(new ti(t3), e4.canonical), i4["text-size"].possiblyEvaluate(new ti(r6), e4.canonical)];
          }
          if ("composite" === e4.bucket.iconSizeData.kind) {
            const { minZoom: t3, maxZoom: r6 } = e4.bucket.iconSizeData;
            s4.compositeIconSizes = [i4["icon-size"].possiblyEvaluate(new ti(t3), e4.canonical), i4["icon-size"].possiblyEvaluate(new ti(r6), e4.canonical)];
          }
          const a3 = n3.get("text-line-height") * Sl, o3 = "viewport" !== n3.get("text-rotation-alignment") && "point" !== n3.get("symbol-placement"), l4 = n3.get("text-keep-upright"), u3 = n3.get("text-size");
          for (const i5 of e4.bucket.features) {
            const c3 = n3.get("text-font").evaluate(i5, {}, e4.canonical).join(","), h2 = u3.evaluate(i5, {}, e4.canonical), p4 = s4.layoutTextSize.evaluate(i5, {}, e4.canonical), f2 = s4.layoutIconSize.evaluate(i5, {}, e4.canonical), d2 = { horizontal: {}, vertical: void 0 }, y4 = i5.text;
            let m2, g3 = [0, 0];
            if (y4) {
              const s5 = y4.toString(), u4 = n3.get("text-letter-spacing").evaluate(i5, {}, e4.canonical) * Sl, f3 = Kn(s5) ? u4 : 0, m3 = n3.get("text-anchor").evaluate(i5, {}, e4.canonical), x6 = Lc2(r5, i5, e4.canonical);
              if (!x6) {
                const t3 = n3.get("text-radial-offset").evaluate(i5, {}, e4.canonical);
                g3 = t3 ? Dc2(m3, [t3 * Sl, $c2]) : n3.get("text-offset").evaluate(i5, {}, e4.canonical).map((t4) => t4 * Sl);
              }
              let v5 = o3 ? "center" : n3.get("text-justify").evaluate(i5, {}, e4.canonical);
              const b3 = n3.get("symbol-placement"), w4 = "point" === b3 ? n3.get("text-max-width").evaluate(i5, {}, e4.canonical) * Sl : 0, _2 = () => {
                e4.bucket.allowVerticalPlacement && Zn(s5) && (d2.vertical = ou(y4, e4.glyphMap, e4.glyphPositions, e4.imagePositions, c3, w4, a3, m3, "left", f3, g3, t2.ah.vertical, true, b3, p4, h2));
              };
              if (!o3 && x6) {
                const r6 = /* @__PURE__ */ new Set();
                if ("auto" === v5)
                  for (let t3 = 0; t3 < x6.values.length; t3 += 2)
                    r6.add(Oc2(x6.values[t3]));
                else
                  r6.add(v5);
                let n4 = false;
                for (const i6 of r6)
                  if (!d2.horizontal[i6])
                    if (n4)
                      d2.horizontal[i6] = d2.horizontal[0];
                    else {
                      const r7 = ou(y4, e4.glyphMap, e4.glyphPositions, e4.imagePositions, c3, w4, a3, "center", i6, f3, g3, t2.ah.horizontal, false, b3, p4, h2);
                      r7 && (d2.horizontal[i6] = r7, n4 = 1 === r7.positionedLines.length);
                    }
                _2();
              } else {
                "auto" === v5 && (v5 = Oc2(m3));
                const r6 = ou(y4, e4.glyphMap, e4.glyphPositions, e4.imagePositions, c3, w4, a3, m3, v5, f3, g3, t2.ah.horizontal, false, b3, p4, h2);
                r6 && (d2.horizontal[v5] = r6), _2(), Zn(s5) && o3 && l4 && (d2.vertical = ou(y4, e4.glyphMap, e4.glyphPositions, e4.imagePositions, c3, w4, a3, m3, v5, f3, g3, t2.ah.vertical, false, b3, p4, h2));
              }
            }
            let x5 = false;
            if (i5.icon && i5.icon.name) {
              const t3 = e4.imageMap[i5.icon.name];
              t3 && (m2 = xu(e4.imagePositions[i5.icon.name], n3.get("icon-offset").evaluate(i5, {}, e4.canonical), n3.get("icon-anchor").evaluate(i5, {}, e4.canonical)), x5 = !!t3.sdf, void 0 === e4.bucket.sdfIcons ? e4.bucket.sdfIcons = x5 : e4.bucket.sdfIcons !== x5 && A2("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (t3.pixelRatio !== e4.bucket.pixelRatio || 0 !== n3.get("icon-rotate").constantOr(1)) && (e4.bucket.iconsNeedLinear = true));
            }
            const v4 = jc2(d2.horizontal) || d2.vertical;
            e4.bucket.iconsInText = !!v4 && v4.iconsInText, (v4 || m2) && Rc2(e4.bucket, i5, d2, m2, e4.imageMap, s4, p4, f2, g3, x5, e4.canonical);
          }
          e4.showCollisionBoxes && e4.bucket.generateCollisionDebugBuffers();
        }, t2.bm = ul, t2.bn = ko, t2.bo = Jo, t2.bp = Eo, t2.bq = Gl, t2.br = class {
          constructor(t3) {
            this._marks = { start: [t3.url, "start"].join("#"), end: [t3.url, "end"].join("#"), measure: t3.url.toString() }, performance.mark(this._marks.start);
          }
          finish() {
            performance.mark(this._marks.end);
            let t3 = performance.getEntriesByName(this._marks.measure);
            return 0 === t3.length && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), t3 = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), t3;
          }
        }, t2.bs = function(t3, r5, n3, i4, s4) {
          return e3(this, void 0, void 0, function* () {
            if (p3())
              try {
                return yield C4(t3, r5, n3, i4, s4);
              } catch (t4) {
              }
            return function(t4, e4, r6, n4, i5) {
              const s5 = t4.width, a3 = t4.height;
              P2 && V2 || (P2 = new OffscreenCanvas(s5, a3), V2 = P2.getContext("2d", { willReadFrequently: true })), P2.width = s5, P2.height = a3, V2.drawImage(t4, 0, 0, s5, a3);
              const o3 = V2.getImageData(e4, r6, n4, i5);
              return V2.clearRect(0, 0, s5, a3), o3.data;
            }(t3, r5, n3, i4, s4);
          });
        }, t2.bt = ac2, t2.bu = r4, t2.bv = n2, t2.bw = kl, t2.bx = Lr, t2.by = function(t3) {
          return t3.message === E2;
        }, t2.bz = Qn, t2.c = F3, t2.d = (t3) => e3(void 0, void 0, void 0, function* () {
          if (0 === t3.byteLength)
            return createImageBitmap(new ImageData(1, 1));
          const e4 = new Blob([new Uint8Array(t3)], { type: "image/png" });
          try {
            return createImageBitmap(e4);
          } catch (t4) {
            throw new Error(`Could not load image because of ${t4.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
          }
        }), t2.e = g2, t2.f = (t3) => new Promise((e4, r5) => {
          const n3 = new Image();
          n3.onload = () => {
            e4(n3), URL.revokeObjectURL(n3.src), n3.onload = null, window.requestAnimationFrame(() => {
              n3.src = B2;
            });
          }, n3.onerror = () => r5(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          const i4 = new Blob([new Uint8Array(t3)], { type: "image/png" });
          n3.src = t3.byteLength ? URL.createObjectURL(i4) : B2;
        }), t2.g = $, t2.h = (t3, e4) => R3(g2(t3, { type: "json" }), e4), t2.i = I2, t2.j = Z4, t2.k = N3, t2.l = (t3, e4) => R3(g2(t3, { type: "arrayBuffer" }), e4), t2.m = R3, t2.n = function(t3) {
          return new Gl(t3).readFields(Xl, []);
        }, t2.o = Ea2, t2.p = Ql, t2.q = di, t2.r = En, t2.s = U2, t2.t = $n, t2.u = Nn, t2.v = G2, t2.w = A2, t2.x = Vn, t2.y = function([t3, e4, r5]) {
          return e4 += 90, e4 *= Math.PI / 180, r5 *= Math.PI / 180, { x: t3 * Math.cos(e4) * Math.sin(r5), y: t3 * Math.sin(e4) * Math.sin(r5), z: t3 * Math.cos(r5) };
        }, t2.z = Ge;
      });
      define2("worker", ["./shared"], function(e3) {
        "use strict";
        class t2 {
          constructor(e4) {
            this.keyCache = {}, e4 && this.replace(e4);
          }
          replace(e4) {
            this._layerConfigs = {}, this._layers = {}, this.update(e4, []);
          }
          update(t3, r5) {
            for (const r6 of t3) {
              this._layerConfigs[r6.id] = r6;
              const t4 = this._layers[r6.id] = e3.az(r6);
              t4._featureFilter = e3.a6(t4.filter), this.keyCache[r6.id] && delete this.keyCache[r6.id];
            }
            for (const e4 of r5)
              delete this.keyCache[e4], delete this._layerConfigs[e4], delete this._layers[e4];
            this.familiesBySource = {};
            const i4 = e3.bg(Object.values(this._layerConfigs), this.keyCache);
            for (const e4 of i4) {
              const t4 = e4.map((e5) => this._layers[e5.id]), r6 = t4[0];
              if ("none" === r6.visibility)
                continue;
              const i5 = r6.source || "";
              let o3 = this.familiesBySource[i5];
              o3 || (o3 = this.familiesBySource[i5] = {});
              const s4 = r6.sourceLayer || "_geojsonTileLayer";
              let n3 = o3[s4];
              n3 || (n3 = o3[s4] = []), n3.push(t4);
            }
          }
        }
        class r4 {
          constructor(t3) {
            const r5 = {}, i4 = [];
            for (const e4 in t3) {
              const o4 = t3[e4], s5 = r5[e4] = {};
              for (const e5 in o4) {
                const t4 = o4[+e5];
                if (!t4 || 0 === t4.bitmap.width || 0 === t4.bitmap.height)
                  continue;
                const r6 = { x: 0, y: 0, w: t4.bitmap.width + 2, h: t4.bitmap.height + 2 };
                i4.push(r6), s5[e5] = { rect: r6, metrics: t4.metrics };
              }
            }
            const { w: o3, h: s4 } = e3.p(i4), n3 = new e3.o({ width: o3 || 1, height: s4 || 1 });
            for (const i5 in t3) {
              const o4 = t3[i5];
              for (const t4 in o4) {
                const s5 = o4[+t4];
                if (!s5 || 0 === s5.bitmap.width || 0 === s5.bitmap.height)
                  continue;
                const a3 = r5[i5][t4].rect;
                e3.o.copy(s5.bitmap, n3, { x: 0, y: 0 }, { x: a3.x + 1, y: a3.y + 1 }, s5.bitmap);
              }
            }
            this.image = n3, this.positions = r5;
          }
        }
        e3.bh("GlyphAtlas", r4);
        class i3 {
          constructor(t3) {
            this.tileID = new e3.Q(t3.tileID.overscaledZ, t3.tileID.wrap, t3.tileID.canonical.z, t3.tileID.canonical.x, t3.tileID.canonical.y), this.uid = t3.uid, this.zoom = t3.zoom, this.pixelRatio = t3.pixelRatio, this.tileSize = t3.tileSize, this.source = t3.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t3.showCollisionBoxes, this.collectResourceTiming = !!t3.collectResourceTiming, this.returnDependencies = !!t3.returnDependencies, this.promoteId = t3.promoteId, this.inFlightDependencies = [];
          }
          parse(t3, i4, s4, n3) {
            return e3._(this, void 0, void 0, function* () {
              this.status = "parsing", this.data = t3, this.collisionBoxArray = new e3.a4();
              const a3 = new e3.bi(Object.keys(t3.layers).sort()), l4 = new e3.bj(this.tileID, this.promoteId);
              l4.bucketLayerIDs = [];
              const h2 = {}, u3 = { featureIndex: l4, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: s4 }, c3 = i4.familiesBySource[this.source];
              for (const r5 in c3) {
                const i5 = t3.layers[r5];
                if (!i5)
                  continue;
                1 === i5.version && e3.w(`Vector tile source "${this.source}" layer "${r5}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                const n4 = a3.encode(r5), d3 = [];
                for (let e4 = 0; e4 < i5.length; e4++) {
                  const t4 = i5.feature(e4), o3 = l4.getId(t4, r5);
                  d3.push({ feature: t4, id: o3, index: e4, sourceLayerIndex: n4 });
                }
                for (const t4 of c3[r5]) {
                  const r6 = t4[0];
                  r6.source !== this.source && e3.w(`layer.source = ${r6.source} does not equal this.source = ${this.source}`), r6.minzoom && this.zoom < Math.floor(r6.minzoom) || r6.maxzoom && this.zoom >= r6.maxzoom || "none" !== r6.visibility && (o2(t4, this.zoom, s4), (h2[r6.id] = r6.createBucket({ index: l4.bucketLayerIDs.length, layers: t4, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: n4, sourceID: this.source })).populate(d3, u3, this.tileID.canonical), l4.bucketLayerIDs.push(t4.map((e4) => e4.id)));
                }
              }
              const d2 = e3.aE(u3.glyphDependencies, (e4) => Object.keys(e4).map(Number));
              this.inFlightDependencies.forEach((e4) => null == e4 ? void 0 : e4.abort()), this.inFlightDependencies = [];
              let f2 = Promise.resolve({});
              if (Object.keys(d2).length) {
                const e4 = new AbortController();
                this.inFlightDependencies.push(e4), f2 = n3.sendAsync({ type: "getGlyphs", data: { stacks: d2, source: this.source, tileID: this.tileID, type: "glyphs" } }, e4);
              }
              const p4 = Object.keys(u3.iconDependencies);
              let g3 = Promise.resolve({});
              if (p4.length) {
                const e4 = new AbortController();
                this.inFlightDependencies.push(e4), g3 = n3.sendAsync({ type: "getImages", data: { icons: p4, source: this.source, tileID: this.tileID, type: "icons" } }, e4);
              }
              const m2 = Object.keys(u3.patternDependencies);
              let v4 = Promise.resolve({});
              if (m2.length) {
                const e4 = new AbortController();
                this.inFlightDependencies.push(e4), v4 = n3.sendAsync({ type: "getImages", data: { icons: m2, source: this.source, tileID: this.tileID, type: "patterns" } }, e4);
              }
              const [y4, w4, x5] = yield Promise.all([f2, g3, v4]), b3 = new r4(y4), M3 = new e3.bk(w4, x5);
              for (const t4 in h2) {
                const r5 = h2[t4];
                r5 instanceof e3.a5 ? (o2(r5.layers, this.zoom, s4), e3.bl({ bucket: r5, glyphMap: y4, glyphPositions: b3.positions, imageMap: w4, imagePositions: M3.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical })) : r5.hasPattern && (r5 instanceof e3.bm || r5 instanceof e3.bn || r5 instanceof e3.bo) && (o2(r5.layers, this.zoom, s4), r5.addFeatures(u3, this.tileID.canonical, M3.patternPositions));
              }
              return this.status = "done", { buckets: Object.values(h2).filter((e4) => !e4.isEmpty()), featureIndex: l4, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: b3.image, imageAtlas: M3, glyphMap: this.returnDependencies ? y4 : null, iconMap: this.returnDependencies ? w4 : null, glyphPositions: this.returnDependencies ? b3.positions : null };
            });
          }
        }
        function o2(t3, r5, i4) {
          const o3 = new e3.a8(r5);
          for (const e4 of t3)
            e4.recalculate(o3, i4);
        }
        class s3 {
          constructor(e4, t3, r5) {
            this.actor = e4, this.layerIndex = t3, this.availableImages = r5, this.fetching = {}, this.loading = {}, this.loaded = {};
          }
          loadVectorTile(t3, r5) {
            return e3._(this, void 0, void 0, function* () {
              const i4 = yield e3.l(t3.request, r5);
              try {
                return { vectorTile: new e3.bp.VectorTile(new e3.bq(i4.data)), rawData: i4.data, cacheControl: i4.cacheControl, expires: i4.expires };
              } catch (e4) {
                const r6 = new Uint8Array(i4.data);
                let o3 = `Unable to parse the tile at ${t3.request.url}, `;
                throw o3 += 31 === r6[0] && 139 === r6[1] ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${e4.messge}`, new Error(o3);
              }
            });
          }
          loadTile(t3) {
            return e3._(this, void 0, void 0, function* () {
              const r5 = t3.uid, o3 = !!(t3 && t3.request && t3.request.collectResourceTiming) && new e3.br(t3.request), s4 = new i3(t3);
              this.loading[r5] = s4;
              const n3 = new AbortController();
              s4.abort = n3;
              try {
                const i4 = yield this.loadVectorTile(t3, n3);
                if (delete this.loading[r5], !i4)
                  return null;
                const a3 = i4.rawData, l4 = {};
                i4.expires && (l4.expires = i4.expires), i4.cacheControl && (l4.cacheControl = i4.cacheControl);
                const h2 = {};
                if (o3) {
                  const e4 = o3.finish();
                  e4 && (h2.resourceTiming = JSON.parse(JSON.stringify(e4)));
                }
                s4.vectorTile = i4.vectorTile;
                const u3 = s4.parse(i4.vectorTile, this.layerIndex, this.availableImages, this.actor);
                this.loaded[r5] = s4, this.fetching[r5] = { rawTileData: a3, cacheControl: l4, resourceTiming: h2 };
                try {
                  const t4 = yield u3;
                  return e3.e({ rawTileData: a3.slice(0) }, t4, l4, h2);
                } finally {
                  delete this.fetching[r5];
                }
              } catch (e4) {
                throw delete this.loading[r5], s4.status = "done", this.loaded[r5] = s4, e4;
              }
            });
          }
          reloadTile(t3) {
            return e3._(this, void 0, void 0, function* () {
              const r5 = t3.uid;
              if (!this.loaded || !this.loaded[r5])
                throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
              const i4 = this.loaded[r5];
              if (i4.showCollisionBoxes = t3.showCollisionBoxes, "parsing" === i4.status) {
                const t4 = yield i4.parse(i4.vectorTile, this.layerIndex, this.availableImages, this.actor);
                let o3;
                if (this.fetching[r5]) {
                  const { rawTileData: i5, cacheControl: s4, resourceTiming: n3 } = this.fetching[r5];
                  delete this.fetching[r5], o3 = e3.e({ rawTileData: i5.slice(0) }, t4, s4, n3);
                } else
                  o3 = t4;
                return o3;
              }
              if ("done" === i4.status && i4.vectorTile)
                return i4.parse(i4.vectorTile, this.layerIndex, this.availableImages, this.actor);
            });
          }
          abortTile(t3) {
            return e3._(this, void 0, void 0, function* () {
              const e4 = this.loading, r5 = t3.uid;
              e4 && e4[r5] && e4[r5].abort && (e4[r5].abort.abort(), delete e4[r5]);
            });
          }
          removeTile(t3) {
            return e3._(this, void 0, void 0, function* () {
              this.loaded && this.loaded[t3.uid] && delete this.loaded[t3.uid];
            });
          }
        }
        class n2 {
          constructor() {
            this.loaded = {};
          }
          loadTile(t3) {
            return e3._(this, void 0, void 0, function* () {
              const { uid: r5, encoding: i4, rawImageData: o3, redFactor: s4, greenFactor: n3, blueFactor: a3, baseShift: l4 } = t3, h2 = o3.width + 2, u3 = o3.height + 2, c3 = e3.b(o3) ? new e3.R({ width: h2, height: u3 }, yield e3.bs(o3, -1, -1, h2, u3)) : o3, d2 = new e3.bt(r5, c3, i4, s4, n3, a3, l4);
              return this.loaded = this.loaded || {}, this.loaded[r5] = d2, d2;
            });
          }
          removeTile(e4) {
            const t3 = this.loaded, r5 = e4.uid;
            t3 && t3[r5] && delete t3[r5];
          }
        }
        function a2(e4, t3) {
          if (0 !== e4.length) {
            l3(e4[0], t3);
            for (var r5 = 1; r5 < e4.length; r5++)
              l3(e4[r5], !t3);
          }
        }
        function l3(e4, t3) {
          for (var r5 = 0, i4 = 0, o3 = 0, s4 = e4.length, n3 = s4 - 1; o3 < s4; n3 = o3++) {
            var a3 = (e4[o3][0] - e4[n3][0]) * (e4[n3][1] + e4[o3][1]), l4 = r5 + a3;
            i4 += Math.abs(r5) >= Math.abs(a3) ? r5 - l4 + a3 : a3 - l4 + r5, r5 = l4;
          }
          r5 + i4 >= 0 != !!t3 && e4.reverse();
        }
        var h = e3.bu(function e4(t3, r5) {
          var i4, o3 = t3 && t3.type;
          if ("FeatureCollection" === o3)
            for (i4 = 0; i4 < t3.features.length; i4++)
              e4(t3.features[i4], r5);
          else if ("GeometryCollection" === o3)
            for (i4 = 0; i4 < t3.geometries.length; i4++)
              e4(t3.geometries[i4], r5);
          else if ("Feature" === o3)
            e4(t3.geometry, r5);
          else if ("Polygon" === o3)
            a2(t3.coordinates, r5);
          else if ("MultiPolygon" === o3)
            for (i4 = 0; i4 < t3.coordinates.length; i4++)
              a2(t3.coordinates[i4], r5);
          return t3;
        });
        const u2 = e3.bp.VectorTileFeature.prototype.toGeoJSON;
        var c2 = { exports: {} }, d = e3.bv, f = e3.bp.VectorTileFeature, p3 = g2;
        function g2(e4, t3) {
          this.options = t3 || {}, this.features = e4, this.length = e4.length;
        }
        function m(e4, t3) {
          this.id = "number" == typeof e4.id ? e4.id : void 0, this.type = e4.type, this.rawGeometry = 1 === e4.type ? [e4.geometry] : e4.geometry, this.properties = e4.tags, this.extent = t3 || 4096;
        }
        g2.prototype.feature = function(e4) {
          return new m(this.features[e4], this.options.extent);
        }, m.prototype.loadGeometry = function() {
          var e4 = this.rawGeometry;
          this.geometry = [];
          for (var t3 = 0; t3 < e4.length; t3++) {
            for (var r5 = e4[t3], i4 = [], o3 = 0; o3 < r5.length; o3++)
              i4.push(new d(r5[o3][0], r5[o3][1]));
            this.geometry.push(i4);
          }
          return this.geometry;
        }, m.prototype.bbox = function() {
          this.geometry || this.loadGeometry();
          for (var e4 = this.geometry, t3 = 1 / 0, r5 = -1 / 0, i4 = 1 / 0, o3 = -1 / 0, s4 = 0; s4 < e4.length; s4++)
            for (var n3 = e4[s4], a3 = 0; a3 < n3.length; a3++) {
              var l4 = n3[a3];
              t3 = Math.min(t3, l4.x), r5 = Math.max(r5, l4.x), i4 = Math.min(i4, l4.y), o3 = Math.max(o3, l4.y);
            }
          return [t3, i4, r5, o3];
        }, m.prototype.toGeoJSON = f.prototype.toGeoJSON;
        var v3 = e3.bw, y3 = p3;
        function w3(e4) {
          var t3 = new v3();
          return function(e5, t4) {
            for (var r5 in e5.layers)
              t4.writeMessage(3, x4, e5.layers[r5]);
          }(e4, t3), t3.finish();
        }
        function x4(e4, t3) {
          var r5;
          t3.writeVarintField(15, e4.version || 1), t3.writeStringField(1, e4.name || ""), t3.writeVarintField(5, e4.extent || 4096);
          var i4 = { keys: [], values: [], keycache: {}, valuecache: {} };
          for (r5 = 0; r5 < e4.length; r5++)
            i4.feature = e4.feature(r5), t3.writeMessage(2, b2, i4);
          var o3 = i4.keys;
          for (r5 = 0; r5 < o3.length; r5++)
            t3.writeStringField(3, o3[r5]);
          var s4 = i4.values;
          for (r5 = 0; r5 < s4.length; r5++)
            t3.writeMessage(4, P2, s4[r5]);
        }
        function b2(e4, t3) {
          var r5 = e4.feature;
          void 0 !== r5.id && t3.writeVarintField(1, r5.id), t3.writeMessage(2, M2, e4), t3.writeVarintField(3, r5.type), t3.writeMessage(4, I2, r5);
        }
        function M2(e4, t3) {
          var r5 = e4.feature, i4 = e4.keys, o3 = e4.values, s4 = e4.keycache, n3 = e4.valuecache;
          for (var a3 in r5.properties) {
            var l4 = r5.properties[a3], h2 = s4[a3];
            if (null !== l4) {
              void 0 === h2 && (i4.push(a3), s4[a3] = h2 = i4.length - 1), t3.writeVarint(h2);
              var u3 = typeof l4;
              "string" !== u3 && "boolean" !== u3 && "number" !== u3 && (l4 = JSON.stringify(l4));
              var c3 = u3 + ":" + l4, d2 = n3[c3];
              void 0 === d2 && (o3.push(l4), n3[c3] = d2 = o3.length - 1), t3.writeVarint(d2);
            }
          }
        }
        function _(e4, t3) {
          return (t3 << 3) + (7 & e4);
        }
        function S3(e4) {
          return e4 << 1 ^ e4 >> 31;
        }
        function I2(e4, t3) {
          for (var r5 = e4.loadGeometry(), i4 = e4.type, o3 = 0, s4 = 0, n3 = r5.length, a3 = 0; a3 < n3; a3++) {
            var l4 = r5[a3], h2 = 1;
            1 === i4 && (h2 = l4.length), t3.writeVarint(_(1, h2));
            for (var u3 = 3 === i4 ? l4.length - 1 : l4.length, c3 = 0; c3 < u3; c3++) {
              1 === c3 && 1 !== i4 && t3.writeVarint(_(2, u3 - 1));
              var d2 = l4[c3].x - o3, f2 = l4[c3].y - s4;
              t3.writeVarint(S3(d2)), t3.writeVarint(S3(f2)), o3 += d2, s4 += f2;
            }
            3 === i4 && t3.writeVarint(_(7, 1));
          }
        }
        function P2(e4, t3) {
          var r5 = typeof e4;
          "string" === r5 ? t3.writeStringField(1, e4) : "boolean" === r5 ? t3.writeBooleanField(7, e4) : "number" === r5 && (e4 % 1 != 0 ? t3.writeDoubleField(3, e4) : e4 < 0 ? t3.writeSVarintField(6, e4) : t3.writeVarintField(5, e4));
        }
        c2.exports = w3, c2.exports.fromVectorTileJs = w3, c2.exports.fromGeojsonVt = function(e4, t3) {
          t3 = t3 || {};
          var r5 = {};
          for (var i4 in e4)
            r5[i4] = new y3(e4[i4].features, t3), r5[i4].name = i4, r5[i4].version = t3.version, r5[i4].extent = t3.extent;
          return w3({ layers: r5 });
        }, c2.exports.GeoJSONWrapper = y3;
        var k2 = e3.bu(c2.exports);
        const T2 = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (e4) => e4 }, D3 = Math.fround || (C4 = new Float32Array(1), (e4) => (C4[0] = +e4, C4[0]));
        var C4;
        const O2 = 3, L2 = 5, z3 = 6;
        class F3 {
          constructor(e4) {
            this.options = Object.assign(Object.create(T2), e4), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
          }
          load(e4) {
            const { log: t3, minZoom: r5, maxZoom: i4 } = this.options;
            t3 && console.time("total time");
            const o3 = `prepare ${e4.length} points`;
            t3 && console.time(o3), this.points = e4;
            const s4 = [];
            for (let t4 = 0; t4 < e4.length; t4++) {
              const r6 = e4[t4];
              if (!r6.geometry)
                continue;
              const [i5, o4] = r6.geometry.coordinates, n4 = D3(A2(i5)), a3 = D3(Z4(o4));
              s4.push(n4, a3, 1 / 0, t4, -1, 1), this.options.reduce && s4.push(0);
            }
            let n3 = this.trees[i4 + 1] = this._createTree(s4);
            t3 && console.timeEnd(o3);
            for (let e5 = i4; e5 >= r5; e5--) {
              const r6 = +Date.now();
              n3 = this.trees[e5] = this._createTree(this._cluster(n3, e5)), t3 && console.log("z%d: %d clusters in %dms", e5, n3.numItems, +Date.now() - r6);
            }
            return t3 && console.timeEnd("total time"), this;
          }
          getClusters(e4, t3) {
            let r5 = ((e4[0] + 180) % 360 + 360) % 360 - 180;
            const i4 = Math.max(-90, Math.min(90, e4[1]));
            let o3 = 180 === e4[2] ? 180 : ((e4[2] + 180) % 360 + 360) % 360 - 180;
            const s4 = Math.max(-90, Math.min(90, e4[3]));
            if (e4[2] - e4[0] >= 360)
              r5 = -180, o3 = 180;
            else if (r5 > o3) {
              const e5 = this.getClusters([r5, i4, 180, s4], t3), n4 = this.getClusters([-180, i4, o3, s4], t3);
              return e5.concat(n4);
            }
            const n3 = this.trees[this._limitZoom(t3)], a3 = n3.range(A2(r5), Z4(s4), A2(o3), Z4(i4)), l4 = n3.data, h2 = [];
            for (const e5 of a3) {
              const t4 = this.stride * e5;
              h2.push(l4[t4 + L2] > 1 ? E2(l4, t4, this.clusterProps) : this.points[l4[t4 + O2]]);
            }
            return h2;
          }
          getChildren(e4) {
            const t3 = this._getOriginId(e4), r5 = this._getOriginZoom(e4), i4 = "No cluster with the specified id.", o3 = this.trees[r5];
            if (!o3)
              throw new Error(i4);
            const s4 = o3.data;
            if (t3 * this.stride >= s4.length)
              throw new Error(i4);
            const n3 = this.options.radius / (this.options.extent * Math.pow(2, r5 - 1)), a3 = o3.within(s4[t3 * this.stride], s4[t3 * this.stride + 1], n3), l4 = [];
            for (const t4 of a3) {
              const r6 = t4 * this.stride;
              s4[r6 + 4] === e4 && l4.push(s4[r6 + L2] > 1 ? E2(s4, r6, this.clusterProps) : this.points[s4[r6 + O2]]);
            }
            if (0 === l4.length)
              throw new Error(i4);
            return l4;
          }
          getLeaves(e4, t3, r5) {
            const i4 = [];
            return this._appendLeaves(i4, e4, t3 = t3 || 10, r5 = r5 || 0, 0), i4;
          }
          getTile(e4, t3, r5) {
            const i4 = this.trees[this._limitZoom(e4)], o3 = Math.pow(2, e4), { extent: s4, radius: n3 } = this.options, a3 = n3 / s4, l4 = (r5 - a3) / o3, h2 = (r5 + 1 + a3) / o3, u3 = { features: [] };
            return this._addTileFeatures(i4.range((t3 - a3) / o3, l4, (t3 + 1 + a3) / o3, h2), i4.data, t3, r5, o3, u3), 0 === t3 && this._addTileFeatures(i4.range(1 - a3 / o3, l4, 1, h2), i4.data, o3, r5, o3, u3), t3 === o3 - 1 && this._addTileFeatures(i4.range(0, l4, a3 / o3, h2), i4.data, -1, r5, o3, u3), u3.features.length ? u3 : null;
          }
          getClusterExpansionZoom(e4) {
            let t3 = this._getOriginZoom(e4) - 1;
            for (; t3 <= this.options.maxZoom; ) {
              const r5 = this.getChildren(e4);
              if (t3++, 1 !== r5.length)
                break;
              e4 = r5[0].properties.cluster_id;
            }
            return t3;
          }
          _appendLeaves(e4, t3, r5, i4, o3) {
            const s4 = this.getChildren(t3);
            for (const t4 of s4) {
              const s5 = t4.properties;
              if (s5 && s5.cluster ? o3 + s5.point_count <= i4 ? o3 += s5.point_count : o3 = this._appendLeaves(e4, s5.cluster_id, r5, i4, o3) : o3 < i4 ? o3++ : e4.push(t4), e4.length === r5)
                break;
            }
            return o3;
          }
          _createTree(t3) {
            const r5 = new e3.au(t3.length / this.stride | 0, this.options.nodeSize, Float32Array);
            for (let e4 = 0; e4 < t3.length; e4 += this.stride)
              r5.add(t3[e4], t3[e4 + 1]);
            return r5.finish(), r5.data = t3, r5;
          }
          _addTileFeatures(e4, t3, r5, i4, o3, s4) {
            for (const n3 of e4) {
              const e5 = n3 * this.stride, a3 = t3[e5 + L2] > 1;
              let l4, h2, u3;
              if (a3)
                l4 = j2(t3, e5, this.clusterProps), h2 = t3[e5], u3 = t3[e5 + 1];
              else {
                const r6 = this.points[t3[e5 + O2]];
                l4 = r6.properties;
                const [i5, o4] = r6.geometry.coordinates;
                h2 = A2(i5), u3 = Z4(o4);
              }
              const c3 = { type: 1, geometry: [[Math.round(this.options.extent * (h2 * o3 - r5)), Math.round(this.options.extent * (u3 * o3 - i4))]], tags: l4 };
              let d2;
              d2 = a3 || this.options.generateId ? t3[e5 + O2] : this.points[t3[e5 + O2]].id, void 0 !== d2 && (c3.id = d2), s4.features.push(c3);
            }
          }
          _limitZoom(e4) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+e4), this.options.maxZoom + 1));
          }
          _cluster(e4, t3) {
            const { radius: r5, extent: i4, reduce: o3, minPoints: s4 } = this.options, n3 = r5 / (i4 * Math.pow(2, t3)), a3 = e4.data, l4 = [], h2 = this.stride;
            for (let r6 = 0; r6 < a3.length; r6 += h2) {
              if (a3[r6 + 2] <= t3)
                continue;
              a3[r6 + 2] = t3;
              const i5 = a3[r6], u3 = a3[r6 + 1], c3 = e4.within(a3[r6], a3[r6 + 1], n3), d2 = a3[r6 + L2];
              let f2 = d2;
              for (const e5 of c3) {
                const r7 = e5 * h2;
                a3[r7 + 2] > t3 && (f2 += a3[r7 + L2]);
              }
              if (f2 > d2 && f2 >= s4) {
                let e5, s5 = i5 * d2, n4 = u3 * d2, p4 = -1;
                const g3 = ((r6 / h2 | 0) << 5) + (t3 + 1) + this.points.length;
                for (const i6 of c3) {
                  const l5 = i6 * h2;
                  if (a3[l5 + 2] <= t3)
                    continue;
                  a3[l5 + 2] = t3;
                  const u4 = a3[l5 + L2];
                  s5 += a3[l5] * u4, n4 += a3[l5 + 1] * u4, a3[l5 + 4] = g3, o3 && (e5 || (e5 = this._map(a3, r6, true), p4 = this.clusterProps.length, this.clusterProps.push(e5)), o3(e5, this._map(a3, l5)));
                }
                a3[r6 + 4] = g3, l4.push(s5 / f2, n4 / f2, 1 / 0, g3, -1, f2), o3 && l4.push(p4);
              } else {
                for (let e5 = 0; e5 < h2; e5++)
                  l4.push(a3[r6 + e5]);
                if (f2 > 1)
                  for (const e5 of c3) {
                    const r7 = e5 * h2;
                    if (!(a3[r7 + 2] <= t3)) {
                      a3[r7 + 2] = t3;
                      for (let e6 = 0; e6 < h2; e6++)
                        l4.push(a3[r7 + e6]);
                    }
                  }
              }
            }
            return l4;
          }
          _getOriginId(e4) {
            return e4 - this.points.length >> 5;
          }
          _getOriginZoom(e4) {
            return (e4 - this.points.length) % 32;
          }
          _map(e4, t3, r5) {
            if (e4[t3 + L2] > 1) {
              const i5 = this.clusterProps[e4[t3 + z3]];
              return r5 ? Object.assign({}, i5) : i5;
            }
            const i4 = this.points[e4[t3 + O2]].properties, o3 = this.options.map(i4);
            return r5 && o3 === i4 ? Object.assign({}, o3) : o3;
          }
        }
        function E2(e4, t3, r5) {
          return { type: "Feature", id: e4[t3 + O2], properties: j2(e4, t3, r5), geometry: { type: "Point", coordinates: [(i4 = e4[t3], 360 * (i4 - 0.5)), N3(e4[t3 + 1])] } };
          var i4;
        }
        function j2(e4, t3, r5) {
          const i4 = e4[t3 + L2], o3 = i4 >= 1e4 ? `${Math.round(i4 / 1e3)}k` : i4 >= 1e3 ? Math.round(i4 / 100) / 10 + "k" : i4, s4 = e4[t3 + z3], n3 = -1 === s4 ? {} : Object.assign({}, r5[s4]);
          return Object.assign(n3, { cluster: true, cluster_id: e4[t3 + O2], point_count: i4, point_count_abbreviated: o3 });
        }
        function A2(e4) {
          return e4 / 360 + 0.5;
        }
        function Z4(e4) {
          const t3 = Math.sin(e4 * Math.PI / 180), r5 = 0.5 - 0.25 * Math.log((1 + t3) / (1 - t3)) / Math.PI;
          return r5 < 0 ? 0 : r5 > 1 ? 1 : r5;
        }
        function N3(e4) {
          const t3 = (180 - 360 * e4) * Math.PI / 180;
          return 360 * Math.atan(Math.exp(t3)) / Math.PI - 90;
        }
        function W2(e4, t3, r5, i4) {
          for (var o3, s4 = i4, n3 = r5 - t3 >> 1, a3 = r5 - t3, l4 = e4[t3], h2 = e4[t3 + 1], u3 = e4[r5], c3 = e4[r5 + 1], d2 = t3 + 3; d2 < r5; d2 += 3) {
            var f2 = G2(e4[d2], e4[d2 + 1], l4, h2, u3, c3);
            if (f2 > s4)
              o3 = d2, s4 = f2;
            else if (f2 === s4) {
              var p4 = Math.abs(d2 - n3);
              p4 < a3 && (o3 = d2, a3 = p4);
            }
          }
          s4 > i4 && (o3 - t3 > 3 && W2(e4, t3, o3, i4), e4[o3 + 2] = s4, r5 - o3 > 3 && W2(e4, o3, r5, i4));
        }
        function G2(e4, t3, r5, i4, o3, s4) {
          var n3 = o3 - r5, a3 = s4 - i4;
          if (0 !== n3 || 0 !== a3) {
            var l4 = ((e4 - r5) * n3 + (t3 - i4) * a3) / (n3 * n3 + a3 * a3);
            l4 > 1 ? (r5 = o3, i4 = s4) : l4 > 0 && (r5 += n3 * l4, i4 += a3 * l4);
          }
          return (n3 = e4 - r5) * n3 + (a3 = t3 - i4) * a3;
        }
        function J3(e4, t3, r5, i4) {
          var o3 = { id: void 0 === e4 ? null : e4, type: t3, geometry: r5, tags: i4, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
          return function(e5) {
            var t4 = e5.geometry, r6 = e5.type;
            if ("Point" === r6 || "MultiPoint" === r6 || "LineString" === r6)
              R3(e5, t4);
            else if ("Polygon" === r6 || "MultiLineString" === r6)
              for (var i5 = 0; i5 < t4.length; i5++)
                R3(e5, t4[i5]);
            else if ("MultiPolygon" === r6)
              for (i5 = 0; i5 < t4.length; i5++)
                for (var o4 = 0; o4 < t4[i5].length; o4++)
                  R3(e5, t4[i5][o4]);
          }(o3), o3;
        }
        function R3(e4, t3) {
          for (var r5 = 0; r5 < t3.length; r5 += 3)
            e4.minX = Math.min(e4.minX, t3[r5]), e4.minY = Math.min(e4.minY, t3[r5 + 1]), e4.maxX = Math.max(e4.maxX, t3[r5]), e4.maxY = Math.max(e4.maxY, t3[r5 + 1]);
        }
        function Y4(e4, t3, r5, i4) {
          if (t3.geometry) {
            var o3 = t3.geometry.coordinates, s4 = t3.geometry.type, n3 = Math.pow(r5.tolerance / ((1 << r5.maxZoom) * r5.extent), 2), a3 = [], l4 = t3.id;
            if (r5.promoteId ? l4 = t3.properties[r5.promoteId] : r5.generateId && (l4 = i4 || 0), "Point" === s4)
              V2(o3, a3);
            else if ("MultiPoint" === s4)
              for (var h2 = 0; h2 < o3.length; h2++)
                V2(o3[h2], a3);
            else if ("LineString" === s4)
              q3(o3, a3, n3, false);
            else if ("MultiLineString" === s4) {
              if (r5.lineMetrics) {
                for (h2 = 0; h2 < o3.length; h2++)
                  q3(o3[h2], a3 = [], n3, false), e4.push(J3(l4, "LineString", a3, t3.properties));
                return;
              }
              X3(o3, a3, n3, false);
            } else if ("Polygon" === s4)
              X3(o3, a3, n3, true);
            else {
              if ("MultiPolygon" !== s4) {
                if ("GeometryCollection" === s4) {
                  for (h2 = 0; h2 < t3.geometry.geometries.length; h2++)
                    Y4(e4, { id: l4, geometry: t3.geometry.geometries[h2], properties: t3.properties }, r5, i4);
                  return;
                }
                throw new Error("Input data is not a valid GeoJSON object.");
              }
              for (h2 = 0; h2 < o3.length; h2++) {
                var u3 = [];
                X3(o3[h2], u3, n3, true), a3.push(u3);
              }
            }
            e4.push(J3(l4, s4, a3, t3.properties));
          }
        }
        function V2(e4, t3) {
          t3.push(H3(e4[0])), t3.push(B2(e4[1])), t3.push(0);
        }
        function q3(e4, t3, r5, i4) {
          for (var o3, s4, n3 = 0, a3 = 0; a3 < e4.length; a3++) {
            var l4 = H3(e4[a3][0]), h2 = B2(e4[a3][1]);
            t3.push(l4), t3.push(h2), t3.push(0), a3 > 0 && (n3 += i4 ? (o3 * h2 - l4 * s4) / 2 : Math.sqrt(Math.pow(l4 - o3, 2) + Math.pow(h2 - s4, 2))), o3 = l4, s4 = h2;
          }
          var u3 = t3.length - 3;
          t3[2] = 1, W2(t3, 0, u3, r5), t3[u3 + 2] = 1, t3.size = Math.abs(n3), t3.start = 0, t3.end = t3.size;
        }
        function X3(e4, t3, r5, i4) {
          for (var o3 = 0; o3 < e4.length; o3++) {
            var s4 = [];
            q3(e4[o3], s4, r5, i4), t3.push(s4);
          }
        }
        function H3(e4) {
          return e4 / 360 + 0.5;
        }
        function B2(e4) {
          var t3 = Math.sin(e4 * Math.PI / 180), r5 = 0.5 - 0.25 * Math.log((1 + t3) / (1 - t3)) / Math.PI;
          return r5 < 0 ? 0 : r5 > 1 ? 1 : r5;
        }
        function $(e4, t3, r5, i4, o3, s4, n3, a3) {
          if (i4 /= t3, s4 >= (r5 /= t3) && n3 < i4)
            return e4;
          if (n3 < r5 || s4 >= i4)
            return null;
          for (var l4 = [], h2 = 0; h2 < e4.length; h2++) {
            var u3 = e4[h2], c3 = u3.geometry, d2 = u3.type, f2 = 0 === o3 ? u3.minX : u3.minY, p4 = 0 === o3 ? u3.maxX : u3.maxY;
            if (f2 >= r5 && p4 < i4)
              l4.push(u3);
            else if (!(p4 < r5 || f2 >= i4)) {
              var g3 = [];
              if ("Point" === d2 || "MultiPoint" === d2)
                U2(c3, g3, r5, i4, o3);
              else if ("LineString" === d2)
                Q2(c3, g3, r5, i4, o3, false, a3.lineMetrics);
              else if ("MultiLineString" === d2)
                ee2(c3, g3, r5, i4, o3, false);
              else if ("Polygon" === d2)
                ee2(c3, g3, r5, i4, o3, true);
              else if ("MultiPolygon" === d2)
                for (var m2 = 0; m2 < c3.length; m2++) {
                  var v4 = [];
                  ee2(c3[m2], v4, r5, i4, o3, true), v4.length && g3.push(v4);
                }
              if (g3.length) {
                if (a3.lineMetrics && "LineString" === d2) {
                  for (m2 = 0; m2 < g3.length; m2++)
                    l4.push(J3(u3.id, d2, g3[m2], u3.tags));
                  continue;
                }
                "LineString" !== d2 && "MultiLineString" !== d2 || (1 === g3.length ? (d2 = "LineString", g3 = g3[0]) : d2 = "MultiLineString"), "Point" !== d2 && "MultiPoint" !== d2 || (d2 = 3 === g3.length ? "Point" : "MultiPoint"), l4.push(J3(u3.id, d2, g3, u3.tags));
              }
            }
          }
          return l4.length ? l4 : null;
        }
        function U2(e4, t3, r5, i4, o3) {
          for (var s4 = 0; s4 < e4.length; s4 += 3) {
            var n3 = e4[s4 + o3];
            n3 >= r5 && n3 <= i4 && (t3.push(e4[s4]), t3.push(e4[s4 + 1]), t3.push(e4[s4 + 2]));
          }
        }
        function Q2(e4, t3, r5, i4, o3, s4, n3) {
          for (var a3, l4, h2 = K2(e4), u3 = 0 === o3 ? re2 : ie3, c3 = e4.start, d2 = 0; d2 < e4.length - 3; d2 += 3) {
            var f2 = e4[d2], p4 = e4[d2 + 1], g3 = e4[d2 + 2], m2 = e4[d2 + 3], v4 = e4[d2 + 4], y4 = 0 === o3 ? f2 : p4, w4 = 0 === o3 ? m2 : v4, x5 = false;
            n3 && (a3 = Math.sqrt(Math.pow(f2 - m2, 2) + Math.pow(p4 - v4, 2))), y4 < r5 ? w4 > r5 && (l4 = u3(h2, f2, p4, m2, v4, r5), n3 && (h2.start = c3 + a3 * l4)) : y4 > i4 ? w4 < i4 && (l4 = u3(h2, f2, p4, m2, v4, i4), n3 && (h2.start = c3 + a3 * l4)) : te2(h2, f2, p4, g3), w4 < r5 && y4 >= r5 && (l4 = u3(h2, f2, p4, m2, v4, r5), x5 = true), w4 > i4 && y4 <= i4 && (l4 = u3(h2, f2, p4, m2, v4, i4), x5 = true), !s4 && x5 && (n3 && (h2.end = c3 + a3 * l4), t3.push(h2), h2 = K2(e4)), n3 && (c3 += a3);
          }
          var b3 = e4.length - 3;
          f2 = e4[b3], p4 = e4[b3 + 1], g3 = e4[b3 + 2], (y4 = 0 === o3 ? f2 : p4) >= r5 && y4 <= i4 && te2(h2, f2, p4, g3), b3 = h2.length - 3, s4 && b3 >= 3 && (h2[b3] !== h2[0] || h2[b3 + 1] !== h2[1]) && te2(h2, h2[0], h2[1], h2[2]), h2.length && t3.push(h2);
        }
        function K2(e4) {
          var t3 = [];
          return t3.size = e4.size, t3.start = e4.start, t3.end = e4.end, t3;
        }
        function ee2(e4, t3, r5, i4, o3, s4) {
          for (var n3 = 0; n3 < e4.length; n3++)
            Q2(e4[n3], t3, r5, i4, o3, s4, false);
        }
        function te2(e4, t3, r5, i4) {
          e4.push(t3), e4.push(r5), e4.push(i4);
        }
        function re2(e4, t3, r5, i4, o3, s4) {
          var n3 = (s4 - t3) / (i4 - t3);
          return e4.push(s4), e4.push(r5 + (o3 - r5) * n3), e4.push(1), n3;
        }
        function ie3(e4, t3, r5, i4, o3, s4) {
          var n3 = (s4 - r5) / (o3 - r5);
          return e4.push(t3 + (i4 - t3) * n3), e4.push(s4), e4.push(1), n3;
        }
        function oe2(e4, t3) {
          for (var r5 = [], i4 = 0; i4 < e4.length; i4++) {
            var o3, s4 = e4[i4], n3 = s4.type;
            if ("Point" === n3 || "MultiPoint" === n3 || "LineString" === n3)
              o3 = se2(s4.geometry, t3);
            else if ("MultiLineString" === n3 || "Polygon" === n3) {
              o3 = [];
              for (var a3 = 0; a3 < s4.geometry.length; a3++)
                o3.push(se2(s4.geometry[a3], t3));
            } else if ("MultiPolygon" === n3)
              for (o3 = [], a3 = 0; a3 < s4.geometry.length; a3++) {
                for (var l4 = [], h2 = 0; h2 < s4.geometry[a3].length; h2++)
                  l4.push(se2(s4.geometry[a3][h2], t3));
                o3.push(l4);
              }
            r5.push(J3(s4.id, n3, o3, s4.tags));
          }
          return r5;
        }
        function se2(e4, t3) {
          var r5 = [];
          r5.size = e4.size, void 0 !== e4.start && (r5.start = e4.start, r5.end = e4.end);
          for (var i4 = 0; i4 < e4.length; i4 += 3)
            r5.push(e4[i4] + t3, e4[i4 + 1], e4[i4 + 2]);
          return r5;
        }
        function ne(e4, t3) {
          if (e4.transformed)
            return e4;
          var r5, i4, o3, s4 = 1 << e4.z, n3 = e4.x, a3 = e4.y;
          for (r5 = 0; r5 < e4.features.length; r5++) {
            var l4 = e4.features[r5], h2 = l4.geometry, u3 = l4.type;
            if (l4.geometry = [], 1 === u3)
              for (i4 = 0; i4 < h2.length; i4 += 2)
                l4.geometry.push(ae3(h2[i4], h2[i4 + 1], t3, s4, n3, a3));
            else
              for (i4 = 0; i4 < h2.length; i4++) {
                var c3 = [];
                for (o3 = 0; o3 < h2[i4].length; o3 += 2)
                  c3.push(ae3(h2[i4][o3], h2[i4][o3 + 1], t3, s4, n3, a3));
                l4.geometry.push(c3);
              }
          }
          return e4.transformed = true, e4;
        }
        function ae3(e4, t3, r5, i4, o3, s4) {
          return [Math.round(r5 * (e4 * i4 - o3)), Math.round(r5 * (t3 * i4 - s4))];
        }
        function le2(e4, t3, r5, i4, o3) {
          for (var s4 = t3 === o3.maxZoom ? 0 : o3.tolerance / ((1 << t3) * o3.extent), n3 = { features: [], numPoints: 0, numSimplified: 0, numFeatures: 0, source: null, x: r5, y: i4, z: t3, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 }, a3 = 0; a3 < e4.length; a3++) {
            n3.numFeatures++, he2(n3, e4[a3], s4, o3);
            var l4 = e4[a3].minX, h2 = e4[a3].minY, u3 = e4[a3].maxX, c3 = e4[a3].maxY;
            l4 < n3.minX && (n3.minX = l4), h2 < n3.minY && (n3.minY = h2), u3 > n3.maxX && (n3.maxX = u3), c3 > n3.maxY && (n3.maxY = c3);
          }
          return n3;
        }
        function he2(e4, t3, r5, i4) {
          var o3 = t3.geometry, s4 = t3.type, n3 = [];
          if ("Point" === s4 || "MultiPoint" === s4)
            for (var a3 = 0; a3 < o3.length; a3 += 3)
              n3.push(o3[a3]), n3.push(o3[a3 + 1]), e4.numPoints++, e4.numSimplified++;
          else if ("LineString" === s4)
            ue2(n3, o3, e4, r5, false, false);
          else if ("MultiLineString" === s4 || "Polygon" === s4)
            for (a3 = 0; a3 < o3.length; a3++)
              ue2(n3, o3[a3], e4, r5, "Polygon" === s4, 0 === a3);
          else if ("MultiPolygon" === s4)
            for (var l4 = 0; l4 < o3.length; l4++) {
              var h2 = o3[l4];
              for (a3 = 0; a3 < h2.length; a3++)
                ue2(n3, h2[a3], e4, r5, true, 0 === a3);
            }
          if (n3.length) {
            var u3 = t3.tags || null;
            if ("LineString" === s4 && i4.lineMetrics) {
              for (var c3 in u3 = {}, t3.tags)
                u3[c3] = t3.tags[c3];
              u3.mapbox_clip_start = o3.start / o3.size, u3.mapbox_clip_end = o3.end / o3.size;
            }
            var d2 = { geometry: n3, type: "Polygon" === s4 || "MultiPolygon" === s4 ? 3 : "LineString" === s4 || "MultiLineString" === s4 ? 2 : 1, tags: u3 };
            null !== t3.id && (d2.id = t3.id), e4.features.push(d2);
          }
        }
        function ue2(e4, t3, r5, i4, o3, s4) {
          var n3 = i4 * i4;
          if (i4 > 0 && t3.size < (o3 ? n3 : i4))
            r5.numPoints += t3.length / 3;
          else {
            for (var a3 = [], l4 = 0; l4 < t3.length; l4 += 3)
              (0 === i4 || t3[l4 + 2] > n3) && (r5.numSimplified++, a3.push(t3[l4]), a3.push(t3[l4 + 1])), r5.numPoints++;
            o3 && function(e5, t4) {
              for (var r6 = 0, i5 = 0, o4 = e5.length, s5 = o4 - 2; i5 < o4; s5 = i5, i5 += 2)
                r6 += (e5[i5] - e5[s5]) * (e5[i5 + 1] + e5[s5 + 1]);
              if (r6 > 0 === t4)
                for (i5 = 0, o4 = e5.length; i5 < o4 / 2; i5 += 2) {
                  var n4 = e5[i5], a4 = e5[i5 + 1];
                  e5[i5] = e5[o4 - 2 - i5], e5[i5 + 1] = e5[o4 - 1 - i5], e5[o4 - 2 - i5] = n4, e5[o4 - 1 - i5] = a4;
                }
            }(a3, s4), e4.push(a3);
          }
        }
        function ce3(e4, t3) {
          var r5 = (t3 = this.options = function(e5, t4) {
            for (var r6 in t4)
              e5[r6] = t4[r6];
            return e5;
          }(Object.create(this.options), t3)).debug;
          if (r5 && console.time("preprocess data"), t3.maxZoom < 0 || t3.maxZoom > 24)
            throw new Error("maxZoom should be in the 0-24 range");
          if (t3.promoteId && t3.generateId)
            throw new Error("promoteId and generateId cannot be used together.");
          var i4 = function(e5, t4) {
            var r6 = [];
            if ("FeatureCollection" === e5.type)
              for (var i5 = 0; i5 < e5.features.length; i5++)
                Y4(r6, e5.features[i5], t4, i5);
            else
              Y4(r6, "Feature" === e5.type ? e5 : { geometry: e5 }, t4);
            return r6;
          }(e4, t3);
          this.tiles = {}, this.tileCoords = [], r5 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t3.indexMaxZoom, t3.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), i4 = function(e5, t4) {
            var r6 = t4.buffer / t4.extent, i5 = e5, o3 = $(e5, 1, -1 - r6, r6, 0, -1, 2, t4), s4 = $(e5, 1, 1 - r6, 2 + r6, 0, -1, 2, t4);
            return (o3 || s4) && (i5 = $(e5, 1, -r6, 1 + r6, 0, -1, 2, t4) || [], o3 && (i5 = oe2(o3, 1).concat(i5)), s4 && (i5 = i5.concat(oe2(s4, -1)))), i5;
          }(i4, t3), i4.length && this.splitTile(i4, 0, 0, 0), r5 && (i4.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
        }
        function de(e4, t3, r5) {
          return 32 * ((1 << e4) * r5 + t3) + e4;
        }
        function fe(e4, t3) {
          return t3 ? e4.properties[t3] : e4.id;
        }
        function pe2(e4, t3) {
          if (null == e4)
            return true;
          if ("Feature" === e4.type)
            return null != fe(e4, t3);
          if ("FeatureCollection" === e4.type) {
            const r5 = /* @__PURE__ */ new Set();
            for (const i4 of e4.features) {
              const e5 = fe(i4, t3);
              if (null == e5)
                return false;
              if (r5.has(e5))
                return false;
              r5.add(e5);
            }
            return true;
          }
          return false;
        }
        function ge2(e4, t3) {
          const r5 = /* @__PURE__ */ new Map();
          if (null == e4)
            ;
          else if ("Feature" === e4.type)
            r5.set(fe(e4, t3), e4);
          else
            for (const i4 of e4.features)
              r5.set(fe(i4, t3), i4);
          return r5;
        }
        ce3.prototype.options = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 }, ce3.prototype.splitTile = function(e4, t3, r5, i4, o3, s4, n3) {
          for (var a3 = [e4, t3, r5, i4], l4 = this.options, h2 = l4.debug; a3.length; ) {
            i4 = a3.pop(), r5 = a3.pop(), t3 = a3.pop(), e4 = a3.pop();
            var u3 = 1 << t3, c3 = de(t3, r5, i4), d2 = this.tiles[c3];
            if (!d2 && (h2 > 1 && console.time("creation"), d2 = this.tiles[c3] = le2(e4, t3, r5, i4, l4), this.tileCoords.push({ z: t3, x: r5, y: i4 }), h2)) {
              h2 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t3, r5, i4, d2.numFeatures, d2.numPoints, d2.numSimplified), console.timeEnd("creation"));
              var f2 = "z" + t3;
              this.stats[f2] = (this.stats[f2] || 0) + 1, this.total++;
            }
            if (d2.source = e4, o3) {
              if (t3 === l4.maxZoom || t3 === o3)
                continue;
              var p4 = 1 << o3 - t3;
              if (r5 !== Math.floor(s4 / p4) || i4 !== Math.floor(n3 / p4))
                continue;
            } else if (t3 === l4.indexMaxZoom || d2.numPoints <= l4.indexMaxPoints)
              continue;
            if (d2.source = null, 0 !== e4.length) {
              h2 > 1 && console.time("clipping");
              var g3, m2, v4, y4, w4, x5, b3 = 0.5 * l4.buffer / l4.extent, M3 = 0.5 - b3, _2 = 0.5 + b3, S4 = 1 + b3;
              g3 = m2 = v4 = y4 = null, w4 = $(e4, u3, r5 - b3, r5 + _2, 0, d2.minX, d2.maxX, l4), x5 = $(e4, u3, r5 + M3, r5 + S4, 0, d2.minX, d2.maxX, l4), e4 = null, w4 && (g3 = $(w4, u3, i4 - b3, i4 + _2, 1, d2.minY, d2.maxY, l4), m2 = $(w4, u3, i4 + M3, i4 + S4, 1, d2.minY, d2.maxY, l4), w4 = null), x5 && (v4 = $(x5, u3, i4 - b3, i4 + _2, 1, d2.minY, d2.maxY, l4), y4 = $(x5, u3, i4 + M3, i4 + S4, 1, d2.minY, d2.maxY, l4), x5 = null), h2 > 1 && console.timeEnd("clipping"), a3.push(g3 || [], t3 + 1, 2 * r5, 2 * i4), a3.push(m2 || [], t3 + 1, 2 * r5, 2 * i4 + 1), a3.push(v4 || [], t3 + 1, 2 * r5 + 1, 2 * i4), a3.push(y4 || [], t3 + 1, 2 * r5 + 1, 2 * i4 + 1);
            }
          }
        }, ce3.prototype.getTile = function(e4, t3, r5) {
          var i4 = this.options, o3 = i4.extent, s4 = i4.debug;
          if (e4 < 0 || e4 > 24)
            return null;
          var n3 = 1 << e4, a3 = de(e4, t3 = (t3 % n3 + n3) % n3, r5);
          if (this.tiles[a3])
            return ne(this.tiles[a3], o3);
          s4 > 1 && console.log("drilling down to z%d-%d-%d", e4, t3, r5);
          for (var l4, h2 = e4, u3 = t3, c3 = r5; !l4 && h2 > 0; )
            h2--, u3 = Math.floor(u3 / 2), c3 = Math.floor(c3 / 2), l4 = this.tiles[de(h2, u3, c3)];
          return l4 && l4.source ? (s4 > 1 && console.log("found parent tile z%d-%d-%d", h2, u3, c3), s4 > 1 && console.time("drilling down"), this.splitTile(l4.source, h2, u3, c3, e4, t3, r5), s4 > 1 && console.timeEnd("drilling down"), this.tiles[a3] ? ne(this.tiles[a3], o3) : null) : null;
        };
        class me2 extends s3 {
          constructor() {
            super(...arguments), this._dataUpdateable = /* @__PURE__ */ new Map();
          }
          loadVectorTile(t3, r5) {
            return e3._(this, void 0, void 0, function* () {
              const r6 = t3.tileID.canonical;
              if (!this._geoJSONIndex)
                throw new Error("Unable to parse the data into a cluster or geojson");
              const i4 = this._geoJSONIndex.getTile(r6.z, r6.x, r6.y);
              if (!i4)
                return null;
              const o3 = new class {
                constructor(t4) {
                  this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = e3.W, this.length = t4.length, this._features = t4;
                }
                feature(t4) {
                  return new class {
                    constructor(t5) {
                      this._feature = t5, this.extent = e3.W, this.type = t5.type, this.properties = t5.tags, "id" in t5 && !isNaN(t5.id) && (this.id = parseInt(t5.id, 10));
                    }
                    loadGeometry() {
                      if (1 === this._feature.type) {
                        const t5 = [];
                        for (const r7 of this._feature.geometry)
                          t5.push([new e3.P(r7[0], r7[1])]);
                        return t5;
                      }
                      {
                        const t5 = [];
                        for (const r7 of this._feature.geometry) {
                          const i5 = [];
                          for (const t6 of r7)
                            i5.push(new e3.P(t6[0], t6[1]));
                          t5.push(i5);
                        }
                        return t5;
                      }
                    }
                    toGeoJSON(e4, t5, r7) {
                      return u2.call(this, e4, t5, r7);
                    }
                  }(this._features[t4]);
                }
              }(i4.features);
              let s4 = k2(o3);
              return 0 === s4.byteOffset && s4.byteLength === s4.buffer.byteLength || (s4 = new Uint8Array(s4)), { vectorTile: o3, rawData: s4.buffer };
            });
          }
          loadData(t3) {
            var r5;
            return e3._(this, void 0, void 0, function* () {
              null === (r5 = this._pendingRequest) || void 0 === r5 || r5.abort();
              const i4 = !!(t3 && t3.request && t3.request.collectResourceTiming) && new e3.br(t3.request);
              this._pendingRequest = new AbortController();
              try {
                let r6 = yield this.loadGeoJSON(t3, this._pendingRequest);
                if (delete this._pendingRequest, "object" != typeof r6)
                  throw new Error(`Input data given to '${t3.source}' is not a valid GeoJSON object.`);
                if (h(r6, true), t3.filter) {
                  const i5 = e3.bx(t3.filter, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
                  if ("error" === i5.result)
                    throw new Error(i5.value.map((e4) => `${e4.key}: ${e4.message}`).join(", "));
                  const o4 = r6.features.filter((e4) => i5.value.evaluate({ zoom: 0 }, e4));
                  r6 = { type: "FeatureCollection", features: o4 };
                }
                this._geoJSONIndex = t3.cluster ? new F3(function({ superclusterOptions: t4, clusterProperties: r7 }) {
                  if (!r7 || !t4)
                    return t4;
                  const i5 = {}, o4 = {}, s4 = { accumulated: null, zoom: 0 }, n3 = { properties: null }, a3 = Object.keys(r7);
                  for (const t5 of a3) {
                    const [s5, n4] = r7[t5], a4 = e3.bx(n4), l4 = e3.bx("string" == typeof s5 ? [s5, ["accumulated"], ["get", t5]] : s5);
                    i5[t5] = a4.value, o4[t5] = l4.value;
                  }
                  return t4.map = (e4) => {
                    n3.properties = e4;
                    const t5 = {};
                    for (const e5 of a3)
                      t5[e5] = i5[e5].evaluate(s4, n3);
                    return t5;
                  }, t4.reduce = (e4, t5) => {
                    n3.properties = t5;
                    for (const t6 of a3)
                      s4.accumulated = e4[t6], e4[t6] = o4[t6].evaluate(s4, n3);
                  }, t4;
                }(t3)).load(r6.features) : function(e4, t4) {
                  return new ce3(e4, t4);
                }(r6, t3.geojsonVtOptions), this.loaded = {};
                const o3 = {};
                if (i4) {
                  const e4 = i4.finish();
                  e4 && (o3.resourceTiming = {}, o3.resourceTiming[t3.source] = JSON.parse(JSON.stringify(e4)));
                }
                return o3;
              } catch (t4) {
                if (delete this._pendingRequest, e3.by(t4))
                  return { abandoned: true };
                throw t4;
              }
            });
          }
          reloadTile(e4) {
            const t3 = this.loaded;
            return t3 && t3[e4.uid] ? super.reloadTile(e4) : this.loadTile(e4);
          }
          loadGeoJSON(t3, r5) {
            return e3._(this, void 0, void 0, function* () {
              const { promoteId: i4 } = t3;
              if (t3.request) {
                const o3 = yield e3.h(t3.request, r5);
                return this._dataUpdateable = pe2(o3.data, i4) ? ge2(o3.data, i4) : void 0, o3.data;
              }
              if ("string" == typeof t3.data)
                try {
                  const e4 = JSON.parse(t3.data);
                  return this._dataUpdateable = pe2(e4, i4) ? ge2(e4, i4) : void 0, e4;
                } catch (e4) {
                  throw new Error(`Input data given to '${t3.source}' is not a valid GeoJSON object.`);
                }
              if (!t3.dataDiff)
                throw new Error(`Input data given to '${t3.source}' is not a valid GeoJSON object.`);
              if (!this._dataUpdateable)
                throw new Error(`Cannot update existing geojson data in ${t3.source}`);
              return function(e4, t4, r6) {
                var i5, o3, s4, n3;
                if (t4.removeAll && e4.clear(), t4.remove)
                  for (const r7 of t4.remove)
                    e4.delete(r7);
                if (t4.add)
                  for (const i6 of t4.add) {
                    const t5 = fe(i6, r6);
                    null != t5 && e4.set(t5, i6);
                  }
                if (t4.update)
                  for (const r7 of t4.update) {
                    let t5 = e4.get(r7.id);
                    if (null == t5)
                      continue;
                    const a3 = !r7.removeAllProperties && ((null === (i5 = r7.removeProperties) || void 0 === i5 ? void 0 : i5.length) > 0 || (null === (o3 = r7.addOrUpdateProperties) || void 0 === o3 ? void 0 : o3.length) > 0);
                    if ((r7.newGeometry || r7.removeAllProperties || a3) && (t5 = Object.assign({}, t5), e4.set(r7.id, t5), a3 && (t5.properties = Object.assign({}, t5.properties))), r7.newGeometry && (t5.geometry = r7.newGeometry), r7.removeAllProperties)
                      t5.properties = {};
                    else if ((null === (s4 = r7.removeProperties) || void 0 === s4 ? void 0 : s4.length) > 0)
                      for (const e5 of r7.removeProperties)
                        Object.prototype.hasOwnProperty.call(t5.properties, e5) && delete t5.properties[e5];
                    if ((null === (n3 = r7.addOrUpdateProperties) || void 0 === n3 ? void 0 : n3.length) > 0)
                      for (const { key: e5, value: i6 } of r7.addOrUpdateProperties)
                        t5.properties[e5] = i6;
                  }
              }(this._dataUpdateable, t3.dataDiff, i4), { type: "FeatureCollection", features: Array.from(this._dataUpdateable.values()) };
            });
          }
          removeSource(t3) {
            return e3._(this, void 0, void 0, function* () {
              this._pendingRequest && this._pendingRequest.abort();
            });
          }
          getClusterExpansionZoom(e4) {
            return this._geoJSONIndex.getClusterExpansionZoom(e4.clusterId);
          }
          getClusterChildren(e4) {
            return this._geoJSONIndex.getChildren(e4.clusterId);
          }
          getClusterLeaves(e4) {
            return this._geoJSONIndex.getLeaves(e4.clusterId, e4.limit, e4.offset);
          }
        }
        class ve {
          constructor(t3) {
            this.self = t3, this.actor = new e3.C(t3), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.self.registerWorkerSource = (e4, t4) => {
              if (this.externalWorkerSourceTypes[e4])
                throw new Error(`Worker source with name "${e4}" already registered.`);
              this.externalWorkerSourceTypes[e4] = t4;
            }, this.self.addProtocol = e3.be, this.self.removeProtocol = e3.bf, this.self.registerRTLTextPlugin = (t4) => {
              if (e3.bz.isParsed())
                throw new Error("RTL text plugin already registered.");
              e3.bz.setMethods(t4);
            }, this.actor.registerMessageHandler("loadDEMTile", (e4, t4) => this._getDEMWorkerSource(e4, t4.source).loadTile(t4)), this.actor.registerMessageHandler("removeDEMTile", (t4, r5) => e3._(this, void 0, void 0, function* () {
              this._getDEMWorkerSource(t4, r5.source).removeTile(r5);
            })), this.actor.registerMessageHandler("getClusterExpansionZoom", (t4, r5) => e3._(this, void 0, void 0, function* () {
              return this._getWorkerSource(t4, r5.type, r5.source).getClusterExpansionZoom(r5);
            })), this.actor.registerMessageHandler("getClusterChildren", (t4, r5) => e3._(this, void 0, void 0, function* () {
              return this._getWorkerSource(t4, r5.type, r5.source).getClusterChildren(r5);
            })), this.actor.registerMessageHandler("getClusterLeaves", (t4, r5) => e3._(this, void 0, void 0, function* () {
              return this._getWorkerSource(t4, r5.type, r5.source).getClusterLeaves(r5);
            })), this.actor.registerMessageHandler("loadData", (e4, t4) => this._getWorkerSource(e4, t4.type, t4.source).loadData(t4)), this.actor.registerMessageHandler("loadTile", (e4, t4) => this._getWorkerSource(e4, t4.type, t4.source).loadTile(t4)), this.actor.registerMessageHandler("reloadTile", (e4, t4) => this._getWorkerSource(e4, t4.type, t4.source).reloadTile(t4)), this.actor.registerMessageHandler("abortTile", (e4, t4) => this._getWorkerSource(e4, t4.type, t4.source).abortTile(t4)), this.actor.registerMessageHandler("removeTile", (e4, t4) => this._getWorkerSource(e4, t4.type, t4.source).removeTile(t4)), this.actor.registerMessageHandler("removeSource", (t4, r5) => e3._(this, void 0, void 0, function* () {
              if (!this.workerSources[t4] || !this.workerSources[t4][r5.type] || !this.workerSources[t4][r5.type][r5.source])
                return;
              const e4 = this.workerSources[t4][r5.type][r5.source];
              delete this.workerSources[t4][r5.type][r5.source], void 0 !== e4.removeSource && e4.removeSource(r5);
            })), this.actor.registerMessageHandler("removeMap", (t4) => e3._(this, void 0, void 0, function* () {
              delete this.layerIndexes[t4], delete this.availableImages[t4], delete this.workerSources[t4], delete this.demWorkerSources[t4];
            })), this.actor.registerMessageHandler("setReferrer", (t4, r5) => e3._(this, void 0, void 0, function* () {
              this.referrer = r5;
            })), this.actor.registerMessageHandler("syncRTLPluginState", (e4, t4) => this._syncRTLPluginState(e4, t4)), this.actor.registerMessageHandler("importScript", (t4, r5) => e3._(this, void 0, void 0, function* () {
              this.self.importScripts(r5);
            })), this.actor.registerMessageHandler("setImages", (e4, t4) => this._setImages(e4, t4)), this.actor.registerMessageHandler("updateLayers", (t4, r5) => e3._(this, void 0, void 0, function* () {
              this._getLayerIndex(t4).update(r5.layers, r5.removedIds);
            })), this.actor.registerMessageHandler("setLayers", (t4, r5) => e3._(this, void 0, void 0, function* () {
              this._getLayerIndex(t4).replace(r5);
            }));
          }
          _setImages(t3, r5) {
            return e3._(this, void 0, void 0, function* () {
              this.availableImages[t3] = r5;
              for (const e4 in this.workerSources[t3]) {
                const i4 = this.workerSources[t3][e4];
                for (const e5 in i4)
                  i4[e5].availableImages = r5;
              }
            });
          }
          _syncRTLPluginState(t3, r5) {
            return e3._(this, void 0, void 0, function* () {
              e3.bz.setState(r5);
              const t4 = e3.bz.getPluginURL();
              if ("loaded" === r5.pluginStatus && !e3.bz.isParsed() && null != t4) {
                this.self.importScripts(t4);
                const r6 = e3.bz.isParsed();
                if (r6)
                  return r6;
                throw new Error(`RTL Text Plugin failed to import scripts from ${t4}`);
              }
              return false;
            });
          }
          _getAvailableImages(e4) {
            let t3 = this.availableImages[e4];
            return t3 || (t3 = []), t3;
          }
          _getLayerIndex(e4) {
            let r5 = this.layerIndexes[e4];
            return r5 || (r5 = this.layerIndexes[e4] = new t2()), r5;
          }
          _getWorkerSource(e4, t3, r5) {
            if (this.workerSources[e4] || (this.workerSources[e4] = {}), this.workerSources[e4][t3] || (this.workerSources[e4][t3] = {}), !this.workerSources[e4][t3][r5]) {
              const i4 = { sendAsync: (t4, r6) => (t4.targetMapId = e4, this.actor.sendAsync(t4, r6)) };
              switch (t3) {
                case "vector":
                  this.workerSources[e4][t3][r5] = new s3(i4, this._getLayerIndex(e4), this._getAvailableImages(e4));
                  break;
                case "geojson":
                  this.workerSources[e4][t3][r5] = new me2(i4, this._getLayerIndex(e4), this._getAvailableImages(e4));
                  break;
                default:
                  this.workerSources[e4][t3][r5] = new this.externalWorkerSourceTypes[t3](i4, this._getLayerIndex(e4), this._getAvailableImages(e4));
              }
            }
            return this.workerSources[e4][t3][r5];
          }
          _getDEMWorkerSource(e4, t3) {
            return this.demWorkerSources[e4] || (this.demWorkerSources[e4] = {}), this.demWorkerSources[e4][t3] || (this.demWorkerSources[e4][t3] = new n2()), this.demWorkerSources[e4][t3];
          }
        }
        return e3.i(self) && (self.worker = new ve(self)), ve;
      });
      define2("index", ["exports", "./shared"], function(t2, e3) {
        "use strict";
        var i3 = "4.1.0";
        let s3, a2;
        const o2 = { now: "undefined" != typeof performance && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), frameAsync: (t3) => new Promise((i4, s4) => {
          const a3 = requestAnimationFrame(i4);
          t3.signal.addEventListener("abort", () => {
            cancelAnimationFrame(a3), s4(e3.c());
          });
        }), getImageData(t3, e4 = 0) {
          return this.getImageCanvasContext(t3).getImageData(-e4, -e4, t3.width + 2 * e4, t3.height + 2 * e4);
        }, getImageCanvasContext(t3) {
          const e4 = window.document.createElement("canvas"), i4 = e4.getContext("2d", { willReadFrequently: true });
          if (!i4)
            throw new Error("failed to create canvas 2d context");
          return e4.width = t3.width, e4.height = t3.height, i4.drawImage(t3, 0, 0, t3.width, t3.height), i4;
        }, resolveURL: (t3) => (s3 || (s3 = document.createElement("a")), s3.href = t3, s3.href), hardwareConcurrency: "undefined" != typeof navigator && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
          return !!matchMedia && (null == a2 && (a2 = matchMedia("(prefers-reduced-motion: reduce)")), a2.matches);
        } };
        class r4 {
          static testProp(t3) {
            if (!r4.docStyle)
              return t3[0];
            for (let e4 = 0; e4 < t3.length; e4++)
              if (t3[e4] in r4.docStyle)
                return t3[e4];
            return t3[0];
          }
          static create(t3, e4, i4) {
            const s4 = window.document.createElement(t3);
            return void 0 !== e4 && (s4.className = e4), i4 && i4.appendChild(s4), s4;
          }
          static createNS(t3, e4) {
            return window.document.createElementNS(t3, e4);
          }
          static disableDrag() {
            r4.docStyle && r4.selectProp && (r4.userSelect = r4.docStyle[r4.selectProp], r4.docStyle[r4.selectProp] = "none");
          }
          static enableDrag() {
            r4.docStyle && r4.selectProp && (r4.docStyle[r4.selectProp] = r4.userSelect);
          }
          static setTransform(t3, e4) {
            t3.style[r4.transformProp] = e4;
          }
          static addEventListener(t3, e4, i4, s4 = {}) {
            t3.addEventListener(e4, i4, "passive" in s4 ? s4 : s4.capture);
          }
          static removeEventListener(t3, e4, i4, s4 = {}) {
            t3.removeEventListener(e4, i4, "passive" in s4 ? s4 : s4.capture);
          }
          static suppressClickInternal(t3) {
            t3.preventDefault(), t3.stopPropagation(), window.removeEventListener("click", r4.suppressClickInternal, true);
          }
          static suppressClick() {
            window.addEventListener("click", r4.suppressClickInternal, true), window.setTimeout(() => {
              window.removeEventListener("click", r4.suppressClickInternal, true);
            }, 0);
          }
          static getScale(t3) {
            const e4 = t3.getBoundingClientRect();
            return { x: e4.width / t3.offsetWidth || 1, y: e4.height / t3.offsetHeight || 1, boundingClientRect: e4 };
          }
          static getPoint(t3, i4, s4) {
            const a3 = i4.boundingClientRect;
            return new e3.P((s4.clientX - a3.left) / i4.x - t3.clientLeft, (s4.clientY - a3.top) / i4.y - t3.clientTop);
          }
          static mousePos(t3, e4) {
            const i4 = r4.getScale(t3);
            return r4.getPoint(t3, i4, e4);
          }
          static touchPos(t3, e4) {
            const i4 = [], s4 = r4.getScale(t3);
            for (let a3 = 0; a3 < e4.length; a3++)
              i4.push(r4.getPoint(t3, s4, e4[a3]));
            return i4;
          }
          static mouseButton(t3) {
            return t3.button;
          }
          static remove(t3) {
            t3.parentNode && t3.parentNode.removeChild(t3);
          }
        }
        r4.docStyle = "undefined" != typeof window && window.document && window.document.documentElement.style, r4.selectProp = r4.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), r4.transformProp = r4.testProp(["transform", "WebkitTransform"]);
        const n2 = { supported: false, testSupport: function(t3) {
          !c2 && h && (u2 ? d(t3) : l3 = t3);
        } };
        let l3, h, c2 = false, u2 = false;
        function d(t3) {
          const e4 = t3.createTexture();
          t3.bindTexture(t3.TEXTURE_2D, e4);
          try {
            if (t3.texImage2D(t3.TEXTURE_2D, 0, t3.RGBA, t3.RGBA, t3.UNSIGNED_BYTE, h), t3.isContextLost())
              return;
            n2.supported = true;
          } catch (t4) {
          }
          t3.deleteTexture(e4), c2 = true;
        }
        var _, p3;
        "undefined" != typeof document && (h = document.createElement("img"), h.onload = function() {
          l3 && d(l3), l3 = null, u2 = true;
        }, h.onerror = function() {
          c2 = true, l3 = null;
        }, h.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), function(t3) {
          let i4, s4, a3, o3;
          t3.resetRequestQueue = () => {
            i4 = [], s4 = 0, a3 = 0, o3 = {};
          }, t3.addThrottleControl = (t4) => {
            const e4 = a3++;
            return o3[e4] = t4, e4;
          }, t3.removeThrottleControl = (t4) => {
            delete o3[t4], l4();
          }, t3.getImage = (t4, s5, a4 = true) => new Promise((o4, r6) => {
            n2.supported && (t4.headers || (t4.headers = {}), t4.headers.accept = "image/webp,*/*"), e3.e(t4, { type: "image" }), i4.push({ abortController: s5, requestParameters: t4, supportImageRefresh: a4, state: "queued", onError: (t5) => {
              r6(t5);
            }, onSuccess: (t5) => {
              o4(t5);
            } }), l4();
          });
          const r5 = (t4) => e3._(this, void 0, void 0, function* () {
            t4.state = "running";
            const { requestParameters: i5, supportImageRefresh: a4, onError: o4, onSuccess: r6, abortController: n3 } = t4, c3 = false === a4 && !e3.i(self) && !e3.g(i5.url) && (!i5.headers || Object.keys(i5.headers).reduce((t5, e4) => t5 && "accept" === e4, true));
            s4++;
            const u3 = c3 ? h2(i5, n3) : e3.m(i5, n3);
            try {
              const i6 = yield u3;
              delete t4.abortController, t4.state = "completed", i6.data instanceof HTMLImageElement || e3.b(i6.data) ? r6(i6) : i6.data && r6({ data: yield (d2 = i6.data, "function" == typeof createImageBitmap ? e3.d(d2) : e3.f(d2)), cacheControl: i6.cacheControl, expires: i6.expires });
            } catch (e4) {
              delete t4.abortController, o4(e4);
            } finally {
              s4--, l4();
            }
            var d2;
          }), l4 = () => {
            const t4 = (() => {
              for (const t5 of Object.keys(o3))
                if (o3[t5]())
                  return true;
              return false;
            })() ? e3.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : e3.a.MAX_PARALLEL_IMAGE_REQUESTS;
            for (let e4 = s4; e4 < t4 && i4.length > 0; e4++) {
              const t5 = i4.shift();
              t5.abortController.signal.aborted ? e4-- : r5(t5);
            }
          }, h2 = (t4, i5) => new Promise((s5, a4) => {
            const o4 = new Image(), r6 = t4.url, n3 = t4.credentials;
            n3 && "include" === n3 ? o4.crossOrigin = "use-credentials" : (n3 && "same-origin" === n3 || !e3.s(r6)) && (o4.crossOrigin = "anonymous"), i5.signal.addEventListener("abort", () => {
              o4.src = "", a4(e3.c());
            }), o4.fetchPriority = "high", o4.onload = () => {
              o4.onerror = o4.onload = null, s5({ data: o4 });
            }, o4.onerror = () => {
              o4.onerror = o4.onload = null, i5.signal.aborted || a4(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            }, o4.src = r6;
          });
        }(_ || (_ = {})), _.resetRequestQueue(), function(t3) {
          t3.Glyphs = "Glyphs", t3.Image = "Image", t3.Source = "Source", t3.SpriteImage = "SpriteImage", t3.SpriteJSON = "SpriteJSON", t3.Style = "Style", t3.Tile = "Tile", t3.Unknown = "Unknown";
        }(p3 || (p3 = {}));
        class m {
          constructor(t3) {
            this._transformRequestFn = t3;
          }
          transformRequest(t3, e4) {
            return this._transformRequestFn && this._transformRequestFn(t3, e4) || { url: t3 };
          }
          normalizeSpriteURL(t3, e4, i4) {
            const s4 = function(t4) {
              const e5 = t4.match(f);
              if (!e5)
                throw new Error(`Unable to parse URL "${t4}"`);
              return { protocol: e5[1], authority: e5[2], path: e5[3] || "/", params: e5[4] ? e5[4].split("&") : [] };
            }(t3);
            return s4.path += `${e4}${i4}`, function(t4) {
              const e5 = t4.params.length ? `?${t4.params.join("&")}` : "";
              return `${t4.protocol}://${t4.authority}${t4.path}${e5}`;
            }(s4);
          }
          setTransformRequest(t3) {
            this._transformRequestFn = t3;
          }
        }
        const f = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
        function g2(t3) {
          var i4 = new e3.A(3);
          return i4[0] = t3[0], i4[1] = t3[1], i4[2] = t3[2], i4;
        }
        var v3, x4 = function(t3, e4, i4) {
          return t3[0] = e4[0] - i4[0], t3[1] = e4[1] - i4[1], t3[2] = e4[2] - i4[2], t3;
        };
        v3 = new e3.A(3), e3.A != Float32Array && (v3[0] = 0, v3[1] = 0, v3[2] = 0);
        var y3 = function(t3) {
          var e4 = t3[0], i4 = t3[1];
          return e4 * e4 + i4 * i4;
        };
        function b2(t3) {
          const e4 = [];
          if ("string" == typeof t3)
            e4.push({ id: "default", url: t3 });
          else if (t3 && t3.length > 0) {
            const i4 = [];
            for (const { id: s4, url: a3 } of t3) {
              const t4 = `${s4}${a3}`;
              -1 === i4.indexOf(t4) && (i4.push(t4), e4.push({ id: s4, url: a3 }));
            }
          }
          return e4;
        }
        !function() {
          var t3 = new e3.A(2);
          e3.A != Float32Array && (t3[0] = 0, t3[1] = 0);
        }();
        class w3 {
          constructor(t3, e4, i4, s4) {
            this.context = t3, this.format = i4, this.texture = t3.gl.createTexture(), this.update(e4, s4);
          }
          update(t3, i4, s4) {
            const { width: a3, height: o3 } = t3, r5 = !(this.size && this.size[0] === a3 && this.size[1] === o3 || s4), { context: n3 } = this, { gl: l4 } = n3;
            if (this.useMipmap = Boolean(i4 && i4.useMipmap), l4.bindTexture(l4.TEXTURE_2D, this.texture), n3.pixelStoreUnpackFlipY.set(false), n3.pixelStoreUnpack.set(1), n3.pixelStoreUnpackPremultiplyAlpha.set(this.format === l4.RGBA && (!i4 || false !== i4.premultiply)), r5)
              this.size = [a3, o3], t3 instanceof HTMLImageElement || t3 instanceof HTMLCanvasElement || t3 instanceof HTMLVideoElement || t3 instanceof ImageData || e3.b(t3) ? l4.texImage2D(l4.TEXTURE_2D, 0, this.format, this.format, l4.UNSIGNED_BYTE, t3) : l4.texImage2D(l4.TEXTURE_2D, 0, this.format, a3, o3, 0, this.format, l4.UNSIGNED_BYTE, t3.data);
            else {
              const { x: i5, y: r6 } = s4 || { x: 0, y: 0 };
              t3 instanceof HTMLImageElement || t3 instanceof HTMLCanvasElement || t3 instanceof HTMLVideoElement || t3 instanceof ImageData || e3.b(t3) ? l4.texSubImage2D(l4.TEXTURE_2D, 0, i5, r6, l4.RGBA, l4.UNSIGNED_BYTE, t3) : l4.texSubImage2D(l4.TEXTURE_2D, 0, i5, r6, a3, o3, l4.RGBA, l4.UNSIGNED_BYTE, t3.data);
            }
            this.useMipmap && this.isSizePowerOfTwo() && l4.generateMipmap(l4.TEXTURE_2D);
          }
          bind(t3, e4, i4) {
            const { context: s4 } = this, { gl: a3 } = s4;
            a3.bindTexture(a3.TEXTURE_2D, this.texture), i4 !== a3.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (i4 = a3.LINEAR), t3 !== this.filter && (a3.texParameteri(a3.TEXTURE_2D, a3.TEXTURE_MAG_FILTER, t3), a3.texParameteri(a3.TEXTURE_2D, a3.TEXTURE_MIN_FILTER, i4 || t3), this.filter = t3), e4 !== this.wrap && (a3.texParameteri(a3.TEXTURE_2D, a3.TEXTURE_WRAP_S, e4), a3.texParameteri(a3.TEXTURE_2D, a3.TEXTURE_WRAP_T, e4), this.wrap = e4);
          }
          isSizePowerOfTwo() {
            return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
          }
          destroy() {
            const { gl: t3 } = this.context;
            t3.deleteTexture(this.texture), this.texture = null;
          }
        }
        function T2(t3) {
          const { userImage: e4 } = t3;
          return !!(e4 && e4.render && e4.render()) && (t3.data.replace(new Uint8Array(e4.data.buffer)), true);
        }
        class I2 extends e3.E {
          constructor() {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new e3.R({ width: 1, height: 1 }), this.dirty = true;
          }
          isLoaded() {
            return this.loaded;
          }
          setLoaded(t3) {
            if (this.loaded !== t3 && (this.loaded = t3, t3)) {
              for (const { ids: t4, promiseResolve: e4 } of this.requestors)
                e4(this._getImagesForIds(t4));
              this.requestors = [];
            }
          }
          getImage(t3) {
            const i4 = this.images[t3];
            if (i4 && !i4.data && i4.spriteData) {
              const t4 = i4.spriteData;
              i4.data = new e3.R({ width: t4.width, height: t4.height }, t4.context.getImageData(t4.x, t4.y, t4.width, t4.height).data), i4.spriteData = null;
            }
            return i4;
          }
          addImage(t3, e4) {
            if (this.images[t3])
              throw new Error(`Image id ${t3} already exist, use updateImage instead`);
            this._validate(t3, e4) && (this.images[t3] = e4);
          }
          _validate(t3, i4) {
            let s4 = true;
            const a3 = i4.data || i4.spriteData;
            return this._validateStretch(i4.stretchX, a3 && a3.width) || (this.fire(new e3.j(new Error(`Image "${t3}" has invalid "stretchX" value`))), s4 = false), this._validateStretch(i4.stretchY, a3 && a3.height) || (this.fire(new e3.j(new Error(`Image "${t3}" has invalid "stretchY" value`))), s4 = false), this._validateContent(i4.content, i4) || (this.fire(new e3.j(new Error(`Image "${t3}" has invalid "content" value`))), s4 = false), s4;
          }
          _validateStretch(t3, e4) {
            if (!t3)
              return true;
            let i4 = 0;
            for (const s4 of t3) {
              if (s4[0] < i4 || s4[1] < s4[0] || e4 < s4[1])
                return false;
              i4 = s4[1];
            }
            return true;
          }
          _validateContent(t3, e4) {
            if (!t3)
              return true;
            if (4 !== t3.length)
              return false;
            const i4 = e4.spriteData, s4 = i4 && i4.width || e4.data.width, a3 = i4 && i4.height || e4.data.height;
            return !(t3[0] < 0 || s4 < t3[0] || t3[1] < 0 || a3 < t3[1] || t3[2] < 0 || s4 < t3[2] || t3[3] < 0 || a3 < t3[3] || t3[2] < t3[0] || t3[3] < t3[1]);
          }
          updateImage(t3, e4, i4 = true) {
            const s4 = this.getImage(t3);
            if (i4 && (s4.data.width !== e4.data.width || s4.data.height !== e4.data.height))
              throw new Error(`size mismatch between old image (${s4.data.width}x${s4.data.height}) and new image (${e4.data.width}x${e4.data.height}).`);
            e4.version = s4.version + 1, this.images[t3] = e4, this.updatedImages[t3] = true;
          }
          removeImage(t3) {
            const e4 = this.images[t3];
            delete this.images[t3], delete this.patterns[t3], e4.userImage && e4.userImage.onRemove && e4.userImage.onRemove();
          }
          listImages() {
            return Object.keys(this.images);
          }
          getImages(t3) {
            return new Promise((e4, i4) => {
              let s4 = true;
              if (!this.isLoaded())
                for (const e5 of t3)
                  this.images[e5] || (s4 = false);
              this.isLoaded() || s4 ? e4(this._getImagesForIds(t3)) : this.requestors.push({ ids: t3, promiseResolve: e4 });
            });
          }
          _getImagesForIds(t3) {
            const i4 = {};
            for (const s4 of t3) {
              let t4 = this.getImage(s4);
              t4 || (this.fire(new e3.k("styleimagemissing", { id: s4 })), t4 = this.getImage(s4)), t4 ? i4[s4] = { data: t4.data.clone(), pixelRatio: t4.pixelRatio, sdf: t4.sdf, version: t4.version, stretchX: t4.stretchX, stretchY: t4.stretchY, content: t4.content, hasRenderCallback: Boolean(t4.userImage && t4.userImage.render) } : e3.w(`Image "${s4}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
            }
            return i4;
          }
          getPixelSize() {
            const { width: t3, height: e4 } = this.atlasImage;
            return { width: t3, height: e4 };
          }
          getPattern(t3) {
            const i4 = this.patterns[t3], s4 = this.getImage(t3);
            if (!s4)
              return null;
            if (i4 && i4.position.version === s4.version)
              return i4.position;
            if (i4)
              i4.position.version = s4.version;
            else {
              const i5 = { w: s4.data.width + 2, h: s4.data.height + 2, x: 0, y: 0 }, a3 = new e3.I(i5, s4);
              this.patterns[t3] = { bin: i5, position: a3 };
            }
            return this._updatePatternAtlas(), this.patterns[t3].position;
          }
          bind(t3) {
            const e4 = t3.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new w3(t3, this.atlasImage, e4.RGBA), this.atlasTexture.bind(e4.LINEAR, e4.CLAMP_TO_EDGE);
          }
          _updatePatternAtlas() {
            const t3 = [];
            for (const e4 in this.patterns)
              t3.push(this.patterns[e4].bin);
            const { w: i4, h: s4 } = e3.p(t3), a3 = this.atlasImage;
            a3.resize({ width: i4 || 1, height: s4 || 1 });
            for (const t4 in this.patterns) {
              const { bin: i5 } = this.patterns[t4], s5 = i5.x + 1, o3 = i5.y + 1, r5 = this.getImage(t4).data, n3 = r5.width, l4 = r5.height;
              e3.R.copy(r5, a3, { x: 0, y: 0 }, { x: s5, y: o3 }, { width: n3, height: l4 }), e3.R.copy(r5, a3, { x: 0, y: l4 - 1 }, { x: s5, y: o3 - 1 }, { width: n3, height: 1 }), e3.R.copy(r5, a3, { x: 0, y: 0 }, { x: s5, y: o3 + l4 }, { width: n3, height: 1 }), e3.R.copy(r5, a3, { x: n3 - 1, y: 0 }, { x: s5 - 1, y: o3 }, { width: 1, height: l4 }), e3.R.copy(r5, a3, { x: 0, y: 0 }, { x: s5 + n3, y: o3 }, { width: 1, height: l4 });
            }
            this.dirty = true;
          }
          beginFrame() {
            this.callbackDispatchedThisFrame = {};
          }
          dispatchRenderCallbacks(t3) {
            for (const i4 of t3) {
              if (this.callbackDispatchedThisFrame[i4])
                continue;
              this.callbackDispatchedThisFrame[i4] = true;
              const t4 = this.getImage(i4);
              t4 || e3.w(`Image with ID: "${i4}" was not found`), T2(t4) && this.updateImage(i4, t4);
            }
          }
        }
        const E2 = 1e20;
        function S3(t3, e4, i4, s4, a3, o3, r5, n3, l4) {
          for (let h2 = e4; h2 < e4 + s4; h2++)
            C4(t3, i4 * o3 + h2, o3, a3, r5, n3, l4);
          for (let h2 = i4; h2 < i4 + a3; h2++)
            C4(t3, h2 * o3 + e4, 1, s4, r5, n3, l4);
        }
        function C4(t3, e4, i4, s4, a3, o3, r5) {
          o3[0] = 0, r5[0] = -E2, r5[1] = E2, a3[0] = t3[e4];
          for (let n3 = 1, l4 = 0, h2 = 0; n3 < s4; n3++) {
            a3[n3] = t3[e4 + n3 * i4];
            const s5 = n3 * n3;
            do {
              const t4 = o3[l4];
              h2 = (a3[n3] - a3[t4] + s5 - t4 * t4) / (n3 - t4) / 2;
            } while (h2 <= r5[l4] && --l4 > -1);
            l4++, o3[l4] = n3, r5[l4] = h2, r5[l4 + 1] = E2;
          }
          for (let n3 = 0, l4 = 0; n3 < s4; n3++) {
            for (; r5[l4 + 1] < n3; )
              l4++;
            const s5 = o3[l4], h2 = n3 - s5;
            t3[e4 + n3 * i4] = a3[s5] + h2 * h2;
          }
        }
        class P2 {
          constructor(t3, e4) {
            this.requestManager = t3, this.localIdeographFontFamily = e4, this.entries = {};
          }
          setURL(t3) {
            this.url = t3;
          }
          getGlyphs(t3) {
            return e3._(this, void 0, void 0, function* () {
              const e4 = [];
              for (const i5 in t3)
                for (const s5 of t3[i5])
                  e4.push(this._getAndCacheGlyphsPromise(i5, s5));
              const i4 = yield Promise.all(e4), s4 = {};
              for (const { stack: t4, id: e5, glyph: a3 } of i4)
                s4[t4] || (s4[t4] = {}), s4[t4][e5] = a3 && { id: a3.id, bitmap: a3.bitmap.clone(), metrics: a3.metrics };
              return s4;
            });
          }
          _getAndCacheGlyphsPromise(t3, i4) {
            return e3._(this, void 0, void 0, function* () {
              let e4 = this.entries[t3];
              e4 || (e4 = this.entries[t3] = { glyphs: {}, requests: {}, ranges: {} });
              let s4 = e4.glyphs[i4];
              if (void 0 !== s4)
                return { stack: t3, id: i4, glyph: s4 };
              if (s4 = this._tinySDF(e4, t3, i4), s4)
                return e4.glyphs[i4] = s4, { stack: t3, id: i4, glyph: s4 };
              const a3 = Math.floor(i4 / 256);
              if (256 * a3 > 65535)
                throw new Error("glyphs > 65535 not supported");
              if (e4.ranges[a3])
                return { stack: t3, id: i4, glyph: s4 };
              if (!this.url)
                throw new Error("glyphsUrl is not set");
              if (!e4.requests[a3]) {
                const i5 = P2.loadGlyphRange(t3, a3, this.url, this.requestManager);
                e4.requests[a3] = i5;
              }
              const o3 = yield e4.requests[a3];
              for (const t4 in o3)
                this._doesCharSupportLocalGlyph(+t4) || (e4.glyphs[+t4] = o3[+t4]);
              return e4.ranges[a3] = true, { stack: t3, id: i4, glyph: o3[i4] || null };
            });
          }
          _doesCharSupportLocalGlyph(t3) {
            return !!this.localIdeographFontFamily && (e3.u["CJK Unified Ideographs"](t3) || e3.u["Hangul Syllables"](t3) || e3.u.Hiragana(t3) || e3.u.Katakana(t3));
          }
          _tinySDF(t3, i4, s4) {
            const a3 = this.localIdeographFontFamily;
            if (!a3)
              return;
            if (!this._doesCharSupportLocalGlyph(s4))
              return;
            let o3 = t3.tinySDF;
            if (!o3) {
              let e4 = "400";
              /bold/i.test(i4) ? e4 = "900" : /medium/i.test(i4) ? e4 = "500" : /light/i.test(i4) && (e4 = "200"), o3 = t3.tinySDF = new P2.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: 0.25, fontFamily: a3, fontWeight: e4 });
            }
            const r5 = o3.draw(String.fromCharCode(s4));
            return { id: s4, bitmap: new e3.o({ width: r5.width || 60, height: r5.height || 60 }, r5.data), metrics: { width: r5.glyphWidth / 2 || 24, height: r5.glyphHeight / 2 || 24, left: r5.glyphLeft / 2 + 0.5 || 0, top: r5.glyphTop / 2 - 27.5 || -8, advance: r5.glyphAdvance / 2 || 24, isDoubleResolution: true } };
          }
        }
        P2.loadGlyphRange = function(t3, i4, s4, a3) {
          return e3._(this, void 0, void 0, function* () {
            const o3 = 256 * i4, r5 = o3 + 255, n3 = a3.transformRequest(s4.replace("{fontstack}", t3).replace("{range}", `${o3}-${r5}`), p3.Glyphs), l4 = yield e3.l(n3, new AbortController());
            if (!l4 || !l4.data)
              throw new Error(`Could not load glyph range. range: ${i4}, ${o3}-${r5}`);
            const h2 = {};
            for (const t4 of e3.n(l4.data))
              h2[t4.id] = t4;
            return h2;
          });
        }, P2.TinySDF = class {
          constructor({ fontSize: t3 = 24, buffer: e4 = 3, radius: i4 = 8, cutoff: s4 = 0.25, fontFamily: a3 = "sans-serif", fontWeight: o3 = "normal", fontStyle: r5 = "normal" } = {}) {
            this.buffer = e4, this.cutoff = s4, this.radius = i4;
            const n3 = this.size = t3 + 4 * e4, l4 = this._createCanvas(n3), h2 = this.ctx = l4.getContext("2d", { willReadFrequently: true });
            h2.font = `${r5} ${o3} ${t3}px ${a3}`, h2.textBaseline = "alphabetic", h2.textAlign = "left", h2.fillStyle = "black", this.gridOuter = new Float64Array(n3 * n3), this.gridInner = new Float64Array(n3 * n3), this.f = new Float64Array(n3), this.z = new Float64Array(n3 + 1), this.v = new Uint16Array(n3);
          }
          _createCanvas(t3) {
            const e4 = document.createElement("canvas");
            return e4.width = e4.height = t3, e4;
          }
          draw(t3) {
            const { width: e4, actualBoundingBoxAscent: i4, actualBoundingBoxDescent: s4, actualBoundingBoxLeft: a3, actualBoundingBoxRight: o3 } = this.ctx.measureText(t3), r5 = Math.ceil(i4), n3 = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(o3 - a3))), l4 = Math.min(this.size - this.buffer, r5 + Math.ceil(s4)), h2 = n3 + 2 * this.buffer, c3 = l4 + 2 * this.buffer, u3 = Math.max(h2 * c3, 0), d2 = new Uint8ClampedArray(u3), _2 = { data: d2, width: h2, height: c3, glyphWidth: n3, glyphHeight: l4, glyphTop: r5, glyphLeft: 0, glyphAdvance: e4 };
            if (0 === n3 || 0 === l4)
              return _2;
            const { ctx: p4, buffer: m2, gridInner: f2, gridOuter: g3 } = this;
            p4.clearRect(m2, m2, n3, l4), p4.fillText(t3, m2, m2 + r5);
            const v4 = p4.getImageData(m2, m2, n3, l4);
            g3.fill(E2, 0, u3), f2.fill(0, 0, u3);
            for (let t4 = 0; t4 < l4; t4++)
              for (let e5 = 0; e5 < n3; e5++) {
                const i5 = v4.data[4 * (t4 * n3 + e5) + 3] / 255;
                if (0 === i5)
                  continue;
                const s5 = (t4 + m2) * h2 + e5 + m2;
                if (1 === i5)
                  g3[s5] = 0, f2[s5] = E2;
                else {
                  const t5 = 0.5 - i5;
                  g3[s5] = t5 > 0 ? t5 * t5 : 0, f2[s5] = t5 < 0 ? t5 * t5 : 0;
                }
              }
            S3(g3, 0, 0, h2, c3, h2, this.f, this.v, this.z), S3(f2, m2, m2, n3, l4, h2, this.f, this.v, this.z);
            for (let t4 = 0; t4 < u3; t4++) {
              const e5 = Math.sqrt(g3[t4]) - Math.sqrt(f2[t4]);
              d2[t4] = Math.round(255 - 255 * (e5 / this.radius + this.cutoff));
            }
            return _2;
          }
        };
        class D3 {
          constructor() {
            this.specification = e3.v.light.position;
          }
          possiblyEvaluate(t3, i4) {
            return e3.y(t3.expression.evaluate(i4));
          }
          interpolate(t3, i4, s4) {
            return { x: e3.z.number(t3.x, i4.x, s4), y: e3.z.number(t3.y, i4.y, s4), z: e3.z.number(t3.z, i4.z, s4) };
          }
        }
        let z3;
        class M2 extends e3.E {
          constructor(t3) {
            super(), z3 = z3 || new e3.q({ anchor: new e3.D(e3.v.light.anchor), position: new D3(), color: new e3.D(e3.v.light.color), intensity: new e3.D(e3.v.light.intensity) }), this._transitionable = new e3.T(z3), this.setLight(t3), this._transitioning = this._transitionable.untransitioned();
          }
          getLight() {
            return this._transitionable.serialize();
          }
          setLight(t3, i4 = {}) {
            if (!this._validate(e3.r, t3, i4))
              for (const e4 in t3) {
                const i5 = t3[e4];
                e4.endsWith("-transition") ? this._transitionable.setTransition(e4.slice(0, -11), i5) : this._transitionable.setValue(e4, i5);
              }
          }
          updateTransitions(t3) {
            this._transitioning = this._transitionable.transitioned(t3, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(t3) {
            this.properties = this._transitioning.possiblyEvaluate(t3);
          }
          _validate(t3, i4, s4) {
            return (!s4 || false !== s4.validate) && e3.t(this, t3.call(e3.x, { value: i4, style: { glyphs: true, sprite: true }, styleSpec: e3.v }));
          }
        }
        class A2 {
          constructor(t3, e4) {
            this.width = t3, this.height = e4, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
          }
          getDash(t3, e4) {
            const i4 = t3.join(",") + String(e4);
            return this.dashEntry[i4] || (this.dashEntry[i4] = this.addDash(t3, e4)), this.dashEntry[i4];
          }
          getDashRanges(t3, e4, i4) {
            const s4 = [];
            let a3 = t3.length % 2 == 1 ? -t3[t3.length - 1] * i4 : 0, o3 = t3[0] * i4, r5 = true;
            s4.push({ left: a3, right: o3, isDash: r5, zeroLength: 0 === t3[0] });
            let n3 = t3[0];
            for (let e5 = 1; e5 < t3.length; e5++) {
              r5 = !r5;
              const l4 = t3[e5];
              a3 = n3 * i4, n3 += l4, o3 = n3 * i4, s4.push({ left: a3, right: o3, isDash: r5, zeroLength: 0 === l4 });
            }
            return s4;
          }
          addRoundDash(t3, e4, i4) {
            const s4 = e4 / 2;
            for (let e5 = -i4; e5 <= i4; e5++) {
              const a3 = this.width * (this.nextRow + i4 + e5);
              let o3 = 0, r5 = t3[o3];
              for (let n3 = 0; n3 < this.width; n3++) {
                n3 / r5.right > 1 && (r5 = t3[++o3]);
                const l4 = Math.abs(n3 - r5.left), h2 = Math.abs(n3 - r5.right), c3 = Math.min(l4, h2);
                let u3;
                const d2 = e5 / i4 * (s4 + 1);
                if (r5.isDash) {
                  const t4 = s4 - Math.abs(d2);
                  u3 = Math.sqrt(c3 * c3 + t4 * t4);
                } else
                  u3 = s4 - Math.sqrt(c3 * c3 + d2 * d2);
                this.data[a3 + n3] = Math.max(0, Math.min(255, u3 + 128));
              }
            }
          }
          addRegularDash(t3) {
            for (let e5 = t3.length - 1; e5 >= 0; --e5) {
              const i5 = t3[e5], s5 = t3[e5 + 1];
              i5.zeroLength ? t3.splice(e5, 1) : s5 && s5.isDash === i5.isDash && (s5.left = i5.left, t3.splice(e5, 1));
            }
            const e4 = t3[0], i4 = t3[t3.length - 1];
            e4.isDash === i4.isDash && (e4.left = i4.left - this.width, i4.right = e4.right + this.width);
            const s4 = this.width * this.nextRow;
            let a3 = 0, o3 = t3[a3];
            for (let e5 = 0; e5 < this.width; e5++) {
              e5 / o3.right > 1 && (o3 = t3[++a3]);
              const i5 = Math.abs(e5 - o3.left), r5 = Math.abs(e5 - o3.right), n3 = Math.min(i5, r5);
              this.data[s4 + e5] = Math.max(0, Math.min(255, (o3.isDash ? n3 : -n3) + 128));
            }
          }
          addDash(t3, i4) {
            const s4 = i4 ? 7 : 0, a3 = 2 * s4 + 1;
            if (this.nextRow + a3 > this.height)
              return e3.w("LineAtlas out of space"), null;
            let o3 = 0;
            for (let e4 = 0; e4 < t3.length; e4++)
              o3 += t3[e4];
            if (0 !== o3) {
              const e4 = this.width / o3, a4 = this.getDashRanges(t3, this.width, e4);
              i4 ? this.addRoundDash(a4, e4, s4) : this.addRegularDash(a4);
            }
            const r5 = { y: (this.nextRow + s4 + 0.5) / this.height, height: 2 * s4 / this.height, width: o3 };
            return this.nextRow += a3, this.dirty = true, r5;
          }
          bind(t3) {
            const e4 = t3.gl;
            this.texture ? (e4.bindTexture(e4.TEXTURE_2D, this.texture), this.dirty && (this.dirty = false, e4.texSubImage2D(e4.TEXTURE_2D, 0, 0, 0, this.width, this.height, e4.ALPHA, e4.UNSIGNED_BYTE, this.data))) : (this.texture = e4.createTexture(), e4.bindTexture(e4.TEXTURE_2D, this.texture), e4.texParameteri(e4.TEXTURE_2D, e4.TEXTURE_WRAP_S, e4.REPEAT), e4.texParameteri(e4.TEXTURE_2D, e4.TEXTURE_WRAP_T, e4.REPEAT), e4.texParameteri(e4.TEXTURE_2D, e4.TEXTURE_MIN_FILTER, e4.LINEAR), e4.texParameteri(e4.TEXTURE_2D, e4.TEXTURE_MAG_FILTER, e4.LINEAR), e4.texImage2D(e4.TEXTURE_2D, 0, e4.ALPHA, this.width, this.height, 0, e4.ALPHA, e4.UNSIGNED_BYTE, this.data));
          }
        }
        const R3 = "maplibre_preloaded_worker_pool";
        class L2 {
          constructor() {
            this.active = {};
          }
          acquire(t3) {
            if (!this.workers)
              for (this.workers = []; this.workers.length < L2.workerCount; )
                this.workers.push(new Worker(e3.a.WORKER_URL));
            return this.active[t3] = true, this.workers.slice();
          }
          release(t3) {
            delete this.active[t3], 0 === this.numActive() && (this.workers.forEach((t4) => {
              t4.terminate();
            }), this.workers = null);
          }
          isPreloaded() {
            return !!this.active[R3];
          }
          numActive() {
            return Object.keys(this.active).length;
          }
        }
        const k2 = Math.floor(o2.hardwareConcurrency / 2);
        let F3, B2;
        function O2() {
          return F3 || (F3 = new L2()), F3;
        }
        L2.workerCount = e3.B(globalThis) ? Math.max(Math.min(k2, 3), 1) : 1;
        class N3 {
          constructor(t3, i4) {
            this.workerPool = t3, this.actors = [], this.currentActor = 0, this.id = i4;
            const s4 = this.workerPool.acquire(i4);
            for (let t4 = 0; t4 < s4.length; t4++) {
              const a3 = new e3.C(s4[t4], i4);
              a3.name = `Worker ${t4}`, this.actors.push(a3);
            }
            if (!this.actors.length)
              throw new Error("No actors found");
          }
          broadcast(t3, e4) {
            const i4 = [];
            for (const s4 of this.actors)
              i4.push(s4.sendAsync({ type: t3, data: e4 }));
            return Promise.all(i4);
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
          }
          remove(t3 = true) {
            this.actors.forEach((t4) => {
              t4.remove();
            }), this.actors = [], t3 && this.workerPool.release(this.id);
          }
          registerMessageHandler(t3, e4) {
            for (const i4 of this.actors)
              i4.registerMessageHandler(t3, e4);
          }
        }
        function U2() {
          return B2 || (B2 = new N3(O2(), e3.G), B2.registerMessageHandler("getResource", (t3, i4, s4) => e3.m(i4, s4))), B2;
        }
        function Z4(t3, i4) {
          const s4 = e3.F();
          return e3.H(s4, s4, [1, 1, 0]), e3.J(s4, s4, [0.5 * t3.width, 0.5 * t3.height, 1]), e3.K(s4, s4, t3.calculatePosMatrix(i4.toUnwrapped()));
        }
        function G2(t3, e4, i4, s4, a3, o3) {
          const r5 = function(t4, e5, i5) {
            if (t4)
              for (const s5 of t4) {
                const t5 = e5[s5];
                if (t5 && t5.source === i5 && "fill-extrusion" === t5.type)
                  return true;
              }
            else
              for (const t5 in e5) {
                const s5 = e5[t5];
                if (s5.source === i5 && "fill-extrusion" === s5.type)
                  return true;
              }
            return false;
          }(a3 && a3.layers, e4, t3.id), n3 = o3.maxPitchScaleFactor(), l4 = t3.tilesIn(s4, n3, r5);
          l4.sort(j2);
          const h2 = [];
          for (const s5 of l4)
            h2.push({ wrappedTileID: s5.tileID.wrapped().key, queryResults: s5.tile.queryRenderedFeatures(e4, i4, t3._state, s5.queryGeometry, s5.cameraQueryGeometry, s5.scale, a3, o3, n3, Z4(t3.transform, s5.tileID)) });
          const c3 = function(t4) {
            const e5 = {}, i5 = {};
            for (const s5 of t4) {
              const t5 = s5.queryResults, a4 = s5.wrappedTileID, o4 = i5[a4] = i5[a4] || {};
              for (const i6 in t5) {
                const s6 = t5[i6], a5 = o4[i6] = o4[i6] || {}, r6 = e5[i6] = e5[i6] || [];
                for (const t6 of s6)
                  a5[t6.featureIndex] || (a5[t6.featureIndex] = true, r6.push(t6));
              }
            }
            return e5;
          }(h2);
          for (const e5 in c3)
            c3[e5].forEach((e6) => {
              const i5 = e6.feature, s5 = t3.getFeatureState(i5.layer["source-layer"], i5.id);
              i5.source = i5.layer.source, i5.layer["source-layer"] && (i5.sourceLayer = i5.layer["source-layer"]), i5.state = s5;
            });
          return c3;
        }
        function j2(t3, e4) {
          const i4 = t3.tileID, s4 = e4.tileID;
          return i4.overscaledZ - s4.overscaledZ || i4.canonical.y - s4.canonical.y || i4.wrap - s4.wrap || i4.canonical.x - s4.canonical.x;
        }
        function q3(t3, i4, s4) {
          return e3._(this, void 0, void 0, function* () {
            let a3 = t3;
            if (t3.url ? a3 = (yield e3.h(i4.transformRequest(t3.url, p3.Source), s4)).data : yield o2.frameAsync(s4), !a3)
              return null;
            const r5 = e3.L(e3.e(a3, t3), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
            return "vector_layers" in a3 && a3.vector_layers && (r5.vectorLayerIds = a3.vector_layers.map((t4) => t4.id)), r5;
          });
        }
        class V2 {
          constructor(t3, e4) {
            t3 && (e4 ? this.setSouthWest(t3).setNorthEast(e4) : Array.isArray(t3) && (4 === t3.length ? this.setSouthWest([t3[0], t3[1]]).setNorthEast([t3[2], t3[3]]) : this.setSouthWest(t3[0]).setNorthEast(t3[1])));
          }
          setNorthEast(t3) {
            return this._ne = t3 instanceof e3.M ? new e3.M(t3.lng, t3.lat) : e3.M.convert(t3), this;
          }
          setSouthWest(t3) {
            return this._sw = t3 instanceof e3.M ? new e3.M(t3.lng, t3.lat) : e3.M.convert(t3), this;
          }
          extend(t3) {
            const i4 = this._sw, s4 = this._ne;
            let a3, o3;
            if (t3 instanceof e3.M)
              a3 = t3, o3 = t3;
            else {
              if (!(t3 instanceof V2))
                return Array.isArray(t3) ? 4 === t3.length || t3.every(Array.isArray) ? this.extend(V2.convert(t3)) : this.extend(e3.M.convert(t3)) : t3 && ("lng" in t3 || "lon" in t3) && "lat" in t3 ? this.extend(e3.M.convert(t3)) : this;
              if (a3 = t3._sw, o3 = t3._ne, !a3 || !o3)
                return this;
            }
            return i4 || s4 ? (i4.lng = Math.min(a3.lng, i4.lng), i4.lat = Math.min(a3.lat, i4.lat), s4.lng = Math.max(o3.lng, s4.lng), s4.lat = Math.max(o3.lat, s4.lat)) : (this._sw = new e3.M(a3.lng, a3.lat), this._ne = new e3.M(o3.lng, o3.lat)), this;
          }
          getCenter() {
            return new e3.M((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
          }
          getSouthWest() {
            return this._sw;
          }
          getNorthEast() {
            return this._ne;
          }
          getNorthWest() {
            return new e3.M(this.getWest(), this.getNorth());
          }
          getSouthEast() {
            return new e3.M(this.getEast(), this.getSouth());
          }
          getWest() {
            return this._sw.lng;
          }
          getSouth() {
            return this._sw.lat;
          }
          getEast() {
            return this._ne.lng;
          }
          getNorth() {
            return this._ne.lat;
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()];
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
          }
          isEmpty() {
            return !(this._sw && this._ne);
          }
          contains(t3) {
            const { lng: i4, lat: s4 } = e3.M.convert(t3);
            let a3 = this._sw.lng <= i4 && i4 <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (a3 = this._sw.lng >= i4 && i4 >= this._ne.lng), this._sw.lat <= s4 && s4 <= this._ne.lat && a3;
          }
          static convert(t3) {
            return t3 instanceof V2 ? t3 : t3 ? new V2(t3) : t3;
          }
          static fromLngLat(t3, i4 = 0) {
            const s4 = 360 * i4 / 40075017, a3 = s4 / Math.cos(Math.PI / 180 * t3.lat);
            return new V2(new e3.M(t3.lng - a3, t3.lat - s4), new e3.M(t3.lng + a3, t3.lat + s4));
          }
        }
        class W2 {
          constructor(t3, e4, i4) {
            this.bounds = V2.convert(this.validateBounds(t3)), this.minzoom = e4 || 0, this.maxzoom = i4 || 24;
          }
          validateBounds(t3) {
            return Array.isArray(t3) && 4 === t3.length ? [Math.max(-180, t3[0]), Math.max(-90, t3[1]), Math.min(180, t3[2]), Math.min(90, t3[3])] : [-180, -90, 180, 90];
          }
          contains(t3) {
            const i4 = Math.pow(2, t3.z), s4 = Math.floor(e3.N(this.bounds.getWest()) * i4), a3 = Math.floor(e3.O(this.bounds.getNorth()) * i4), o3 = Math.ceil(e3.N(this.bounds.getEast()) * i4), r5 = Math.ceil(e3.O(this.bounds.getSouth()) * i4);
            return t3.x >= s4 && t3.x < o3 && t3.y >= a3 && t3.y < r5;
          }
        }
        class H3 extends e3.E {
          constructor(t3, i4, s4, a3) {
            if (super(), this.id = t3, this.dispatcher = s4, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, e3.e(this, e3.L(i4, ["url", "scheme", "tileSize", "promoteId"])), this._options = e3.e({ type: "vector" }, i4), this._collectResourceTiming = i4.collectResourceTiming, 512 !== this.tileSize)
              throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(a3);
          }
          load() {
            return e3._(this, void 0, void 0, function* () {
              this._loaded = false, this.fire(new e3.k("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
              try {
                const t3 = yield q3(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = true, this.map.style.sourceCaches[this.id].clearTiles(), t3 && (e3.e(this, t3), t3.bounds && (this.tileBounds = new W2(t3.bounds, this.minzoom, this.maxzoom)), this.fire(new e3.k("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e3.k("data", { dataType: "source", sourceDataType: "content" })));
              } catch (t3) {
                this._tileJSONRequest = null, this.fire(new e3.j(t3));
              }
            });
          }
          loaded() {
            return this._loaded;
          }
          hasTile(t3) {
            return !this.tileBounds || this.tileBounds.contains(t3.canonical);
          }
          onAdd(t3) {
            this.map = t3, this.load();
          }
          setSourceProperty(t3) {
            this._tileJSONRequest && this._tileJSONRequest.abort(), t3(), this.load();
          }
          setTiles(t3) {
            return this.setSourceProperty(() => {
              this._options.tiles = t3;
            }), this;
          }
          setUrl(t3) {
            return this.setSourceProperty(() => {
              this.url = t3, this._options.url = t3;
            }), this;
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
          }
          serialize() {
            return e3.e({}, this._options);
          }
          loadTile(t3) {
            return e3._(this, void 0, void 0, function* () {
              const e4 = t3.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), i4 = { request: this.map._requestManager.transformRequest(e4, p3.Tile), uid: t3.uid, tileID: t3.tileID, zoom: t3.tileID.overscaledZ, tileSize: this.tileSize * t3.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
              i4.request.collectResourceTiming = this._collectResourceTiming;
              let s4 = "reloadTile";
              if (t3.actor && "expired" !== t3.state) {
                if ("loading" === t3.state)
                  return new Promise((e5, i5) => {
                    t3.reloadPromise = { resolve: e5, reject: i5 };
                  });
              } else
                t3.actor = this.dispatcher.getActor(), s4 = "loadTile";
              t3.abortController = new AbortController();
              try {
                const e5 = yield t3.actor.sendAsync({ type: s4, data: i4 }, t3.abortController);
                if (delete t3.abortController, t3.aborted)
                  return;
                this._afterTileLoadWorkerResponse(t3, e5);
              } catch (e5) {
                if (delete t3.abortController, t3.aborted)
                  return;
                if (e5 && 404 !== e5.status)
                  throw e5;
                this._afterTileLoadWorkerResponse(t3, null);
              }
            });
          }
          _afterTileLoadWorkerResponse(t3, e4) {
            if (e4 && e4.resourceTiming && (t3.resourceTiming = e4.resourceTiming), e4 && this.map._refreshExpiredTiles && t3.setExpiryData(e4), t3.loadVectorData(e4, this.map.painter), t3.reloadPromise) {
              const e5 = t3.reloadPromise;
              t3.reloadPromise = null, this.loadTile(t3).then(e5.resolve).catch(e5.reject);
            }
          }
          abortTile(t3) {
            return e3._(this, void 0, void 0, function* () {
              t3.abortController && (t3.abortController.abort(), delete t3.abortController), t3.actor && (yield t3.actor.sendAsync({ type: "abortTile", data: { uid: t3.uid, type: this.type, source: this.id } }));
            });
          }
          unloadTile(t3) {
            return e3._(this, void 0, void 0, function* () {
              t3.unloadVectorData(), t3.actor && (yield t3.actor.sendAsync({ type: "removeTile", data: { uid: t3.uid, type: this.type, source: this.id } }));
            });
          }
          hasTransition() {
            return false;
          }
        }
        class $ extends e3.E {
          constructor(t3, i4, s4, a3) {
            super(), this.id = t3, this.dispatcher = s4, this.setEventedParent(a3), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = e3.e({ type: "raster" }, i4), e3.e(this, e3.L(i4, ["url", "scheme", "tileSize"]));
          }
          load() {
            return e3._(this, void 0, void 0, function* () {
              this._loaded = false, this.fire(new e3.k("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
              try {
                const t3 = yield q3(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = true, t3 && (e3.e(this, t3), t3.bounds && (this.tileBounds = new W2(t3.bounds, this.minzoom, this.maxzoom)), this.fire(new e3.k("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e3.k("data", { dataType: "source", sourceDataType: "content" })));
              } catch (t3) {
                this._tileJSONRequest = null, this.fire(new e3.j(t3));
              }
            });
          }
          loaded() {
            return this._loaded;
          }
          onAdd(t3) {
            this.map = t3, this.load();
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
          }
          setSourceProperty(t3) {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), t3(), this.load();
          }
          setTiles(t3) {
            return this.setSourceProperty(() => {
              this._options.tiles = t3;
            }), this;
          }
          setUrl(t3) {
            return this.setSourceProperty(() => {
              this.url = t3, this._options.url = t3;
            }), this;
          }
          serialize() {
            return e3.e({}, this._options);
          }
          hasTile(t3) {
            return !this.tileBounds || this.tileBounds.contains(t3.canonical);
          }
          loadTile(t3) {
            return e3._(this, void 0, void 0, function* () {
              const e4 = t3.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
              t3.abortController = new AbortController();
              try {
                const i4 = yield _.getImage(this.map._requestManager.transformRequest(e4, p3.Tile), t3.abortController, this.map._refreshExpiredTiles);
                if (delete t3.abortController, t3.aborted)
                  return void (t3.state = "unloaded");
                if (i4 && i4.data) {
                  this.map._refreshExpiredTiles && i4.cacheControl && i4.expires && t3.setExpiryData({ cacheControl: i4.cacheControl, expires: i4.expires });
                  const e5 = this.map.painter.context, s4 = e5.gl, a3 = i4.data;
                  t3.texture = this.map.painter.getTileTexture(a3.width), t3.texture ? t3.texture.update(a3, { useMipmap: true }) : (t3.texture = new w3(e5, a3, s4.RGBA, { useMipmap: true }), t3.texture.bind(s4.LINEAR, s4.CLAMP_TO_EDGE, s4.LINEAR_MIPMAP_NEAREST), e5.extTextureFilterAnisotropic && s4.texParameterf(s4.TEXTURE_2D, e5.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, e5.extTextureFilterAnisotropicMax)), t3.state = "loaded";
                }
              } catch (e5) {
                if (delete t3.abortController, t3.aborted)
                  t3.state = "unloaded";
                else if (e5)
                  throw t3.state = "errored", e5;
              }
            });
          }
          abortTile(t3) {
            return e3._(this, void 0, void 0, function* () {
              t3.abortController && (t3.abortController.abort(), delete t3.abortController);
            });
          }
          unloadTile(t3) {
            return e3._(this, void 0, void 0, function* () {
              t3.texture && this.map.painter.saveTileTexture(t3.texture);
            });
          }
          hasTransition() {
            return false;
          }
        }
        class X3 extends $ {
          constructor(t3, i4, s4, a3) {
            super(t3, i4, s4, a3), this.type = "raster-dem", this.maxzoom = 22, this._options = e3.e({ type: "raster-dem" }, i4), this.encoding = i4.encoding || "mapbox", this.redFactor = i4.redFactor, this.greenFactor = i4.greenFactor, this.blueFactor = i4.blueFactor, this.baseShift = i4.baseShift;
          }
          loadTile(t3) {
            return e3._(this, void 0, void 0, function* () {
              const i4 = t3.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), s4 = this.map._requestManager.transformRequest(i4, p3.Tile);
              t3.neighboringTiles = this._getNeighboringTiles(t3.tileID), t3.abortController = new AbortController();
              try {
                const i5 = yield _.getImage(s4, t3.abortController, this.map._refreshExpiredTiles);
                if (delete t3.abortController, t3.aborted)
                  return void (t3.state = "unloaded");
                if (i5 && i5.data) {
                  const s5 = i5.data;
                  this.map._refreshExpiredTiles && i5.cacheControl && i5.expires && t3.setExpiryData({ cacheControl: i5.cacheControl, expires: i5.expires });
                  const a3 = e3.b(s5) && e3.S() ? s5 : yield this.readImageNow(s5), o3 = { type: this.type, uid: t3.uid, source: this.id, rawImageData: a3, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
                  if (!t3.actor || "expired" === t3.state) {
                    t3.actor = this.dispatcher.getActor();
                    const e4 = yield t3.actor.sendAsync({ type: "loadDEMTile", data: o3 });
                    t3.dem = e4, t3.needsHillshadePrepare = true, t3.needsTerrainPrepare = true, t3.state = "loaded";
                  }
                }
              } catch (e4) {
                if (delete t3.abortController, t3.aborted)
                  t3.state = "unloaded";
                else if (e4)
                  throw t3.state = "errored", e4;
              }
            });
          }
          readImageNow(t3) {
            return e3._(this, void 0, void 0, function* () {
              if ("undefined" != typeof VideoFrame && e3.U()) {
                const i4 = t3.width + 2, s4 = t3.height + 2;
                try {
                  return new e3.R({ width: i4, height: s4 }, yield e3.V(t3, -1, -1, i4, s4));
                } catch (t4) {
                }
              }
              return o2.getImageData(t3, 1);
            });
          }
          _getNeighboringTiles(t3) {
            const i4 = t3.canonical, s4 = Math.pow(2, i4.z), a3 = (i4.x - 1 + s4) % s4, o3 = 0 === i4.x ? t3.wrap - 1 : t3.wrap, r5 = (i4.x + 1 + s4) % s4, n3 = i4.x + 1 === s4 ? t3.wrap + 1 : t3.wrap, l4 = {};
            return l4[new e3.Q(t3.overscaledZ, o3, i4.z, a3, i4.y).key] = { backfilled: false }, l4[new e3.Q(t3.overscaledZ, n3, i4.z, r5, i4.y).key] = { backfilled: false }, i4.y > 0 && (l4[new e3.Q(t3.overscaledZ, o3, i4.z, a3, i4.y - 1).key] = { backfilled: false }, l4[new e3.Q(t3.overscaledZ, t3.wrap, i4.z, i4.x, i4.y - 1).key] = { backfilled: false }, l4[new e3.Q(t3.overscaledZ, n3, i4.z, r5, i4.y - 1).key] = { backfilled: false }), i4.y + 1 < s4 && (l4[new e3.Q(t3.overscaledZ, o3, i4.z, a3, i4.y + 1).key] = { backfilled: false }, l4[new e3.Q(t3.overscaledZ, t3.wrap, i4.z, i4.x, i4.y + 1).key] = { backfilled: false }, l4[new e3.Q(t3.overscaledZ, n3, i4.z, r5, i4.y + 1).key] = { backfilled: false }), l4;
          }
          unloadTile(t3) {
            return e3._(this, void 0, void 0, function* () {
              t3.demTexture && this.map.painter.saveTileTexture(t3.demTexture), t3.fbo && (t3.fbo.destroy(), delete t3.fbo), t3.dem && delete t3.dem, delete t3.neighboringTiles, t3.state = "unloaded", t3.actor && (yield t3.actor.sendAsync({ type: "removeDEMTile", data: { type: this.type, uid: t3.uid, source: this.id } }));
            });
          }
        }
        class K2 extends e3.E {
          constructor(t3, i4, s4, a3) {
            super(), this.id = t3, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._removed = false, this._pendingLoads = 0, this.actor = s4.getActor(), this.setEventedParent(a3), this._data = i4.data, this._options = e3.e({}, i4), this._collectResourceTiming = i4.collectResourceTiming, void 0 !== i4.maxzoom && (this.maxzoom = i4.maxzoom), i4.type && (this.type = i4.type), i4.attribution && (this.attribution = i4.attribution), this.promoteId = i4.promoteId;
            const o3 = e3.W / this.tileSize;
            this.workerOptions = e3.e({ source: this.id, cluster: i4.cluster || false, geojsonVtOptions: { buffer: (void 0 !== i4.buffer ? i4.buffer : 128) * o3, tolerance: (void 0 !== i4.tolerance ? i4.tolerance : 0.375) * o3, extent: e3.W, maxZoom: this.maxzoom, lineMetrics: i4.lineMetrics || false, generateId: i4.generateId || false }, superclusterOptions: { maxZoom: void 0 !== i4.clusterMaxZoom ? i4.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, i4.clusterMinPoints || 2), extent: e3.W, radius: (i4.clusterRadius || 50) * o3, log: false, generateId: i4.generateId || false }, clusterProperties: i4.clusterProperties, filter: i4.filter }, i4.workerOptions), "string" == typeof this.promoteId && (this.workerOptions.promoteId = this.promoteId);
          }
          load() {
            return e3._(this, void 0, void 0, function* () {
              yield this._updateWorkerData();
            });
          }
          onAdd(t3) {
            this.map = t3, this.load();
          }
          setData(t3) {
            return this._data = t3, this._updateWorkerData(), this;
          }
          updateData(t3) {
            return this._updateWorkerData(t3), this;
          }
          setClusterOptions(t3) {
            return this.workerOptions.cluster = t3.cluster, t3 && (void 0 !== t3.clusterRadius && (this.workerOptions.superclusterOptions.radius = t3.clusterRadius), void 0 !== t3.clusterMaxZoom && (this.workerOptions.superclusterOptions.maxZoom = t3.clusterMaxZoom)), this._updateWorkerData(), this;
          }
          getClusterExpansionZoom(t3) {
            return this.actor.sendAsync({ type: "getClusterExpansionZoom", data: { type: this.type, clusterId: t3, source: this.id } });
          }
          getClusterChildren(t3) {
            return this.actor.sendAsync({ type: "getClusterChildren", data: { type: this.type, clusterId: t3, source: this.id } });
          }
          getClusterLeaves(t3, e4, i4) {
            return this.actor.sendAsync({ type: "getClusterLeaves", data: { type: this.type, source: this.id, clusterId: t3, limit: e4, offset: i4 } });
          }
          _updateWorkerData(t3) {
            return e3._(this, void 0, void 0, function* () {
              const i4 = e3.e({ type: this.type }, this.workerOptions);
              t3 ? i4.dataDiff = t3 : "string" == typeof this._data ? (i4.request = this.map._requestManager.transformRequest(o2.resolveURL(this._data), p3.Source), i4.request.collectResourceTiming = this._collectResourceTiming) : i4.data = JSON.stringify(this._data), this._pendingLoads++, this.fire(new e3.k("dataloading", { dataType: "source" }));
              try {
                const t4 = yield this.actor.sendAsync({ type: "loadData", data: i4 });
                if (this._pendingLoads--, this._removed || t4.abandoned)
                  return void this.fire(new e3.k("dataabort", { dataType: "source" }));
                let s4 = null;
                t4.resourceTiming && t4.resourceTiming[this.id] && (s4 = t4.resourceTiming[this.id].slice(0));
                const a3 = { dataType: "source" };
                this._collectResourceTiming && s4 && s4.length > 0 && e3.e(a3, { resourceTiming: s4 }), this.fire(new e3.k("data", Object.assign(Object.assign({}, a3), { sourceDataType: "metadata" }))), this.fire(new e3.k("data", Object.assign(Object.assign({}, a3), { sourceDataType: "content" })));
              } catch (t4) {
                if (this._pendingLoads--, this._removed)
                  return void this.fire(new e3.k("dataabort", { dataType: "source" }));
                this.fire(new e3.j(t4));
              }
            });
          }
          loaded() {
            return 0 === this._pendingLoads;
          }
          loadTile(t3) {
            return e3._(this, void 0, void 0, function* () {
              const e4 = t3.actor ? "reloadTile" : "loadTile";
              t3.actor = this.actor;
              const i4 = { type: this.type, uid: t3.uid, tileID: t3.tileID, zoom: t3.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
              t3.abortController = new AbortController();
              const s4 = yield this.actor.sendAsync({ type: e4, data: i4 }, t3.abortController);
              delete t3.abortController, t3.unloadVectorData(), t3.aborted || t3.loadVectorData(s4, this.map.painter, "reloadTile" === e4);
            });
          }
          abortTile(t3) {
            return e3._(this, void 0, void 0, function* () {
              t3.abortController && (t3.abortController.abort(), delete t3.abortController), t3.aborted = true;
            });
          }
          unloadTile(t3) {
            return e3._(this, void 0, void 0, function* () {
              t3.unloadVectorData(), yield this.actor.sendAsync({ type: "removeTile", data: { uid: t3.uid, type: this.type, source: this.id } });
            });
          }
          onRemove() {
            this._removed = true, this.actor.sendAsync({ type: "removeSource", data: { type: this.type, source: this.id } });
          }
          serialize() {
            return e3.e({}, this._options, { type: this.type, data: this._data });
          }
          hasTransition() {
            return false;
          }
        }
        var Y4 = e3.X([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
        class J3 extends e3.E {
          constructor(t3, e4, i4, s4) {
            super(), this.id = t3, this.dispatcher = i4, this.coordinates = e4.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(s4), this.options = e4;
          }
          load(t3) {
            return e3._(this, void 0, void 0, function* () {
              this._loaded = false, this.fire(new e3.k("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
              try {
                const e4 = yield _.getImage(this.map._requestManager.transformRequest(this.url, p3.Image), this._request);
                this._request = null, this._loaded = true, e4 && e4.data && (this.image = e4.data, t3 && (this.coordinates = t3), this._finishLoading());
              } catch (t4) {
                this._request = null, this.fire(new e3.j(t4));
              }
            });
          }
          loaded() {
            return this._loaded;
          }
          updateImage(t3) {
            return t3.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = t3.url, this.load(t3.coordinates).finally(() => {
              this.texture = null;
            }), this) : this;
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new e3.k("data", { dataType: "source", sourceDataType: "metadata" })));
          }
          onAdd(t3) {
            this.map = t3, this.load();
          }
          onRemove() {
            this._request && (this._request.abort(), this._request = null);
          }
          setCoordinates(t3) {
            this.coordinates = t3;
            const i4 = t3.map(e3.Y.fromLngLat);
            this.tileID = function(t4) {
              let i5 = 1 / 0, s5 = 1 / 0, a3 = -1 / 0, o3 = -1 / 0;
              for (const e4 of t4)
                i5 = Math.min(i5, e4.x), s5 = Math.min(s5, e4.y), a3 = Math.max(a3, e4.x), o3 = Math.max(o3, e4.y);
              const r5 = Math.max(a3 - i5, o3 - s5), n3 = Math.max(0, Math.floor(-Math.log(r5) / Math.LN2)), l4 = Math.pow(2, n3);
              return new e3.a0(n3, Math.floor((i5 + a3) / 2 * l4), Math.floor((s5 + o3) / 2 * l4));
            }(i4), this.minzoom = this.maxzoom = this.tileID.z;
            const s4 = i4.map((t4) => this.tileID.getTilePoint(t4)._round());
            return this._boundsArray = new e3.Z(), this._boundsArray.emplaceBack(s4[0].x, s4[0].y, 0, 0), this._boundsArray.emplaceBack(s4[1].x, s4[1].y, e3.W, 0), this._boundsArray.emplaceBack(s4[3].x, s4[3].y, 0, e3.W), this._boundsArray.emplaceBack(s4[2].x, s4[2].y, e3.W, e3.W), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new e3.k("data", { dataType: "source", sourceDataType: "content" })), this;
          }
          prepare() {
            if (0 === Object.keys(this.tiles).length || !this.image)
              return;
            const t3 = this.map.painter.context, i4 = t3.gl;
            this.boundsBuffer || (this.boundsBuffer = t3.createVertexBuffer(this._boundsArray, Y4.members)), this.boundsSegments || (this.boundsSegments = e3.$.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new w3(t3, this.image, i4.RGBA), this.texture.bind(i4.LINEAR, i4.CLAMP_TO_EDGE));
            let s4 = false;
            for (const t4 in this.tiles) {
              const e4 = this.tiles[t4];
              "loaded" !== e4.state && (e4.state = "loaded", e4.texture = this.texture, s4 = true);
            }
            s4 && this.fire(new e3.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          loadTile(t3) {
            return e3._(this, void 0, void 0, function* () {
              this.tileID && this.tileID.equals(t3.tileID.canonical) ? (this.tiles[String(t3.tileID.wrap)] = t3, t3.buckets = {}) : t3.state = "errored";
            });
          }
          serialize() {
            return { type: "image", url: this.options.url, coordinates: this.coordinates };
          }
          hasTransition() {
            return false;
          }
        }
        class Q2 extends J3 {
          constructor(t3, e4, i4, s4) {
            super(t3, e4, i4, s4), this.roundZoom = true, this.type = "video", this.options = e4;
          }
          load() {
            return e3._(this, void 0, void 0, function* () {
              this._loaded = false;
              const t3 = this.options;
              this.urls = [];
              for (const e4 of t3.urls)
                this.urls.push(this.map._requestManager.transformRequest(e4, p3.Source).url);
              try {
                const t4 = yield e3.a2(this.urls);
                if (this._loaded = true, !t4)
                  return;
                this.video = t4, this.video.loop = true, this.video.addEventListener("playing", () => {
                  this.map.triggerRepaint();
                }), this.map && this.video.play(), this._finishLoading();
              } catch (t4) {
                this.fire(new e3.j(t4));
              }
            });
          }
          pause() {
            this.video && this.video.pause();
          }
          play() {
            this.video && this.video.play();
          }
          seek(t3) {
            if (this.video) {
              const i4 = this.video.seekable;
              t3 < i4.start(0) || t3 > i4.end(0) ? this.fire(new e3.j(new e3.a1(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i4.start(0)} and ${i4.end(0)}-second mark.`))) : this.video.currentTime = t3;
            }
          }
          getVideo() {
            return this.video;
          }
          onAdd(t3) {
            this.map || (this.map = t3, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
          }
          prepare() {
            if (0 === Object.keys(this.tiles).length || this.video.readyState < 2)
              return;
            const t3 = this.map.painter.context, i4 = t3.gl;
            this.boundsBuffer || (this.boundsBuffer = t3.createVertexBuffer(this._boundsArray, Y4.members)), this.boundsSegments || (this.boundsSegments = e3.$.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(i4.LINEAR, i4.CLAMP_TO_EDGE), i4.texSubImage2D(i4.TEXTURE_2D, 0, 0, 0, i4.RGBA, i4.UNSIGNED_BYTE, this.video)) : (this.texture = new w3(t3, this.video, i4.RGBA), this.texture.bind(i4.LINEAR, i4.CLAMP_TO_EDGE));
            let s4 = false;
            for (const t4 in this.tiles) {
              const e4 = this.tiles[t4];
              "loaded" !== e4.state && (e4.state = "loaded", e4.texture = this.texture, s4 = true);
            }
            s4 && this.fire(new e3.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          serialize() {
            return { type: "video", urls: this.urls, coordinates: this.coordinates };
          }
          hasTransition() {
            return this.video && !this.video.paused;
          }
        }
        class tt extends J3 {
          constructor(t3, i4, s4, a3) {
            super(t3, i4, s4, a3), i4.coordinates ? Array.isArray(i4.coordinates) && 4 === i4.coordinates.length && !i4.coordinates.some((t4) => !Array.isArray(t4) || 2 !== t4.length || t4.some((t5) => "number" != typeof t5)) || this.fire(new e3.j(new e3.a1(`sources.${t3}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new e3.j(new e3.a1(`sources.${t3}`, null, 'missing required property "coordinates"'))), i4.animate && "boolean" != typeof i4.animate && this.fire(new e3.j(new e3.a1(`sources.${t3}`, null, 'optional "animate" property must be a boolean value'))), i4.canvas ? "string" == typeof i4.canvas || i4.canvas instanceof HTMLCanvasElement || this.fire(new e3.j(new e3.a1(`sources.${t3}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new e3.j(new e3.a1(`sources.${t3}`, null, 'missing required property "canvas"'))), this.options = i4, this.animate = void 0 === i4.animate || i4.animate;
          }
          load() {
            return e3._(this, void 0, void 0, function* () {
              this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new e3.j(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                this._playing = true, this.map.triggerRepaint();
              }, this.pause = function() {
                this._playing && (this.prepare(), this._playing = false);
              }, this._finishLoading());
            });
          }
          getCanvas() {
            return this.canvas;
          }
          onAdd(t3) {
            this.map = t3, this.load(), this.canvas && this.animate && this.play();
          }
          onRemove() {
            this.pause();
          }
          prepare() {
            let t3 = false;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, t3 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, t3 = true), this._hasInvalidDimensions())
              return;
            if (0 === Object.keys(this.tiles).length)
              return;
            const i4 = this.map.painter.context, s4 = i4.gl;
            this.boundsBuffer || (this.boundsBuffer = i4.createVertexBuffer(this._boundsArray, Y4.members)), this.boundsSegments || (this.boundsSegments = e3.$.simpleSegment(0, 0, 4, 2)), this.texture ? (t3 || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new w3(i4, this.canvas, s4.RGBA, { premultiply: true });
            let a3 = false;
            for (const t4 in this.tiles) {
              const e4 = this.tiles[t4];
              "loaded" !== e4.state && (e4.state = "loaded", e4.texture = this.texture, a3 = true);
            }
            a3 && this.fire(new e3.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          serialize() {
            return { type: "canvas", coordinates: this.coordinates };
          }
          hasTransition() {
            return this._playing;
          }
          _hasInvalidDimensions() {
            for (const t3 of [this.canvas.width, this.canvas.height])
              if (isNaN(t3) || t3 <= 0)
                return true;
            return false;
          }
        }
        const et2 = {}, it = (t3) => {
          switch (t3) {
            case "geojson":
              return K2;
            case "image":
              return J3;
            case "raster":
              return $;
            case "raster-dem":
              return X3;
            case "vector":
              return H3;
            case "video":
              return Q2;
            case "canvas":
              return tt;
          }
          return et2[t3];
        };
        class st extends e3.E {
          constructor() {
            super(...arguments), this.pluginStatus = "unavailable", this.pluginURL = null, this.dispatcher = U2(), this.queue = [];
          }
          _sendPluginStateToWorker() {
            return e3._(this, void 0, void 0, function* () {
              yield this.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL }), this.fire(new e3.k("pluginStateChange", { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL }));
            });
          }
          getRTLTextPluginStatus() {
            return this.pluginStatus;
          }
          clearRTLTextPlugin() {
            this.pluginStatus = "unavailable", this.pluginURL = null;
          }
          setRTLTextPlugin(t3, i4 = false) {
            return e3._(this, void 0, void 0, function* () {
              if ("deferred" === this.pluginStatus || "loading" === this.pluginStatus || "loaded" === this.pluginStatus)
                throw new Error("setRTLTextPlugin cannot be called multiple times.");
              this.pluginURL = o2.resolveURL(t3), this.pluginStatus = "deferred", yield this._sendPluginStateToWorker(), i4 || (yield this._downloadRTLTextPlugin());
            });
          }
          _downloadRTLTextPlugin() {
            return e3._(this, void 0, void 0, function* () {
              if ("deferred" !== this.pluginStatus || !this.pluginURL)
                throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
              try {
                this.pluginStatus = "loading", yield this._sendPluginStateToWorker(), yield e3.l({ url: this.pluginURL }, new AbortController()), this.pluginStatus = "loaded";
              } catch (t3) {
                this.pluginStatus = "error";
              }
              yield this._sendPluginStateToWorker();
            });
          }
          lazyLoadRTLTextPlugin() {
            return e3._(this, void 0, void 0, function* () {
              "deferred" === this.pluginStatus && (yield this._downloadRTLTextPlugin());
            });
          }
        }
        let at = null;
        function ot() {
          return at || (at = new st()), at;
        }
        class rt {
          constructor(t3, i4) {
            this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = t3, this.uid = e3.a3(), this.uses = 0, this.tileSize = i4, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
          }
          registerFadeDuration(t3) {
            const e4 = t3 + this.timeAdded;
            e4 < this.fadeEndTime || (this.fadeEndTime = e4);
          }
          wasRequested() {
            return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
          }
          clearTextures(t3) {
            this.demTexture && t3.saveTileTexture(this.demTexture), this.demTexture = null;
          }
          loadVectorData(t3, i4, s4) {
            if (this.hasData() && this.unloadVectorData(), this.state = "loaded", t3) {
              t3.featureIndex && (this.latestFeatureIndex = t3.featureIndex, t3.rawTileData ? (this.latestRawTileData = t3.rawTileData, this.latestFeatureIndex.rawTileData = t3.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t3.collisionBoxArray, this.buckets = function(t4, e4) {
                const i5 = {};
                if (!e4)
                  return i5;
                for (const s5 of t4) {
                  const t5 = s5.layerIds.map((t6) => e4.getLayer(t6)).filter(Boolean);
                  if (0 !== t5.length) {
                    s5.layers = t5, s5.stateDependentLayerIds && (s5.stateDependentLayers = s5.stateDependentLayerIds.map((e5) => t5.filter((t6) => t6.id === e5)[0]));
                    for (const e5 of t5)
                      i5[e5.id] = s5;
                  }
                }
                return i5;
              }(t3.buckets, i4.style), this.hasSymbolBuckets = false;
              for (const t4 in this.buckets) {
                const i5 = this.buckets[t4];
                if (i5 instanceof e3.a5) {
                  if (this.hasSymbolBuckets = true, !s4)
                    break;
                  i5.justReloaded = true;
                }
              }
              if (this.hasRTLText = false, this.hasSymbolBuckets)
                for (const t4 in this.buckets) {
                  const i5 = this.buckets[t4];
                  if (i5 instanceof e3.a5 && i5.hasRTLText) {
                    this.hasRTLText = true, ot().lazyLoadRTLTextPlugin();
                    break;
                  }
                }
              this.queryPadding = 0;
              for (const t4 in this.buckets) {
                const e4 = this.buckets[t4];
                this.queryPadding = Math.max(this.queryPadding, i4.style.getLayer(t4).queryRadius(e4));
              }
              t3.imageAtlas && (this.imageAtlas = t3.imageAtlas), t3.glyphAtlasImage && (this.glyphAtlasImage = t3.glyphAtlasImage);
            } else
              this.collisionBoxArray = new e3.a4();
          }
          unloadVectorData() {
            for (const t3 in this.buckets)
              this.buckets[t3].destroy();
            this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
          }
          getBucket(t3) {
            return this.buckets[t3.id];
          }
          upload(t3) {
            for (const e5 in this.buckets) {
              const i4 = this.buckets[e5];
              i4.uploadPending() && i4.upload(t3);
            }
            const e4 = t3.gl;
            this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new w3(t3, this.imageAtlas.image, e4.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new w3(t3, this.glyphAtlasImage, e4.ALPHA), this.glyphAtlasImage = null);
          }
          prepare(t3) {
            this.imageAtlas && this.imageAtlas.patchUpdatedImages(t3, this.imageAtlasTexture);
          }
          queryRenderedFeatures(t3, e4, i4, s4, a3, o3, r5, n3, l4, h2) {
            return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: s4, cameraQueryGeometry: a3, scale: o3, tileSize: this.tileSize, pixelPosMatrix: h2, transform: n3, params: r5, queryPadding: this.queryPadding * l4 }, t3, e4, i4) : {};
          }
          querySourceFeatures(t3, i4) {
            const s4 = this.latestFeatureIndex;
            if (!s4 || !s4.rawTileData)
              return;
            const a3 = s4.loadVTLayers(), o3 = i4 && i4.sourceLayer ? i4.sourceLayer : "", r5 = a3._geojsonTileLayer || a3[o3];
            if (!r5)
              return;
            const n3 = e3.a6(i4 && i4.filter), { z: l4, x: h2, y: c3 } = this.tileID.canonical, u3 = { z: l4, x: h2, y: c3 };
            for (let i5 = 0; i5 < r5.length; i5++) {
              const a4 = r5.feature(i5);
              if (n3.needGeometry) {
                const t4 = e3.a7(a4, true);
                if (!n3.filter(new e3.a8(this.tileID.overscaledZ), t4, this.tileID.canonical))
                  continue;
              } else if (!n3.filter(new e3.a8(this.tileID.overscaledZ), a4))
                continue;
              const d2 = s4.getId(a4, o3), _2 = new e3.a9(a4, l4, h2, c3, d2);
              _2.tile = u3, t3.push(_2);
            }
          }
          hasData() {
            return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
          }
          patternsLoaded() {
            return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
          }
          setExpiryData(t3) {
            const i4 = this.expirationTime;
            if (t3.cacheControl) {
              const i5 = e3.aa(t3.cacheControl);
              i5["max-age"] && (this.expirationTime = Date.now() + 1e3 * i5["max-age"]);
            } else
              t3.expires && (this.expirationTime = new Date(t3.expires).getTime());
            if (this.expirationTime) {
              const t4 = Date.now();
              let e4 = false;
              if (this.expirationTime > t4)
                e4 = false;
              else if (i4)
                if (this.expirationTime < i4)
                  e4 = true;
                else {
                  const s4 = this.expirationTime - i4;
                  s4 ? this.expirationTime = t4 + Math.max(s4, 3e4) : e4 = true;
                }
              else
                e4 = true;
              e4 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime)
              return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
          }
          setFeatureState(t3, e4) {
            if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || 0 === Object.keys(t3).length)
              return;
            const i4 = this.latestFeatureIndex.loadVTLayers();
            for (const s4 in this.buckets) {
              if (!e4.style.hasLayer(s4))
                continue;
              const a3 = this.buckets[s4], o3 = a3.layers[0].sourceLayer || "_geojsonTileLayer", r5 = i4[o3], n3 = t3[o3];
              if (!r5 || !n3 || 0 === Object.keys(n3).length)
                continue;
              a3.update(n3, r5, this.imageAtlas && this.imageAtlas.patternPositions || {});
              const l4 = e4 && e4.style && e4.style.getLayer(s4);
              l4 && (this.queryPadding = Math.max(this.queryPadding, l4.queryRadius(a3)));
            }
          }
          holdingForFade() {
            return void 0 !== this.symbolFadeHoldUntil;
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < o2.now();
          }
          clearFadeHold() {
            this.symbolFadeHoldUntil = void 0;
          }
          setHoldDuration(t3) {
            this.symbolFadeHoldUntil = o2.now() + t3;
          }
          setDependencies(t3, e4) {
            const i4 = {};
            for (const t4 of e4)
              i4[t4] = true;
            this.dependencies[t3] = i4;
          }
          hasDependency(t3, e4) {
            for (const i4 of t3) {
              const t4 = this.dependencies[i4];
              if (t4) {
                for (const i5 of e4)
                  if (t4[i5])
                    return true;
              }
            }
            return false;
          }
        }
        class nt {
          constructor(t3, e4) {
            this.max = t3, this.onRemove = e4, this.reset();
          }
          reset() {
            for (const t3 in this.data)
              for (const e4 of this.data[t3])
                e4.timeout && clearTimeout(e4.timeout), this.onRemove(e4.value);
            return this.data = {}, this.order = [], this;
          }
          add(t3, e4, i4) {
            const s4 = t3.wrapped().key;
            void 0 === this.data[s4] && (this.data[s4] = []);
            const a3 = { value: e4, timeout: void 0 };
            if (void 0 !== i4 && (a3.timeout = setTimeout(() => {
              this.remove(t3, a3);
            }, i4)), this.data[s4].push(a3), this.order.push(s4), this.order.length > this.max) {
              const t4 = this._getAndRemoveByKey(this.order[0]);
              t4 && this.onRemove(t4);
            }
            return this;
          }
          has(t3) {
            return t3.wrapped().key in this.data;
          }
          getAndRemove(t3) {
            return this.has(t3) ? this._getAndRemoveByKey(t3.wrapped().key) : null;
          }
          _getAndRemoveByKey(t3) {
            const e4 = this.data[t3].shift();
            return e4.timeout && clearTimeout(e4.timeout), 0 === this.data[t3].length && delete this.data[t3], this.order.splice(this.order.indexOf(t3), 1), e4.value;
          }
          getByKey(t3) {
            const e4 = this.data[t3];
            return e4 ? e4[0].value : null;
          }
          get(t3) {
            return this.has(t3) ? this.data[t3.wrapped().key][0].value : null;
          }
          remove(t3, e4) {
            if (!this.has(t3))
              return this;
            const i4 = t3.wrapped().key, s4 = void 0 === e4 ? 0 : this.data[i4].indexOf(e4), a3 = this.data[i4][s4];
            return this.data[i4].splice(s4, 1), a3.timeout && clearTimeout(a3.timeout), 0 === this.data[i4].length && delete this.data[i4], this.onRemove(a3.value), this.order.splice(this.order.indexOf(i4), 1), this;
          }
          setMaxSize(t3) {
            for (this.max = t3; this.order.length > this.max; ) {
              const t4 = this._getAndRemoveByKey(this.order[0]);
              t4 && this.onRemove(t4);
            }
            return this;
          }
          filter(t3) {
            const e4 = [];
            for (const i4 in this.data)
              for (const s4 of this.data[i4])
                t3(s4.value) || e4.push(s4);
            for (const t4 of e4)
              this.remove(t4.value.tileID, t4);
          }
        }
        class lt {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {};
          }
          updateState(t3, i4, s4) {
            const a3 = String(i4);
            if (this.stateChanges[t3] = this.stateChanges[t3] || {}, this.stateChanges[t3][a3] = this.stateChanges[t3][a3] || {}, e3.e(this.stateChanges[t3][a3], s4), null === this.deletedStates[t3]) {
              this.deletedStates[t3] = {};
              for (const e4 in this.state[t3])
                e4 !== a3 && (this.deletedStates[t3][e4] = null);
            } else if (this.deletedStates[t3] && null === this.deletedStates[t3][a3]) {
              this.deletedStates[t3][a3] = {};
              for (const e4 in this.state[t3][a3])
                s4[e4] || (this.deletedStates[t3][a3][e4] = null);
            } else
              for (const e4 in s4)
                this.deletedStates[t3] && this.deletedStates[t3][a3] && null === this.deletedStates[t3][a3][e4] && delete this.deletedStates[t3][a3][e4];
          }
          removeFeatureState(t3, e4, i4) {
            if (null === this.deletedStates[t3])
              return;
            const s4 = String(e4);
            if (this.deletedStates[t3] = this.deletedStates[t3] || {}, i4 && void 0 !== e4)
              null !== this.deletedStates[t3][s4] && (this.deletedStates[t3][s4] = this.deletedStates[t3][s4] || {}, this.deletedStates[t3][s4][i4] = null);
            else if (void 0 !== e4)
              if (this.stateChanges[t3] && this.stateChanges[t3][s4])
                for (i4 in this.deletedStates[t3][s4] = {}, this.stateChanges[t3][s4])
                  this.deletedStates[t3][s4][i4] = null;
              else
                this.deletedStates[t3][s4] = null;
            else
              this.deletedStates[t3] = null;
          }
          getState(t3, i4) {
            const s4 = String(i4), a3 = e3.e({}, (this.state[t3] || {})[s4], (this.stateChanges[t3] || {})[s4]);
            if (null === this.deletedStates[t3])
              return {};
            if (this.deletedStates[t3]) {
              const e4 = this.deletedStates[t3][i4];
              if (null === e4)
                return {};
              for (const t4 in e4)
                delete a3[t4];
            }
            return a3;
          }
          initializeTileState(t3, e4) {
            t3.setFeatureState(this.state, e4);
          }
          coalesceChanges(t3, i4) {
            const s4 = {};
            for (const t4 in this.stateChanges) {
              this.state[t4] = this.state[t4] || {};
              const i5 = {};
              for (const s5 in this.stateChanges[t4])
                this.state[t4][s5] || (this.state[t4][s5] = {}), e3.e(this.state[t4][s5], this.stateChanges[t4][s5]), i5[s5] = this.state[t4][s5];
              s4[t4] = i5;
            }
            for (const t4 in this.deletedStates) {
              this.state[t4] = this.state[t4] || {};
              const i5 = {};
              if (null === this.deletedStates[t4])
                for (const e4 in this.state[t4])
                  i5[e4] = {}, this.state[t4][e4] = {};
              else
                for (const e4 in this.deletedStates[t4]) {
                  if (null === this.deletedStates[t4][e4])
                    this.state[t4][e4] = {};
                  else
                    for (const i6 of Object.keys(this.deletedStates[t4][e4]))
                      delete this.state[t4][e4][i6];
                  i5[e4] = this.state[t4][e4];
                }
              s4[t4] = s4[t4] || {}, e3.e(s4[t4], i5);
            }
            if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(s4).length)
              for (const e4 in t3)
                t3[e4].setFeatureState(s4, i4);
          }
        }
        class ht extends e3.E {
          constructor(t3, e4, i4) {
            super(), this.id = t3, this.dispatcher = i4, this.on("data", (t4) => {
              "source" === t4.dataType && "metadata" === t4.sourceDataType && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && "source" === t4.dataType && "content" === t4.sourceDataType && (this.reload(), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = true);
            }), this.on("dataloading", () => {
              this._sourceErrored = false;
            }), this.on("error", () => {
              this._sourceErrored = this._source.loaded();
            }), this._source = ((t4, e5, i5, s4) => {
              const a3 = new (it(e5.type))(t4, e5, i5, s4);
              if (a3.id !== t4)
                throw new Error(`Expected Source id to be ${t4} instead of ${a3.id}`);
              return a3;
            })(t3, e4, i4, this), this._tiles = {}, this._cache = new nt(0, (t4) => this._unloadTile(t4)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new lt(), this._didEmitContent = false, this._updated = false;
          }
          onAdd(t3) {
            this.map = t3, this._maxTileCacheSize = t3 ? t3._maxTileCacheSize : null, this._maxTileCacheZoomLevels = t3 ? t3._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(t3);
          }
          onRemove(t3) {
            this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(t3);
          }
          loaded() {
            if (this._sourceErrored)
              return true;
            if (!this._sourceLoaded)
              return false;
            if (!this._source.loaded())
              return false;
            if (!(void 0 === this.used && void 0 === this.usedForTerrain || this.used || this.usedForTerrain))
              return true;
            if (!this._updated)
              return false;
            for (const t3 in this._tiles) {
              const e4 = this._tiles[t3];
              if ("loaded" !== e4.state && "errored" !== e4.state)
                return false;
            }
            return true;
          }
          getSource() {
            return this._source;
          }
          pause() {
            this._paused = true;
          }
          resume() {
            if (!this._paused)
              return;
            const t3 = this._shouldReloadOnResume;
            this._paused = false, this._shouldReloadOnResume = false, t3 && this.reload(), this.transform && this.update(this.transform, this.terrain);
          }
          _loadTile(t3, i4, s4) {
            return e3._(this, void 0, void 0, function* () {
              try {
                yield this._source.loadTile(t3), this._tileLoaded(t3, i4, s4);
              } catch (i5) {
                t3.state = "errored", 404 !== i5.status ? this._source.fire(new e3.j(i5, { tile: t3 })) : this.update(this.transform, this.terrain);
              }
            });
          }
          _unloadTile(t3) {
            this._source.unloadTile && this._source.unloadTile(t3);
          }
          _abortTile(t3) {
            this._source.abortTile && this._source.abortTile(t3), this._source.fire(new e3.k("dataabort", { tile: t3, coord: t3.tileID, dataType: "source" }));
          }
          serialize() {
            return this._source.serialize();
          }
          prepare(t3) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
            for (const e4 in this._tiles) {
              const i4 = this._tiles[e4];
              i4.upload(t3), i4.prepare(this.map.style.imageManager);
            }
          }
          getIds() {
            return Object.values(this._tiles).map((t3) => t3.tileID).sort(ct).map((t3) => t3.key);
          }
          getRenderableIds(t3) {
            const i4 = [];
            for (const e4 in this._tiles)
              this._isIdRenderable(e4, t3) && i4.push(this._tiles[e4]);
            return t3 ? i4.sort((t4, i5) => {
              const s4 = t4.tileID, a3 = i5.tileID, o3 = new e3.P(s4.canonical.x, s4.canonical.y)._rotate(this.transform.angle), r5 = new e3.P(a3.canonical.x, a3.canonical.y)._rotate(this.transform.angle);
              return s4.overscaledZ - a3.overscaledZ || r5.y - o3.y || r5.x - o3.x;
            }).map((t4) => t4.tileID.key) : i4.map((t4) => t4.tileID).sort(ct).map((t4) => t4.key);
          }
          hasRenderableParent(t3) {
            const e4 = this.findLoadedParent(t3, 0);
            return !!e4 && this._isIdRenderable(e4.tileID.key);
          }
          _isIdRenderable(t3, e4) {
            return this._tiles[t3] && this._tiles[t3].hasData() && !this._coveredTiles[t3] && (e4 || !this._tiles[t3].holdingForFade());
          }
          reload() {
            if (this._paused)
              this._shouldReloadOnResume = true;
            else {
              this._cache.reset();
              for (const t3 in this._tiles)
                "errored" !== this._tiles[t3].state && this._reloadTile(t3, "reloading");
            }
          }
          _reloadTile(t3, i4) {
            return e3._(this, void 0, void 0, function* () {
              const e4 = this._tiles[t3];
              e4 && ("loading" !== e4.state && (e4.state = i4), yield this._loadTile(e4, t3, i4));
            });
          }
          _tileLoaded(t3, i4, s4) {
            t3.timeAdded = o2.now(), "expired" === s4 && (t3.refreshedUponExpiration = true), this._setTileReloadTimer(i4, t3), "raster-dem" === this.getSource().type && t3.dem && this._backfillDEM(t3), this._state.initializeTileState(t3, this.map ? this.map.painter : null), t3.aborted || this._source.fire(new e3.k("data", { dataType: "source", tile: t3, coord: t3.tileID }));
          }
          _backfillDEM(t3) {
            const e4 = this.getRenderableIds();
            for (let s4 = 0; s4 < e4.length; s4++) {
              const a3 = e4[s4];
              if (t3.neighboringTiles && t3.neighboringTiles[a3]) {
                const e5 = this.getTileByID(a3);
                i4(t3, e5), i4(e5, t3);
              }
            }
            function i4(t4, e5) {
              t4.needsHillshadePrepare = true, t4.needsTerrainPrepare = true;
              let i5 = e5.tileID.canonical.x - t4.tileID.canonical.x;
              const s4 = e5.tileID.canonical.y - t4.tileID.canonical.y, a3 = Math.pow(2, t4.tileID.canonical.z), o3 = e5.tileID.key;
              0 === i5 && 0 === s4 || Math.abs(s4) > 1 || (Math.abs(i5) > 1 && (1 === Math.abs(i5 + a3) ? i5 += a3 : 1 === Math.abs(i5 - a3) && (i5 -= a3)), e5.dem && t4.dem && (t4.dem.backfillBorder(e5.dem, i5, s4), t4.neighboringTiles && t4.neighboringTiles[o3] && (t4.neighboringTiles[o3].backfilled = true)));
            }
          }
          getTile(t3) {
            return this.getTileByID(t3.key);
          }
          getTileByID(t3) {
            return this._tiles[t3];
          }
          _retainLoadedChildren(t3, e4, i4, s4) {
            for (const a3 in this._tiles) {
              let o3 = this._tiles[a3];
              if (s4[a3] || !o3.hasData() || o3.tileID.overscaledZ <= e4 || o3.tileID.overscaledZ > i4)
                continue;
              let r5 = o3.tileID;
              for (; o3 && o3.tileID.overscaledZ > e4 + 1; ) {
                const t4 = o3.tileID.scaledTo(o3.tileID.overscaledZ - 1);
                o3 = this._tiles[t4.key], o3 && o3.hasData() && (r5 = t4);
              }
              let n3 = r5;
              for (; n3.overscaledZ > e4; )
                if (n3 = n3.scaledTo(n3.overscaledZ - 1), t3[n3.key]) {
                  s4[r5.key] = r5;
                  break;
                }
            }
          }
          findLoadedParent(t3, e4) {
            if (t3.key in this._loadedParentTiles) {
              const i4 = this._loadedParentTiles[t3.key];
              return i4 && i4.tileID.overscaledZ >= e4 ? i4 : null;
            }
            for (let i4 = t3.overscaledZ - 1; i4 >= e4; i4--) {
              const e5 = t3.scaledTo(i4), s4 = this._getLoadedTile(e5);
              if (s4)
                return s4;
            }
          }
          _getLoadedTile(t3) {
            const e4 = this._tiles[t3.key];
            return e4 && e4.hasData() ? e4 : this._cache.getByKey(t3.wrapped().key);
          }
          updateCacheSize(t3) {
            const i4 = Math.ceil(t3.width / this._source.tileSize) + 1, s4 = Math.ceil(t3.height / this._source.tileSize) + 1, a3 = Math.floor(i4 * s4 * (null === this._maxTileCacheZoomLevels ? e3.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), o3 = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, a3) : a3;
            this._cache.setMaxSize(o3);
          }
          handleWrapJump(t3) {
            const e4 = Math.round((t3 - (void 0 === this._prevLng ? t3 : this._prevLng)) / 360);
            if (this._prevLng = t3, e4) {
              const t4 = {};
              for (const i4 in this._tiles) {
                const s4 = this._tiles[i4];
                s4.tileID = s4.tileID.unwrapTo(s4.tileID.wrap + e4), t4[s4.tileID.key] = s4;
              }
              this._tiles = t4;
              for (const t5 in this._timers)
                clearTimeout(this._timers[t5]), delete this._timers[t5];
              for (const t5 in this._tiles)
                this._setTileReloadTimer(t5, this._tiles[t5]);
            }
          }
          update(t3, i4) {
            if (this.transform = t3, this.terrain = i4, !this._sourceLoaded || this._paused)
              return;
            let s4;
            this.updateCacheSize(t3), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? s4 = t3.getVisibleUnwrappedCoordinates(this._source.tileID).map((t4) => new e3.Q(t4.canonical.z, t4.wrap, t4.canonical.z, t4.canonical.x, t4.canonical.y)) : (s4 = t3.coveringTiles({ tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: i4 }), this._source.hasTile && (s4 = s4.filter((t4) => this._source.hasTile(t4)))) : s4 = [];
            const a3 = t3.coveringZoomLevel(this._source), r5 = Math.max(a3 - ht.maxOverzooming, this._source.minzoom), n3 = Math.max(a3 + ht.maxUnderzooming, this._source.minzoom);
            if (this.usedForTerrain) {
              const t4 = {};
              for (const e4 of s4)
                if (e4.canonical.z > this._source.minzoom) {
                  const i5 = e4.scaledTo(e4.canonical.z - 1);
                  t4[i5.key] = i5;
                  const s5 = e4.scaledTo(Math.max(this._source.minzoom, Math.min(e4.canonical.z, 5)));
                  t4[s5.key] = s5;
                }
              s4 = s4.concat(Object.values(t4));
            }
            const l4 = 0 === s4.length && !this._updated && this._didEmitContent;
            this._updated = true, l4 && this.fire(new e3.k("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
            const h2 = this._updateRetainedTiles(s4, a3);
            if (ut(this._source.type)) {
              const t4 = {}, e4 = {}, l5 = Object.keys(h2), c4 = o2.now();
              for (const i5 of l5) {
                const s5 = h2[i5], a4 = this._tiles[i5];
                if (!a4 || 0 !== a4.fadeEndTime && a4.fadeEndTime <= c4)
                  continue;
                const o3 = this.findLoadedParent(s5, r5);
                o3 && (this._addTile(o3.tileID), t4[o3.tileID.key] = o3.tileID), e4[i5] = s5;
              }
              this._retainLoadedChildren(e4, a3, n3, h2);
              for (const e5 in t4)
                h2[e5] || (this._coveredTiles[e5] = true, h2[e5] = t4[e5]);
              if (i4) {
                const t5 = {}, e5 = {};
                for (const i5 of s4)
                  this._tiles[i5.key].hasData() ? t5[i5.key] = i5 : e5[i5.key] = i5;
                for (const i5 in e5) {
                  const s5 = e5[i5].children(this._source.maxzoom);
                  this._tiles[s5[0].key] && this._tiles[s5[1].key] && this._tiles[s5[2].key] && this._tiles[s5[3].key] && (t5[s5[0].key] = h2[s5[0].key] = s5[0], t5[s5[1].key] = h2[s5[1].key] = s5[1], t5[s5[2].key] = h2[s5[2].key] = s5[2], t5[s5[3].key] = h2[s5[3].key] = s5[3], delete e5[i5]);
                }
                for (const i5 in e5) {
                  const s5 = this.findLoadedParent(e5[i5], this._source.minzoom);
                  if (s5) {
                    t5[s5.tileID.key] = h2[s5.tileID.key] = s5.tileID;
                    for (const e6 in t5)
                      t5[e6].isChildOf(s5.tileID) && delete t5[e6];
                  }
                }
                for (const e6 in this._tiles)
                  t5[e6] || (this._coveredTiles[e6] = true);
              }
            }
            for (const t4 in h2)
              this._tiles[t4].clearFadeHold();
            const c3 = e3.ab(this._tiles, h2);
            for (const t4 of c3) {
              const e4 = this._tiles[t4];
              e4.hasSymbolBuckets && !e4.holdingForFade() ? e4.setHoldDuration(this.map._fadeDuration) : e4.hasSymbolBuckets && !e4.symbolFadeFinished() || this._removeTile(t4);
            }
            this._updateLoadedParentTileCache();
          }
          releaseSymbolFadeTiles() {
            for (const t3 in this._tiles)
              this._tiles[t3].holdingForFade() && this._removeTile(t3);
          }
          _updateRetainedTiles(t3, e4) {
            const i4 = {}, s4 = {}, a3 = Math.max(e4 - ht.maxOverzooming, this._source.minzoom), o3 = Math.max(e4 + ht.maxUnderzooming, this._source.minzoom), r5 = {};
            for (const s5 of t3) {
              const t4 = this._addTile(s5);
              i4[s5.key] = s5, t4.hasData() || e4 < this._source.maxzoom && (r5[s5.key] = s5);
            }
            this._retainLoadedChildren(r5, e4, o3, i4);
            for (const o4 of t3) {
              let t4 = this._tiles[o4.key];
              if (t4.hasData())
                continue;
              if (e4 + 1 > this._source.maxzoom) {
                const t5 = o4.children(this._source.maxzoom)[0], e5 = this.getTile(t5);
                if (e5 && e5.hasData()) {
                  i4[t5.key] = t5;
                  continue;
                }
              } else {
                const t5 = o4.children(this._source.maxzoom);
                if (i4[t5[0].key] && i4[t5[1].key] && i4[t5[2].key] && i4[t5[3].key])
                  continue;
              }
              let r6 = t4.wasRequested();
              for (let e5 = o4.overscaledZ - 1; e5 >= a3; --e5) {
                const a4 = o4.scaledTo(e5);
                if (s4[a4.key])
                  break;
                if (s4[a4.key] = true, t4 = this.getTile(a4), !t4 && r6 && (t4 = this._addTile(a4)), t4) {
                  const e6 = t4.hasData();
                  if ((r6 || e6) && (i4[a4.key] = a4), r6 = t4.wasRequested(), e6)
                    break;
                }
              }
            }
            return i4;
          }
          _updateLoadedParentTileCache() {
            this._loadedParentTiles = {};
            for (const t3 in this._tiles) {
              const e4 = [];
              let i4, s4 = this._tiles[t3].tileID;
              for (; s4.overscaledZ > 0; ) {
                if (s4.key in this._loadedParentTiles) {
                  i4 = this._loadedParentTiles[s4.key];
                  break;
                }
                e4.push(s4.key);
                const t4 = s4.scaledTo(s4.overscaledZ - 1);
                if (i4 = this._getLoadedTile(t4), i4)
                  break;
                s4 = t4;
              }
              for (const t4 of e4)
                this._loadedParentTiles[t4] = i4;
            }
          }
          _addTile(t3) {
            let i4 = this._tiles[t3.key];
            if (i4)
              return i4;
            i4 = this._cache.getAndRemove(t3), i4 && (this._setTileReloadTimer(t3.key, i4), i4.tileID = t3, this._state.initializeTileState(i4, this.map ? this.map.painter : null), this._cacheTimers[t3.key] && (clearTimeout(this._cacheTimers[t3.key]), delete this._cacheTimers[t3.key], this._setTileReloadTimer(t3.key, i4)));
            const s4 = i4;
            return i4 || (i4 = new rt(t3, this._source.tileSize * t3.overscaleFactor()), this._loadTile(i4, t3.key, i4.state)), i4.uses++, this._tiles[t3.key] = i4, s4 || this._source.fire(new e3.k("dataloading", { tile: i4, coord: i4.tileID, dataType: "source" })), i4;
          }
          _setTileReloadTimer(t3, e4) {
            t3 in this._timers && (clearTimeout(this._timers[t3]), delete this._timers[t3]);
            const i4 = e4.getExpiryTimeout();
            i4 && (this._timers[t3] = setTimeout(() => {
              this._reloadTile(t3, "expired"), delete this._timers[t3];
            }, i4));
          }
          _removeTile(t3) {
            const e4 = this._tiles[t3];
            e4 && (e4.uses--, delete this._tiles[t3], this._timers[t3] && (clearTimeout(this._timers[t3]), delete this._timers[t3]), e4.uses > 0 || (e4.hasData() && "reloading" !== e4.state ? this._cache.add(e4.tileID, e4, e4.getExpiryTimeout()) : (e4.aborted = true, this._abortTile(e4), this._unloadTile(e4))));
          }
          clearTiles() {
            this._shouldReloadOnResume = false, this._paused = false;
            for (const t3 in this._tiles)
              this._removeTile(t3);
            this._cache.reset();
          }
          tilesIn(t3, i4, s4) {
            const a3 = [], o3 = this.transform;
            if (!o3)
              return a3;
            const r5 = s4 ? o3.getCameraQueryGeometry(t3) : t3, n3 = t3.map((t4) => o3.pointCoordinate(t4, this.terrain)), l4 = r5.map((t4) => o3.pointCoordinate(t4, this.terrain)), h2 = this.getIds();
            let c3 = 1 / 0, u3 = 1 / 0, d2 = -1 / 0, _2 = -1 / 0;
            for (const t4 of l4)
              c3 = Math.min(c3, t4.x), u3 = Math.min(u3, t4.y), d2 = Math.max(d2, t4.x), _2 = Math.max(_2, t4.y);
            for (let t4 = 0; t4 < h2.length; t4++) {
              const s5 = this._tiles[h2[t4]];
              if (s5.holdingForFade())
                continue;
              const r6 = s5.tileID, p4 = Math.pow(2, o3.zoom - s5.tileID.overscaledZ), m2 = i4 * s5.queryPadding * e3.W / s5.tileSize / p4, f2 = [r6.getTilePoint(new e3.Y(c3, u3)), r6.getTilePoint(new e3.Y(d2, _2))];
              if (f2[0].x - m2 < e3.W && f2[0].y - m2 < e3.W && f2[1].x + m2 >= 0 && f2[1].y + m2 >= 0) {
                const t5 = n3.map((t6) => r6.getTilePoint(t6)), e4 = l4.map((t6) => r6.getTilePoint(t6));
                a3.push({ tile: s5, tileID: r6, queryGeometry: t5, cameraQueryGeometry: e4, scale: p4 });
              }
            }
            return a3;
          }
          getVisibleCoordinates(t3) {
            const e4 = this.getRenderableIds(t3).map((t4) => this._tiles[t4].tileID);
            for (const t4 of e4)
              t4.posMatrix = this.transform.calculatePosMatrix(t4.toUnwrapped());
            return e4;
          }
          hasTransition() {
            if (this._source.hasTransition())
              return true;
            if (ut(this._source.type)) {
              const t3 = o2.now();
              for (const e4 in this._tiles)
                if (this._tiles[e4].fadeEndTime >= t3)
                  return true;
            }
            return false;
          }
          setFeatureState(t3, e4, i4) {
            this._state.updateState(t3 = t3 || "_geojsonTileLayer", e4, i4);
          }
          removeFeatureState(t3, e4, i4) {
            this._state.removeFeatureState(t3 = t3 || "_geojsonTileLayer", e4, i4);
          }
          getFeatureState(t3, e4) {
            return this._state.getState(t3 = t3 || "_geojsonTileLayer", e4);
          }
          setDependencies(t3, e4, i4) {
            const s4 = this._tiles[t3];
            s4 && s4.setDependencies(e4, i4);
          }
          reloadTilesForDependencies(t3, e4) {
            for (const i4 in this._tiles)
              this._tiles[i4].hasDependency(t3, e4) && this._reloadTile(i4, "reloading");
            this._cache.filter((i4) => !i4.hasDependency(t3, e4));
          }
        }
        function ct(t3, e4) {
          const i4 = Math.abs(2 * t3.wrap) - +(t3.wrap < 0), s4 = Math.abs(2 * e4.wrap) - +(e4.wrap < 0);
          return t3.overscaledZ - e4.overscaledZ || s4 - i4 || e4.canonical.y - t3.canonical.y || e4.canonical.x - t3.canonical.x;
        }
        function ut(t3) {
          return "raster" === t3 || "image" === t3 || "video" === t3;
        }
        ht.maxOverzooming = 10, ht.maxUnderzooming = 3;
        class dt {
          constructor(t3, e4) {
            this.reset(t3, e4);
          }
          reset(t3, e4) {
            this.points = t3 || [], this._distances = [0];
            for (let t4 = 1; t4 < this.points.length; t4++)
              this._distances[t4] = this._distances[t4 - 1] + this.points[t4].dist(this.points[t4 - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(e4 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
          }
          lerp(t3) {
            if (1 === this.points.length)
              return this.points[0];
            t3 = e3.ac(t3, 0, 1);
            let i4 = 1, s4 = this._distances[i4];
            const a3 = t3 * this.paddedLength + this.padding;
            for (; s4 < a3 && i4 < this._distances.length; )
              s4 = this._distances[++i4];
            const o3 = i4 - 1, r5 = this._distances[o3], n3 = s4 - r5, l4 = n3 > 0 ? (a3 - r5) / n3 : 0;
            return this.points[o3].mult(1 - l4).add(this.points[i4].mult(l4));
          }
        }
        function _t(t3, e4) {
          let i4 = true;
          return "always" === t3 || "never" !== t3 && "never" !== e4 || (i4 = false), i4;
        }
        class pt2 {
          constructor(t3, e4, i4) {
            const s4 = this.boxCells = [], a3 = this.circleCells = [];
            this.xCellCount = Math.ceil(t3 / i4), this.yCellCount = Math.ceil(e4 / i4);
            for (let t4 = 0; t4 < this.xCellCount * this.yCellCount; t4++)
              s4.push([]), a3.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = t3, this.height = e4, this.xScale = this.xCellCount / t3, this.yScale = this.yCellCount / e4, this.boxUid = 0, this.circleUid = 0;
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length;
          }
          insert(t3, e4, i4, s4, a3) {
            this._forEachCell(e4, i4, s4, a3, this._insertBoxCell, this.boxUid++), this.boxKeys.push(t3), this.bboxes.push(e4), this.bboxes.push(i4), this.bboxes.push(s4), this.bboxes.push(a3);
          }
          insertCircle(t3, e4, i4, s4) {
            this._forEachCell(e4 - s4, i4 - s4, e4 + s4, i4 + s4, this._insertCircleCell, this.circleUid++), this.circleKeys.push(t3), this.circles.push(e4), this.circles.push(i4), this.circles.push(s4);
          }
          _insertBoxCell(t3, e4, i4, s4, a3, o3) {
            this.boxCells[a3].push(o3);
          }
          _insertCircleCell(t3, e4, i4, s4, a3, o3) {
            this.circleCells[a3].push(o3);
          }
          _query(t3, e4, i4, s4, a3, o3, r5) {
            if (i4 < 0 || t3 > this.width || s4 < 0 || e4 > this.height)
              return [];
            const n3 = [];
            if (t3 <= 0 && e4 <= 0 && this.width <= i4 && this.height <= s4) {
              if (a3)
                return [{ key: null, x1: t3, y1: e4, x2: i4, y2: s4 }];
              for (let t4 = 0; t4 < this.boxKeys.length; t4++)
                n3.push({ key: this.boxKeys[t4], x1: this.bboxes[4 * t4], y1: this.bboxes[4 * t4 + 1], x2: this.bboxes[4 * t4 + 2], y2: this.bboxes[4 * t4 + 3] });
              for (let t4 = 0; t4 < this.circleKeys.length; t4++) {
                const e5 = this.circles[3 * t4], i5 = this.circles[3 * t4 + 1], s5 = this.circles[3 * t4 + 2];
                n3.push({ key: this.circleKeys[t4], x1: e5 - s5, y1: i5 - s5, x2: e5 + s5, y2: i5 + s5 });
              }
            } else
              this._forEachCell(t3, e4, i4, s4, this._queryCell, n3, { hitTest: a3, overlapMode: o3, seenUids: { box: {}, circle: {} } }, r5);
            return n3;
          }
          query(t3, e4, i4, s4) {
            return this._query(t3, e4, i4, s4, false, null);
          }
          hitTest(t3, e4, i4, s4, a3, o3) {
            return this._query(t3, e4, i4, s4, true, a3, o3).length > 0;
          }
          hitTestCircle(t3, e4, i4, s4, a3) {
            const o3 = t3 - i4, r5 = t3 + i4, n3 = e4 - i4, l4 = e4 + i4;
            if (r5 < 0 || o3 > this.width || l4 < 0 || n3 > this.height)
              return false;
            const h2 = [];
            return this._forEachCell(o3, n3, r5, l4, this._queryCellCircle, h2, { hitTest: true, overlapMode: s4, circle: { x: t3, y: e4, radius: i4 }, seenUids: { box: {}, circle: {} } }, a3), h2.length > 0;
          }
          _queryCell(t3, e4, i4, s4, a3, o3, r5, n3) {
            const { seenUids: l4, hitTest: h2, overlapMode: c3 } = r5, u3 = this.boxCells[a3];
            if (null !== u3) {
              const a4 = this.bboxes;
              for (const r6 of u3)
                if (!l4.box[r6]) {
                  l4.box[r6] = true;
                  const u4 = 4 * r6, d3 = this.boxKeys[r6];
                  if (t3 <= a4[u4 + 2] && e4 <= a4[u4 + 3] && i4 >= a4[u4 + 0] && s4 >= a4[u4 + 1] && (!n3 || n3(d3)) && (!h2 || !_t(c3, d3.overlapMode)) && (o3.push({ key: d3, x1: a4[u4], y1: a4[u4 + 1], x2: a4[u4 + 2], y2: a4[u4 + 3] }), h2))
                    return true;
                }
            }
            const d2 = this.circleCells[a3];
            if (null !== d2) {
              const a4 = this.circles;
              for (const r6 of d2)
                if (!l4.circle[r6]) {
                  l4.circle[r6] = true;
                  const u4 = 3 * r6, d3 = this.circleKeys[r6];
                  if (this._circleAndRectCollide(a4[u4], a4[u4 + 1], a4[u4 + 2], t3, e4, i4, s4) && (!n3 || n3(d3)) && (!h2 || !_t(c3, d3.overlapMode))) {
                    const t4 = a4[u4], e5 = a4[u4 + 1], i5 = a4[u4 + 2];
                    if (o3.push({ key: d3, x1: t4 - i5, y1: e5 - i5, x2: t4 + i5, y2: e5 + i5 }), h2)
                      return true;
                  }
                }
            }
            return false;
          }
          _queryCellCircle(t3, e4, i4, s4, a3, o3, r5, n3) {
            const { circle: l4, seenUids: h2, overlapMode: c3 } = r5, u3 = this.boxCells[a3];
            if (null !== u3) {
              const t4 = this.bboxes;
              for (const e5 of u3)
                if (!h2.box[e5]) {
                  h2.box[e5] = true;
                  const i5 = 4 * e5, s5 = this.boxKeys[e5];
                  if (this._circleAndRectCollide(l4.x, l4.y, l4.radius, t4[i5 + 0], t4[i5 + 1], t4[i5 + 2], t4[i5 + 3]) && (!n3 || n3(s5)) && !_t(c3, s5.overlapMode))
                    return o3.push(true), true;
                }
            }
            const d2 = this.circleCells[a3];
            if (null !== d2) {
              const t4 = this.circles;
              for (const e5 of d2)
                if (!h2.circle[e5]) {
                  h2.circle[e5] = true;
                  const i5 = 3 * e5, s5 = this.circleKeys[e5];
                  if (this._circlesCollide(t4[i5], t4[i5 + 1], t4[i5 + 2], l4.x, l4.y, l4.radius) && (!n3 || n3(s5)) && !_t(c3, s5.overlapMode))
                    return o3.push(true), true;
                }
            }
          }
          _forEachCell(t3, e4, i4, s4, a3, o3, r5, n3) {
            const l4 = this._convertToXCellCoord(t3), h2 = this._convertToYCellCoord(e4), c3 = this._convertToXCellCoord(i4), u3 = this._convertToYCellCoord(s4);
            for (let d2 = l4; d2 <= c3; d2++)
              for (let l5 = h2; l5 <= u3; l5++)
                if (a3.call(this, t3, e4, i4, s4, this.xCellCount * l5 + d2, o3, r5, n3))
                  return;
          }
          _convertToXCellCoord(t3) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t3 * this.xScale)));
          }
          _convertToYCellCoord(t3) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t3 * this.yScale)));
          }
          _circlesCollide(t3, e4, i4, s4, a3, o3) {
            const r5 = s4 - t3, n3 = a3 - e4, l4 = i4 + o3;
            return l4 * l4 > r5 * r5 + n3 * n3;
          }
          _circleAndRectCollide(t3, e4, i4, s4, a3, o3, r5) {
            const n3 = (o3 - s4) / 2, l4 = Math.abs(t3 - (s4 + n3));
            if (l4 > n3 + i4)
              return false;
            const h2 = (r5 - a3) / 2, c3 = Math.abs(e4 - (a3 + h2));
            if (c3 > h2 + i4)
              return false;
            if (l4 <= n3 || c3 <= h2)
              return true;
            const u3 = l4 - n3, d2 = c3 - h2;
            return u3 * u3 + d2 * d2 <= i4 * i4;
          }
        }
        function mt(t3, i4, s4, a3, o3) {
          const r5 = e3.F();
          return i4 ? (e3.J(r5, r5, [1 / o3, 1 / o3, 1]), s4 || e3.ad(r5, r5, a3.angle)) : e3.K(r5, a3.labelPlaneMatrix, t3), r5;
        }
        function ft(t3, i4, s4, a3, o3) {
          if (i4) {
            const i5 = e3.ae(t3);
            return e3.J(i5, i5, [o3, o3, 1]), s4 || e3.ad(i5, i5, -a3.angle), i5;
          }
          return a3.glCoordMatrix;
        }
        function gt(t3, i4, s4) {
          let a3;
          s4 ? (a3 = [t3.x, t3.y, s4(t3.x, t3.y), 1], e3.af(a3, a3, i4)) : (a3 = [t3.x, t3.y, 0, 1], Mt(a3, a3, i4));
          const o3 = a3[3];
          return { point: new e3.P(a3[0] / o3, a3[1] / o3), signedDistanceFromCamera: o3 };
        }
        function vt(t3, e4) {
          return 0.5 + t3 / e4 * 0.5;
        }
        function xt(t3, e4) {
          const i4 = t3[0] / t3[3], s4 = t3[1] / t3[3];
          return i4 >= -e4[0] && i4 <= e4[0] && s4 >= -e4[1] && s4 <= e4[1];
        }
        function yt(t3, i4, s4, a3, o3, r5, n3, l4, h2, c3) {
          const u3 = a3 ? t3.textSizeData : t3.iconSizeData, d2 = e3.ag(u3, s4.transform.zoom), _2 = [256 / s4.width * 2 + 1, 256 / s4.height * 2 + 1], p4 = a3 ? t3.text.dynamicLayoutVertexArray : t3.icon.dynamicLayoutVertexArray;
          p4.clear();
          const m2 = t3.lineVertexArray, f2 = a3 ? t3.text.placedSymbolArray : t3.icon.placedSymbolArray, g3 = s4.transform.width / s4.transform.height;
          let v4 = false;
          for (let a4 = 0; a4 < f2.length; a4++) {
            const x5 = f2.get(a4);
            if (x5.hidden || x5.writingMode === e3.ah.vertical && !v4) {
              zt(x5.numGlyphs, p4);
              continue;
            }
            let y4;
            if (v4 = false, c3 ? (y4 = [x5.anchorX, x5.anchorY, c3(x5.anchorX, x5.anchorY), 1], e3.af(y4, y4, i4)) : (y4 = [x5.anchorX, x5.anchorY, 0, 1], Mt(y4, y4, i4)), !xt(y4, _2)) {
              zt(x5.numGlyphs, p4);
              continue;
            }
            const b3 = vt(s4.transform.cameraToCenterDistance, y4[3]), w4 = e3.ai(u3, d2, x5), T3 = n3 ? w4 / b3 : w4 * b3, I3 = new e3.P(x5.anchorX, x5.anchorY), E3 = gt(I3, o3, c3).point, S4 = { projections: {}, offsets: {} }, C5 = Tt(x5, T3, false, l4, i4, o3, r5, t3.glyphOffsetArray, m2, p4, E3, I3, S4, g3, h2, c3);
            v4 = C5.useVertical, (C5.notEnoughRoom || v4 || C5.needsFlipping && Tt(x5, T3, true, l4, i4, o3, r5, t3.glyphOffsetArray, m2, p4, E3, I3, S4, g3, h2, c3).notEnoughRoom) && zt(x5.numGlyphs, p4);
          }
          a3 ? t3.text.dynamicLayoutVertexBuffer.updateData(p4) : t3.icon.dynamicLayoutVertexBuffer.updateData(p4);
        }
        function bt(t3, e4, i4, s4, a3, o3, r5, n3, l4, h2, c3, u3, d2) {
          const _2 = n3.glyphStartIndex + n3.numGlyphs, p4 = n3.lineStartIndex, m2 = n3.lineStartIndex + n3.lineLength, f2 = e4.getoffsetX(n3.glyphStartIndex), g3 = e4.getoffsetX(_2 - 1), v4 = Pt(t3 * f2, i4, s4, a3, o3, r5, n3.segment, p4, m2, l4, h2, c3, u3, d2);
          if (!v4)
            return null;
          const x5 = Pt(t3 * g3, i4, s4, a3, o3, r5, n3.segment, p4, m2, l4, h2, c3, u3, d2);
          return x5 ? { first: v4, last: x5 } : null;
        }
        function wt(t3, i4, s4, a3) {
          return t3 === e3.ah.horizontal && Math.abs(s4.y - i4.y) > Math.abs(s4.x - i4.x) * a3 ? { useVertical: true } : (t3 === e3.ah.vertical ? i4.y < s4.y : i4.x > s4.x) ? { needsFlipping: true } : null;
        }
        function Tt(t3, i4, s4, a3, o3, r5, n3, l4, h2, c3, u3, d2, _2, p4, m2, f2) {
          const g3 = i4 / 24, v4 = t3.lineOffsetX * g3, x5 = t3.lineOffsetY * g3;
          let y4;
          if (t3.numGlyphs > 1) {
            const e4 = t3.glyphStartIndex + t3.numGlyphs, i5 = t3.lineStartIndex, o4 = t3.lineStartIndex + t3.lineLength, c4 = bt(g3, l4, v4, x5, s4, u3, d2, t3, h2, r5, _2, m2, f2);
            if (!c4)
              return { notEnoughRoom: true };
            const b3 = gt(c4.first.point, n3, f2).point, w4 = gt(c4.last.point, n3, f2).point;
            if (a3 && !s4) {
              const e5 = wt(t3.writingMode, b3, w4, p4);
              if (e5)
                return e5;
            }
            y4 = [c4.first];
            for (let a4 = t3.glyphStartIndex + 1; a4 < e4 - 1; a4++)
              y4.push(Pt(g3 * l4.getoffsetX(a4), v4, x5, s4, u3, d2, t3.segment, i5, o4, h2, r5, _2, m2, f2));
            y4.push(c4.last);
          } else {
            if (a3 && !s4) {
              const i6 = gt(d2, o3, f2).point, s5 = t3.lineStartIndex + t3.segment + 1, a4 = new e3.P(h2.getx(s5), h2.gety(s5)), r6 = gt(a4, o3, f2), n4 = r6.signedDistanceFromCamera > 0 ? r6.point : It(d2, a4, i6, 1, o3, f2), l5 = wt(t3.writingMode, i6, n4, p4);
              if (l5)
                return l5;
            }
            const i5 = Pt(g3 * l4.getoffsetX(t3.glyphStartIndex), v4, x5, s4, u3, d2, t3.segment, t3.lineStartIndex, t3.lineStartIndex + t3.lineLength, h2, r5, _2, m2, f2);
            if (!i5)
              return { notEnoughRoom: true };
            y4 = [i5];
          }
          for (const t4 of y4)
            e3.aj(c3, t4.point, t4.angle);
          return {};
        }
        function It(t3, e4, i4, s4, a3, o3) {
          const r5 = gt(t3.add(t3.sub(e4)._unit()), a3, o3).point, n3 = i4.sub(r5);
          return i4.add(n3._mult(s4 / n3.mag()));
        }
        function Et(t3, i4) {
          const { projectionCache: s4, lineVertexArray: a3, labelPlaneMatrix: o3, tileAnchorPoint: r5, distanceFromAnchor: n3, getElevation: l4, previousVertex: h2, direction: c3, absOffsetX: u3 } = i4;
          if (s4.projections[t3])
            return s4.projections[t3];
          const d2 = new e3.P(a3.getx(t3), a3.gety(t3)), _2 = gt(d2, o3, l4);
          if (_2.signedDistanceFromCamera > 0)
            return s4.projections[t3] = _2.point, _2.point;
          const p4 = t3 - c3;
          return It(0 === n3 ? r5 : new e3.P(a3.getx(p4), a3.gety(p4)), d2, h2, u3 - n3 + 1, o3, l4);
        }
        function St(t3, e4, i4) {
          return t3._unit()._perp()._mult(e4 * i4);
        }
        function Ct(t3, i4, s4, a3, o3, r5, n3, l4) {
          const { projectionCache: h2, direction: c3 } = l4;
          if (h2.offsets[t3])
            return h2.offsets[t3];
          const u3 = s4.add(i4);
          if (t3 + c3 < a3 || t3 + c3 >= o3)
            return h2.offsets[t3] = u3, u3;
          const d2 = Et(t3 + c3, l4), _2 = St(d2.sub(s4), n3, c3), p4 = s4.add(_2), m2 = d2.add(_2);
          return h2.offsets[t3] = e3.ak(r5, u3, p4, m2) || u3, h2.offsets[t3];
        }
        function Pt(t3, e4, i4, s4, a3, o3, r5, n3, l4, h2, c3, u3, d2, _2) {
          const p4 = s4 ? t3 - e4 : t3 + e4;
          let m2 = p4 > 0 ? 1 : -1, f2 = 0;
          s4 && (m2 *= -1, f2 = Math.PI), m2 < 0 && (f2 += Math.PI);
          let g3, v4, x5 = m2 > 0 ? n3 + r5 : n3 + r5 + 1, y4 = a3, b3 = a3, w4 = 0, T3 = 0;
          const I3 = Math.abs(p4), E3 = [];
          let S4;
          for (; w4 + T3 <= I3; ) {
            if (x5 += m2, x5 < n3 || x5 >= l4)
              return null;
            w4 += T3, b3 = y4, v4 = g3;
            const t4 = { projectionCache: u3, lineVertexArray: h2, labelPlaneMatrix: c3, tileAnchorPoint: o3, distanceFromAnchor: w4, getElevation: _2, previousVertex: b3, direction: m2, absOffsetX: I3 };
            if (y4 = Et(x5, t4), 0 === i4)
              E3.push(b3), S4 = y4.sub(b3);
            else {
              let e5;
              const s5 = y4.sub(b3);
              e5 = 0 === s5.mag() ? St(Et(x5 + m2, t4).sub(y4), i4, m2) : St(s5, i4, m2), v4 || (v4 = b3.add(e5)), g3 = Ct(x5, e5, y4, n3, l4, v4, i4, t4), E3.push(v4), S4 = g3.sub(v4);
            }
            T3 = S4.mag();
          }
          const C5 = S4._mult((I3 - w4) / T3)._add(v4 || b3), P3 = f2 + Math.atan2(y4.y - b3.y, y4.x - b3.x);
          return E3.push(C5), { point: C5, angle: d2 ? P3 : 0, path: E3 };
        }
        const Dt = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
        function zt(t3, e4) {
          for (let i4 = 0; i4 < t3; i4++) {
            const t4 = e4.length;
            e4.resize(t4 + 4), e4.float32.set(Dt, 3 * t4);
          }
        }
        function Mt(t3, e4, i4) {
          const s4 = e4[0], a3 = e4[1];
          return t3[0] = i4[0] * s4 + i4[4] * a3 + i4[12], t3[1] = i4[1] * s4 + i4[5] * a3 + i4[13], t3[3] = i4[3] * s4 + i4[7] * a3 + i4[15], t3;
        }
        const At = 100;
        class Rt {
          constructor(t3, e4 = new pt2(t3.width + 200, t3.height + 200, 25), i4 = new pt2(t3.width + 200, t3.height + 200, 25)) {
            this.transform = t3, this.grid = e4, this.ignoredGrid = i4, this.pitchfactor = Math.cos(t3._pitch) * t3.cameraToCenterDistance, this.screenRightBoundary = t3.width + At, this.screenBottomBoundary = t3.height + At, this.gridRightBoundary = t3.width + 200, this.gridBottomBoundary = t3.height + 200, this.perspectiveRatioCutoff = 0.6;
          }
          placeCollisionBox(t3, e4, i4, s4, a3, o3) {
            const r5 = this.projectAndGetPerspectiveRatio(s4, t3.anchorPointX, t3.anchorPointY, o3), n3 = i4 * r5.perspectiveRatio, l4 = t3.x1 * n3 + r5.point.x, h2 = t3.y1 * n3 + r5.point.y, c3 = t3.x2 * n3 + r5.point.x, u3 = t3.y2 * n3 + r5.point.y;
            return !this.isInsideGrid(l4, h2, c3, u3) || "always" !== e4 && this.grid.hitTest(l4, h2, c3, u3, e4, a3) || r5.perspectiveRatio < this.perspectiveRatioCutoff ? { box: [], offscreen: false } : { box: [l4, h2, c3, u3], offscreen: this.isOffscreen(l4, h2, c3, u3) };
          }
          placeCollisionCircles(t3, i4, s4, a3, o3, r5, n3, l4, h2, c3, u3, d2, _2, p4) {
            const m2 = [], f2 = new e3.P(i4.anchorX, i4.anchorY), g3 = gt(f2, r5, p4), v4 = vt(this.transform.cameraToCenterDistance, g3.signedDistanceFromCamera), x5 = (c3 ? o3 / v4 : o3 * v4) / e3.ao, y4 = gt(f2, n3, p4).point, b3 = bt(x5, a3, i4.lineOffsetX * x5, i4.lineOffsetY * x5, false, y4, f2, i4, s4, n3, { projections: {}, offsets: {} }, false, p4);
            let w4 = false, T3 = false, I3 = true;
            if (b3) {
              const i5 = 0.5 * d2 * v4 + _2, s5 = new e3.P(-100, -100), a4 = new e3.P(this.screenRightBoundary, this.screenBottomBoundary), o4 = new dt(), r6 = b3.first, n4 = b3.last;
              let c4 = [];
              for (let t4 = r6.path.length - 1; t4 >= 1; t4--)
                c4.push(r6.path[t4]);
              for (let t4 = 1; t4 < n4.path.length; t4++)
                c4.push(n4.path[t4]);
              const f3 = 2.5 * i5;
              if (l4) {
                const t4 = c4.map((t5) => gt(t5, l4, p4));
                c4 = t4.some((t5) => t5.signedDistanceFromCamera <= 0) ? [] : t4.map((t5) => t5.point);
              }
              let g4 = [];
              if (c4.length > 0) {
                const t4 = c4[0].clone(), i6 = c4[0].clone();
                for (let e4 = 1; e4 < c4.length; e4++)
                  t4.x = Math.min(t4.x, c4[e4].x), t4.y = Math.min(t4.y, c4[e4].y), i6.x = Math.max(i6.x, c4[e4].x), i6.y = Math.max(i6.y, c4[e4].y);
                g4 = t4.x >= s5.x && i6.x <= a4.x && t4.y >= s5.y && i6.y <= a4.y ? [c4] : i6.x < s5.x || t4.x > a4.x || i6.y < s5.y || t4.y > a4.y ? [] : e3.al([c4], s5.x, s5.y, a4.x, a4.y);
              }
              for (const e4 of g4) {
                o4.reset(e4, 0.25 * i5);
                let s6 = 0;
                s6 = o4.length <= 0.5 * i5 ? 1 : Math.ceil(o4.paddedLength / f3) + 1;
                for (let e5 = 0; e5 < s6; e5++) {
                  const a5 = e5 / Math.max(s6 - 1, 1), r7 = o4.lerp(a5), n5 = r7.x + At, l5 = r7.y + At;
                  m2.push(n5, l5, i5, 0);
                  const c5 = n5 - i5, d3 = l5 - i5, _3 = n5 + i5, p5 = l5 + i5;
                  if (I3 = I3 && this.isOffscreen(c5, d3, _3, p5), T3 = T3 || this.isInsideGrid(c5, d3, _3, p5), "always" !== t3 && this.grid.hitTestCircle(n5, l5, i5, t3, u3) && (w4 = true, !h2))
                    return { circles: [], offscreen: false, collisionDetected: w4 };
                }
              }
            }
            return { circles: !h2 && w4 || !T3 || v4 < this.perspectiveRatioCutoff ? [] : m2, offscreen: I3, collisionDetected: w4 };
          }
          queryRenderedSymbols(t3) {
            if (0 === t3.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength())
              return {};
            const i4 = [];
            let s4 = 1 / 0, a3 = 1 / 0, o3 = -1 / 0, r5 = -1 / 0;
            for (const n4 of t3) {
              const t4 = new e3.P(n4.x + At, n4.y + At);
              s4 = Math.min(s4, t4.x), a3 = Math.min(a3, t4.y), o3 = Math.max(o3, t4.x), r5 = Math.max(r5, t4.y), i4.push(t4);
            }
            const n3 = this.grid.query(s4, a3, o3, r5).concat(this.ignoredGrid.query(s4, a3, o3, r5)), l4 = {}, h2 = {};
            for (const t4 of n3) {
              const s5 = t4.key;
              if (void 0 === l4[s5.bucketInstanceId] && (l4[s5.bucketInstanceId] = {}), l4[s5.bucketInstanceId][s5.featureIndex])
                continue;
              const a4 = [new e3.P(t4.x1, t4.y1), new e3.P(t4.x2, t4.y1), new e3.P(t4.x2, t4.y2), new e3.P(t4.x1, t4.y2)];
              e3.am(i4, a4) && (l4[s5.bucketInstanceId][s5.featureIndex] = true, void 0 === h2[s5.bucketInstanceId] && (h2[s5.bucketInstanceId] = []), h2[s5.bucketInstanceId].push(s5.featureIndex));
            }
            return h2;
          }
          insertCollisionBox(t3, e4, i4, s4, a3, o3) {
            (i4 ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: s4, featureIndex: a3, collisionGroupID: o3, overlapMode: e4 }, t3[0], t3[1], t3[2], t3[3]);
          }
          insertCollisionCircles(t3, e4, i4, s4, a3, o3) {
            const r5 = i4 ? this.ignoredGrid : this.grid, n3 = { bucketInstanceId: s4, featureIndex: a3, collisionGroupID: o3, overlapMode: e4 };
            for (let e5 = 0; e5 < t3.length; e5 += 4)
              r5.insertCircle(n3, t3[e5], t3[e5 + 1], t3[e5 + 2]);
          }
          projectAndGetPerspectiveRatio(t3, i4, s4, a3) {
            let o3;
            return a3 ? (o3 = [i4, s4, a3(i4, s4), 1], e3.af(o3, o3, t3)) : (o3 = [i4, s4, 0, 1], Mt(o3, o3, t3)), { point: new e3.P((o3[0] / o3[3] + 1) / 2 * this.transform.width + At, (-o3[1] / o3[3] + 1) / 2 * this.transform.height + At), perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / o3[3] * 0.5 };
          }
          isOffscreen(t3, e4, i4, s4) {
            return i4 < At || t3 >= this.screenRightBoundary || s4 < At || e4 > this.screenBottomBoundary;
          }
          isInsideGrid(t3, e4, i4, s4) {
            return i4 >= 0 && t3 < this.gridRightBoundary && s4 >= 0 && e4 < this.gridBottomBoundary;
          }
          getViewportMatrix() {
            const t3 = e3.an([]);
            return e3.H(t3, t3, [-100, -100, 0]), t3;
          }
        }
        function Lt(t3, i4, s4) {
          return i4 * (e3.W / (t3.tileSize * Math.pow(2, s4 - t3.tileID.overscaledZ)));
        }
        class kt {
          constructor(t3, e4, i4, s4) {
            this.opacity = t3 ? Math.max(0, Math.min(1, t3.opacity + (t3.placed ? e4 : -e4))) : s4 && i4 ? 1 : 0, this.placed = i4;
          }
          isHidden() {
            return 0 === this.opacity && !this.placed;
          }
        }
        class Ft {
          constructor(t3, e4, i4, s4, a3) {
            this.text = new kt(t3 ? t3.text : null, e4, i4, a3), this.icon = new kt(t3 ? t3.icon : null, e4, s4, a3);
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden();
          }
        }
        class Bt {
          constructor(t3, e4, i4) {
            this.text = t3, this.icon = e4, this.skipFade = i4;
          }
        }
        class Ot {
          constructor() {
            this.invProjMatrix = e3.F(), this.viewportMatrix = e3.F(), this.circles = [];
          }
        }
        class Nt {
          constructor(t3, e4, i4, s4, a3) {
            this.bucketInstanceId = t3, this.featureIndex = e4, this.sourceLayerIndex = i4, this.bucketIndex = s4, this.tileID = a3;
          }
        }
        class Ut {
          constructor(t3) {
            this.crossSourceCollisions = t3, this.maxGroupID = 0, this.collisionGroups = {};
          }
          get(t3) {
            if (this.crossSourceCollisions)
              return { ID: 0, predicate: null };
            if (!this.collisionGroups[t3]) {
              const e4 = ++this.maxGroupID;
              this.collisionGroups[t3] = { ID: e4, predicate: (t4) => t4.collisionGroupID === e4 };
            }
            return this.collisionGroups[t3];
          }
        }
        function Zt(t3, i4, s4, a3, o3) {
          const { horizontalAlign: r5, verticalAlign: n3 } = e3.at(t3);
          return new e3.P(-(r5 - 0.5) * i4 + a3[0] * o3, -(n3 - 0.5) * s4 + a3[1] * o3);
        }
        function Gt(t3, i4, s4, a3, o3, r5) {
          const { x1: n3, x2: l4, y1: h2, y2: c3, anchorPointX: u3, anchorPointY: d2 } = t3, _2 = new e3.P(i4, s4);
          return a3 && _2._rotate(o3 ? r5 : -r5), { x1: n3 + _2.x, y1: h2 + _2.y, x2: l4 + _2.x, y2: c3 + _2.y, anchorPointX: u3, anchorPointY: d2 };
        }
        class jt {
          constructor(t3, e4, i4, s4, a3) {
            this.transform = t3.clone(), this.terrain = e4, this.collisionIndex = new Rt(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = i4, this.retainedQueryData = {}, this.collisionGroups = new Ut(s4), this.collisionCircleArrays = {}, this.prevPlacement = a3, a3 && (a3.prevPlacement = void 0), this.placedOrientations = {};
          }
          getBucketParts(t3, i4, s4, a3) {
            const o3 = s4.getBucket(i4), r5 = s4.latestFeatureIndex;
            if (!o3 || !r5 || i4.id !== o3.layerIds[0])
              return;
            const n3 = s4.collisionBoxArray, l4 = o3.layers[0].layout, h2 = Math.pow(2, this.transform.zoom - s4.tileID.overscaledZ), c3 = s4.tileSize / e3.W, u3 = this.transform.calculatePosMatrix(s4.tileID.toUnwrapped()), d2 = "map" === l4.get("text-pitch-alignment"), _2 = "map" === l4.get("text-rotation-alignment"), p4 = Lt(s4, 1, this.transform.zoom), m2 = mt(u3, d2, _2, this.transform, p4);
            let f2 = null;
            if (d2) {
              const t4 = ft(u3, d2, _2, this.transform, p4);
              f2 = e3.K([], this.transform.labelPlaneMatrix, t4);
            }
            this.retainedQueryData[o3.bucketInstanceId] = new Nt(o3.bucketInstanceId, r5, o3.sourceLayerIndex, o3.index, s4.tileID);
            const g3 = { bucket: o3, layout: l4, posMatrix: u3, textLabelPlaneMatrix: m2, labelToScreenMatrix: f2, scale: h2, textPixelRatio: c3, holdingForFade: s4.holdingForFade(), collisionBoxArray: n3, partiallyEvaluatedTextSize: e3.ag(o3.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(o3.sourceID) };
            if (a3)
              for (const e4 of o3.sortKeyRanges) {
                const { sortKey: i5, symbolInstanceStart: s5, symbolInstanceEnd: a4 } = e4;
                t3.push({ sortKey: i5, symbolInstanceStart: s5, symbolInstanceEnd: a4, parameters: g3 });
              }
            else
              t3.push({ symbolInstanceStart: 0, symbolInstanceEnd: o3.symbolInstances.length, parameters: g3 });
          }
          attemptAnchorPlacement(t3, i4, s4, a3, o3, r5, n3, l4, h2, c3, u3, d2, _2, p4, m2, f2) {
            const g3 = e3.ap[t3.textAnchor], v4 = [t3.textOffset0, t3.textOffset1], x5 = Zt(g3, s4, a3, v4, o3), y4 = this.collisionIndex.placeCollisionBox(Gt(i4, x5.x, x5.y, r5, n3, this.transform.angle), u3, l4, h2, c3.predicate, f2);
            if ((!m2 || 0 !== this.collisionIndex.placeCollisionBox(Gt(m2, x5.x, x5.y, r5, n3, this.transform.angle), u3, l4, h2, c3.predicate, f2).box.length) && y4.box.length > 0) {
              let t4;
              if (this.prevPlacement && this.prevPlacement.variableOffsets[d2.crossTileID] && this.prevPlacement.placements[d2.crossTileID] && this.prevPlacement.placements[d2.crossTileID].text && (t4 = this.prevPlacement.variableOffsets[d2.crossTileID].anchor), 0 === d2.crossTileID)
                throw new Error("symbolInstance.crossTileID can't be 0");
              return this.variableOffsets[d2.crossTileID] = { textOffset: v4, width: s4, height: a3, anchor: g3, textBoxScale: o3, prevAnchor: t4 }, this.markUsedJustification(_2, g3, d2, p4), _2.allowVerticalPlacement && (this.markUsedOrientation(_2, p4, d2), this.placedOrientations[d2.crossTileID] = p4), { shift: x5, placedGlyphBoxes: y4 };
            }
          }
          placeLayerBucketPart(t3, i4, s4) {
            const { bucket: a3, layout: o3, posMatrix: r5, textLabelPlaneMatrix: n3, labelToScreenMatrix: l4, textPixelRatio: h2, holdingForFade: c3, collisionBoxArray: u3, partiallyEvaluatedTextSize: d2, collisionGroup: _2 } = t3.parameters, p4 = o3.get("text-optional"), m2 = o3.get("icon-optional"), f2 = e3.aq(o3, "text-overlap", "text-allow-overlap"), g3 = "always" === f2, v4 = e3.aq(o3, "icon-overlap", "icon-allow-overlap"), x5 = "always" === v4, y4 = "map" === o3.get("text-rotation-alignment"), b3 = "map" === o3.get("text-pitch-alignment"), w4 = "none" !== o3.get("icon-text-fit"), T3 = "viewport-y" === o3.get("symbol-z-order"), I3 = g3 && (x5 || !a3.hasIconData() || m2), E3 = x5 && (g3 || !a3.hasTextData() || p4);
            !a3.collisionArrays && u3 && a3.deserializeCollisionBoxes(u3);
            const S4 = this.retainedQueryData[a3.bucketInstanceId].tileID, C5 = this.terrain ? (t4, e4) => this.terrain.getElevation(S4, t4, e4) : null, P3 = (t4, u4) => {
              var x6, T4;
              if (i4[t4.crossTileID])
                return;
              if (c3)
                return void (this.placements[t4.crossTileID] = new Bt(false, false, false));
              let S5 = false, P4 = false, D4 = true, z4 = null, M3 = { box: null, offscreen: null }, A3 = { box: null, offscreen: null }, R4 = null, L3 = null, k3 = null, F4 = 0, B3 = 0, O3 = 0;
              u4.textFeatureIndex ? F4 = u4.textFeatureIndex : t4.useRuntimeCollisionCircles && (F4 = t4.featureIndex), u4.verticalTextFeatureIndex && (B3 = u4.verticalTextFeatureIndex);
              const N4 = u4.textBox;
              if (N4) {
                const i5 = (i6) => {
                  let s6 = e3.ah.horizontal;
                  if (a3.allowVerticalPlacement && !i6 && this.prevPlacement) {
                    const e4 = this.prevPlacement.placedOrientations[t4.crossTileID];
                    e4 && (this.placedOrientations[t4.crossTileID] = e4, s6 = e4, this.markUsedOrientation(a3, s6, t4));
                  }
                  return s6;
                }, s5 = (i6, s6) => {
                  if (a3.allowVerticalPlacement && t4.numVerticalGlyphVertices > 0 && u4.verticalTextBox) {
                    for (const t5 of a3.writingModes)
                      if (t5 === e3.ah.vertical ? (M3 = s6(), A3 = M3) : M3 = i6(), M3 && M3.box && M3.box.length)
                        break;
                  } else
                    M3 = i6();
                }, o4 = t4.textAnchorOffsetStartIndex, n4 = t4.textAnchorOffsetEndIndex;
                if (n4 === o4) {
                  const o5 = (e4, i6) => {
                    const s6 = this.collisionIndex.placeCollisionBox(e4, f2, h2, r5, _2.predicate, C5);
                    return s6 && s6.box && s6.box.length && (this.markUsedOrientation(a3, i6, t4), this.placedOrientations[t4.crossTileID] = i6), s6;
                  };
                  s5(() => o5(N4, e3.ah.horizontal), () => {
                    const i6 = u4.verticalTextBox;
                    return a3.allowVerticalPlacement && t4.numVerticalGlyphVertices > 0 && i6 ? o5(i6, e3.ah.vertical) : { box: null, offscreen: null };
                  }), i5(M3 && M3.box && M3.box.length);
                } else {
                  let l5 = e3.ap[null === (T4 = null === (x6 = this.prevPlacement) || void 0 === x6 ? void 0 : x6.variableOffsets[t4.crossTileID]) || void 0 === T4 ? void 0 : T4.anchor];
                  const c4 = (e4, i6, s6) => {
                    const c5 = e4.x2 - e4.x1, u5 = e4.y2 - e4.y1, d4 = t4.textBoxScale, p5 = w4 && "never" === v4 ? i6 : null;
                    let m3 = { box: [], offscreen: false }, g4 = "never" === f2 ? 1 : 2, x7 = "never";
                    l5 && g4++;
                    for (let i7 = 0; i7 < g4; i7++) {
                      for (let i8 = o4; i8 < n4; i8++) {
                        const o5 = a3.textAnchorOffsets.get(i8);
                        if (l5 && o5.textAnchor !== l5)
                          continue;
                        const n5 = this.attemptAnchorPlacement(o5, e4, c5, u5, d4, y4, b3, h2, r5, _2, x7, t4, a3, s6, p5, C5);
                        if (n5 && (m3 = n5.placedGlyphBoxes, m3 && m3.box && m3.box.length))
                          return S5 = true, z4 = n5.shift, m3;
                      }
                      l5 ? l5 = null : x7 = f2;
                    }
                    return m3;
                  };
                  s5(() => c4(N4, u4.iconBox, e3.ah.horizontal), () => {
                    const i6 = u4.verticalTextBox;
                    return a3.allowVerticalPlacement && !(M3 && M3.box && M3.box.length) && t4.numVerticalGlyphVertices > 0 && i6 ? c4(i6, u4.verticalIconBox, e3.ah.vertical) : { box: null, offscreen: null };
                  }), M3 && (S5 = M3.box, D4 = M3.offscreen);
                  const d3 = i5(M3 && M3.box);
                  if (!S5 && this.prevPlacement) {
                    const e4 = this.prevPlacement.variableOffsets[t4.crossTileID];
                    e4 && (this.variableOffsets[t4.crossTileID] = e4, this.markUsedJustification(a3, e4.anchor, t4, d3));
                  }
                }
              }
              if (R4 = M3, S5 = R4 && R4.box && R4.box.length > 0, D4 = R4 && R4.offscreen, t4.useRuntimeCollisionCircles) {
                const i5 = a3.text.placedSymbolArray.get(t4.centerJustifiedTextSymbolIndex), h3 = e3.ai(a3.textSizeData, d2, i5), c4 = o3.get("text-padding");
                L3 = this.collisionIndex.placeCollisionCircles(f2, i5, a3.lineVertexArray, a3.glyphOffsetArray, h3, r5, n3, l4, s4, b3, _2.predicate, t4.collisionCircleDiameter, c4, C5), L3.circles.length && L3.collisionDetected && !s4 && e3.w("Collisions detected, but collision boxes are not shown"), S5 = g3 || L3.circles.length > 0 && !L3.collisionDetected, D4 = D4 && L3.offscreen;
              }
              if (u4.iconFeatureIndex && (O3 = u4.iconFeatureIndex), u4.iconBox) {
                const t5 = (t6) => {
                  const e4 = w4 && z4 ? Gt(t6, z4.x, z4.y, y4, b3, this.transform.angle) : t6;
                  return this.collisionIndex.placeCollisionBox(e4, v4, h2, r5, _2.predicate, C5);
                };
                A3 && A3.box && A3.box.length && u4.verticalIconBox ? (k3 = t5(u4.verticalIconBox), P4 = k3.box.length > 0) : (k3 = t5(u4.iconBox), P4 = k3.box.length > 0), D4 = D4 && k3.offscreen;
              }
              const U3 = p4 || 0 === t4.numHorizontalGlyphVertices && 0 === t4.numVerticalGlyphVertices, Z5 = m2 || 0 === t4.numIconVertices;
              if (U3 || Z5 ? Z5 ? U3 || (P4 = P4 && S5) : S5 = P4 && S5 : P4 = S5 = P4 && S5, S5 && R4 && R4.box && this.collisionIndex.insertCollisionBox(R4.box, f2, o3.get("text-ignore-placement"), a3.bucketInstanceId, A3 && A3.box && B3 ? B3 : F4, _2.ID), P4 && k3 && this.collisionIndex.insertCollisionBox(k3.box, v4, o3.get("icon-ignore-placement"), a3.bucketInstanceId, O3, _2.ID), L3 && (S5 && this.collisionIndex.insertCollisionCircles(L3.circles, f2, o3.get("text-ignore-placement"), a3.bucketInstanceId, F4, _2.ID), s4)) {
                const t5 = a3.bucketInstanceId;
                let e4 = this.collisionCircleArrays[t5];
                void 0 === e4 && (e4 = this.collisionCircleArrays[t5] = new Ot());
                for (let t6 = 0; t6 < L3.circles.length; t6 += 4)
                  e4.circles.push(L3.circles[t6 + 0]), e4.circles.push(L3.circles[t6 + 1]), e4.circles.push(L3.circles[t6 + 2]), e4.circles.push(L3.collisionDetected ? 1 : 0);
              }
              if (0 === t4.crossTileID)
                throw new Error("symbolInstance.crossTileID can't be 0");
              if (0 === a3.bucketInstanceId)
                throw new Error("bucket.bucketInstanceId can't be 0");
              this.placements[t4.crossTileID] = new Bt(S5 || I3, P4 || E3, D4 || a3.justReloaded), i4[t4.crossTileID] = true;
            };
            if (T3) {
              if (0 !== t3.symbolInstanceStart)
                throw new Error("bucket.bucketInstanceId should be 0");
              const e4 = a3.getSortedSymbolIndexes(this.transform.angle);
              for (let t4 = e4.length - 1; t4 >= 0; --t4) {
                const i5 = e4[t4];
                P3(a3.symbolInstances.get(i5), a3.collisionArrays[i5]);
              }
            } else
              for (let e4 = t3.symbolInstanceStart; e4 < t3.symbolInstanceEnd; e4++)
                P3(a3.symbolInstances.get(e4), a3.collisionArrays[e4]);
            if (s4 && a3.bucketInstanceId in this.collisionCircleArrays) {
              const t4 = this.collisionCircleArrays[a3.bucketInstanceId];
              e3.ar(t4.invProjMatrix, r5), t4.viewportMatrix = this.collisionIndex.getViewportMatrix();
            }
            a3.justReloaded = false;
          }
          markUsedJustification(t3, i4, s4, a3) {
            let o3;
            o3 = a3 === e3.ah.vertical ? s4.verticalPlacedTextSymbolIndex : { left: s4.leftJustifiedTextSymbolIndex, center: s4.centerJustifiedTextSymbolIndex, right: s4.rightJustifiedTextSymbolIndex }[e3.as(i4)];
            const r5 = [s4.leftJustifiedTextSymbolIndex, s4.centerJustifiedTextSymbolIndex, s4.rightJustifiedTextSymbolIndex, s4.verticalPlacedTextSymbolIndex];
            for (const e4 of r5)
              e4 >= 0 && (t3.text.placedSymbolArray.get(e4).crossTileID = o3 >= 0 && e4 !== o3 ? 0 : s4.crossTileID);
          }
          markUsedOrientation(t3, i4, s4) {
            const a3 = i4 === e3.ah.horizontal || i4 === e3.ah.horizontalOnly ? i4 : 0, o3 = i4 === e3.ah.vertical ? i4 : 0, r5 = [s4.leftJustifiedTextSymbolIndex, s4.centerJustifiedTextSymbolIndex, s4.rightJustifiedTextSymbolIndex];
            for (const e4 of r5)
              t3.text.placedSymbolArray.get(e4).placedOrientation = a3;
            s4.verticalPlacedTextSymbolIndex && (t3.text.placedSymbolArray.get(s4.verticalPlacedTextSymbolIndex).placedOrientation = o3);
          }
          commit(t3) {
            this.commitTime = t3, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const e4 = this.prevPlacement;
            let i4 = false;
            this.prevZoomAdjustment = e4 ? e4.zoomAdjustment(this.transform.zoom) : 0;
            const s4 = e4 ? e4.symbolFadeChange(t3) : 1, a3 = e4 ? e4.opacities : {}, o3 = e4 ? e4.variableOffsets : {}, r5 = e4 ? e4.placedOrientations : {};
            for (const t4 in this.placements) {
              const e5 = this.placements[t4], o4 = a3[t4];
              o4 ? (this.opacities[t4] = new Ft(o4, s4, e5.text, e5.icon), i4 = i4 || e5.text !== o4.text.placed || e5.icon !== o4.icon.placed) : (this.opacities[t4] = new Ft(null, s4, e5.text, e5.icon, e5.skipFade), i4 = i4 || e5.text || e5.icon);
            }
            for (const t4 in a3) {
              const e5 = a3[t4];
              if (!this.opacities[t4]) {
                const a4 = new Ft(e5, s4, false, false);
                a4.isHidden() || (this.opacities[t4] = a4, i4 = i4 || e5.text.placed || e5.icon.placed);
              }
            }
            for (const t4 in o3)
              this.variableOffsets[t4] || !this.opacities[t4] || this.opacities[t4].isHidden() || (this.variableOffsets[t4] = o3[t4]);
            for (const t4 in r5)
              this.placedOrientations[t4] || !this.opacities[t4] || this.opacities[t4].isHidden() || (this.placedOrientations[t4] = r5[t4]);
            if (e4 && void 0 === e4.lastPlacementChangeTime)
              throw new Error("Last placement time for previous placement is not defined");
            i4 ? this.lastPlacementChangeTime = t3 : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = e4 ? e4.lastPlacementChangeTime : t3);
          }
          updateLayerOpacities(t3, e4) {
            const i4 = {};
            for (const s4 of e4) {
              const e5 = s4.getBucket(t3);
              e5 && s4.latestFeatureIndex && t3.id === e5.layerIds[0] && this.updateBucketOpacities(e5, i4, s4.collisionBoxArray);
            }
          }
          updateBucketOpacities(t3, i4, s4) {
            t3.hasTextData() && (t3.text.opacityVertexArray.clear(), t3.text.hasVisibleVertices = false), t3.hasIconData() && (t3.icon.opacityVertexArray.clear(), t3.icon.hasVisibleVertices = false), t3.hasIconCollisionBoxData() && t3.iconCollisionBox.collisionVertexArray.clear(), t3.hasTextCollisionBoxData() && t3.textCollisionBox.collisionVertexArray.clear();
            const a3 = t3.layers[0], o3 = a3.layout, r5 = new Ft(null, 0, false, false, true), n3 = o3.get("text-allow-overlap"), l4 = o3.get("icon-allow-overlap"), h2 = a3._unevaluatedLayout.hasValue("text-variable-anchor") || a3._unevaluatedLayout.hasValue("text-variable-anchor-offset"), c3 = "map" === o3.get("text-rotation-alignment"), u3 = "map" === o3.get("text-pitch-alignment"), d2 = "none" !== o3.get("icon-text-fit"), _2 = new Ft(null, 0, n3 && (l4 || !t3.hasIconData() || o3.get("icon-optional")), l4 && (n3 || !t3.hasTextData() || o3.get("text-optional")), true);
            !t3.collisionArrays && s4 && (t3.hasIconCollisionBoxData() || t3.hasTextCollisionBoxData()) && t3.deserializeCollisionBoxes(s4);
            const p4 = (t4, e4, i5) => {
              for (let s5 = 0; s5 < e4 / 4; s5++)
                t4.opacityVertexArray.emplaceBack(i5);
              t4.hasVisibleVertices = t4.hasVisibleVertices || i5 !== Qt;
            };
            for (let s5 = 0; s5 < t3.symbolInstances.length; s5++) {
              const a4 = t3.symbolInstances.get(s5), { numHorizontalGlyphVertices: o4, numVerticalGlyphVertices: n4, crossTileID: l5 } = a4;
              let m2 = this.opacities[l5];
              i4[l5] ? m2 = r5 : m2 || (m2 = _2, this.opacities[l5] = m2), i4[l5] = true;
              const f2 = a4.numIconVertices > 0, g3 = this.placedOrientations[a4.crossTileID], v4 = g3 === e3.ah.vertical, x5 = g3 === e3.ah.horizontal || g3 === e3.ah.horizontalOnly;
              if (o4 > 0 || n4 > 0) {
                const e4 = Jt(m2.text);
                p4(t3.text, o4, v4 ? Qt : e4), p4(t3.text, n4, x5 ? Qt : e4);
                const i5 = m2.text.isHidden();
                [a4.rightJustifiedTextSymbolIndex, a4.centerJustifiedTextSymbolIndex, a4.leftJustifiedTextSymbolIndex].forEach((e5) => {
                  e5 >= 0 && (t3.text.placedSymbolArray.get(e5).hidden = i5 || v4 ? 1 : 0);
                }), a4.verticalPlacedTextSymbolIndex >= 0 && (t3.text.placedSymbolArray.get(a4.verticalPlacedTextSymbolIndex).hidden = i5 || x5 ? 1 : 0);
                const s6 = this.variableOffsets[a4.crossTileID];
                s6 && this.markUsedJustification(t3, s6.anchor, a4, g3);
                const r6 = this.placedOrientations[a4.crossTileID];
                r6 && (this.markUsedJustification(t3, "left", a4, r6), this.markUsedOrientation(t3, r6, a4));
              }
              if (f2) {
                const e4 = Jt(m2.icon), i5 = !(d2 && a4.verticalPlacedIconSymbolIndex && v4);
                a4.placedIconSymbolIndex >= 0 && (p4(t3.icon, a4.numIconVertices, i5 ? e4 : Qt), t3.icon.placedSymbolArray.get(a4.placedIconSymbolIndex).hidden = m2.icon.isHidden()), a4.verticalPlacedIconSymbolIndex >= 0 && (p4(t3.icon, a4.numVerticalIconVertices, i5 ? Qt : e4), t3.icon.placedSymbolArray.get(a4.verticalPlacedIconSymbolIndex).hidden = m2.icon.isHidden());
              }
              if (t3.hasIconCollisionBoxData() || t3.hasTextCollisionBoxData()) {
                const i5 = t3.collisionArrays[s5];
                if (i5) {
                  let s6 = new e3.P(0, 0);
                  if (i5.textBox || i5.verticalTextBox) {
                    let e4 = true;
                    if (h2) {
                      const t4 = this.variableOffsets[l5];
                      t4 ? (s6 = Zt(t4.anchor, t4.width, t4.height, t4.textOffset, t4.textBoxScale), c3 && s6._rotate(u3 ? this.transform.angle : -this.transform.angle)) : e4 = false;
                    }
                    i5.textBox && qt(t3.textCollisionBox.collisionVertexArray, m2.text.placed, !e4 || v4, s6.x, s6.y), i5.verticalTextBox && qt(t3.textCollisionBox.collisionVertexArray, m2.text.placed, !e4 || x5, s6.x, s6.y);
                  }
                  const a5 = Boolean(!x5 && i5.verticalIconBox);
                  i5.iconBox && qt(t3.iconCollisionBox.collisionVertexArray, m2.icon.placed, a5, d2 ? s6.x : 0, d2 ? s6.y : 0), i5.verticalIconBox && qt(t3.iconCollisionBox.collisionVertexArray, m2.icon.placed, !a5, d2 ? s6.x : 0, d2 ? s6.y : 0);
                }
              }
            }
            if (t3.sortFeatures(this.transform.angle), this.retainedQueryData[t3.bucketInstanceId] && (this.retainedQueryData[t3.bucketInstanceId].featureSortOrder = t3.featureSortOrder), t3.hasTextData() && t3.text.opacityVertexBuffer && t3.text.opacityVertexBuffer.updateData(t3.text.opacityVertexArray), t3.hasIconData() && t3.icon.opacityVertexBuffer && t3.icon.opacityVertexBuffer.updateData(t3.icon.opacityVertexArray), t3.hasIconCollisionBoxData() && t3.iconCollisionBox.collisionVertexBuffer && t3.iconCollisionBox.collisionVertexBuffer.updateData(t3.iconCollisionBox.collisionVertexArray), t3.hasTextCollisionBoxData() && t3.textCollisionBox.collisionVertexBuffer && t3.textCollisionBox.collisionVertexBuffer.updateData(t3.textCollisionBox.collisionVertexArray), t3.text.opacityVertexArray.length !== t3.text.layoutVertexArray.length / 4)
              throw new Error(`bucket.text.opacityVertexArray.length (= ${t3.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${t3.text.layoutVertexArray.length}) / 4`);
            if (t3.icon.opacityVertexArray.length !== t3.icon.layoutVertexArray.length / 4)
              throw new Error(`bucket.icon.opacityVertexArray.length (= ${t3.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${t3.icon.layoutVertexArray.length}) / 4`);
            if (t3.bucketInstanceId in this.collisionCircleArrays) {
              const e4 = this.collisionCircleArrays[t3.bucketInstanceId];
              t3.placementInvProjMatrix = e4.invProjMatrix, t3.placementViewportMatrix = e4.viewportMatrix, t3.collisionCircleArray = e4.circles, delete this.collisionCircleArrays[t3.bucketInstanceId];
            }
          }
          symbolFadeChange(t3) {
            return 0 === this.fadeDuration ? 1 : (t3 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
          }
          zoomAdjustment(t3) {
            return Math.max(0, (this.transform.zoom - t3) / 1.5);
          }
          hasTransitions(t3) {
            return this.stale || t3 - this.lastPlacementChangeTime < this.fadeDuration;
          }
          stillRecent(t3, e4) {
            const i4 = this.zoomAtLastRecencyCheck === e4 ? 1 - this.zoomAdjustment(e4) : 1;
            return this.zoomAtLastRecencyCheck = e4, this.commitTime + this.fadeDuration * i4 > t3;
          }
          setStale() {
            this.stale = true;
          }
        }
        function qt(t3, e4, i4, s4, a3) {
          t3.emplaceBack(e4 ? 1 : 0, i4 ? 1 : 0, s4 || 0, a3 || 0), t3.emplaceBack(e4 ? 1 : 0, i4 ? 1 : 0, s4 || 0, a3 || 0), t3.emplaceBack(e4 ? 1 : 0, i4 ? 1 : 0, s4 || 0, a3 || 0), t3.emplaceBack(e4 ? 1 : 0, i4 ? 1 : 0, s4 || 0, a3 || 0);
        }
        const Vt = Math.pow(2, 25), Wt = Math.pow(2, 24), Ht = Math.pow(2, 17), $t = Math.pow(2, 16), Xt = Math.pow(2, 9), Kt = Math.pow(2, 8), Yt = Math.pow(2, 1);
        function Jt(t3) {
          if (0 === t3.opacity && !t3.placed)
            return 0;
          if (1 === t3.opacity && t3.placed)
            return 4294967295;
          const e4 = t3.placed ? 1 : 0, i4 = Math.floor(127 * t3.opacity);
          return i4 * Vt + e4 * Wt + i4 * Ht + e4 * $t + i4 * Xt + e4 * Kt + i4 * Yt + e4;
        }
        const Qt = 0;
        class te2 {
          constructor(t3) {
            this._sortAcrossTiles = "viewport-y" !== t3.layout.get("symbol-z-order") && !t3.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
          }
          continuePlacement(t3, e4, i4, s4, a3) {
            const o3 = this._bucketParts;
            for (; this._currentTileIndex < t3.length; )
              if (e4.getBucketParts(o3, s4, t3[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, a3())
                return true;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = false, o3.sort((t4, e5) => t4.sortKey - e5.sortKey)); this._currentPartIndex < o3.length; )
              if (e4.placeLayerBucketPart(o3[this._currentPartIndex], this._seenCrossTileIDs, i4), this._currentPartIndex++, a3())
                return true;
            return false;
          }
        }
        class ee2 {
          constructor(t3, e4, i4, s4, a3, o3, r5, n3) {
            this.placement = new jt(t3, e4, o3, r5, n3), this._currentPlacementIndex = i4.length - 1, this._forceFullPlacement = s4, this._showCollisionBoxes = a3, this._done = false;
          }
          isDone() {
            return this._done;
          }
          continuePlacement(t3, e4, i4) {
            const s4 = o2.now(), a3 = () => !this._forceFullPlacement && o2.now() - s4 > 2;
            for (; this._currentPlacementIndex >= 0; ) {
              const s5 = e4[t3[this._currentPlacementIndex]], o3 = this.placement.collisionIndex.transform.zoom;
              if ("symbol" === s5.type && (!s5.minzoom || s5.minzoom <= o3) && (!s5.maxzoom || s5.maxzoom > o3)) {
                if (this._inProgressLayer || (this._inProgressLayer = new te2(s5)), this._inProgressLayer.continuePlacement(i4[s5.source], this.placement, this._showCollisionBoxes, s5, a3))
                  return;
                delete this._inProgressLayer;
              }
              this._currentPlacementIndex--;
            }
            this._done = true;
          }
          commit(t3) {
            return this.placement.commit(t3), this.placement;
          }
        }
        const ie3 = 512 / e3.W / 2;
        class se2 {
          constructor(t3, i4, s4) {
            this.tileID = t3, this.bucketInstanceId = s4, this._symbolsByKey = {};
            const a3 = /* @__PURE__ */ new Map();
            for (let t4 = 0; t4 < i4.length; t4++) {
              const e4 = i4.get(t4), s5 = e4.key, o3 = a3.get(s5);
              o3 ? o3.push(e4) : a3.set(s5, [e4]);
            }
            for (const [t4, i5] of a3) {
              const s5 = { positions: i5.map((t5) => ({ x: Math.floor(t5.anchorX * ie3), y: Math.floor(t5.anchorY * ie3) })), crossTileIDs: i5.map((t5) => t5.crossTileID) };
              if (s5.positions.length > 128) {
                const t5 = new e3.au(s5.positions.length, 16, Uint16Array);
                for (const { x: e4, y: i6 } of s5.positions)
                  t5.add(e4, i6);
                t5.finish(), delete s5.positions, s5.index = t5;
              }
              this._symbolsByKey[t4] = s5;
            }
          }
          getScaledCoordinates(t3, i4) {
            const { x: s4, y: a3, z: o3 } = this.tileID.canonical, { x: r5, y: n3, z: l4 } = i4.canonical, h2 = ie3 / Math.pow(2, l4 - o3), c3 = (n3 * e3.W + t3.anchorY) * h2, u3 = a3 * e3.W * ie3;
            return { x: Math.floor((r5 * e3.W + t3.anchorX) * h2 - s4 * e3.W * ie3), y: Math.floor(c3 - u3) };
          }
          findMatches(t3, e4, i4) {
            const s4 = this.tileID.canonical.z < e4.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - e4.canonical.z);
            for (let a3 = 0; a3 < t3.length; a3++) {
              const o3 = t3.get(a3);
              if (o3.crossTileID)
                continue;
              const r5 = this._symbolsByKey[o3.key];
              if (!r5)
                continue;
              const n3 = this.getScaledCoordinates(o3, e4);
              if (r5.index) {
                const t4 = r5.index.range(n3.x - s4, n3.y - s4, n3.x + s4, n3.y + s4).sort();
                for (const e5 of t4) {
                  const t5 = r5.crossTileIDs[e5];
                  if (!i4[t5]) {
                    i4[t5] = true, o3.crossTileID = t5;
                    break;
                  }
                }
              } else if (r5.positions)
                for (let t4 = 0; t4 < r5.positions.length; t4++) {
                  const e5 = r5.positions[t4], a4 = r5.crossTileIDs[t4];
                  if (Math.abs(e5.x - n3.x) <= s4 && Math.abs(e5.y - n3.y) <= s4 && !i4[a4]) {
                    i4[a4] = true, o3.crossTileID = a4;
                    break;
                  }
                }
            }
          }
          getCrossTileIDsLists() {
            return Object.values(this._symbolsByKey).map(({ crossTileIDs: t3 }) => t3);
          }
        }
        class ae3 {
          constructor() {
            this.maxCrossTileID = 0;
          }
          generate() {
            return ++this.maxCrossTileID;
          }
        }
        class oe2 {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
          }
          handleWrapJump(t3) {
            const e4 = Math.round((t3 - this.lng) / 360);
            if (0 !== e4)
              for (const t4 in this.indexes) {
                const i4 = this.indexes[t4], s4 = {};
                for (const t5 in i4) {
                  const a3 = i4[t5];
                  a3.tileID = a3.tileID.unwrapTo(a3.tileID.wrap + e4), s4[a3.tileID.key] = a3;
                }
                this.indexes[t4] = s4;
              }
            this.lng = t3;
          }
          addBucket(t3, e4, i4) {
            if (this.indexes[t3.overscaledZ] && this.indexes[t3.overscaledZ][t3.key]) {
              if (this.indexes[t3.overscaledZ][t3.key].bucketInstanceId === e4.bucketInstanceId)
                return false;
              this.removeBucketCrossTileIDs(t3.overscaledZ, this.indexes[t3.overscaledZ][t3.key]);
            }
            for (let t4 = 0; t4 < e4.symbolInstances.length; t4++)
              e4.symbolInstances.get(t4).crossTileID = 0;
            this.usedCrossTileIDs[t3.overscaledZ] || (this.usedCrossTileIDs[t3.overscaledZ] = {});
            const s4 = this.usedCrossTileIDs[t3.overscaledZ];
            for (const i5 in this.indexes) {
              const a3 = this.indexes[i5];
              if (Number(i5) > t3.overscaledZ)
                for (const i6 in a3) {
                  const o3 = a3[i6];
                  o3.tileID.isChildOf(t3) && o3.findMatches(e4.symbolInstances, t3, s4);
                }
              else {
                const o3 = a3[t3.scaledTo(Number(i5)).key];
                o3 && o3.findMatches(e4.symbolInstances, t3, s4);
              }
            }
            for (let t4 = 0; t4 < e4.symbolInstances.length; t4++) {
              const a3 = e4.symbolInstances.get(t4);
              a3.crossTileID || (a3.crossTileID = i4.generate(), s4[a3.crossTileID] = true);
            }
            return void 0 === this.indexes[t3.overscaledZ] && (this.indexes[t3.overscaledZ] = {}), this.indexes[t3.overscaledZ][t3.key] = new se2(t3, e4.symbolInstances, e4.bucketInstanceId), true;
          }
          removeBucketCrossTileIDs(t3, e4) {
            for (const i4 of e4.getCrossTileIDsLists())
              for (const e5 of i4)
                delete this.usedCrossTileIDs[t3][e5];
          }
          removeStaleBuckets(t3) {
            let e4 = false;
            for (const i4 in this.indexes) {
              const s4 = this.indexes[i4];
              for (const a3 in s4)
                t3[s4[a3].bucketInstanceId] || (this.removeBucketCrossTileIDs(i4, s4[a3]), delete s4[a3], e4 = true);
            }
            return e4;
          }
        }
        class re2 {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new ae3(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
          }
          addLayer(t3, e4, i4) {
            let s4 = this.layerIndexes[t3.id];
            void 0 === s4 && (s4 = this.layerIndexes[t3.id] = new oe2());
            let a3 = false;
            const o3 = {};
            s4.handleWrapJump(i4);
            for (const i5 of e4) {
              const e5 = i5.getBucket(t3);
              e5 && t3.id === e5.layerIds[0] && (e5.bucketInstanceId || (e5.bucketInstanceId = ++this.maxBucketInstanceId), s4.addBucket(i5.tileID, e5, this.crossTileIDs) && (a3 = true), o3[e5.bucketInstanceId] = true);
            }
            return s4.removeStaleBuckets(o3) && (a3 = true), a3;
          }
          pruneUnusedLayers(t3) {
            const e4 = {};
            t3.forEach((t4) => {
              e4[t4] = true;
            });
            for (const t4 in this.layerIndexes)
              e4[t4] || delete this.layerIndexes[t4];
          }
        }
        const ne = (t3, i4) => e3.t(t3, i4 && i4.filter((t4) => "source.canvas" !== t4.identifier)), le2 = e3.av();
        class he2 extends e3.E {
          constructor(t3, i4 = {}) {
            super(), this._rtlTextPluginStateChange = () => {
              for (const t4 in this.sourceCaches) {
                const e4 = this.sourceCaches[t4].getSource().type;
                "vector" !== e4 && "geojson" !== e4 || this.sourceCaches[t4].reload();
              }
            }, this.map = t3, this.dispatcher = new N3(O2(), t3._getMapId()), this.dispatcher.registerMessageHandler("getGlyphs", (t4, e4) => this.getGlyphs(t4, e4)), this.dispatcher.registerMessageHandler("getImages", (t4, e4) => this.getImages(t4, e4)), this.imageManager = new I2(), this.imageManager.setEventedParent(this), this.glyphManager = new P2(t3._requestManager, i4.localIdeographFontFamily), this.lineAtlas = new A2(256, 512), this.crossTileSymbolIndex = new re2(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new e3.aw(), this._loaded = false, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("setReferrer", e3.ax()), ot().on("pluginStateChange", this._rtlTextPluginStateChange), this.on("data", (t4) => {
              if ("source" !== t4.dataType || "metadata" !== t4.sourceDataType)
                return;
              const e4 = this.sourceCaches[t4.sourceId];
              if (!e4)
                return;
              const i5 = e4.getSource();
              if (i5 && i5.vectorLayerIds)
                for (const t5 in this._layers) {
                  const e5 = this._layers[t5];
                  e5.source === i5.id && this._validateLayer(e5);
                }
            });
          }
          loadURL(t3, i4 = {}, s4) {
            this.fire(new e3.k("dataloading", { dataType: "style" })), i4.validate = "boolean" != typeof i4.validate || i4.validate;
            const a3 = this.map._requestManager.transformRequest(t3, p3.Style);
            this._loadStyleRequest = new AbortController(), e3.h(a3, this._loadStyleRequest).then((t4) => {
              this._loadStyleRequest = null, this._load(t4.data, i4, s4);
            }).catch((t4) => {
              this._loadStyleRequest = null, t4 && this.fire(new e3.j(t4));
            });
          }
          loadJSON(t3, i4 = {}, s4) {
            this.fire(new e3.k("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), o2.frameAsync(this._frameRequest).then(() => {
              this._frameRequest = null, i4.validate = false !== i4.validate, this._load(t3, i4, s4);
            }).catch(() => {
            });
          }
          loadEmpty() {
            this.fire(new e3.k("dataloading", { dataType: "style" })), this._load(le2, { validate: false });
          }
          _load(t3, i4, s4) {
            var a3;
            const o3 = i4.transformStyle ? i4.transformStyle(s4, t3) : t3;
            if (!i4.validate || !ne(this, e3.x(o3))) {
              this._loaded = true, this.stylesheet = o3;
              for (const t4 in o3.sources)
                this.addSource(t4, o3.sources[t4], { validate: false });
              o3.sprite ? this._loadSprite(o3.sprite) : this.imageManager.setLoaded(true), this.glyphManager.setURL(o3.glyphs), this._createLayers(), this.light = new M2(this.stylesheet.light), this.map.setTerrain(null !== (a3 = this.stylesheet.terrain) && void 0 !== a3 ? a3 : null), this.fire(new e3.k("data", { dataType: "style" })), this.fire(new e3.k("style.load"));
            }
          }
          _createLayers() {
            const t3 = e3.ay(this.stylesheet.layers);
            this.dispatcher.broadcast("setLayers", t3), this._order = t3.map((t4) => t4.id), this._layers = {}, this._serializedLayers = null;
            for (const i4 of t3) {
              const t4 = e3.az(i4);
              t4.setEventedParent(this, { layer: { id: i4.id } }), this._layers[i4.id] = t4;
            }
          }
          _loadSprite(t3, i4 = false, s4 = void 0) {
            let a3;
            this.imageManager.setLoaded(false), this._spriteRequest = new AbortController(), function(t4, i5, s5, a4) {
              return e3._(this, void 0, void 0, function* () {
                const r5 = b2(t4), n3 = s5 > 1 ? "@2x" : "", l4 = {}, h2 = {};
                for (const { id: t5, url: s6 } of r5) {
                  const o3 = i5.transformRequest(i5.normalizeSpriteURL(s6, n3, ".json"), p3.SpriteJSON);
                  l4[t5] = e3.h(o3, a4);
                  const r6 = i5.transformRequest(i5.normalizeSpriteURL(s6, n3, ".png"), p3.SpriteImage);
                  h2[t5] = _.getImage(r6, a4);
                }
                return yield Promise.all([...Object.values(l4), ...Object.values(h2)]), function(t5, i6) {
                  return e3._(this, void 0, void 0, function* () {
                    const e4 = {};
                    for (const s6 in t5) {
                      e4[s6] = {};
                      const a5 = o2.getImageCanvasContext((yield i6[s6]).data), r6 = (yield t5[s6]).data;
                      for (const t6 in r6) {
                        const { width: i7, height: o3, x: n4, y: l5, sdf: h3, pixelRatio: c3, stretchX: u3, stretchY: d2, content: _2 } = r6[t6];
                        e4[s6][t6] = { data: null, pixelRatio: c3, sdf: h3, stretchX: u3, stretchY: d2, content: _2, spriteData: { width: i7, height: o3, x: n4, y: l5, context: a5 } };
                      }
                    }
                    return e4;
                  });
                }(l4, h2);
              });
            }(t3, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then((t4) => {
              if (this._spriteRequest = null, t4)
                for (const e4 in t4) {
                  this._spritesImagesIds[e4] = [];
                  const s5 = this._spritesImagesIds[e4] ? this._spritesImagesIds[e4].filter((e5) => !(e5 in t4)) : [];
                  for (const t5 of s5)
                    this.imageManager.removeImage(t5), this._changedImages[t5] = true;
                  for (const s6 in t4[e4]) {
                    const a4 = "default" === e4 ? s6 : `${e4}:${s6}`;
                    this._spritesImagesIds[e4].push(a4), a4 in this.imageManager.images ? this.imageManager.updateImage(a4, t4[e4][s6], false) : this.imageManager.addImage(a4, t4[e4][s6]), i4 && (this._changedImages[a4] = true);
                  }
                }
            }).catch((t4) => {
              this._spriteRequest = null, a3 = t4, this.fire(new e3.j(a3));
            }).finally(() => {
              this.imageManager.setLoaded(true), this._availableImages = this.imageManager.listImages(), i4 && (this._changed = true), this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new e3.k("data", { dataType: "style" })), s4 && s4(a3);
            });
          }
          _unloadSprite() {
            for (const t3 of Object.values(this._spritesImagesIds).flat())
              this.imageManager.removeImage(t3), this._changedImages[t3] = true;
            this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new e3.k("data", { dataType: "style" }));
          }
          _validateLayer(t3) {
            const i4 = this.sourceCaches[t3.source];
            if (!i4)
              return;
            const s4 = t3.sourceLayer;
            if (!s4)
              return;
            const a3 = i4.getSource();
            ("geojson" === a3.type || a3.vectorLayerIds && -1 === a3.vectorLayerIds.indexOf(s4)) && this.fire(new e3.j(new Error(`Source layer "${s4}" does not exist on source "${a3.id}" as specified by style layer "${t3.id}".`)));
          }
          loaded() {
            if (!this._loaded)
              return false;
            if (Object.keys(this._updatedSources).length)
              return false;
            for (const t3 in this.sourceCaches)
              if (!this.sourceCaches[t3].loaded())
                return false;
            return !!this.imageManager.isLoaded();
          }
          _serializeByIds(t3) {
            const e4 = this._serializedAllLayers();
            if (!t3 || 0 === t3.length)
              return Object.values(e4);
            const i4 = [];
            for (const s4 of t3)
              e4[s4] && i4.push(e4[s4]);
            return i4;
          }
          _serializedAllLayers() {
            let t3 = this._serializedLayers;
            if (t3)
              return t3;
            t3 = this._serializedLayers = {};
            const e4 = Object.keys(this._layers);
            for (const i4 of e4) {
              const e5 = this._layers[i4];
              "custom" !== e5.type && (t3[i4] = e5.serialize());
            }
            return t3;
          }
          hasTransitions() {
            if (this.light && this.light.hasTransition())
              return true;
            for (const t3 in this.sourceCaches)
              if (this.sourceCaches[t3].hasTransition())
                return true;
            for (const t3 in this._layers)
              if (this._layers[t3].hasTransition())
                return true;
            return false;
          }
          _checkLoaded() {
            if (!this._loaded)
              throw new Error("Style is not done loading.");
          }
          update(t3) {
            if (!this._loaded)
              return;
            const i4 = this._changed;
            if (this._changed) {
              const e4 = Object.keys(this._updatedLayers), i5 = Object.keys(this._removedLayers);
              (e4.length || i5.length) && this._updateWorkerLayers(e4, i5);
              for (const t4 in this._updatedSources) {
                const e5 = this._updatedSources[t4];
                if ("reload" === e5)
                  this._reloadSource(t4);
                else {
                  if ("clear" !== e5)
                    throw new Error(`Invalid action ${e5}`);
                  this._clearSource(t4);
                }
              }
              this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
              for (const e5 in this._updatedPaintProps)
                this._layers[e5].updateTransitions(t3);
              this.light.updateTransitions(t3), this._resetUpdates();
            }
            const s4 = {};
            for (const t4 in this.sourceCaches) {
              const e4 = this.sourceCaches[t4];
              s4[t4] = e4.used, e4.used = false;
            }
            for (const e4 of this._order) {
              const i5 = this._layers[e4];
              i5.recalculate(t3, this._availableImages), !i5.isHidden(t3.zoom) && i5.source && (this.sourceCaches[i5.source].used = true);
            }
            for (const t4 in s4) {
              const i5 = this.sourceCaches[t4];
              s4[t4] !== i5.used && i5.fire(new e3.k("data", { sourceDataType: "visibility", dataType: "source", sourceId: t4 }));
            }
            this.light.recalculate(t3), this.z = t3.zoom, i4 && this.fire(new e3.k("data", { dataType: "style" }));
          }
          _updateTilesForChangedImages() {
            const t3 = Object.keys(this._changedImages);
            if (t3.length) {
              for (const e4 in this.sourceCaches)
                this.sourceCaches[e4].reloadTilesForDependencies(["icons", "patterns"], t3);
              this._changedImages = {};
            }
          }
          _updateTilesForChangedGlyphs() {
            if (this._glyphsDidChange) {
              for (const t3 in this.sourceCaches)
                this.sourceCaches[t3].reloadTilesForDependencies(["glyphs"], [""]);
              this._glyphsDidChange = false;
            }
          }
          _updateWorkerLayers(t3, e4) {
            this.dispatcher.broadcast("updateLayers", { layers: this._serializeByIds(t3), removedIds: e4 });
          }
          _resetUpdates() {
            this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = false;
          }
          setState(t3, i4 = {}) {
            var s4;
            this._checkLoaded();
            const a3 = this.serialize();
            if (t3 = i4.transformStyle ? i4.transformStyle(a3, t3) : t3, (null === (s4 = i4.validate) || void 0 === s4 || s4) && ne(this, e3.x(t3)))
              return false;
            (t3 = e3.aA(t3)).layers = e3.ay(t3.layers);
            const o3 = e3.aB(a3, t3), r5 = this._getOperationsToPerform(o3);
            if (r5.unimplemented.length > 0)
              throw new Error(`Unimplemented: ${r5.unimplemented.join(", ")}.`);
            if (0 === r5.operations.length)
              return false;
            for (const t4 of r5.operations)
              t4();
            return this.stylesheet = t3, this._serializedLayers = null, true;
          }
          _getOperationsToPerform(t3) {
            const e4 = [], i4 = [];
            for (const s4 of t3)
              switch (s4.command) {
                case "setCenter":
                case "setZoom":
                case "setBearing":
                case "setPitch":
                  continue;
                case "addLayer":
                  e4.push(() => this.addLayer.apply(this, s4.args));
                  break;
                case "removeLayer":
                  e4.push(() => this.removeLayer.apply(this, s4.args));
                  break;
                case "setPaintProperty":
                  e4.push(() => this.setPaintProperty.apply(this, s4.args));
                  break;
                case "setLayoutProperty":
                  e4.push(() => this.setLayoutProperty.apply(this, s4.args));
                  break;
                case "setFilter":
                  e4.push(() => this.setFilter.apply(this, s4.args));
                  break;
                case "addSource":
                  e4.push(() => this.addSource.apply(this, s4.args));
                  break;
                case "removeSource":
                  e4.push(() => this.removeSource.apply(this, s4.args));
                  break;
                case "setLayerZoomRange":
                  e4.push(() => this.setLayerZoomRange.apply(this, s4.args));
                  break;
                case "setLight":
                  e4.push(() => this.setLight.apply(this, s4.args));
                  break;
                case "setGeoJSONSourceData":
                  e4.push(() => this.setGeoJSONSourceData.apply(this, s4.args));
                  break;
                case "setGlyphs":
                  e4.push(() => this.setGlyphs.apply(this, s4.args));
                  break;
                case "setSprite":
                  e4.push(() => this.setSprite.apply(this, s4.args));
                  break;
                case "setTerrain":
                  e4.push(() => this.map.setTerrain.apply(this, s4.args));
                  break;
                case "setTransition":
                  e4.push(() => {
                  });
                  break;
                default:
                  i4.push(s4.command);
              }
            return { operations: e4, unimplemented: i4 };
          }
          addImage(t3, i4) {
            if (this.getImage(t3))
              return this.fire(new e3.j(new Error(`An image named "${t3}" already exists.`)));
            this.imageManager.addImage(t3, i4), this._afterImageUpdated(t3);
          }
          updateImage(t3, e4) {
            this.imageManager.updateImage(t3, e4);
          }
          getImage(t3) {
            return this.imageManager.getImage(t3);
          }
          removeImage(t3) {
            if (!this.getImage(t3))
              return this.fire(new e3.j(new Error(`An image named "${t3}" does not exist.`)));
            this.imageManager.removeImage(t3), this._afterImageUpdated(t3);
          }
          _afterImageUpdated(t3) {
            this._availableImages = this.imageManager.listImages(), this._changedImages[t3] = true, this._changed = true, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new e3.k("data", { dataType: "style" }));
          }
          listImages() {
            return this._checkLoaded(), this.imageManager.listImages();
          }
          addSource(t3, i4, s4 = {}) {
            if (this._checkLoaded(), void 0 !== this.sourceCaches[t3])
              throw new Error(`Source "${t3}" already exists.`);
            if (!i4.type)
              throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i4).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(i4.type) >= 0 && this._validate(e3.x.source, `sources.${t3}`, i4, null, s4))
              return;
            this.map && this.map._collectResourceTiming && (i4.collectResourceTiming = true);
            const a3 = this.sourceCaches[t3] = new ht(t3, i4, this.dispatcher);
            a3.style = this, a3.setEventedParent(this, () => ({ isSourceLoaded: a3.loaded(), source: a3.serialize(), sourceId: t3 })), a3.onAdd(this.map), this._changed = true;
          }
          removeSource(t3) {
            if (this._checkLoaded(), void 0 === this.sourceCaches[t3])
              throw new Error("There is no source with this ID");
            for (const i5 in this._layers)
              if (this._layers[i5].source === t3)
                return this.fire(new e3.j(new Error(`Source "${t3}" cannot be removed while layer "${i5}" is using it.`)));
            const i4 = this.sourceCaches[t3];
            delete this.sourceCaches[t3], delete this._updatedSources[t3], i4.fire(new e3.k("data", { sourceDataType: "metadata", dataType: "source", sourceId: t3 })), i4.setEventedParent(null), i4.onRemove(this.map), this._changed = true;
          }
          setGeoJSONSourceData(t3, e4) {
            if (this._checkLoaded(), void 0 === this.sourceCaches[t3])
              throw new Error(`There is no source with this ID=${t3}`);
            const i4 = this.sourceCaches[t3].getSource();
            if ("geojson" !== i4.type)
              throw new Error(`geojsonSource.type is ${i4.type}, which is !== 'geojson`);
            i4.setData(e4), this._changed = true;
          }
          getSource(t3) {
            return this.sourceCaches[t3] && this.sourceCaches[t3].getSource();
          }
          addLayer(t3, i4, s4 = {}) {
            this._checkLoaded();
            const a3 = t3.id;
            if (this.getLayer(a3))
              return void this.fire(new e3.j(new Error(`Layer "${a3}" already exists on this map.`)));
            let o3;
            if ("custom" === t3.type) {
              if (ne(this, e3.aC(t3)))
                return;
              o3 = e3.az(t3);
            } else {
              if ("source" in t3 && "object" == typeof t3.source && (this.addSource(a3, t3.source), t3 = e3.aA(t3), t3 = e3.e(t3, { source: a3 })), this._validate(e3.x.layer, `layers.${a3}`, t3, { arrayIndex: -1 }, s4))
                return;
              o3 = e3.az(t3), this._validateLayer(o3), o3.setEventedParent(this, { layer: { id: a3 } });
            }
            const r5 = i4 ? this._order.indexOf(i4) : this._order.length;
            if (i4 && -1 === r5)
              this.fire(new e3.j(new Error(`Cannot add layer "${a3}" before non-existing layer "${i4}".`)));
            else {
              if (this._order.splice(r5, 0, a3), this._layerOrderChanged = true, this._layers[a3] = o3, this._removedLayers[a3] && o3.source && "custom" !== o3.type) {
                const t4 = this._removedLayers[a3];
                delete this._removedLayers[a3], t4.type !== o3.type ? this._updatedSources[o3.source] = "clear" : (this._updatedSources[o3.source] = "reload", this.sourceCaches[o3.source].pause());
              }
              this._updateLayer(o3), o3.onAdd && o3.onAdd(this.map);
            }
          }
          moveLayer(t3, i4) {
            if (this._checkLoaded(), this._changed = true, !this._layers[t3])
              return void this.fire(new e3.j(new Error(`The layer '${t3}' does not exist in the map's style and cannot be moved.`)));
            if (t3 === i4)
              return;
            const s4 = this._order.indexOf(t3);
            this._order.splice(s4, 1);
            const a3 = i4 ? this._order.indexOf(i4) : this._order.length;
            i4 && -1 === a3 ? this.fire(new e3.j(new Error(`Cannot move layer "${t3}" before non-existing layer "${i4}".`))) : (this._order.splice(a3, 0, t3), this._layerOrderChanged = true);
          }
          removeLayer(t3) {
            this._checkLoaded();
            const i4 = this._layers[t3];
            if (!i4)
              return void this.fire(new e3.j(new Error(`Cannot remove non-existing layer "${t3}".`)));
            i4.setEventedParent(null);
            const s4 = this._order.indexOf(t3);
            this._order.splice(s4, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[t3] = i4, delete this._layers[t3], this._serializedLayers && delete this._serializedLayers[t3], delete this._updatedLayers[t3], delete this._updatedPaintProps[t3], i4.onRemove && i4.onRemove(this.map);
          }
          getLayer(t3) {
            return this._layers[t3];
          }
          getLayersOrder() {
            return [...this._order];
          }
          hasLayer(t3) {
            return t3 in this._layers;
          }
          setLayerZoomRange(t3, i4, s4) {
            this._checkLoaded();
            const a3 = this.getLayer(t3);
            a3 ? a3.minzoom === i4 && a3.maxzoom === s4 || (null != i4 && (a3.minzoom = i4), null != s4 && (a3.maxzoom = s4), this._updateLayer(a3)) : this.fire(new e3.j(new Error(`Cannot set the zoom range of non-existing layer "${t3}".`)));
          }
          setFilter(t3, i4, s4 = {}) {
            this._checkLoaded();
            const a3 = this.getLayer(t3);
            if (a3) {
              if (!e3.aD(a3.filter, i4))
                return null == i4 ? (a3.filter = void 0, void this._updateLayer(a3)) : void (this._validate(e3.x.filter, `layers.${a3.id}.filter`, i4, null, s4) || (a3.filter = e3.aA(i4), this._updateLayer(a3)));
            } else
              this.fire(new e3.j(new Error(`Cannot filter non-existing layer "${t3}".`)));
          }
          getFilter(t3) {
            return e3.aA(this.getLayer(t3).filter);
          }
          setLayoutProperty(t3, i4, s4, a3 = {}) {
            this._checkLoaded();
            const o3 = this.getLayer(t3);
            o3 ? e3.aD(o3.getLayoutProperty(i4), s4) || (o3.setLayoutProperty(i4, s4, a3), this._updateLayer(o3)) : this.fire(new e3.j(new Error(`Cannot style non-existing layer "${t3}".`)));
          }
          getLayoutProperty(t3, i4) {
            const s4 = this.getLayer(t3);
            if (s4)
              return s4.getLayoutProperty(i4);
            this.fire(new e3.j(new Error(`Cannot get style of non-existing layer "${t3}".`)));
          }
          setPaintProperty(t3, i4, s4, a3 = {}) {
            this._checkLoaded();
            const o3 = this.getLayer(t3);
            o3 ? e3.aD(o3.getPaintProperty(i4), s4) || (o3.setPaintProperty(i4, s4, a3) && this._updateLayer(o3), this._changed = true, this._updatedPaintProps[t3] = true) : this.fire(new e3.j(new Error(`Cannot style non-existing layer "${t3}".`)));
          }
          getPaintProperty(t3, e4) {
            return this.getLayer(t3).getPaintProperty(e4);
          }
          setFeatureState(t3, i4) {
            this._checkLoaded();
            const s4 = t3.source, a3 = t3.sourceLayer, o3 = this.sourceCaches[s4];
            if (void 0 === o3)
              return void this.fire(new e3.j(new Error(`The source '${s4}' does not exist in the map's style.`)));
            const r5 = o3.getSource().type;
            "geojson" === r5 && a3 ? this.fire(new e3.j(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : "vector" !== r5 || a3 ? (void 0 === t3.id && this.fire(new e3.j(new Error("The feature id parameter must be provided."))), o3.setFeatureState(a3, t3.id, i4)) : this.fire(new e3.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          removeFeatureState(t3, i4) {
            this._checkLoaded();
            const s4 = t3.source, a3 = this.sourceCaches[s4];
            if (void 0 === a3)
              return void this.fire(new e3.j(new Error(`The source '${s4}' does not exist in the map's style.`)));
            const o3 = a3.getSource().type, r5 = "vector" === o3 ? t3.sourceLayer : void 0;
            "vector" !== o3 || r5 ? i4 && "string" != typeof t3.id && "number" != typeof t3.id ? this.fire(new e3.j(new Error("A feature id is required to remove its specific state property."))) : a3.removeFeatureState(r5, t3.id, i4) : this.fire(new e3.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          getFeatureState(t3) {
            this._checkLoaded();
            const i4 = t3.source, s4 = t3.sourceLayer, a3 = this.sourceCaches[i4];
            if (void 0 !== a3)
              return "vector" !== a3.getSource().type || s4 ? (void 0 === t3.id && this.fire(new e3.j(new Error("The feature id parameter must be provided."))), a3.getFeatureState(s4, t3.id)) : void this.fire(new e3.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
            this.fire(new e3.j(new Error(`The source '${i4}' does not exist in the map's style.`)));
          }
          getTransition() {
            return e3.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
          }
          serialize() {
            if (!this._loaded)
              return;
            const t3 = e3.aE(this.sourceCaches, (t4) => t4.serialize()), i4 = this._serializeByIds(this._order), s4 = this.map.getTerrain() || void 0, a3 = this.stylesheet;
            return e3.aF({ version: a3.version, name: a3.name, metadata: a3.metadata, light: a3.light, center: a3.center, zoom: a3.zoom, bearing: a3.bearing, pitch: a3.pitch, sprite: a3.sprite, glyphs: a3.glyphs, transition: a3.transition, sources: t3, layers: i4, terrain: s4 }, (t4) => void 0 !== t4);
          }
          _updateLayer(t3) {
            this._updatedLayers[t3.id] = true, t3.source && !this._updatedSources[t3.source] && "raster" !== this.sourceCaches[t3.source].getSource().type && (this._updatedSources[t3.source] = "reload", this.sourceCaches[t3.source].pause()), this._serializedLayers = null, this._changed = true;
          }
          _flattenAndSortRenderedFeatures(t3) {
            const e4 = (t4) => "fill-extrusion" === this._layers[t4].type, i4 = {}, s4 = [];
            for (let a4 = this._order.length - 1; a4 >= 0; a4--) {
              const o3 = this._order[a4];
              if (e4(o3)) {
                i4[o3] = a4;
                for (const e5 of t3) {
                  const t4 = e5[o3];
                  if (t4)
                    for (const e6 of t4)
                      s4.push(e6);
                }
              }
            }
            s4.sort((t4, e5) => e5.intersectionZ - t4.intersectionZ);
            const a3 = [];
            for (let o3 = this._order.length - 1; o3 >= 0; o3--) {
              const r5 = this._order[o3];
              if (e4(r5))
                for (let t4 = s4.length - 1; t4 >= 0; t4--) {
                  const e5 = s4[t4].feature;
                  if (i4[e5.layer.id] < o3)
                    break;
                  a3.push(e5), s4.pop();
                }
              else
                for (const e5 of t3) {
                  const t4 = e5[r5];
                  if (t4)
                    for (const e6 of t4)
                      a3.push(e6.feature);
                }
            }
            return a3;
          }
          queryRenderedFeatures(t3, i4, s4) {
            i4 && i4.filter && this._validate(e3.x.filter, "queryRenderedFeatures.filter", i4.filter, null, i4);
            const a3 = {};
            if (i4 && i4.layers) {
              if (!Array.isArray(i4.layers))
                return this.fire(new e3.j(new Error("parameters.layers must be an Array."))), [];
              for (const t4 of i4.layers) {
                const i5 = this._layers[t4];
                if (!i5)
                  return this.fire(new e3.j(new Error(`The layer '${t4}' does not exist in the map's style and cannot be queried for features.`))), [];
                a3[i5.source] = true;
              }
            }
            const o3 = [];
            i4.availableImages = this._availableImages;
            const r5 = this._serializedAllLayers();
            for (const e4 in this.sourceCaches)
              i4.layers && !a3[e4] || o3.push(G2(this.sourceCaches[e4], this._layers, r5, t3, i4, s4));
            return this.placement && o3.push(function(t4, e4, i5, s5, a4, o4, r6) {
              const n3 = {}, l4 = o4.queryRenderedSymbols(s5), h2 = [];
              for (const t5 of Object.keys(l4).map(Number))
                h2.push(r6[t5]);
              h2.sort(j2);
              for (const i6 of h2) {
                const s6 = i6.featureIndex.lookupSymbolFeatures(l4[i6.bucketInstanceId], e4, i6.bucketIndex, i6.sourceLayerIndex, a4.filter, a4.layers, a4.availableImages, t4);
                for (const t5 in s6) {
                  const e5 = n3[t5] = n3[t5] || [], a5 = s6[t5];
                  a5.sort((t6, e6) => {
                    const s7 = i6.featureSortOrder;
                    if (s7) {
                      const i7 = s7.indexOf(t6.featureIndex);
                      return s7.indexOf(e6.featureIndex) - i7;
                    }
                    return e6.featureIndex - t6.featureIndex;
                  });
                  for (const t6 of a5)
                    e5.push(t6);
                }
              }
              for (const e5 in n3)
                n3[e5].forEach((s6) => {
                  const a5 = s6.feature, o5 = i5[t4[e5].source].getFeatureState(a5.layer["source-layer"], a5.id);
                  a5.source = a5.layer.source, a5.layer["source-layer"] && (a5.sourceLayer = a5.layer["source-layer"]), a5.state = o5;
                });
              return n3;
            }(this._layers, r5, this.sourceCaches, t3, i4, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(o3);
          }
          querySourceFeatures(t3, i4) {
            i4 && i4.filter && this._validate(e3.x.filter, "querySourceFeatures.filter", i4.filter, null, i4);
            const s4 = this.sourceCaches[t3];
            return s4 ? function(t4, e4) {
              const i5 = t4.getRenderableIds().map((e5) => t4.getTileByID(e5)), s5 = [], a3 = {};
              for (let t5 = 0; t5 < i5.length; t5++) {
                const o3 = i5[t5], r5 = o3.tileID.canonical.key;
                a3[r5] || (a3[r5] = true, o3.querySourceFeatures(s5, e4));
              }
              return s5;
            }(s4, i4) : [];
          }
          getLight() {
            return this.light.getLight();
          }
          setLight(t3, i4 = {}) {
            this._checkLoaded();
            const s4 = this.light.getLight();
            let a3 = false;
            for (const i5 in t3)
              if (!e3.aD(t3[i5], s4[i5])) {
                a3 = true;
                break;
              }
            if (!a3)
              return;
            const r5 = { now: o2.now(), transition: e3.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.light.setLight(t3, i4), this.light.updateTransitions(r5);
          }
          _validate(t3, i4, s4, a3, o3 = {}) {
            return (!o3 || false !== o3.validate) && ne(this, t3.call(e3.x, e3.e({ key: i4, style: this.serialize(), value: s4, styleSpec: e3.v }, a3)));
          }
          _remove(t3 = true) {
            this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), ot().off("pluginStateChange", this._rtlTextPluginStateChange);
            for (const t4 in this._layers)
              this._layers[t4].setEventedParent(null);
            for (const t4 in this.sourceCaches) {
              const e4 = this.sourceCaches[t4];
              e4.setEventedParent(null), e4.onRemove(this.map);
            }
            this.imageManager.setEventedParent(null), this.setEventedParent(null), t3 && this.dispatcher.broadcast("removeMap", void 0), this.dispatcher.remove(t3);
          }
          _clearSource(t3) {
            this.sourceCaches[t3].clearTiles();
          }
          _reloadSource(t3) {
            this.sourceCaches[t3].resume(), this.sourceCaches[t3].reload();
          }
          _updateSources(t3) {
            for (const e4 in this.sourceCaches)
              this.sourceCaches[e4].update(t3, this.map.terrain);
          }
          _generateCollisionBoxes() {
            for (const t3 in this.sourceCaches)
              this._reloadSource(t3);
          }
          _updatePlacement(t3, e4, i4, s4, a3 = false) {
            let r5 = false, n3 = false;
            const l4 = {};
            for (const e5 of this._order) {
              const i5 = this._layers[e5];
              if ("symbol" !== i5.type)
                continue;
              if (!l4[i5.source]) {
                const t4 = this.sourceCaches[i5.source];
                l4[i5.source] = t4.getRenderableIds(true).map((e6) => t4.getTileByID(e6)).sort((t5, e6) => e6.tileID.overscaledZ - t5.tileID.overscaledZ || (t5.tileID.isLessThan(e6.tileID) ? -1 : 1));
              }
              const s5 = this.crossTileSymbolIndex.addLayer(i5, l4[i5.source], t3.center.lng);
              r5 = r5 || s5;
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((a3 = a3 || this._layerOrderChanged || 0 === i4) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(o2.now(), t3.zoom)) && (this.pauseablePlacement = new ee2(t3, this.map.terrain, this._order, a3, e4, i4, s4, this.placement), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l4), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(o2.now()), n3 = true), r5 && this.pauseablePlacement.placement.setStale()), n3 || r5)
              for (const t4 of this._order) {
                const e5 = this._layers[t4];
                "symbol" === e5.type && this.placement.updateLayerOpacities(e5, l4[e5.source]);
              }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(o2.now());
          }
          _releaseSymbolFadeTiles() {
            for (const t3 in this.sourceCaches)
              this.sourceCaches[t3].releaseSymbolFadeTiles();
          }
          getImages(t3, i4) {
            return e3._(this, void 0, void 0, function* () {
              const t4 = yield this.imageManager.getImages(i4.icons);
              this._updateTilesForChangedImages();
              const e4 = this.sourceCaches[i4.source];
              return e4 && e4.setDependencies(i4.tileID.key, i4.type, i4.icons), t4;
            });
          }
          getGlyphs(t3, i4) {
            return e3._(this, void 0, void 0, function* () {
              const t4 = yield this.glyphManager.getGlyphs(i4.stacks), e4 = this.sourceCaches[i4.source];
              return e4 && e4.setDependencies(i4.tileID.key, i4.type, [""]), t4;
            });
          }
          getGlyphsUrl() {
            return this.stylesheet.glyphs || null;
          }
          setGlyphs(t3, i4 = {}) {
            this._checkLoaded(), t3 && this._validate(e3.x.glyphs, "glyphs", t3, null, i4) || (this._glyphsDidChange = true, this.stylesheet.glyphs = t3, this.glyphManager.entries = {}, this.glyphManager.setURL(t3));
          }
          addSprite(t3, i4, s4 = {}, a3) {
            this._checkLoaded();
            const o3 = [{ id: t3, url: i4 }], r5 = [...b2(this.stylesheet.sprite), ...o3];
            this._validate(e3.x.sprite, "sprite", r5, null, s4) || (this.stylesheet.sprite = r5, this._loadSprite(o3, true, a3));
          }
          removeSprite(t3) {
            this._checkLoaded();
            const i4 = b2(this.stylesheet.sprite);
            if (i4.find((e4) => e4.id === t3)) {
              if (this._spritesImagesIds[t3])
                for (const e4 of this._spritesImagesIds[t3])
                  this.imageManager.removeImage(e4), this._changedImages[e4] = true;
              i4.splice(i4.findIndex((e4) => e4.id === t3), 1), this.stylesheet.sprite = i4.length > 0 ? i4 : void 0, delete this._spritesImagesIds[t3], this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new e3.k("data", { dataType: "style" }));
            } else
              this.fire(new e3.j(new Error(`Sprite "${t3}" doesn't exists on this map.`)));
          }
          getSprite() {
            return b2(this.stylesheet.sprite);
          }
          setSprite(t3, i4 = {}, s4) {
            this._checkLoaded(), t3 && this._validate(e3.x.sprite, "sprite", t3, null, i4) || (this.stylesheet.sprite = t3, t3 ? this._loadSprite(t3, true, s4) : (this._unloadSprite(), s4 && s4(null)));
          }
        }
        var ce3 = e3.X([{ name: "a_pos", type: "Int16", components: 2 }]), ue2 = "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform float u_ele_delta;varying vec2 v_texture_pos;varying float v_depth;void main() {float extent=8192.0;float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/extent;gl_Position=u_matrix*vec4(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta,1.0);v_depth=gl_Position.z/gl_Position.w;}";
        const de = { prelude: _e2("#ifdef GL_ES\nprecision mediump float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\n", "#ifdef GL_ES\nprecision highp float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}\n#ifdef TERRAIN3D\nuniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;\n#endif\nconst highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {\n#ifdef TERRAIN3D\nhighp float d=unpack(texture2D(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));\n#else\nreturn 1.0;\n#endif\n}float calculate_visibility(vec4 pos) {\n#ifdef TERRAIN3D\nvec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;\n#else\nreturn 1.0;\n#endif\n}float ele(vec2 pos) {\n#ifdef TERRAIN3D\nvec4 rgb=(texture2D(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;\n#else\nreturn 0.0;\n#endif\n}float get_elevation(vec2 pos) {\n#ifdef TERRAIN3D\nvec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;\n#else\nreturn 0.0;\n#endif\n}"), background: _e2("uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), backgroundPattern: _e2("uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: _e2("varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);float ele=get_elevation(circle_center);v_visibility=calculate_visibility(u_matrix*vec4(circle_center,ele,1.0));if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,ele,1);} else {gl_Position=u_matrix*vec4(circle_center,ele,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}"), clippingMask: _e2("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: _e2("uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,0,1);gl_Position=u_matrix*pos;}"), heatmapTexture: _e2("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: _e2("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}", "attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);gl_Position=u_matrix*vec4(a_pos,get_elevation(a_pos),1.0);gl_Position.xy+=(a_extrude+a_shift)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: _e2("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: _e2("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,get_elevation(a_pos),1);}"), fill: _e2("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_FragColor=color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);}"), fillOutline: _e2("varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"), fillOutlinePattern: _e2("uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"), fillPattern: _e2("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}"), fillExtrusion: _e2("varying vec4 v_color;void main() {gl_FragColor=v_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;\n#ifdef TERRAIN3D\nattribute vec2 a_centroid;\n#endif\nvarying vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 normal=a_normal_ed.xyz;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}"), fillExtrusionPattern: _e2("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;\n#ifdef TERRAIN3D\nattribute vec2 a_centroid;\n#endif\nvarying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0\n? a_pos\n: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}"), hillshadePrepare: _e2("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: _e2("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;\n#define PI 3.141592653589793\nvoid main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"), line: _e2("uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"), lineGradient: _e2("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"), linePattern: _e2("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}"), lineSDF: _e2("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}"), raster: _e2("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"), symbolIcon: _e2("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0),z,1.0);v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}"), symbolSDF: _e2("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset),z,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}"), symbolTextAndIcon: _e2("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale),z,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}"), terrain: _e2("uniform sampler2D u_texture;varying vec2 v_texture_pos;void main() {gl_FragColor=texture2D(u_texture,v_texture_pos);}", ue2), terrainDepth: _e2("varying float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {gl_FragColor=pack(v_depth);}", ue2), terrainCoords: _e2("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;varying vec2 v_texture_pos;void main() {vec4 rgba=texture2D(u_texture,v_texture_pos);gl_FragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", ue2) };
        function _e2(t3, e4) {
          const i4 = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, s4 = e4.match(/attribute ([\w]+) ([\w]+)/g), a3 = t3.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), o3 = e4.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), r5 = o3 ? o3.concat(a3) : a3, n3 = {};
          return { fragmentSource: t3 = t3.replace(i4, (t4, e5, i5, s5, a4) => (n3[a4] = true, "define" === e5 ? `
#ifndef HAS_UNIFORM_u_${a4}
varying ${i5} ${s5} ${a4};
#else
uniform ${i5} ${s5} u_${a4};
#endif
` : `
#ifdef HAS_UNIFORM_u_${a4}
    ${i5} ${s5} ${a4} = u_${a4};
#endif
`)), vertexSource: e4 = e4.replace(i4, (t4, e5, i5, s5, a4) => {
            const o4 = "float" === s5 ? "vec2" : "vec4", r6 = a4.match(/color/) ? "color" : o4;
            return n3[a4] ? "define" === e5 ? `
#ifndef HAS_UNIFORM_u_${a4}
uniform lowp float u_${a4}_t;
attribute ${i5} ${o4} a_${a4};
varying ${i5} ${s5} ${a4};
#else
uniform ${i5} ${s5} u_${a4};
#endif
` : "vec4" === r6 ? `
#ifndef HAS_UNIFORM_u_${a4}
    ${a4} = a_${a4};
#else
    ${i5} ${s5} ${a4} = u_${a4};
#endif
` : `
#ifndef HAS_UNIFORM_u_${a4}
    ${a4} = unpack_mix_${r6}(a_${a4}, u_${a4}_t);
#else
    ${i5} ${s5} ${a4} = u_${a4};
#endif
` : "define" === e5 ? `
#ifndef HAS_UNIFORM_u_${a4}
uniform lowp float u_${a4}_t;
attribute ${i5} ${o4} a_${a4};
#else
uniform ${i5} ${s5} u_${a4};
#endif
` : "vec4" === r6 ? `
#ifndef HAS_UNIFORM_u_${a4}
    ${i5} ${s5} ${a4} = a_${a4};
#else
    ${i5} ${s5} ${a4} = u_${a4};
#endif
` : `
#ifndef HAS_UNIFORM_u_${a4}
    ${i5} ${s5} ${a4} = unpack_mix_${r6}(a_${a4}, u_${a4}_t);
#else
    ${i5} ${s5} ${a4} = u_${a4};
#endif
`;
          }), staticAttributes: s4, staticUniforms: r5 };
        }
        class pe2 {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
          }
          bind(t3, e4, i4, s4, a3, o3, r5, n3, l4) {
            this.context = t3;
            let h2 = this.boundPaintVertexBuffers.length !== s4.length;
            for (let t4 = 0; !h2 && t4 < s4.length; t4++)
              this.boundPaintVertexBuffers[t4] !== s4[t4] && (h2 = true);
            !this.vao || this.boundProgram !== e4 || this.boundLayoutVertexBuffer !== i4 || h2 || this.boundIndexBuffer !== a3 || this.boundVertexOffset !== o3 || this.boundDynamicVertexBuffer !== r5 || this.boundDynamicVertexBuffer2 !== n3 || this.boundDynamicVertexBuffer3 !== l4 ? this.freshBind(e4, i4, s4, a3, o3, r5, n3, l4) : (t3.bindVertexArray.set(this.vao), r5 && r5.bind(), a3 && a3.dynamicDraw && a3.bind(), n3 && n3.bind(), l4 && l4.bind());
          }
          freshBind(t3, e4, i4, s4, a3, o3, r5, n3) {
            const l4 = t3.numAttributes, h2 = this.context, c3 = h2.gl;
            this.vao && this.destroy(), this.vao = h2.createVertexArray(), h2.bindVertexArray.set(this.vao), this.boundProgram = t3, this.boundLayoutVertexBuffer = e4, this.boundPaintVertexBuffers = i4, this.boundIndexBuffer = s4, this.boundVertexOffset = a3, this.boundDynamicVertexBuffer = o3, this.boundDynamicVertexBuffer2 = r5, this.boundDynamicVertexBuffer3 = n3, e4.enableAttributes(c3, t3);
            for (const e5 of i4)
              e5.enableAttributes(c3, t3);
            o3 && o3.enableAttributes(c3, t3), r5 && r5.enableAttributes(c3, t3), n3 && n3.enableAttributes(c3, t3), e4.bind(), e4.setVertexAttribPointers(c3, t3, a3);
            for (const e5 of i4)
              e5.bind(), e5.setVertexAttribPointers(c3, t3, a3);
            o3 && (o3.bind(), o3.setVertexAttribPointers(c3, t3, a3)), s4 && s4.bind(), r5 && (r5.bind(), r5.setVertexAttribPointers(c3, t3, a3)), n3 && (n3.bind(), n3.setVertexAttribPointers(c3, t3, a3)), h2.currentNumAttributes = l4;
          }
          destroy() {
            this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
          }
        }
        function me2(t3) {
          const e4 = [];
          for (let i4 = 0; i4 < t3.length; i4++) {
            if (null === t3[i4])
              continue;
            const s4 = t3[i4].split(" ");
            e4.push(s4.pop());
          }
          return e4;
        }
        class fe {
          constructor(t3, i4, s4, a3, o3, r5) {
            const n3 = t3.gl;
            this.program = n3.createProgram();
            const l4 = me2(i4.staticAttributes), h2 = s4 ? s4.getBinderAttributes() : [], c3 = l4.concat(h2), u3 = de.prelude.staticUniforms ? me2(de.prelude.staticUniforms) : [], d2 = i4.staticUniforms ? me2(i4.staticUniforms) : [], _2 = s4 ? s4.getBinderUniforms() : [], p4 = u3.concat(d2).concat(_2), m2 = [];
            for (const t4 of p4)
              m2.indexOf(t4) < 0 && m2.push(t4);
            const f2 = s4 ? s4.defines() : [];
            o3 && f2.push("#define OVERDRAW_INSPECTOR;"), r5 && f2.push("#define TERRAIN3D;");
            const g3 = f2.concat(de.prelude.fragmentSource, i4.fragmentSource).join("\n"), v4 = f2.concat(de.prelude.vertexSource, i4.vertexSource).join("\n"), x5 = n3.createShader(n3.FRAGMENT_SHADER);
            if (n3.isContextLost())
              return void (this.failedToCreate = true);
            if (n3.shaderSource(x5, g3), n3.compileShader(x5), !n3.getShaderParameter(x5, n3.COMPILE_STATUS))
              throw new Error(`Could not compile fragment shader: ${n3.getShaderInfoLog(x5)}`);
            n3.attachShader(this.program, x5);
            const y4 = n3.createShader(n3.VERTEX_SHADER);
            if (n3.isContextLost())
              return void (this.failedToCreate = true);
            if (n3.shaderSource(y4, v4), n3.compileShader(y4), !n3.getShaderParameter(y4, n3.COMPILE_STATUS))
              throw new Error(`Could not compile vertex shader: ${n3.getShaderInfoLog(y4)}`);
            n3.attachShader(this.program, y4), this.attributes = {};
            const b3 = {};
            this.numAttributes = c3.length;
            for (let t4 = 0; t4 < this.numAttributes; t4++)
              c3[t4] && (n3.bindAttribLocation(this.program, t4, c3[t4]), this.attributes[c3[t4]] = t4);
            if (n3.linkProgram(this.program), !n3.getProgramParameter(this.program, n3.LINK_STATUS))
              throw new Error(`Program failed to link: ${n3.getProgramInfoLog(this.program)}`);
            n3.deleteShader(y4), n3.deleteShader(x5);
            for (let t4 = 0; t4 < m2.length; t4++) {
              const e4 = m2[t4];
              if (e4 && !b3[e4]) {
                const t5 = n3.getUniformLocation(this.program, e4);
                t5 && (b3[e4] = t5);
              }
            }
            this.fixedUniforms = a3(t3, b3), this.terrainUniforms = ((t4, i5) => ({ u_depth: new e3.aG(t4, i5.u_depth), u_terrain: new e3.aG(t4, i5.u_terrain), u_terrain_dim: new e3.aH(t4, i5.u_terrain_dim), u_terrain_matrix: new e3.aI(t4, i5.u_terrain_matrix), u_terrain_unpack: new e3.aJ(t4, i5.u_terrain_unpack), u_terrain_exaggeration: new e3.aH(t4, i5.u_terrain_exaggeration) }))(t3, b3), this.binderUniforms = s4 ? s4.getUniforms(t3, b3) : [];
          }
          draw(t3, e4, i4, s4, a3, o3, r5, n3, l4, h2, c3, u3, d2, _2, p4, m2, f2, g3) {
            const v4 = t3.gl;
            if (this.failedToCreate)
              return;
            if (t3.program.set(this.program), t3.setDepthMode(i4), t3.setStencilMode(s4), t3.setColorMode(a3), t3.setCullFace(o3), n3) {
              t3.activeTexture.set(v4.TEXTURE2), v4.bindTexture(v4.TEXTURE_2D, n3.depthTexture), t3.activeTexture.set(v4.TEXTURE3), v4.bindTexture(v4.TEXTURE_2D, n3.texture);
              for (const t4 in this.terrainUniforms)
                this.terrainUniforms[t4].set(n3[t4]);
            }
            for (const t4 in this.fixedUniforms)
              this.fixedUniforms[t4].set(r5[t4]);
            p4 && p4.setUniforms(t3, this.binderUniforms, d2, { zoom: _2 });
            let x5 = 0;
            switch (e4) {
              case v4.LINES:
                x5 = 2;
                break;
              case v4.TRIANGLES:
                x5 = 3;
                break;
              case v4.LINE_STRIP:
                x5 = 1;
            }
            for (const i5 of u3.get()) {
              const s5 = i5.vaos || (i5.vaos = {});
              (s5[l4] || (s5[l4] = new pe2())).bind(t3, this, h2, p4 ? p4.getPaintVertexBuffers() : [], c3, i5.vertexOffset, m2, f2, g3), v4.drawElements(e4, i5.primitiveLength * x5, v4.UNSIGNED_SHORT, i5.primitiveOffset * x5 * 2);
            }
          }
        }
        function ge2(t3, e4, i4) {
          const s4 = 1 / Lt(i4, 1, e4.transform.tileZoom), a3 = Math.pow(2, i4.tileID.overscaledZ), o3 = i4.tileSize * Math.pow(2, e4.transform.tileZoom) / a3, r5 = o3 * (i4.tileID.canonical.x + i4.tileID.wrap * a3), n3 = o3 * i4.tileID.canonical.y;
          return { u_image: 0, u_texsize: i4.imageAtlasTexture.size, u_scale: [s4, t3.fromScale, t3.toScale], u_fade: t3.t, u_pixel_coord_upper: [r5 >> 16, n3 >> 16], u_pixel_coord_lower: [65535 & r5, 65535 & n3] };
        }
        const ve = (t3, i4, s4, a3) => {
          const o3 = i4.style.light, r5 = o3.properties.get("position"), n3 = [r5.x, r5.y, r5.z], l4 = function() {
            var t4 = new e3.A(9);
            return e3.A != Float32Array && (t4[1] = 0, t4[2] = 0, t4[3] = 0, t4[5] = 0, t4[6] = 0, t4[7] = 0), t4[0] = 1, t4[4] = 1, t4[8] = 1, t4;
          }();
          "viewport" === o3.properties.get("anchor") && function(t4, e4) {
            var i5 = Math.sin(e4), s5 = Math.cos(e4);
            t4[0] = s5, t4[1] = i5, t4[2] = 0, t4[3] = -i5, t4[4] = s5, t4[5] = 0, t4[6] = 0, t4[7] = 0, t4[8] = 1;
          }(l4, -i4.transform.angle), function(t4, e4, i5) {
            var s5 = e4[0], a4 = e4[1], o4 = e4[2];
            t4[0] = s5 * i5[0] + a4 * i5[3] + o4 * i5[6], t4[1] = s5 * i5[1] + a4 * i5[4] + o4 * i5[7], t4[2] = s5 * i5[2] + a4 * i5[5] + o4 * i5[8];
          }(n3, n3, l4);
          const h2 = o3.properties.get("color");
          return { u_matrix: t3, u_lightpos: n3, u_lightintensity: o3.properties.get("intensity"), u_lightcolor: [h2.r, h2.g, h2.b], u_vertical_gradient: +s4, u_opacity: a3 };
        }, xe = (t3, i4, s4, a3, o3, r5, n3) => e3.e(ve(t3, i4, s4, a3), ge2(r5, i4, n3), { u_height_factor: -Math.pow(2, o3.overscaledZ) / n3.tileSize / 8 }), ye = (t3) => ({ u_matrix: t3 }), be2 = (t3, i4, s4, a3) => e3.e(ye(t3), ge2(s4, i4, a3)), we = (t3, e4) => ({ u_matrix: t3, u_world: e4 }), Te2 = (t3, i4, s4, a3, o3) => e3.e(be2(t3, i4, s4, a3), { u_world: o3 }), Ie2 = (t3, e4, i4, s4) => {
          const a3 = t3.transform;
          let o3, r5;
          if ("map" === s4.paint.get("circle-pitch-alignment")) {
            const t4 = Lt(i4, 1, a3.zoom);
            o3 = true, r5 = [t4, t4];
          } else
            o3 = false, r5 = a3.pixelsToGLUnits;
          return { u_camera_to_center_distance: a3.cameraToCenterDistance, u_scale_with_map: +("map" === s4.paint.get("circle-pitch-scale")), u_matrix: t3.translatePosMatrix(e4.posMatrix, i4, s4.paint.get("circle-translate"), s4.paint.get("circle-translate-anchor")), u_pitch_with_map: +o3, u_device_pixel_ratio: t3.pixelRatio, u_extrude_scale: r5 };
        }, Ee = (t3, e4, i4) => {
          const s4 = Lt(i4, 1, e4.zoom), a3 = Math.pow(2, e4.zoom - i4.tileID.overscaledZ), o3 = i4.tileID.overscaleFactor();
          return { u_matrix: t3, u_camera_to_center_distance: e4.cameraToCenterDistance, u_pixels_to_tile_units: s4, u_extrude_scale: [e4.pixelsToGLUnits[0] / (s4 * a3), e4.pixelsToGLUnits[1] / (s4 * a3)], u_overscale_factor: o3 };
        }, Se = (t3, e4, i4 = 1) => ({ u_matrix: t3, u_color: e4, u_overlay: 0, u_overlay_scale: i4 }), Ce = (t3) => ({ u_matrix: t3 }), Pe2 = (t3, e4, i4, s4) => ({ u_matrix: t3, u_extrude_scale: Lt(e4, 1, i4), u_intensity: s4 });
        function De(t3, i4) {
          const s4 = Math.pow(2, i4.canonical.z), a3 = i4.canonical.y;
          return [new e3.Y(0, a3 / s4).toLngLat().lat, new e3.Y(0, (a3 + 1) / s4).toLngLat().lat];
        }
        const ze = (t3, e4, i4, s4) => {
          const a3 = t3.transform;
          return { u_matrix: ke(t3, e4, i4, s4), u_ratio: 1 / Lt(e4, 1, a3.zoom), u_device_pixel_ratio: t3.pixelRatio, u_units_to_pixels: [1 / a3.pixelsToGLUnits[0], 1 / a3.pixelsToGLUnits[1]] };
        }, Me = (t3, i4, s4, a3, o3) => e3.e(ze(t3, i4, s4, o3), { u_image: 0, u_image_height: a3 }), Ae2 = (t3, e4, i4, s4, a3) => {
          const o3 = t3.transform, r5 = Le(e4, o3);
          return { u_matrix: ke(t3, e4, i4, a3), u_texsize: e4.imageAtlasTexture.size, u_ratio: 1 / Lt(e4, 1, o3.zoom), u_device_pixel_ratio: t3.pixelRatio, u_image: 0, u_scale: [r5, s4.fromScale, s4.toScale], u_fade: s4.t, u_units_to_pixels: [1 / o3.pixelsToGLUnits[0], 1 / o3.pixelsToGLUnits[1]] };
        }, Re2 = (t3, i4, s4, a3, o3, r5) => {
          const n3 = t3.lineAtlas, l4 = Le(i4, t3.transform), h2 = "round" === s4.layout.get("line-cap"), c3 = n3.getDash(a3.from, h2), u3 = n3.getDash(a3.to, h2), d2 = c3.width * o3.fromScale, _2 = u3.width * o3.toScale;
          return e3.e(ze(t3, i4, s4, r5), { u_patternscale_a: [l4 / d2, -c3.height / 2], u_patternscale_b: [l4 / _2, -u3.height / 2], u_sdfgamma: n3.width / (256 * Math.min(d2, _2) * t3.pixelRatio) / 2, u_image: 0, u_tex_y_a: c3.y, u_tex_y_b: u3.y, u_mix: o3.t });
        };
        function Le(t3, e4) {
          return 1 / Lt(t3, 1, e4.tileZoom);
        }
        function ke(t3, e4, i4, s4) {
          return t3.translatePosMatrix(s4 ? s4.posMatrix : e4.tileID.posMatrix, e4, i4.paint.get("line-translate"), i4.paint.get("line-translate-anchor"));
        }
        const Fe = (t3, e4, i4, s4, a3) => {
          return { u_matrix: t3, u_tl_parent: e4, u_scale_parent: i4, u_buffer_scale: 1, u_fade_t: s4.mix, u_opacity: s4.opacity * a3.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: a3.paint.get("raster-brightness-min"), u_brightness_high: a3.paint.get("raster-brightness-max"), u_saturation_factor: (r5 = a3.paint.get("raster-saturation"), r5 > 0 ? 1 - 1 / (1.001 - r5) : -r5), u_contrast_factor: (o3 = a3.paint.get("raster-contrast"), o3 > 0 ? 1 / (1 - o3) : 1 + o3), u_spin_weights: Be(a3.paint.get("raster-hue-rotate")) };
          var o3, r5;
        };
        function Be(t3) {
          t3 *= Math.PI / 180;
          const e4 = Math.sin(t3), i4 = Math.cos(t3);
          return [(2 * i4 + 1) / 3, (-Math.sqrt(3) * e4 - i4 + 1) / 3, (Math.sqrt(3) * e4 - i4 + 1) / 3];
        }
        const Oe = (t3, e4, i4, s4, a3, o3, r5, n3, l4, h2) => {
          const c3 = a3.transform;
          return { u_is_size_zoom_constant: +("constant" === t3 || "source" === t3), u_is_size_feature_constant: +("constant" === t3 || "camera" === t3), u_size_t: e4 ? e4.uSizeT : 0, u_size: e4 ? e4.uSize : 0, u_camera_to_center_distance: c3.cameraToCenterDistance, u_pitch: c3.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +i4, u_aspect_ratio: c3.width / c3.height, u_fade_change: a3.options.fadeDuration ? a3.symbolFadeChange : 1, u_matrix: o3, u_label_plane_matrix: r5, u_coord_matrix: n3, u_is_text: +l4, u_pitch_with_map: +s4, u_texsize: h2, u_texture: 0 };
        }, Ne = (t3, i4, s4, a3, o3, r5, n3, l4, h2, c3, u3) => {
          const d2 = o3.transform;
          return e3.e(Oe(t3, i4, s4, a3, o3, r5, n3, l4, h2, c3), { u_gamma_scale: a3 ? Math.cos(d2._pitch) * d2.cameraToCenterDistance : 1, u_device_pixel_ratio: o3.pixelRatio, u_is_halo: +u3 });
        }, Ue = (t3, i4, s4, a3, o3, r5, n3, l4, h2, c3) => e3.e(Ne(t3, i4, s4, a3, o3, r5, n3, l4, true, h2, true), { u_texsize_icon: c3, u_texture_icon: 1 }), Ze = (t3, e4, i4) => ({ u_matrix: t3, u_opacity: e4, u_color: i4 }), Ge = (t3, i4, s4, a3, o3, r5) => e3.e(function(t4, e4, i5, s5) {
          const a4 = i5.imageManager.getPattern(t4.from.toString()), o4 = i5.imageManager.getPattern(t4.to.toString()), { width: r6, height: n3 } = i5.imageManager.getPixelSize(), l4 = Math.pow(2, s5.tileID.overscaledZ), h2 = s5.tileSize * Math.pow(2, i5.transform.tileZoom) / l4, c3 = h2 * (s5.tileID.canonical.x + s5.tileID.wrap * l4), u3 = h2 * s5.tileID.canonical.y;
          return { u_image: 0, u_pattern_tl_a: a4.tl, u_pattern_br_a: a4.br, u_pattern_tl_b: o4.tl, u_pattern_br_b: o4.br, u_texsize: [r6, n3], u_mix: e4.t, u_pattern_size_a: a4.displaySize, u_pattern_size_b: o4.displaySize, u_scale_a: e4.fromScale, u_scale_b: e4.toScale, u_tile_units_to_pixels: 1 / Lt(s5, 1, i5.transform.tileZoom), u_pixel_coord_upper: [c3 >> 16, u3 >> 16], u_pixel_coord_lower: [65535 & c3, 65535 & u3] };
        }(a3, r5, s4, o3), { u_matrix: t3, u_opacity: i4 }), je = { fillExtrusion: (t3, i4) => ({ u_matrix: new e3.aI(t3, i4.u_matrix), u_lightpos: new e3.aK(t3, i4.u_lightpos), u_lightintensity: new e3.aH(t3, i4.u_lightintensity), u_lightcolor: new e3.aK(t3, i4.u_lightcolor), u_vertical_gradient: new e3.aH(t3, i4.u_vertical_gradient), u_opacity: new e3.aH(t3, i4.u_opacity) }), fillExtrusionPattern: (t3, i4) => ({ u_matrix: new e3.aI(t3, i4.u_matrix), u_lightpos: new e3.aK(t3, i4.u_lightpos), u_lightintensity: new e3.aH(t3, i4.u_lightintensity), u_lightcolor: new e3.aK(t3, i4.u_lightcolor), u_vertical_gradient: new e3.aH(t3, i4.u_vertical_gradient), u_height_factor: new e3.aH(t3, i4.u_height_factor), u_image: new e3.aG(t3, i4.u_image), u_texsize: new e3.aL(t3, i4.u_texsize), u_pixel_coord_upper: new e3.aL(t3, i4.u_pixel_coord_upper), u_pixel_coord_lower: new e3.aL(t3, i4.u_pixel_coord_lower), u_scale: new e3.aK(t3, i4.u_scale), u_fade: new e3.aH(t3, i4.u_fade), u_opacity: new e3.aH(t3, i4.u_opacity) }), fill: (t3, i4) => ({ u_matrix: new e3.aI(t3, i4.u_matrix) }), fillPattern: (t3, i4) => ({ u_matrix: new e3.aI(t3, i4.u_matrix), u_image: new e3.aG(t3, i4.u_image), u_texsize: new e3.aL(t3, i4.u_texsize), u_pixel_coord_upper: new e3.aL(t3, i4.u_pixel_coord_upper), u_pixel_coord_lower: new e3.aL(t3, i4.u_pixel_coord_lower), u_scale: new e3.aK(t3, i4.u_scale), u_fade: new e3.aH(t3, i4.u_fade) }), fillOutline: (t3, i4) => ({ u_matrix: new e3.aI(t3, i4.u_matrix), u_world: new e3.aL(t3, i4.u_world) }), fillOutlinePattern: (t3, i4) => ({ u_matrix: new e3.aI(t3, i4.u_matrix), u_world: new e3.aL(t3, i4.u_world), u_image: new e3.aG(t3, i4.u_image), u_texsize: new e3.aL(t3, i4.u_texsize), u_pixel_coord_upper: new e3.aL(t3, i4.u_pixel_coord_upper), u_pixel_coord_lower: new e3.aL(t3, i4.u_pixel_coord_lower), u_scale: new e3.aK(t3, i4.u_scale), u_fade: new e3.aH(t3, i4.u_fade) }), circle: (t3, i4) => ({ u_camera_to_center_distance: new e3.aH(t3, i4.u_camera_to_center_distance), u_scale_with_map: new e3.aG(t3, i4.u_scale_with_map), u_pitch_with_map: new e3.aG(t3, i4.u_pitch_with_map), u_extrude_scale: new e3.aL(t3, i4.u_extrude_scale), u_device_pixel_ratio: new e3.aH(t3, i4.u_device_pixel_ratio), u_matrix: new e3.aI(t3, i4.u_matrix) }), collisionBox: (t3, i4) => ({ u_matrix: new e3.aI(t3, i4.u_matrix), u_camera_to_center_distance: new e3.aH(t3, i4.u_camera_to_center_distance), u_pixels_to_tile_units: new e3.aH(t3, i4.u_pixels_to_tile_units), u_extrude_scale: new e3.aL(t3, i4.u_extrude_scale), u_overscale_factor: new e3.aH(t3, i4.u_overscale_factor) }), collisionCircle: (t3, i4) => ({ u_matrix: new e3.aI(t3, i4.u_matrix), u_inv_matrix: new e3.aI(t3, i4.u_inv_matrix), u_camera_to_center_distance: new e3.aH(t3, i4.u_camera_to_center_distance), u_viewport_size: new e3.aL(t3, i4.u_viewport_size) }), debug: (t3, i4) => ({ u_color: new e3.aM(t3, i4.u_color), u_matrix: new e3.aI(t3, i4.u_matrix), u_overlay: new e3.aG(t3, i4.u_overlay), u_overlay_scale: new e3.aH(t3, i4.u_overlay_scale) }), clippingMask: (t3, i4) => ({ u_matrix: new e3.aI(t3, i4.u_matrix) }), heatmap: (t3, i4) => ({ u_extrude_scale: new e3.aH(t3, i4.u_extrude_scale), u_intensity: new e3.aH(t3, i4.u_intensity), u_matrix: new e3.aI(t3, i4.u_matrix) }), heatmapTexture: (t3, i4) => ({ u_matrix: new e3.aI(t3, i4.u_matrix), u_world: new e3.aL(t3, i4.u_world), u_image: new e3.aG(t3, i4.u_image), u_color_ramp: new e3.aG(t3, i4.u_color_ramp), u_opacity: new e3.aH(t3, i4.u_opacity) }), hillshade: (t3, i4) => ({ u_matrix: new e3.aI(t3, i4.u_matrix), u_image: new e3.aG(t3, i4.u_image), u_latrange: new e3.aL(t3, i4.u_latrange), u_light: new e3.aL(t3, i4.u_light), u_shadow: new e3.aM(t3, i4.u_shadow), u_highlight: new e3.aM(t3, i4.u_highlight), u_accent: new e3.aM(t3, i4.u_accent) }), hillshadePrepare: (t3, i4) => ({ u_matrix: new e3.aI(t3, i4.u_matrix), u_image: new e3.aG(t3, i4.u_image), u_dimension: new e3.aL(t3, i4.u_dimension), u_zoom: new e3.aH(t3, i4.u_zoom), u_unpack: new e3.aJ(t3, i4.u_unpack) }), line: (t3, i4) => ({ u_matrix: new e3.aI(t3, i4.u_matrix), u_ratio: new e3.aH(t3, i4.u_ratio), u_device_pixel_ratio: new e3.aH(t3, i4.u_device_pixel_ratio), u_units_to_pixels: new e3.aL(t3, i4.u_units_to_pixels) }), lineGradient: (t3, i4) => ({ u_matrix: new e3.aI(t3, i4.u_matrix), u_ratio: new e3.aH(t3, i4.u_ratio), u_device_pixel_ratio: new e3.aH(t3, i4.u_device_pixel_ratio), u_units_to_pixels: new e3.aL(t3, i4.u_units_to_pixels), u_image: new e3.aG(t3, i4.u_image), u_image_height: new e3.aH(t3, i4.u_image_height) }), linePattern: (t3, i4) => ({ u_matrix: new e3.aI(t3, i4.u_matrix), u_texsize: new e3.aL(t3, i4.u_texsize), u_ratio: new e3.aH(t3, i4.u_ratio), u_device_pixel_ratio: new e3.aH(t3, i4.u_device_pixel_ratio), u_image: new e3.aG(t3, i4.u_image), u_units_to_pixels: new e3.aL(t3, i4.u_units_to_pixels), u_scale: new e3.aK(t3, i4.u_scale), u_fade: new e3.aH(t3, i4.u_fade) }), lineSDF: (t3, i4) => ({ u_matrix: new e3.aI(t3, i4.u_matrix), u_ratio: new e3.aH(t3, i4.u_ratio), u_device_pixel_ratio: new e3.aH(t3, i4.u_device_pixel_ratio), u_units_to_pixels: new e3.aL(t3, i4.u_units_to_pixels), u_patternscale_a: new e3.aL(t3, i4.u_patternscale_a), u_patternscale_b: new e3.aL(t3, i4.u_patternscale_b), u_sdfgamma: new e3.aH(t3, i4.u_sdfgamma), u_image: new e3.aG(t3, i4.u_image), u_tex_y_a: new e3.aH(t3, i4.u_tex_y_a), u_tex_y_b: new e3.aH(t3, i4.u_tex_y_b), u_mix: new e3.aH(t3, i4.u_mix) }), raster: (t3, i4) => ({ u_matrix: new e3.aI(t3, i4.u_matrix), u_tl_parent: new e3.aL(t3, i4.u_tl_parent), u_scale_parent: new e3.aH(t3, i4.u_scale_parent), u_buffer_scale: new e3.aH(t3, i4.u_buffer_scale), u_fade_t: new e3.aH(t3, i4.u_fade_t), u_opacity: new e3.aH(t3, i4.u_opacity), u_image0: new e3.aG(t3, i4.u_image0), u_image1: new e3.aG(t3, i4.u_image1), u_brightness_low: new e3.aH(t3, i4.u_brightness_low), u_brightness_high: new e3.aH(t3, i4.u_brightness_high), u_saturation_factor: new e3.aH(t3, i4.u_saturation_factor), u_contrast_factor: new e3.aH(t3, i4.u_contrast_factor), u_spin_weights: new e3.aK(t3, i4.u_spin_weights) }), symbolIcon: (t3, i4) => ({ u_is_size_zoom_constant: new e3.aG(t3, i4.u_is_size_zoom_constant), u_is_size_feature_constant: new e3.aG(t3, i4.u_is_size_feature_constant), u_size_t: new e3.aH(t3, i4.u_size_t), u_size: new e3.aH(t3, i4.u_size), u_camera_to_center_distance: new e3.aH(t3, i4.u_camera_to_center_distance), u_pitch: new e3.aH(t3, i4.u_pitch), u_rotate_symbol: new e3.aG(t3, i4.u_rotate_symbol), u_aspect_ratio: new e3.aH(t3, i4.u_aspect_ratio), u_fade_change: new e3.aH(t3, i4.u_fade_change), u_matrix: new e3.aI(t3, i4.u_matrix), u_label_plane_matrix: new e3.aI(t3, i4.u_label_plane_matrix), u_coord_matrix: new e3.aI(t3, i4.u_coord_matrix), u_is_text: new e3.aG(t3, i4.u_is_text), u_pitch_with_map: new e3.aG(t3, i4.u_pitch_with_map), u_texsize: new e3.aL(t3, i4.u_texsize), u_texture: new e3.aG(t3, i4.u_texture) }), symbolSDF: (t3, i4) => ({ u_is_size_zoom_constant: new e3.aG(t3, i4.u_is_size_zoom_constant), u_is_size_feature_constant: new e3.aG(t3, i4.u_is_size_feature_constant), u_size_t: new e3.aH(t3, i4.u_size_t), u_size: new e3.aH(t3, i4.u_size), u_camera_to_center_distance: new e3.aH(t3, i4.u_camera_to_center_distance), u_pitch: new e3.aH(t3, i4.u_pitch), u_rotate_symbol: new e3.aG(t3, i4.u_rotate_symbol), u_aspect_ratio: new e3.aH(t3, i4.u_aspect_ratio), u_fade_change: new e3.aH(t3, i4.u_fade_change), u_matrix: new e3.aI(t3, i4.u_matrix), u_label_plane_matrix: new e3.aI(t3, i4.u_label_plane_matrix), u_coord_matrix: new e3.aI(t3, i4.u_coord_matrix), u_is_text: new e3.aG(t3, i4.u_is_text), u_pitch_with_map: new e3.aG(t3, i4.u_pitch_with_map), u_texsize: new e3.aL(t3, i4.u_texsize), u_texture: new e3.aG(t3, i4.u_texture), u_gamma_scale: new e3.aH(t3, i4.u_gamma_scale), u_device_pixel_ratio: new e3.aH(t3, i4.u_device_pixel_ratio), u_is_halo: new e3.aG(t3, i4.u_is_halo) }), symbolTextAndIcon: (t3, i4) => ({ u_is_size_zoom_constant: new e3.aG(t3, i4.u_is_size_zoom_constant), u_is_size_feature_constant: new e3.aG(t3, i4.u_is_size_feature_constant), u_size_t: new e3.aH(t3, i4.u_size_t), u_size: new e3.aH(t3, i4.u_size), u_camera_to_center_distance: new e3.aH(t3, i4.u_camera_to_center_distance), u_pitch: new e3.aH(t3, i4.u_pitch), u_rotate_symbol: new e3.aG(t3, i4.u_rotate_symbol), u_aspect_ratio: new e3.aH(t3, i4.u_aspect_ratio), u_fade_change: new e3.aH(t3, i4.u_fade_change), u_matrix: new e3.aI(t3, i4.u_matrix), u_label_plane_matrix: new e3.aI(t3, i4.u_label_plane_matrix), u_coord_matrix: new e3.aI(t3, i4.u_coord_matrix), u_is_text: new e3.aG(t3, i4.u_is_text), u_pitch_with_map: new e3.aG(t3, i4.u_pitch_with_map), u_texsize: new e3.aL(t3, i4.u_texsize), u_texsize_icon: new e3.aL(t3, i4.u_texsize_icon), u_texture: new e3.aG(t3, i4.u_texture), u_texture_icon: new e3.aG(t3, i4.u_texture_icon), u_gamma_scale: new e3.aH(t3, i4.u_gamma_scale), u_device_pixel_ratio: new e3.aH(t3, i4.u_device_pixel_ratio), u_is_halo: new e3.aG(t3, i4.u_is_halo) }), background: (t3, i4) => ({ u_matrix: new e3.aI(t3, i4.u_matrix), u_opacity: new e3.aH(t3, i4.u_opacity), u_color: new e3.aM(t3, i4.u_color) }), backgroundPattern: (t3, i4) => ({ u_matrix: new e3.aI(t3, i4.u_matrix), u_opacity: new e3.aH(t3, i4.u_opacity), u_image: new e3.aG(t3, i4.u_image), u_pattern_tl_a: new e3.aL(t3, i4.u_pattern_tl_a), u_pattern_br_a: new e3.aL(t3, i4.u_pattern_br_a), u_pattern_tl_b: new e3.aL(t3, i4.u_pattern_tl_b), u_pattern_br_b: new e3.aL(t3, i4.u_pattern_br_b), u_texsize: new e3.aL(t3, i4.u_texsize), u_mix: new e3.aH(t3, i4.u_mix), u_pattern_size_a: new e3.aL(t3, i4.u_pattern_size_a), u_pattern_size_b: new e3.aL(t3, i4.u_pattern_size_b), u_scale_a: new e3.aH(t3, i4.u_scale_a), u_scale_b: new e3.aH(t3, i4.u_scale_b), u_pixel_coord_upper: new e3.aL(t3, i4.u_pixel_coord_upper), u_pixel_coord_lower: new e3.aL(t3, i4.u_pixel_coord_lower), u_tile_units_to_pixels: new e3.aH(t3, i4.u_tile_units_to_pixels) }), terrain: (t3, i4) => ({ u_matrix: new e3.aI(t3, i4.u_matrix), u_texture: new e3.aG(t3, i4.u_texture), u_ele_delta: new e3.aH(t3, i4.u_ele_delta) }), terrainDepth: (t3, i4) => ({ u_matrix: new e3.aI(t3, i4.u_matrix), u_ele_delta: new e3.aH(t3, i4.u_ele_delta) }), terrainCoords: (t3, i4) => ({ u_matrix: new e3.aI(t3, i4.u_matrix), u_texture: new e3.aG(t3, i4.u_texture), u_terrain_coords_id: new e3.aH(t3, i4.u_terrain_coords_id), u_ele_delta: new e3.aH(t3, i4.u_ele_delta) }) };
        class qe {
          constructor(t3, e4, i4) {
            this.context = t3;
            const s4 = t3.gl;
            this.buffer = s4.createBuffer(), this.dynamicDraw = Boolean(i4), this.context.unbindVAO(), t3.bindElementBuffer.set(this.buffer), s4.bufferData(s4.ELEMENT_ARRAY_BUFFER, e4.arrayBuffer, this.dynamicDraw ? s4.DYNAMIC_DRAW : s4.STATIC_DRAW), this.dynamicDraw || delete e4.arrayBuffer;
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer);
          }
          updateData(t3) {
            const e4 = this.context.gl;
            if (!this.dynamicDraw)
              throw new Error("Attempted to update data while not in dynamic mode.");
            this.context.unbindVAO(), this.bind(), e4.bufferSubData(e4.ELEMENT_ARRAY_BUFFER, 0, t3.arrayBuffer);
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        const Ve2 = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
        class We {
          constructor(t3, e4, i4, s4) {
            this.length = e4.length, this.attributes = i4, this.itemSize = e4.bytesPerElement, this.dynamicDraw = s4, this.context = t3;
            const a3 = t3.gl;
            this.buffer = a3.createBuffer(), t3.bindVertexBuffer.set(this.buffer), a3.bufferData(a3.ARRAY_BUFFER, e4.arrayBuffer, this.dynamicDraw ? a3.DYNAMIC_DRAW : a3.STATIC_DRAW), this.dynamicDraw || delete e4.arrayBuffer;
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer);
          }
          updateData(t3) {
            if (t3.length !== this.length)
              throw new Error(`Length of new data is ${t3.length}, which doesn't match current length of ${this.length}`);
            const e4 = this.context.gl;
            this.bind(), e4.bufferSubData(e4.ARRAY_BUFFER, 0, t3.arrayBuffer);
          }
          enableAttributes(t3, e4) {
            for (let i4 = 0; i4 < this.attributes.length; i4++) {
              const s4 = e4.attributes[this.attributes[i4].name];
              void 0 !== s4 && t3.enableVertexAttribArray(s4);
            }
          }
          setVertexAttribPointers(t3, e4, i4) {
            for (let s4 = 0; s4 < this.attributes.length; s4++) {
              const a3 = this.attributes[s4], o3 = e4.attributes[a3.name];
              void 0 !== o3 && t3.vertexAttribPointer(o3, a3.components, t3[Ve2[a3.type]], false, this.itemSize, a3.offset + this.itemSize * (i4 || 0));
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        const He = /* @__PURE__ */ new WeakMap();
        function $e(t3) {
          var e4;
          if (He.has(t3))
            return He.get(t3);
          {
            const i4 = null === (e4 = t3.getParameter(t3.VERSION)) || void 0 === e4 ? void 0 : e4.startsWith("WebGL 2.0");
            return He.set(t3, i4), i4;
          }
        }
        class Xe {
          constructor(t3) {
            this.gl = t3.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
          }
          get() {
            return this.current;
          }
          set(t3) {
          }
          getDefault() {
            return this.default;
          }
          setDefault() {
            this.set(this.default);
          }
        }
        class Ke extends Xe {
          getDefault() {
            return e3.aO.transparent;
          }
          set(t3) {
            const e4 = this.current;
            (t3.r !== e4.r || t3.g !== e4.g || t3.b !== e4.b || t3.a !== e4.a || this.dirty) && (this.gl.clearColor(t3.r, t3.g, t3.b, t3.a), this.current = t3, this.dirty = false);
          }
        }
        class Ye extends Xe {
          getDefault() {
            return 1;
          }
          set(t3) {
            (t3 !== this.current || this.dirty) && (this.gl.clearDepth(t3), this.current = t3, this.dirty = false);
          }
        }
        class Je extends Xe {
          getDefault() {
            return 0;
          }
          set(t3) {
            (t3 !== this.current || this.dirty) && (this.gl.clearStencil(t3), this.current = t3, this.dirty = false);
          }
        }
        class Qe extends Xe {
          getDefault() {
            return [true, true, true, true];
          }
          set(t3) {
            const e4 = this.current;
            (t3[0] !== e4[0] || t3[1] !== e4[1] || t3[2] !== e4[2] || t3[3] !== e4[3] || this.dirty) && (this.gl.colorMask(t3[0], t3[1], t3[2], t3[3]), this.current = t3, this.dirty = false);
          }
        }
        class ti extends Xe {
          getDefault() {
            return true;
          }
          set(t3) {
            (t3 !== this.current || this.dirty) && (this.gl.depthMask(t3), this.current = t3, this.dirty = false);
          }
        }
        class ei extends Xe {
          getDefault() {
            return 255;
          }
          set(t3) {
            (t3 !== this.current || this.dirty) && (this.gl.stencilMask(t3), this.current = t3, this.dirty = false);
          }
        }
        class ii extends Xe {
          getDefault() {
            return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
          }
          set(t3) {
            const e4 = this.current;
            (t3.func !== e4.func || t3.ref !== e4.ref || t3.mask !== e4.mask || this.dirty) && (this.gl.stencilFunc(t3.func, t3.ref, t3.mask), this.current = t3, this.dirty = false);
          }
        }
        class si extends Xe {
          getDefault() {
            const t3 = this.gl;
            return [t3.KEEP, t3.KEEP, t3.KEEP];
          }
          set(t3) {
            const e4 = this.current;
            (t3[0] !== e4[0] || t3[1] !== e4[1] || t3[2] !== e4[2] || this.dirty) && (this.gl.stencilOp(t3[0], t3[1], t3[2]), this.current = t3, this.dirty = false);
          }
        }
        class ai extends Xe {
          getDefault() {
            return false;
          }
          set(t3) {
            if (t3 === this.current && !this.dirty)
              return;
            const e4 = this.gl;
            t3 ? e4.enable(e4.STENCIL_TEST) : e4.disable(e4.STENCIL_TEST), this.current = t3, this.dirty = false;
          }
        }
        class oi extends Xe {
          getDefault() {
            return [0, 1];
          }
          set(t3) {
            const e4 = this.current;
            (t3[0] !== e4[0] || t3[1] !== e4[1] || this.dirty) && (this.gl.depthRange(t3[0], t3[1]), this.current = t3, this.dirty = false);
          }
        }
        class ri extends Xe {
          getDefault() {
            return false;
          }
          set(t3) {
            if (t3 === this.current && !this.dirty)
              return;
            const e4 = this.gl;
            t3 ? e4.enable(e4.DEPTH_TEST) : e4.disable(e4.DEPTH_TEST), this.current = t3, this.dirty = false;
          }
        }
        class ni extends Xe {
          getDefault() {
            return this.gl.LESS;
          }
          set(t3) {
            (t3 !== this.current || this.dirty) && (this.gl.depthFunc(t3), this.current = t3, this.dirty = false);
          }
        }
        class li extends Xe {
          getDefault() {
            return false;
          }
          set(t3) {
            if (t3 === this.current && !this.dirty)
              return;
            const e4 = this.gl;
            t3 ? e4.enable(e4.BLEND) : e4.disable(e4.BLEND), this.current = t3, this.dirty = false;
          }
        }
        class hi extends Xe {
          getDefault() {
            const t3 = this.gl;
            return [t3.ONE, t3.ZERO];
          }
          set(t3) {
            const e4 = this.current;
            (t3[0] !== e4[0] || t3[1] !== e4[1] || this.dirty) && (this.gl.blendFunc(t3[0], t3[1]), this.current = t3, this.dirty = false);
          }
        }
        class ci extends Xe {
          getDefault() {
            return e3.aO.transparent;
          }
          set(t3) {
            const e4 = this.current;
            (t3.r !== e4.r || t3.g !== e4.g || t3.b !== e4.b || t3.a !== e4.a || this.dirty) && (this.gl.blendColor(t3.r, t3.g, t3.b, t3.a), this.current = t3, this.dirty = false);
          }
        }
        class ui extends Xe {
          getDefault() {
            return this.gl.FUNC_ADD;
          }
          set(t3) {
            (t3 !== this.current || this.dirty) && (this.gl.blendEquation(t3), this.current = t3, this.dirty = false);
          }
        }
        class di extends Xe {
          getDefault() {
            return false;
          }
          set(t3) {
            if (t3 === this.current && !this.dirty)
              return;
            const e4 = this.gl;
            t3 ? e4.enable(e4.CULL_FACE) : e4.disable(e4.CULL_FACE), this.current = t3, this.dirty = false;
          }
        }
        class _i extends Xe {
          getDefault() {
            return this.gl.BACK;
          }
          set(t3) {
            (t3 !== this.current || this.dirty) && (this.gl.cullFace(t3), this.current = t3, this.dirty = false);
          }
        }
        class pi extends Xe {
          getDefault() {
            return this.gl.CCW;
          }
          set(t3) {
            (t3 !== this.current || this.dirty) && (this.gl.frontFace(t3), this.current = t3, this.dirty = false);
          }
        }
        class mi extends Xe {
          getDefault() {
            return null;
          }
          set(t3) {
            (t3 !== this.current || this.dirty) && (this.gl.useProgram(t3), this.current = t3, this.dirty = false);
          }
        }
        class fi extends Xe {
          getDefault() {
            return this.gl.TEXTURE0;
          }
          set(t3) {
            (t3 !== this.current || this.dirty) && (this.gl.activeTexture(t3), this.current = t3, this.dirty = false);
          }
        }
        class gi extends Xe {
          getDefault() {
            const t3 = this.gl;
            return [0, 0, t3.drawingBufferWidth, t3.drawingBufferHeight];
          }
          set(t3) {
            const e4 = this.current;
            (t3[0] !== e4[0] || t3[1] !== e4[1] || t3[2] !== e4[2] || t3[3] !== e4[3] || this.dirty) && (this.gl.viewport(t3[0], t3[1], t3[2], t3[3]), this.current = t3, this.dirty = false);
          }
        }
        class vi extends Xe {
          getDefault() {
            return null;
          }
          set(t3) {
            if (t3 === this.current && !this.dirty)
              return;
            const e4 = this.gl;
            e4.bindFramebuffer(e4.FRAMEBUFFER, t3), this.current = t3, this.dirty = false;
          }
        }
        class xi extends Xe {
          getDefault() {
            return null;
          }
          set(t3) {
            if (t3 === this.current && !this.dirty)
              return;
            const e4 = this.gl;
            e4.bindRenderbuffer(e4.RENDERBUFFER, t3), this.current = t3, this.dirty = false;
          }
        }
        class yi extends Xe {
          getDefault() {
            return null;
          }
          set(t3) {
            if (t3 === this.current && !this.dirty)
              return;
            const e4 = this.gl;
            e4.bindTexture(e4.TEXTURE_2D, t3), this.current = t3, this.dirty = false;
          }
        }
        class bi extends Xe {
          getDefault() {
            return null;
          }
          set(t3) {
            if (t3 === this.current && !this.dirty)
              return;
            const e4 = this.gl;
            e4.bindBuffer(e4.ARRAY_BUFFER, t3), this.current = t3, this.dirty = false;
          }
        }
        class wi extends Xe {
          getDefault() {
            return null;
          }
          set(t3) {
            const e4 = this.gl;
            e4.bindBuffer(e4.ELEMENT_ARRAY_BUFFER, t3), this.current = t3, this.dirty = false;
          }
        }
        class Ti extends Xe {
          getDefault() {
            return null;
          }
          set(t3) {
            var e4;
            if (t3 === this.current && !this.dirty)
              return;
            const i4 = this.gl;
            $e(i4) ? i4.bindVertexArray(t3) : null === (e4 = i4.getExtension("OES_vertex_array_object")) || void 0 === e4 || e4.bindVertexArrayOES(t3), this.current = t3, this.dirty = false;
          }
        }
        class Ii extends Xe {
          getDefault() {
            return 4;
          }
          set(t3) {
            if (t3 === this.current && !this.dirty)
              return;
            const e4 = this.gl;
            e4.pixelStorei(e4.UNPACK_ALIGNMENT, t3), this.current = t3, this.dirty = false;
          }
        }
        class Ei extends Xe {
          getDefault() {
            return false;
          }
          set(t3) {
            if (t3 === this.current && !this.dirty)
              return;
            const e4 = this.gl;
            e4.pixelStorei(e4.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t3), this.current = t3, this.dirty = false;
          }
        }
        class Si extends Xe {
          getDefault() {
            return false;
          }
          set(t3) {
            if (t3 === this.current && !this.dirty)
              return;
            const e4 = this.gl;
            e4.pixelStorei(e4.UNPACK_FLIP_Y_WEBGL, t3), this.current = t3, this.dirty = false;
          }
        }
        class Ci extends Xe {
          constructor(t3, e4) {
            super(t3), this.context = t3, this.parent = e4;
          }
          getDefault() {
            return null;
          }
        }
        class Pi extends Ci {
          setDirty() {
            this.dirty = true;
          }
          set(t3) {
            if (t3 === this.current && !this.dirty)
              return;
            this.context.bindFramebuffer.set(this.parent);
            const e4 = this.gl;
            e4.framebufferTexture2D(e4.FRAMEBUFFER, e4.COLOR_ATTACHMENT0, e4.TEXTURE_2D, t3, 0), this.current = t3, this.dirty = false;
          }
        }
        class Di extends Ci {
          set(t3) {
            if (t3 === this.current && !this.dirty)
              return;
            this.context.bindFramebuffer.set(this.parent);
            const e4 = this.gl;
            e4.framebufferRenderbuffer(e4.FRAMEBUFFER, e4.DEPTH_ATTACHMENT, e4.RENDERBUFFER, t3), this.current = t3, this.dirty = false;
          }
        }
        class zi extends Ci {
          set(t3) {
            if (t3 === this.current && !this.dirty)
              return;
            this.context.bindFramebuffer.set(this.parent);
            const e4 = this.gl;
            e4.framebufferRenderbuffer(e4.FRAMEBUFFER, e4.DEPTH_STENCIL_ATTACHMENT, e4.RENDERBUFFER, t3), this.current = t3, this.dirty = false;
          }
        }
        class Mi {
          constructor(t3, e4, i4, s4, a3) {
            this.context = t3, this.width = e4, this.height = i4;
            const o3 = t3.gl, r5 = this.framebuffer = o3.createFramebuffer();
            if (this.colorAttachment = new Pi(t3, r5), s4)
              this.depthAttachment = a3 ? new zi(t3, r5) : new Di(t3, r5);
            else if (a3)
              throw new Error("Stencil cannot be set without depth");
            if (o3.checkFramebufferStatus(o3.FRAMEBUFFER) !== o3.FRAMEBUFFER_COMPLETE)
              throw new Error("Framebuffer is not complete");
          }
          destroy() {
            const t3 = this.context.gl, e4 = this.colorAttachment.get();
            if (e4 && t3.deleteTexture(e4), this.depthAttachment) {
              const e5 = this.depthAttachment.get();
              e5 && t3.deleteRenderbuffer(e5);
            }
            t3.deleteFramebuffer(this.framebuffer);
          }
        }
        class Ai {
          constructor(t3, e4, i4) {
            this.blendFunction = t3, this.blendColor = e4, this.mask = i4;
          }
        }
        Ai.Replace = [1, 0], Ai.disabled = new Ai(Ai.Replace, e3.aO.transparent, [false, false, false, false]), Ai.unblended = new Ai(Ai.Replace, e3.aO.transparent, [true, true, true, true]), Ai.alphaBlended = new Ai([1, 771], e3.aO.transparent, [true, true, true, true]);
        class Ri {
          constructor(t3) {
            var e4, i4;
            if (this.gl = t3, this.clearColor = new Ke(this), this.clearDepth = new Ye(this), this.clearStencil = new Je(this), this.colorMask = new Qe(this), this.depthMask = new ti(this), this.stencilMask = new ei(this), this.stencilFunc = new ii(this), this.stencilOp = new si(this), this.stencilTest = new ai(this), this.depthRange = new oi(this), this.depthTest = new ri(this), this.depthFunc = new ni(this), this.blend = new li(this), this.blendFunc = new hi(this), this.blendColor = new ci(this), this.blendEquation = new ui(this), this.cullFace = new di(this), this.cullFaceSide = new _i(this), this.frontFace = new pi(this), this.program = new mi(this), this.activeTexture = new fi(this), this.viewport = new gi(this), this.bindFramebuffer = new vi(this), this.bindRenderbuffer = new xi(this), this.bindTexture = new yi(this), this.bindVertexBuffer = new bi(this), this.bindElementBuffer = new wi(this), this.bindVertexArray = new Ti(this), this.pixelStoreUnpack = new Ii(this), this.pixelStoreUnpackPremultiplyAlpha = new Ei(this), this.pixelStoreUnpackFlipY = new Si(this), this.extTextureFilterAnisotropic = t3.getExtension("EXT_texture_filter_anisotropic") || t3.getExtension("MOZ_EXT_texture_filter_anisotropic") || t3.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t3.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = t3.getParameter(t3.MAX_TEXTURE_SIZE), $e(t3)) {
              this.HALF_FLOAT = t3.HALF_FLOAT;
              const s4 = t3.getExtension("EXT_color_buffer_half_float");
              this.RGBA16F = null !== (e4 = t3.RGBA16F) && void 0 !== e4 ? e4 : null == s4 ? void 0 : s4.RGBA16F_EXT, this.RGB16F = null !== (i4 = t3.RGB16F) && void 0 !== i4 ? i4 : null == s4 ? void 0 : s4.RGB16F_EXT, t3.getExtension("EXT_color_buffer_float");
            } else {
              t3.getExtension("EXT_color_buffer_half_float"), t3.getExtension("OES_texture_half_float_linear");
              const e5 = t3.getExtension("OES_texture_half_float");
              this.HALF_FLOAT = null == e5 ? void 0 : e5.HALF_FLOAT_OES;
            }
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
          }
          setDirty() {
            this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.bindVertexArray.dirty = true, this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
          }
          createIndexBuffer(t3, e4) {
            return new qe(this, t3, e4);
          }
          createVertexBuffer(t3, e4, i4) {
            return new We(this, t3, e4, i4);
          }
          createRenderbuffer(t3, e4, i4) {
            const s4 = this.gl, a3 = s4.createRenderbuffer();
            return this.bindRenderbuffer.set(a3), s4.renderbufferStorage(s4.RENDERBUFFER, t3, e4, i4), this.bindRenderbuffer.set(null), a3;
          }
          createFramebuffer(t3, e4, i4, s4) {
            return new Mi(this, t3, e4, i4, s4);
          }
          clear({ color: t3, depth: e4, stencil: i4 }) {
            const s4 = this.gl;
            let a3 = 0;
            t3 && (a3 |= s4.COLOR_BUFFER_BIT, this.clearColor.set(t3), this.colorMask.set([true, true, true, true])), void 0 !== e4 && (a3 |= s4.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(e4), this.depthMask.set(true)), void 0 !== i4 && (a3 |= s4.STENCIL_BUFFER_BIT, this.clearStencil.set(i4), this.stencilMask.set(255)), s4.clear(a3);
          }
          setCullFace(t3) {
            false === t3.enable ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(t3.mode), this.frontFace.set(t3.frontFace));
          }
          setDepthMode(t3) {
            t3.func !== this.gl.ALWAYS || t3.mask ? (this.depthTest.set(true), this.depthFunc.set(t3.func), this.depthMask.set(t3.mask), this.depthRange.set(t3.range)) : this.depthTest.set(false);
          }
          setStencilMode(t3) {
            t3.test.func !== this.gl.ALWAYS || t3.mask ? (this.stencilTest.set(true), this.stencilMask.set(t3.mask), this.stencilOp.set([t3.fail, t3.depthFail, t3.pass]), this.stencilFunc.set({ func: t3.test.func, ref: t3.ref, mask: t3.test.mask })) : this.stencilTest.set(false);
          }
          setColorMode(t3) {
            e3.aD(t3.blendFunction, Ai.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(t3.blendFunction), this.blendColor.set(t3.blendColor)), this.colorMask.set(t3.mask);
          }
          createVertexArray() {
            var t3;
            return $e(this.gl) ? this.gl.createVertexArray() : null === (t3 = this.gl.getExtension("OES_vertex_array_object")) || void 0 === t3 ? void 0 : t3.createVertexArrayOES();
          }
          deleteVertexArray(t3) {
            var e4;
            return $e(this.gl) ? this.gl.deleteVertexArray(t3) : null === (e4 = this.gl.getExtension("OES_vertex_array_object")) || void 0 === e4 ? void 0 : e4.deleteVertexArrayOES(t3);
          }
          unbindVAO() {
            this.bindVertexArray.set(null);
          }
        }
        class Li {
          constructor(t3, e4, i4) {
            this.func = t3, this.mask = e4, this.range = i4;
          }
        }
        Li.ReadOnly = false, Li.ReadWrite = true, Li.disabled = new Li(519, Li.ReadOnly, [0, 1]);
        const ki = 7680;
        class Fi {
          constructor(t3, e4, i4, s4, a3, o3) {
            this.test = t3, this.ref = e4, this.mask = i4, this.fail = s4, this.depthFail = a3, this.pass = o3;
          }
        }
        Fi.disabled = new Fi({ func: 519, mask: 0 }, 0, 0, ki, ki, ki);
        class Bi {
          constructor(t3, e4, i4) {
            this.enable = t3, this.mode = e4, this.frontFace = i4;
          }
        }
        let Oi;
        function Ni(t3, i4, s4, a3, o3, r5, n3) {
          const l4 = t3.context, h2 = l4.gl, c3 = t3.useProgram("collisionBox"), u3 = [];
          let d2 = 0, _2 = 0;
          for (let p5 = 0; p5 < a3.length; p5++) {
            const m3 = a3[p5], f3 = i4.getTile(m3), g4 = f3.getBucket(s4);
            if (!g4)
              continue;
            let v5 = m3.posMatrix;
            0 === o3[0] && 0 === o3[1] || (v5 = t3.translatePosMatrix(m3.posMatrix, f3, o3, r5));
            const x6 = n3 ? g4.textCollisionBox : g4.iconCollisionBox, y4 = g4.collisionCircleArray;
            if (y4.length > 0) {
              const i5 = e3.F(), s5 = v5;
              e3.aP(i5, g4.placementInvProjMatrix, t3.transform.glCoordMatrix), e3.aP(i5, i5, g4.placementViewportMatrix), u3.push({ circleArray: y4, circleOffset: _2, transform: s5, invTransform: i5, coord: m3 }), d2 += y4.length / 4, _2 = d2;
            }
            x6 && c3.draw(l4, h2.LINES, Li.disabled, Fi.disabled, t3.colorModeForRenderPass(), Bi.disabled, Ee(v5, t3.transform, f3), t3.style.map.terrain && t3.style.map.terrain.getTerrainData(m3), s4.id, x6.layoutVertexBuffer, x6.indexBuffer, x6.segments, null, t3.transform.zoom, null, null, x6.collisionVertexBuffer);
          }
          if (!n3 || !u3.length)
            return;
          const p4 = t3.useProgram("collisionCircle"), m2 = new e3.aQ();
          m2.resize(4 * d2), m2._trim();
          let f2 = 0;
          for (const t4 of u3)
            for (let e4 = 0; e4 < t4.circleArray.length / 4; e4++) {
              const i5 = 4 * e4, s5 = t4.circleArray[i5 + 0], a4 = t4.circleArray[i5 + 1], o4 = t4.circleArray[i5 + 2], r6 = t4.circleArray[i5 + 3];
              m2.emplace(f2++, s5, a4, o4, r6, 0), m2.emplace(f2++, s5, a4, o4, r6, 1), m2.emplace(f2++, s5, a4, o4, r6, 2), m2.emplace(f2++, s5, a4, o4, r6, 3);
            }
          (!Oi || Oi.length < 2 * d2) && (Oi = function(t4) {
            const i5 = 2 * t4, s5 = new e3.aS();
            s5.resize(i5), s5._trim();
            for (let t5 = 0; t5 < i5; t5++) {
              const e4 = 6 * t5;
              s5.uint16[e4 + 0] = 4 * t5 + 0, s5.uint16[e4 + 1] = 4 * t5 + 1, s5.uint16[e4 + 2] = 4 * t5 + 2, s5.uint16[e4 + 3] = 4 * t5 + 2, s5.uint16[e4 + 4] = 4 * t5 + 3, s5.uint16[e4 + 5] = 4 * t5 + 0;
            }
            return s5;
          }(d2));
          const g3 = l4.createIndexBuffer(Oi, true), v4 = l4.createVertexBuffer(m2, e3.aR.members, true);
          for (const i5 of u3) {
            const a4 = { u_matrix: i5.transform, u_inv_matrix: i5.invTransform, u_camera_to_center_distance: (x5 = t3.transform).cameraToCenterDistance, u_viewport_size: [x5.width, x5.height] };
            p4.draw(l4, h2.TRIANGLES, Li.disabled, Fi.disabled, t3.colorModeForRenderPass(), Bi.disabled, a4, t3.style.map.terrain && t3.style.map.terrain.getTerrainData(i5.coord), s4.id, v4, g3, e3.$.simpleSegment(0, 2 * i5.circleOffset, i5.circleArray.length, i5.circleArray.length / 2), null, t3.transform.zoom, null, null, null);
          }
          var x5;
          v4.destroy(), g3.destroy();
        }
        Bi.disabled = new Bi(false, 1029, 2305), Bi.backCCW = new Bi(true, 1029, 2305);
        const Ui = e3.an(new Float32Array(16));
        function Zi(t3, i4, s4, a3, o3, r5) {
          const { horizontalAlign: n3, verticalAlign: l4 } = e3.at(t3);
          return new e3.P((-(n3 - 0.5) * i4 / o3 + a3[0]) * r5, (-(l4 - 0.5) * s4 / o3 + a3[1]) * r5);
        }
        function Gi(t3, i4, s4, a3, o3, r5, n3, l4, h2, c3, u3) {
          const d2 = t3.text.placedSymbolArray, _2 = t3.text.dynamicLayoutVertexArray, p4 = t3.icon.dynamicLayoutVertexArray, m2 = {};
          _2.clear();
          for (let p5 = 0; p5 < d2.length; p5++) {
            const f2 = d2.get(p5), g3 = f2.hidden || !f2.crossTileID || t3.allowVerticalPlacement && !f2.placedOrientation ? null : a3[f2.crossTileID];
            if (g3) {
              const a4 = new e3.P(f2.anchorX, f2.anchorY), d3 = gt(a4, s4 ? n3 : r5, u3), p6 = vt(o3.cameraToCenterDistance, d3.signedDistanceFromCamera);
              let v4 = e3.ai(t3.textSizeData, h2, f2) * p6 / e3.ao;
              s4 && (v4 *= t3.tilePixelRatio / l4);
              const { width: x5, height: y4, anchor: b3, textOffset: w4, textBoxScale: T3 } = g3, I3 = Zi(b3, x5, y4, w4, T3, v4), E3 = s4 ? gt(a4.add(I3), r5, u3).point : d3.point.add(i4 ? I3.rotate(-o3.angle) : I3), S4 = t3.allowVerticalPlacement && f2.placedOrientation === e3.ah.vertical ? Math.PI / 2 : 0;
              for (let t4 = 0; t4 < f2.numGlyphs; t4++)
                e3.aj(_2, E3, S4);
              c3 && f2.associatedIconIndex >= 0 && (m2[f2.associatedIconIndex] = { shiftedAnchor: E3, angle: S4 });
            } else
              zt(f2.numGlyphs, _2);
          }
          if (c3) {
            p4.clear();
            const i5 = t3.icon.placedSymbolArray;
            for (let t4 = 0; t4 < i5.length; t4++) {
              const s5 = i5.get(t4);
              if (s5.hidden)
                zt(s5.numGlyphs, p4);
              else {
                const i6 = m2[t4];
                if (i6)
                  for (let t5 = 0; t5 < s5.numGlyphs; t5++)
                    e3.aj(p4, i6.shiftedAnchor, i6.angle);
                else
                  zt(s5.numGlyphs, p4);
              }
            }
            t3.icon.dynamicLayoutVertexBuffer.updateData(p4);
          }
          t3.text.dynamicLayoutVertexBuffer.updateData(_2);
        }
        function ji(t3, e4, i4) {
          return i4.iconsInText && e4 ? "symbolTextAndIcon" : t3 ? "symbolSDF" : "symbolIcon";
        }
        function qi(t3, i4, s4, a3, o3, r5, n3, l4, h2, c3, u3, d2) {
          const _2 = t3.context, p4 = _2.gl, m2 = t3.transform, f2 = "map" === l4, g3 = "map" === h2, v4 = "viewport" !== l4 && "point" !== s4.layout.get("symbol-placement"), x5 = f2 && !g3 && !v4, y4 = !s4.layout.get("symbol-sort-key").isConstant();
          let b3 = false;
          const w4 = t3.depthModeForSublayer(0, Li.ReadOnly), T3 = s4._unevaluatedLayout.hasValue("text-variable-anchor") || s4._unevaluatedLayout.hasValue("text-variable-anchor-offset"), I3 = [];
          for (const l5 of a3) {
            const a4 = i4.getTile(l5), h3 = a4.getBucket(s4);
            if (!h3)
              continue;
            const u4 = o3 ? h3.text : h3.icon;
            if (!u4 || !u4.segments.get().length || !u4.hasVisibleVertices)
              continue;
            const d3 = u4.programConfigurations.get(s4.id), _3 = o3 || h3.sdfIcons, w5 = o3 ? h3.textSizeData : h3.iconSizeData, E3 = g3 || 0 !== m2.pitch, S4 = t3.useProgram(ji(_3, o3, h3), d3), C5 = e3.ag(w5, m2.zoom), P3 = t3.style.map.terrain && t3.style.map.terrain.getTerrainData(l5);
            let D4, z4, M3, A3, R4 = [0, 0], L3 = null;
            if (o3)
              z4 = a4.glyphAtlasTexture, M3 = p4.LINEAR, D4 = a4.glyphAtlasTexture.size, h3.iconsInText && (R4 = a4.imageAtlasTexture.size, L3 = a4.imageAtlasTexture, A3 = E3 || t3.options.rotating || t3.options.zooming || "composite" === w5.kind || "camera" === w5.kind ? p4.LINEAR : p4.NEAREST);
            else {
              const e4 = 1 !== s4.layout.get("icon-size").constantOr(0) || h3.iconsNeedLinear;
              z4 = a4.imageAtlasTexture, M3 = _3 || t3.options.rotating || t3.options.zooming || e4 || E3 ? p4.LINEAR : p4.NEAREST, D4 = a4.imageAtlasTexture.size;
            }
            const k3 = Lt(a4, 1, t3.transform.zoom), F4 = mt(l5.posMatrix, g3, f2, t3.transform, k3), B3 = ft(l5.posMatrix, g3, f2, t3.transform, k3), O3 = T3 && h3.hasTextData(), N4 = "none" !== s4.layout.get("icon-text-fit") && O3 && h3.hasIconData();
            if (v4) {
              const e4 = t3.style.map.terrain ? (e5, i6) => t3.style.map.terrain.getElevation(l5, e5, i6) : null, i5 = "map" === s4.layout.get("text-rotation-alignment");
              yt(h3, l5.posMatrix, t3, o3, F4, B3, g3, c3, i5, e4);
            }
            const U3 = t3.translatePosMatrix(l5.posMatrix, a4, r5, n3), Z5 = v4 || o3 && T3 || N4 ? Ui : F4, G3 = t3.translatePosMatrix(B3, a4, r5, n3, true), j3 = _3 && 0 !== s4.paint.get(o3 ? "text-halo-width" : "icon-halo-width").constantOr(1);
            let q4;
            q4 = _3 ? h3.iconsInText ? Ue(w5.kind, C5, x5, g3, t3, U3, Z5, G3, D4, R4) : Ne(w5.kind, C5, x5, g3, t3, U3, Z5, G3, o3, D4, true) : Oe(w5.kind, C5, x5, g3, t3, U3, Z5, G3, o3, D4);
            const V3 = { program: S4, buffers: u4, uniformValues: q4, atlasTexture: z4, atlasTextureIcon: L3, atlasInterpolation: M3, atlasInterpolationIcon: A3, isSDF: _3, hasHalo: j3 };
            if (y4 && h3.canOverlap) {
              b3 = true;
              const t4 = u4.segments.get();
              for (const i5 of t4)
                I3.push({ segments: new e3.$([i5]), sortKey: i5.sortKey, state: V3, terrainData: P3 });
            } else
              I3.push({ segments: u4.segments, sortKey: 0, state: V3, terrainData: P3 });
          }
          b3 && I3.sort((t4, e4) => t4.sortKey - e4.sortKey);
          for (const e4 of I3) {
            const i5 = e4.state;
            if (_2.activeTexture.set(p4.TEXTURE0), i5.atlasTexture.bind(i5.atlasInterpolation, p4.CLAMP_TO_EDGE), i5.atlasTextureIcon && (_2.activeTexture.set(p4.TEXTURE1), i5.atlasTextureIcon && i5.atlasTextureIcon.bind(i5.atlasInterpolationIcon, p4.CLAMP_TO_EDGE)), i5.isSDF) {
              const a4 = i5.uniformValues;
              i5.hasHalo && (a4.u_is_halo = 1, Vi(i5.buffers, e4.segments, s4, t3, i5.program, w4, u3, d2, a4, e4.terrainData)), a4.u_is_halo = 0;
            }
            Vi(i5.buffers, e4.segments, s4, t3, i5.program, w4, u3, d2, i5.uniformValues, e4.terrainData);
          }
        }
        function Vi(t3, e4, i4, s4, a3, o3, r5, n3, l4, h2) {
          const c3 = s4.context;
          a3.draw(c3, c3.gl.TRIANGLES, o3, r5, n3, Bi.disabled, l4, h2, i4.id, t3.layoutVertexBuffer, t3.indexBuffer, e4, i4.paint, s4.transform.zoom, t3.programConfigurations.get(i4.id), t3.dynamicLayoutVertexBuffer, t3.opacityVertexBuffer);
        }
        function Wi(t3, e4, i4, s4, a3) {
          if (!i4 || !s4 || !s4.imageAtlas)
            return;
          const o3 = s4.imageAtlas.patternPositions;
          let r5 = o3[i4.to.toString()], n3 = o3[i4.from.toString()];
          if (!r5 && n3 && (r5 = n3), !n3 && r5 && (n3 = r5), !r5 || !n3) {
            const t4 = a3.getPaintProperty(e4);
            r5 = o3[t4], n3 = o3[t4];
          }
          r5 && n3 && t3.setConstantPatternPositions(r5, n3);
        }
        function Hi(t3, e4, i4, s4, a3, o3, r5) {
          const n3 = t3.context.gl, l4 = "fill-pattern", h2 = i4.paint.get(l4), c3 = h2 && h2.constantOr(1), u3 = i4.getCrossfadeParameters();
          let d2, _2, p4, m2, f2;
          r5 ? (_2 = c3 && !i4.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", d2 = n3.LINES) : (_2 = c3 ? "fillPattern" : "fill", d2 = n3.TRIANGLES);
          const g3 = h2.constantOr(null);
          for (const h3 of s4) {
            const s5 = e4.getTile(h3);
            if (c3 && !s5.patternsLoaded())
              continue;
            const v4 = s5.getBucket(i4);
            if (!v4)
              continue;
            const x5 = v4.programConfigurations.get(i4.id), y4 = t3.useProgram(_2, x5), b3 = t3.style.map.terrain && t3.style.map.terrain.getTerrainData(h3);
            c3 && (t3.context.activeTexture.set(n3.TEXTURE0), s5.imageAtlasTexture.bind(n3.LINEAR, n3.CLAMP_TO_EDGE), x5.updatePaintBuffers(u3)), Wi(x5, l4, g3, s5, i4);
            const w4 = b3 ? h3 : null, T3 = t3.translatePosMatrix(w4 ? w4.posMatrix : h3.posMatrix, s5, i4.paint.get("fill-translate"), i4.paint.get("fill-translate-anchor"));
            if (r5) {
              m2 = v4.indexBuffer2, f2 = v4.segments2;
              const e5 = [n3.drawingBufferWidth, n3.drawingBufferHeight];
              p4 = "fillOutlinePattern" === _2 && c3 ? Te2(T3, t3, u3, s5, e5) : we(T3, e5);
            } else
              m2 = v4.indexBuffer, f2 = v4.segments, p4 = c3 ? be2(T3, t3, u3, s5) : ye(T3);
            y4.draw(t3.context, d2, a3, t3.stencilModeForClipping(h3), o3, Bi.disabled, p4, b3, i4.id, v4.layoutVertexBuffer, m2, f2, i4.paint, t3.transform.zoom, x5);
          }
        }
        function $i(t3, e4, i4, s4, a3, o3, r5) {
          const n3 = t3.context, l4 = n3.gl, h2 = "fill-extrusion-pattern", c3 = i4.paint.get(h2), u3 = c3.constantOr(1), d2 = i4.getCrossfadeParameters(), _2 = i4.paint.get("fill-extrusion-opacity"), p4 = c3.constantOr(null);
          for (const c4 of s4) {
            const s5 = e4.getTile(c4), m2 = s5.getBucket(i4);
            if (!m2)
              continue;
            const f2 = t3.style.map.terrain && t3.style.map.terrain.getTerrainData(c4), g3 = m2.programConfigurations.get(i4.id), v4 = t3.useProgram(u3 ? "fillExtrusionPattern" : "fillExtrusion", g3);
            u3 && (t3.context.activeTexture.set(l4.TEXTURE0), s5.imageAtlasTexture.bind(l4.LINEAR, l4.CLAMP_TO_EDGE), g3.updatePaintBuffers(d2)), Wi(g3, h2, p4, s5, i4);
            const x5 = t3.translatePosMatrix(c4.posMatrix, s5, i4.paint.get("fill-extrusion-translate"), i4.paint.get("fill-extrusion-translate-anchor")), y4 = i4.paint.get("fill-extrusion-vertical-gradient"), b3 = u3 ? xe(x5, t3, y4, _2, c4, d2, s5) : ve(x5, t3, y4, _2);
            v4.draw(n3, n3.gl.TRIANGLES, a3, o3, r5, Bi.backCCW, b3, f2, i4.id, m2.layoutVertexBuffer, m2.indexBuffer, m2.segments, i4.paint, t3.transform.zoom, g3, t3.style.map.terrain && m2.centroidVertexBuffer);
          }
        }
        function Xi(t3, e4, i4, s4, a3, o3, r5) {
          const n3 = t3.context, l4 = n3.gl, h2 = i4.fbo;
          if (!h2)
            return;
          const c3 = t3.useProgram("hillshade"), u3 = t3.style.map.terrain && t3.style.map.terrain.getTerrainData(e4);
          n3.activeTexture.set(l4.TEXTURE0), l4.bindTexture(l4.TEXTURE_2D, h2.colorAttachment.get()), c3.draw(n3, l4.TRIANGLES, a3, o3, r5, Bi.disabled, ((t4, e5, i5, s5) => {
            const a4 = i5.paint.get("hillshade-shadow-color"), o4 = i5.paint.get("hillshade-highlight-color"), r6 = i5.paint.get("hillshade-accent-color");
            let n4 = i5.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
            "viewport" === i5.paint.get("hillshade-illumination-anchor") && (n4 -= t4.transform.angle);
            const l5 = !t4.options.moving;
            return { u_matrix: s5 ? s5.posMatrix : t4.transform.calculatePosMatrix(e5.tileID.toUnwrapped(), l5), u_image: 0, u_latrange: De(0, e5.tileID), u_light: [i5.paint.get("hillshade-exaggeration"), n4], u_shadow: a4, u_highlight: o4, u_accent: r6 };
          })(t3, i4, s4, u3 ? e4 : null), u3, s4.id, t3.rasterBoundsBuffer, t3.quadTriangleIndexBuffer, t3.rasterBoundsSegments);
        }
        function Ki(t3, i4, s4, a3, o3, r5) {
          const n3 = t3.context, l4 = n3.gl, h2 = i4.dem;
          if (h2 && h2.data) {
            const c3 = h2.dim, u3 = h2.stride, d2 = h2.getPixels();
            if (n3.activeTexture.set(l4.TEXTURE1), n3.pixelStoreUnpackPremultiplyAlpha.set(false), i4.demTexture = i4.demTexture || t3.getTileTexture(u3), i4.demTexture) {
              const t4 = i4.demTexture;
              t4.update(d2, { premultiply: false }), t4.bind(l4.NEAREST, l4.CLAMP_TO_EDGE);
            } else
              i4.demTexture = new w3(n3, d2, l4.RGBA, { premultiply: false }), i4.demTexture.bind(l4.NEAREST, l4.CLAMP_TO_EDGE);
            n3.activeTexture.set(l4.TEXTURE0);
            let _2 = i4.fbo;
            if (!_2) {
              const t4 = new w3(n3, { width: c3, height: c3, data: null }, l4.RGBA);
              t4.bind(l4.LINEAR, l4.CLAMP_TO_EDGE), _2 = i4.fbo = n3.createFramebuffer(c3, c3, true, false), _2.colorAttachment.set(t4.texture);
            }
            n3.bindFramebuffer.set(_2.framebuffer), n3.viewport.set([0, 0, c3, c3]), t3.useProgram("hillshadePrepare").draw(n3, l4.TRIANGLES, a3, o3, r5, Bi.disabled, ((t4, i5) => {
              const s5 = i5.stride, a4 = e3.F();
              return e3.aN(a4, 0, e3.W, -e3.W, 0, 0, 1), e3.H(a4, a4, [0, -e3.W, 0]), { u_matrix: a4, u_image: 1, u_dimension: [s5, s5], u_zoom: t4.overscaledZ, u_unpack: i5.getUnpackVector() };
            })(i4.tileID, h2), null, s4.id, t3.rasterBoundsBuffer, t3.quadTriangleIndexBuffer, t3.rasterBoundsSegments), i4.needsHillshadePrepare = false;
          }
        }
        function Yi(t3, i4, s4, a3, r5, n3) {
          const l4 = a3.paint.get("raster-fade-duration");
          if (!n3 && l4 > 0) {
            const a4 = o2.now(), n4 = (a4 - t3.timeAdded) / l4, h2 = i4 ? (a4 - i4.timeAdded) / l4 : -1, c3 = s4.getSource(), u3 = r5.coveringZoomLevel({ tileSize: c3.tileSize, roundZoom: c3.roundZoom }), d2 = !i4 || Math.abs(i4.tileID.overscaledZ - u3) > Math.abs(t3.tileID.overscaledZ - u3), _2 = d2 && t3.refreshedUponExpiration ? 1 : e3.ac(d2 ? n4 : 1 - h2, 0, 1);
            return t3.refreshedUponExpiration && n4 >= 1 && (t3.refreshedUponExpiration = false), i4 ? { opacity: 1, mix: 1 - _2 } : { opacity: _2, mix: 0 };
          }
          return { opacity: 1, mix: 0 };
        }
        const Ji = new e3.aO(1, 0, 0, 1), Qi = new e3.aO(0, 1, 0, 1), ts = new e3.aO(0, 0, 1, 1), es = new e3.aO(1, 0, 1, 1), is = new e3.aO(0, 1, 1, 1);
        function ss(t3, e4, i4, s4) {
          os(t3, 0, e4 + i4 / 2, t3.transform.width, i4, s4);
        }
        function as(t3, e4, i4, s4) {
          os(t3, e4 - i4 / 2, 0, i4, t3.transform.height, s4);
        }
        function os(t3, e4, i4, s4, a3, o3) {
          const r5 = t3.context, n3 = r5.gl;
          n3.enable(n3.SCISSOR_TEST), n3.scissor(e4 * t3.pixelRatio, i4 * t3.pixelRatio, s4 * t3.pixelRatio, a3 * t3.pixelRatio), r5.clear({ color: o3 }), n3.disable(n3.SCISSOR_TEST);
        }
        function rs(t3, i4, s4) {
          const a3 = t3.context, o3 = a3.gl, r5 = s4.posMatrix, n3 = t3.useProgram("debug"), l4 = Li.disabled, h2 = Fi.disabled, c3 = t3.colorModeForRenderPass(), u3 = "$debug", d2 = t3.style.map.terrain && t3.style.map.terrain.getTerrainData(s4);
          a3.activeTexture.set(o3.TEXTURE0);
          const _2 = i4.getTileByID(s4.key).latestRawTileData, p4 = Math.floor((_2 && _2.byteLength || 0) / 1024), m2 = i4.getTile(s4).tileSize, f2 = 512 / Math.min(m2, 512) * (s4.overscaledZ / t3.transform.zoom) * 0.5;
          let g3 = s4.canonical.toString();
          s4.overscaledZ !== s4.canonical.z && (g3 += ` => ${s4.overscaledZ}`), function(t4, e4) {
            t4.initDebugOverlayCanvas();
            const i5 = t4.debugOverlayCanvas, s5 = t4.context.gl, a4 = t4.debugOverlayCanvas.getContext("2d");
            a4.clearRect(0, 0, i5.width, i5.height), a4.shadowColor = "white", a4.shadowBlur = 2, a4.lineWidth = 1.5, a4.strokeStyle = "white", a4.textBaseline = "top", a4.font = "bold 36px Open Sans, sans-serif", a4.fillText(e4, 5, 5), a4.strokeText(e4, 5, 5), t4.debugOverlayTexture.update(i5), t4.debugOverlayTexture.bind(s5.LINEAR, s5.CLAMP_TO_EDGE);
          }(t3, `${g3} ${p4}kB`), n3.draw(a3, o3.TRIANGLES, l4, h2, Ai.alphaBlended, Bi.disabled, Se(r5, e3.aO.transparent, f2), null, u3, t3.debugBuffer, t3.quadTriangleIndexBuffer, t3.debugSegments), n3.draw(a3, o3.LINE_STRIP, l4, h2, c3, Bi.disabled, Se(r5, e3.aO.red), d2, u3, t3.debugBuffer, t3.tileBorderIndexBuffer, t3.debugSegments);
        }
        function ns(t3, e4, i4) {
          const s4 = t3.context, a3 = s4.gl, o3 = t3.colorModeForRenderPass(), r5 = new Li(a3.LEQUAL, Li.ReadWrite, t3.depthRangeFor3D), n3 = t3.useProgram("terrain"), l4 = e4.getTerrainMesh();
          s4.bindFramebuffer.set(null), s4.viewport.set([0, 0, t3.width, t3.height]);
          for (const h2 of i4) {
            const i5 = t3.renderToTexture.getTexture(h2), c3 = e4.getTerrainData(h2.tileID);
            s4.activeTexture.set(a3.TEXTURE0), a3.bindTexture(a3.TEXTURE_2D, i5.texture);
            const u3 = { u_matrix: t3.transform.calculatePosMatrix(h2.tileID.toUnwrapped()), u_texture: 0, u_ele_delta: e4.getMeshFrameDelta(t3.transform.zoom) };
            n3.draw(s4, a3.TRIANGLES, r5, Fi.disabled, o3, Bi.backCCW, u3, c3, "terrain", l4.vertexBuffer, l4.indexBuffer, l4.segments);
          }
        }
        class ls {
          constructor(t3, i4) {
            this.context = new Ri(t3), this.transform = i4, this._tileTextures = {}, this.terrainFacilitator = { dirty: true, matrix: e3.F(), renderTime: 0 }, this.setup(), this.numSublayers = ht.maxUnderzooming + ht.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new re2();
          }
          resize(t3, e4, i4) {
            if (this.width = Math.floor(t3 * i4), this.height = Math.floor(e4 * i4), this.pixelRatio = i4, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
              for (const t4 of this.style._order)
                this.style._layers[t4].resize();
          }
          setup() {
            const t3 = this.context, i4 = new e3.aV();
            i4.emplaceBack(0, 0), i4.emplaceBack(e3.W, 0), i4.emplaceBack(0, e3.W), i4.emplaceBack(e3.W, e3.W), this.tileExtentBuffer = t3.createVertexBuffer(i4, ce3.members), this.tileExtentSegments = e3.$.simpleSegment(0, 0, 4, 2);
            const s4 = new e3.aV();
            s4.emplaceBack(0, 0), s4.emplaceBack(e3.W, 0), s4.emplaceBack(0, e3.W), s4.emplaceBack(e3.W, e3.W), this.debugBuffer = t3.createVertexBuffer(s4, ce3.members), this.debugSegments = e3.$.simpleSegment(0, 0, 4, 5);
            const a3 = new e3.Z();
            a3.emplaceBack(0, 0, 0, 0), a3.emplaceBack(e3.W, 0, e3.W, 0), a3.emplaceBack(0, e3.W, 0, e3.W), a3.emplaceBack(e3.W, e3.W, e3.W, e3.W), this.rasterBoundsBuffer = t3.createVertexBuffer(a3, Y4.members), this.rasterBoundsSegments = e3.$.simpleSegment(0, 0, 4, 2);
            const o3 = new e3.aV();
            o3.emplaceBack(0, 0), o3.emplaceBack(1, 0), o3.emplaceBack(0, 1), o3.emplaceBack(1, 1), this.viewportBuffer = t3.createVertexBuffer(o3, ce3.members), this.viewportSegments = e3.$.simpleSegment(0, 0, 4, 2);
            const r5 = new e3.aW();
            r5.emplaceBack(0), r5.emplaceBack(1), r5.emplaceBack(3), r5.emplaceBack(2), r5.emplaceBack(0), this.tileBorderIndexBuffer = t3.createIndexBuffer(r5);
            const n3 = new e3.aX();
            n3.emplaceBack(0, 1, 2), n3.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t3.createIndexBuffer(n3);
            const l4 = this.context.gl;
            this.stencilClearMode = new Fi({ func: l4.ALWAYS, mask: 0 }, 0, 255, l4.ZERO, l4.ZERO, l4.ZERO);
          }
          clearStencil() {
            const t3 = this.context, i4 = t3.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0;
            const s4 = e3.F();
            e3.aN(s4, 0, this.width, this.height, 0, 0, 1), e3.J(s4, s4, [i4.drawingBufferWidth, i4.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(t3, i4.TRIANGLES, Li.disabled, this.stencilClearMode, Ai.disabled, Bi.disabled, Ce(s4), null, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
          }
          _renderTileClippingMasks(t3, e4) {
            if (this.currentStencilSource === t3.source || !t3.isTileClipped() || !e4 || !e4.length)
              return;
            this.currentStencilSource = t3.source;
            const i4 = this.context, s4 = i4.gl;
            this.nextStencilID + e4.length > 256 && this.clearStencil(), i4.setColorMode(Ai.disabled), i4.setDepthMode(Li.disabled);
            const a3 = this.useProgram("clippingMask");
            this._tileClippingMaskIDs = {};
            for (const t4 of e4) {
              const e5 = this._tileClippingMaskIDs[t4.key] = this.nextStencilID++, o3 = this.style.map.terrain && this.style.map.terrain.getTerrainData(t4);
              a3.draw(i4, s4.TRIANGLES, Li.disabled, new Fi({ func: s4.ALWAYS, mask: 0 }, e5, 255, s4.KEEP, s4.KEEP, s4.REPLACE), Ai.disabled, Bi.disabled, Ce(t4.posMatrix), o3, "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const t3 = this.nextStencilID++, e4 = this.context.gl;
            return new Fi({ func: e4.NOTEQUAL, mask: 255 }, t3, 255, e4.KEEP, e4.KEEP, e4.REPLACE);
          }
          stencilModeForClipping(t3) {
            const e4 = this.context.gl;
            return new Fi({ func: e4.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t3.key], 0, e4.KEEP, e4.KEEP, e4.REPLACE);
          }
          stencilConfigForOverlap(t3) {
            const e4 = this.context.gl, i4 = t3.sort((t4, e5) => e5.overscaledZ - t4.overscaledZ), s4 = i4[i4.length - 1].overscaledZ, a3 = i4[0].overscaledZ - s4 + 1;
            if (a3 > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + a3 > 256 && this.clearStencil();
              const t4 = {};
              for (let i5 = 0; i5 < a3; i5++)
                t4[i5 + s4] = new Fi({ func: e4.GEQUAL, mask: 255 }, i5 + this.nextStencilID, 255, e4.KEEP, e4.KEEP, e4.REPLACE);
              return this.nextStencilID += a3, [t4, i4];
            }
            return [{ [s4]: Fi.disabled }, i4];
          }
          colorModeForRenderPass() {
            const t3 = this.context.gl;
            if (this._showOverdrawInspector) {
              const i4 = 1 / 8;
              return new Ai([t3.CONSTANT_COLOR, t3.ONE], new e3.aO(i4, i4, i4, 0), [true, true, true, true]);
            }
            return "opaque" === this.renderPass ? Ai.unblended : Ai.alphaBlended;
          }
          depthModeForSublayer(t3, e4, i4) {
            if (!this.opaquePassEnabledForLayer())
              return Li.disabled;
            const s4 = 1 - ((1 + this.currentLayer) * this.numSublayers + t3) * this.depthEpsilon;
            return new Li(i4 || this.context.gl.LEQUAL, e4, [s4, s4]);
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff;
          }
          render(t3, i4) {
            this.style = t3, this.options = i4, this.lineAtlas = t3.lineAtlas, this.imageManager = t3.imageManager, this.glyphManager = t3.glyphManager, this.symbolFadeChange = t3.placement.symbolFadeChange(o2.now()), this.imageManager.beginFrame();
            const s4 = this.style._order, a3 = this.style.sourceCaches, r5 = {}, n3 = {}, l4 = {};
            for (const t4 in a3) {
              const e4 = a3[t4];
              e4.used && e4.prepare(this.context), r5[t4] = e4.getVisibleCoordinates(), n3[t4] = r5[t4].slice().reverse(), l4[t4] = e4.getVisibleCoordinates(true).reverse();
            }
            this.opaquePassCutoff = 1 / 0;
            for (let t4 = 0; t4 < s4.length; t4++)
              if (this.style._layers[s4[t4]].is3D()) {
                this.opaquePassCutoff = t4;
                break;
              }
            if (this.renderToTexture) {
              this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0;
              const t4 = this.style.map.terrain.sourceCache.tilesAfterTime(this.terrainFacilitator.renderTime);
              (this.terrainFacilitator.dirty || !e3.aY(this.terrainFacilitator.matrix, this.transform.projMatrix) || t4.length) && (e3.aZ(this.terrainFacilitator.matrix, this.transform.projMatrix), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = false, function(t5, i5) {
                const s5 = t5.context, a4 = s5.gl, o3 = Ai.unblended, r6 = new Li(a4.LEQUAL, Li.ReadWrite, [0, 1]), n4 = i5.getTerrainMesh(), l5 = i5.sourceCache.getRenderableTiles(), h2 = t5.useProgram("terrainDepth");
                s5.bindFramebuffer.set(i5.getFramebuffer("depth").framebuffer), s5.viewport.set([0, 0, t5.width / devicePixelRatio, t5.height / devicePixelRatio]), s5.clear({ color: e3.aO.transparent, depth: 1 });
                for (const e4 of l5) {
                  const l6 = i5.getTerrainData(e4.tileID), c3 = { u_matrix: t5.transform.calculatePosMatrix(e4.tileID.toUnwrapped()), u_ele_delta: i5.getMeshFrameDelta(t5.transform.zoom) };
                  h2.draw(s5, a4.TRIANGLES, r6, Fi.disabled, o3, Bi.backCCW, c3, l6, "terrain", n4.vertexBuffer, n4.indexBuffer, n4.segments);
                }
                s5.bindFramebuffer.set(null), s5.viewport.set([0, 0, t5.width, t5.height]);
              }(this, this.style.map.terrain), function(t5, i5) {
                const s5 = t5.context, a4 = s5.gl, o3 = Ai.unblended, r6 = new Li(a4.LEQUAL, Li.ReadWrite, [0, 1]), n4 = i5.getTerrainMesh(), l5 = i5.getCoordsTexture(), h2 = i5.sourceCache.getRenderableTiles(), c3 = t5.useProgram("terrainCoords");
                s5.bindFramebuffer.set(i5.getFramebuffer("coords").framebuffer), s5.viewport.set([0, 0, t5.width / devicePixelRatio, t5.height / devicePixelRatio]), s5.clear({ color: e3.aO.transparent, depth: 1 }), i5.coordsIndex = [];
                for (const e4 of h2) {
                  const h3 = i5.getTerrainData(e4.tileID);
                  s5.activeTexture.set(a4.TEXTURE0), a4.bindTexture(a4.TEXTURE_2D, l5.texture);
                  const u3 = { u_matrix: t5.transform.calculatePosMatrix(e4.tileID.toUnwrapped()), u_terrain_coords_id: (255 - i5.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: i5.getMeshFrameDelta(t5.transform.zoom) };
                  c3.draw(s5, a4.TRIANGLES, r6, Fi.disabled, o3, Bi.backCCW, u3, h3, "terrain", n4.vertexBuffer, n4.indexBuffer, n4.segments), i5.coordsIndex.push(e4.tileID.key);
                }
                s5.bindFramebuffer.set(null), s5.viewport.set([0, 0, t5.width, t5.height]);
              }(this, this.style.map.terrain));
            }
            this.renderPass = "offscreen";
            for (const t4 of s4) {
              const e4 = this.style._layers[t4];
              if (!e4.hasOffscreenPass() || e4.isHidden(this.transform.zoom))
                continue;
              const i5 = n3[e4.source];
              ("custom" === e4.type || i5.length) && this.renderLayer(this, a3[e4.source], e4, i5);
            }
            if (this.context.bindFramebuffer.set(null), this.context.clear({ color: i4.showOverdrawInspector ? e3.aO.black : e3.aO.transparent, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = i4.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (t3._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture)
              for (this.renderPass = "opaque", this.currentLayer = s4.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                const t4 = this.style._layers[s4[this.currentLayer]], e4 = a3[t4.source], i5 = r5[t4.source];
                this._renderTileClippingMasks(t4, i5), this.renderLayer(this, e4, t4, i5);
              }
            for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < s4.length; this.currentLayer++) {
              const t4 = this.style._layers[s4[this.currentLayer]], e4 = a3[t4.source];
              if (this.renderToTexture && this.renderToTexture.renderLayer(t4))
                continue;
              const i5 = ("symbol" === t4.type ? l4 : n3)[t4.source];
              this._renderTileClippingMasks(t4, r5[t4.source]), this.renderLayer(this, e4, t4, i5);
            }
            if (this.options.showTileBoundaries) {
              const t4 = function(t5, e4) {
                let i5 = null;
                const s5 = Object.values(t5._layers).flatMap((i6) => i6.source && !i6.isHidden(e4) ? [t5.sourceCaches[i6.source]] : []), a4 = s5.filter((t6) => "vector" === t6.getSource().type), o3 = s5.filter((t6) => "vector" !== t6.getSource().type), r6 = (t6) => {
                  (!i5 || i5.getSource().maxzoom < t6.getSource().maxzoom) && (i5 = t6);
                };
                return a4.forEach((t6) => r6(t6)), i5 || o3.forEach((t6) => r6(t6)), i5;
              }(this.style, this.transform.zoom);
              t4 && function(t5, e4, i5) {
                for (let s5 = 0; s5 < i5.length; s5++)
                  rs(t5, e4, i5[s5]);
              }(this, t4, t4.getVisibleCoordinates());
            }
            this.options.showPadding && function(t4) {
              const e4 = t4.transform.padding;
              ss(t4, t4.transform.height - (e4.top || 0), 3, Ji), ss(t4, e4.bottom || 0, 3, Qi), as(t4, e4.left || 0, 3, ts), as(t4, t4.transform.width - (e4.right || 0), 3, es);
              const i5 = t4.transform.centerPoint;
              !function(t5, e5, i6, s5) {
                os(t5, e5 - 1, i6 - 10, 2, 20, s5), os(t5, e5 - 10, i6 - 1, 20, 2, s5);
              }(t4, i5.x, t4.transform.height - i5.y, is);
            }(this), this.context.setDefault();
          }
          renderLayer(t3, i4, s4, a3) {
            if (!s4.isHidden(this.transform.zoom) && ("background" === s4.type || "custom" === s4.type || (a3 || []).length))
              switch (this.id = s4.id, s4.type) {
                case "symbol":
                  !function(t4, i5, s5, a4, o3) {
                    if ("translucent" !== t4.renderPass)
                      return;
                    const r5 = Fi.disabled, n3 = t4.colorModeForRenderPass();
                    (s5._unevaluatedLayout.hasValue("text-variable-anchor") || s5._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && function(t5, i6, s6, a5, o4, r6, n4) {
                      const l4 = i6.transform, h2 = "map" === o4, c3 = "map" === r6;
                      for (const o5 of t5) {
                        const t6 = a5.getTile(o5), r7 = t6.getBucket(s6);
                        if (!r7 || !r7.text || !r7.text.segments.get().length)
                          continue;
                        const u3 = e3.ag(r7.textSizeData, l4.zoom), d2 = Lt(t6, 1, i6.transform.zoom), _2 = mt(o5.posMatrix, c3, h2, i6.transform, d2), p4 = "none" !== s6.layout.get("icon-text-fit") && r7.hasIconData();
                        if (u3) {
                          const e4 = Math.pow(2, l4.zoom - t6.tileID.overscaledZ);
                          Gi(r7, h2, c3, n4, l4, _2, o5.posMatrix, e4, u3, p4, i6.style.map.terrain ? (t7, e5) => i6.style.map.terrain.getElevation(o5, t7, e5) : null);
                        }
                      }
                    }(a4, t4, s5, i5, s5.layout.get("text-rotation-alignment"), s5.layout.get("text-pitch-alignment"), o3), 0 !== s5.paint.get("icon-opacity").constantOr(1) && qi(t4, i5, s5, a4, false, s5.paint.get("icon-translate"), s5.paint.get("icon-translate-anchor"), s5.layout.get("icon-rotation-alignment"), s5.layout.get("icon-pitch-alignment"), s5.layout.get("icon-keep-upright"), r5, n3), 0 !== s5.paint.get("text-opacity").constantOr(1) && qi(t4, i5, s5, a4, true, s5.paint.get("text-translate"), s5.paint.get("text-translate-anchor"), s5.layout.get("text-rotation-alignment"), s5.layout.get("text-pitch-alignment"), s5.layout.get("text-keep-upright"), r5, n3), i5.map.showCollisionBoxes && (Ni(t4, i5, s5, a4, s5.paint.get("text-translate"), s5.paint.get("text-translate-anchor"), true), Ni(t4, i5, s5, a4, s5.paint.get("icon-translate"), s5.paint.get("icon-translate-anchor"), false));
                  }(t3, i4, s4, a3, this.style.placement.variableOffsets);
                  break;
                case "circle":
                  !function(t4, i5, s5, a4) {
                    if ("translucent" !== t4.renderPass)
                      return;
                    const o3 = s5.paint.get("circle-opacity"), r5 = s5.paint.get("circle-stroke-width"), n3 = s5.paint.get("circle-stroke-opacity"), l4 = !s5.layout.get("circle-sort-key").isConstant();
                    if (0 === o3.constantOr(1) && (0 === r5.constantOr(1) || 0 === n3.constantOr(1)))
                      return;
                    const h2 = t4.context, c3 = h2.gl, u3 = t4.depthModeForSublayer(0, Li.ReadOnly), d2 = Fi.disabled, _2 = t4.colorModeForRenderPass(), p4 = [];
                    for (let o4 = 0; o4 < a4.length; o4++) {
                      const r6 = a4[o4], n4 = i5.getTile(r6), h3 = n4.getBucket(s5);
                      if (!h3)
                        continue;
                      const c4 = h3.programConfigurations.get(s5.id), u4 = t4.useProgram("circle", c4), d3 = h3.layoutVertexBuffer, _3 = h3.indexBuffer, m2 = t4.style.map.terrain && t4.style.map.terrain.getTerrainData(r6), f2 = { programConfiguration: c4, program: u4, layoutVertexBuffer: d3, indexBuffer: _3, uniformValues: Ie2(t4, r6, n4, s5), terrainData: m2 };
                      if (l4) {
                        const t5 = h3.segments.get();
                        for (const i6 of t5)
                          p4.push({ segments: new e3.$([i6]), sortKey: i6.sortKey, state: f2 });
                      } else
                        p4.push({ segments: h3.segments, sortKey: 0, state: f2 });
                    }
                    l4 && p4.sort((t5, e4) => t5.sortKey - e4.sortKey);
                    for (const e4 of p4) {
                      const { programConfiguration: i6, program: a5, layoutVertexBuffer: o4, indexBuffer: r6, uniformValues: n4, terrainData: l5 } = e4.state;
                      a5.draw(h2, c3.TRIANGLES, u3, d2, _2, Bi.disabled, n4, l5, s5.id, o4, r6, e4.segments, s5.paint, t4.transform.zoom, i6);
                    }
                  }(t3, i4, s4, a3);
                  break;
                case "heatmap":
                  !function(t4, i5, s5, a4) {
                    if (0 !== s5.paint.get("heatmap-opacity"))
                      if ("offscreen" === t4.renderPass) {
                        const o3 = t4.context, r5 = o3.gl, n3 = Fi.disabled, l4 = new Ai([r5.ONE, r5.ONE], e3.aO.transparent, [true, true, true, true]);
                        !function(t5, e4, i6) {
                          const s6 = t5.gl;
                          t5.activeTexture.set(s6.TEXTURE1), t5.viewport.set([0, 0, e4.width / 4, e4.height / 4]);
                          let a5 = i6.heatmapFbo;
                          if (a5)
                            s6.bindTexture(s6.TEXTURE_2D, a5.colorAttachment.get()), t5.bindFramebuffer.set(a5.framebuffer);
                          else {
                            const o4 = s6.createTexture();
                            s6.bindTexture(s6.TEXTURE_2D, o4), s6.texParameteri(s6.TEXTURE_2D, s6.TEXTURE_WRAP_S, s6.CLAMP_TO_EDGE), s6.texParameteri(s6.TEXTURE_2D, s6.TEXTURE_WRAP_T, s6.CLAMP_TO_EDGE), s6.texParameteri(s6.TEXTURE_2D, s6.TEXTURE_MIN_FILTER, s6.LINEAR), s6.texParameteri(s6.TEXTURE_2D, s6.TEXTURE_MAG_FILTER, s6.LINEAR), a5 = i6.heatmapFbo = t5.createFramebuffer(e4.width / 4, e4.height / 4, false, false), function(t6, e5, i7, s7) {
                              var a6, o5;
                              const r6 = t6.gl, n4 = null !== (a6 = t6.HALF_FLOAT) && void 0 !== a6 ? a6 : r6.UNSIGNED_BYTE, l5 = null !== (o5 = t6.RGBA16F) && void 0 !== o5 ? o5 : r6.RGBA;
                              r6.texImage2D(r6.TEXTURE_2D, 0, l5, e5.width / 4, e5.height / 4, 0, r6.RGBA, n4, null), s7.colorAttachment.set(i7);
                            }(t5, e4, o4, a5);
                          }
                        }(o3, t4, s5), o3.clear({ color: e3.aO.transparent });
                        for (let e4 = 0; e4 < a4.length; e4++) {
                          const h2 = a4[e4];
                          if (i5.hasRenderableParent(h2))
                            continue;
                          const c3 = i5.getTile(h2), u3 = c3.getBucket(s5);
                          if (!u3)
                            continue;
                          const d2 = u3.programConfigurations.get(s5.id), _2 = t4.useProgram("heatmap", d2), { zoom: p4 } = t4.transform;
                          _2.draw(o3, r5.TRIANGLES, Li.disabled, n3, l4, Bi.disabled, Pe2(h2.posMatrix, c3, p4, s5.paint.get("heatmap-intensity")), null, s5.id, u3.layoutVertexBuffer, u3.indexBuffer, u3.segments, s5.paint, t4.transform.zoom, d2);
                        }
                        o3.viewport.set([0, 0, t4.width, t4.height]);
                      } else
                        "translucent" === t4.renderPass && (t4.context.setColorMode(t4.colorModeForRenderPass()), function(t5, i6) {
                          const s6 = t5.context, a5 = s6.gl, o3 = i6.heatmapFbo;
                          if (!o3)
                            return;
                          s6.activeTexture.set(a5.TEXTURE0), a5.bindTexture(a5.TEXTURE_2D, o3.colorAttachment.get()), s6.activeTexture.set(a5.TEXTURE1);
                          let r5 = i6.colorRampTexture;
                          r5 || (r5 = i6.colorRampTexture = new w3(s6, i6.colorRamp, a5.RGBA)), r5.bind(a5.LINEAR, a5.CLAMP_TO_EDGE), t5.useProgram("heatmapTexture").draw(s6, a5.TRIANGLES, Li.disabled, Fi.disabled, t5.colorModeForRenderPass(), Bi.disabled, ((t6, i7, s7, a6) => {
                            const o4 = e3.F();
                            e3.aN(o4, 0, t6.width, t6.height, 0, 0, 1);
                            const r6 = t6.context.gl;
                            return { u_matrix: o4, u_world: [r6.drawingBufferWidth, r6.drawingBufferHeight], u_image: 0, u_color_ramp: 1, u_opacity: i7.paint.get("heatmap-opacity") };
                          })(t5, i6), null, i6.id, t5.viewportBuffer, t5.quadTriangleIndexBuffer, t5.viewportSegments, i6.paint, t5.transform.zoom);
                        }(t4, s5));
                  }(t3, i4, s4, a3);
                  break;
                case "line":
                  !function(t4, i5, s5, a4) {
                    if ("translucent" !== t4.renderPass)
                      return;
                    const o3 = s5.paint.get("line-opacity"), r5 = s5.paint.get("line-width");
                    if (0 === o3.constantOr(1) || 0 === r5.constantOr(1))
                      return;
                    const n3 = t4.depthModeForSublayer(0, Li.ReadOnly), l4 = t4.colorModeForRenderPass(), h2 = s5.paint.get("line-dasharray"), c3 = s5.paint.get("line-pattern"), u3 = c3.constantOr(1), d2 = s5.paint.get("line-gradient"), _2 = s5.getCrossfadeParameters(), p4 = u3 ? "linePattern" : h2 ? "lineSDF" : d2 ? "lineGradient" : "line", m2 = t4.context, f2 = m2.gl;
                    let g3 = true;
                    for (const o4 of a4) {
                      const a5 = i5.getTile(o4);
                      if (u3 && !a5.patternsLoaded())
                        continue;
                      const r6 = a5.getBucket(s5);
                      if (!r6)
                        continue;
                      const v4 = r6.programConfigurations.get(s5.id), x5 = t4.context.program.get(), y4 = t4.useProgram(p4, v4), b3 = g3 || y4.program !== x5, T3 = t4.style.map.terrain && t4.style.map.terrain.getTerrainData(o4), I3 = c3.constantOr(null);
                      if (I3 && a5.imageAtlas) {
                        const t5 = a5.imageAtlas, e4 = t5.patternPositions[I3.to.toString()], i6 = t5.patternPositions[I3.from.toString()];
                        e4 && i6 && v4.setConstantPatternPositions(e4, i6);
                      }
                      const E3 = T3 ? o4 : null, S4 = u3 ? Ae2(t4, a5, s5, _2, E3) : h2 ? Re2(t4, a5, s5, h2, _2, E3) : d2 ? Me(t4, a5, s5, r6.lineClipsArray.length, E3) : ze(t4, a5, s5, E3);
                      if (u3)
                        m2.activeTexture.set(f2.TEXTURE0), a5.imageAtlasTexture.bind(f2.LINEAR, f2.CLAMP_TO_EDGE), v4.updatePaintBuffers(_2);
                      else if (h2 && (b3 || t4.lineAtlas.dirty))
                        m2.activeTexture.set(f2.TEXTURE0), t4.lineAtlas.bind(m2);
                      else if (d2) {
                        const a6 = r6.gradients[s5.id];
                        let n4 = a6.texture;
                        if (s5.gradientVersion !== a6.version) {
                          let l5 = 256;
                          if (s5.stepInterpolant) {
                            const s6 = i5.getSource().maxzoom, a7 = o4.canonical.z === s6 ? Math.ceil(1 << t4.transform.maxZoom - o4.canonical.z) : 1;
                            l5 = e3.ac(e3.aT(r6.maxLineLength / e3.W * 1024 * a7), 256, m2.maxTextureSize);
                          }
                          a6.gradient = e3.aU({ expression: s5.gradientExpression(), evaluationKey: "lineProgress", resolution: l5, image: a6.gradient || void 0, clips: r6.lineClipsArray }), a6.texture ? a6.texture.update(a6.gradient) : a6.texture = new w3(m2, a6.gradient, f2.RGBA), a6.version = s5.gradientVersion, n4 = a6.texture;
                        }
                        m2.activeTexture.set(f2.TEXTURE0), n4.bind(s5.stepInterpolant ? f2.NEAREST : f2.LINEAR, f2.CLAMP_TO_EDGE);
                      }
                      y4.draw(m2, f2.TRIANGLES, n3, t4.stencilModeForClipping(o4), l4, Bi.disabled, S4, T3, s5.id, r6.layoutVertexBuffer, r6.indexBuffer, r6.segments, s5.paint, t4.transform.zoom, v4, r6.layoutVertexBuffer2), g3 = false;
                    }
                  }(t3, i4, s4, a3);
                  break;
                case "fill":
                  !function(t4, i5, s5, a4) {
                    const o3 = s5.paint.get("fill-color"), r5 = s5.paint.get("fill-opacity");
                    if (0 === r5.constantOr(1))
                      return;
                    const n3 = t4.colorModeForRenderPass(), l4 = s5.paint.get("fill-pattern"), h2 = t4.opaquePassEnabledForLayer() && !l4.constantOr(1) && 1 === o3.constantOr(e3.aO.transparent).a && 1 === r5.constantOr(0) ? "opaque" : "translucent";
                    if (t4.renderPass === h2) {
                      const e4 = t4.depthModeForSublayer(1, "opaque" === t4.renderPass ? Li.ReadWrite : Li.ReadOnly);
                      Hi(t4, i5, s5, a4, e4, n3, false);
                    }
                    if ("translucent" === t4.renderPass && s5.paint.get("fill-antialias")) {
                      const e4 = t4.depthModeForSublayer(s5.getPaintProperty("fill-outline-color") ? 2 : 0, Li.ReadOnly);
                      Hi(t4, i5, s5, a4, e4, n3, true);
                    }
                  }(t3, i4, s4, a3);
                  break;
                case "fill-extrusion":
                  !function(t4, e4, i5, s5) {
                    const a4 = i5.paint.get("fill-extrusion-opacity");
                    if (0 !== a4 && "translucent" === t4.renderPass) {
                      const o3 = new Li(t4.context.gl.LEQUAL, Li.ReadWrite, t4.depthRangeFor3D);
                      if (1 !== a4 || i5.paint.get("fill-extrusion-pattern").constantOr(1))
                        $i(t4, e4, i5, s5, o3, Fi.disabled, Ai.disabled), $i(t4, e4, i5, s5, o3, t4.stencilModeFor3D(), t4.colorModeForRenderPass());
                      else {
                        const a5 = t4.colorModeForRenderPass();
                        $i(t4, e4, i5, s5, o3, Fi.disabled, a5);
                      }
                    }
                  }(t3, i4, s4, a3);
                  break;
                case "hillshade":
                  !function(t4, e4, i5, s5) {
                    if ("offscreen" !== t4.renderPass && "translucent" !== t4.renderPass)
                      return;
                    const a4 = t4.context, o3 = t4.depthModeForSublayer(0, Li.ReadOnly), r5 = t4.colorModeForRenderPass(), [n3, l4] = "translucent" === t4.renderPass ? t4.stencilConfigForOverlap(s5) : [{}, s5];
                    for (const s6 of l4) {
                      const a5 = e4.getTile(s6);
                      void 0 !== a5.needsHillshadePrepare && a5.needsHillshadePrepare && "offscreen" === t4.renderPass ? Ki(t4, a5, i5, o3, Fi.disabled, r5) : "translucent" === t4.renderPass && Xi(t4, s6, a5, i5, o3, n3[s6.overscaledZ], r5);
                    }
                    a4.viewport.set([0, 0, t4.width, t4.height]);
                  }(t3, i4, s4, a3);
                  break;
                case "raster":
                  !function(t4, e4, i5, s5) {
                    if ("translucent" !== t4.renderPass)
                      return;
                    if (0 === i5.paint.get("raster-opacity"))
                      return;
                    if (!s5.length)
                      return;
                    const a4 = t4.context, o3 = a4.gl, r5 = e4.getSource(), n3 = t4.useProgram("raster"), l4 = t4.colorModeForRenderPass(), [h2, c3] = r5 instanceof J3 ? [{}, s5] : t4.stencilConfigForOverlap(s5), u3 = c3[c3.length - 1].overscaledZ, d2 = !t4.options.moving;
                    for (const s6 of c3) {
                      const c4 = t4.depthModeForSublayer(s6.overscaledZ - u3, 1 === i5.paint.get("raster-opacity") ? Li.ReadWrite : Li.ReadOnly, o3.LESS), _2 = e4.getTile(s6);
                      _2.registerFadeDuration(i5.paint.get("raster-fade-duration"));
                      const p4 = e4.findLoadedParent(s6, 0), m2 = Yi(_2, p4, e4, i5, t4.transform, t4.style.map.terrain);
                      let f2, g3;
                      const v4 = "nearest" === i5.paint.get("raster-resampling") ? o3.NEAREST : o3.LINEAR;
                      a4.activeTexture.set(o3.TEXTURE0), _2.texture.bind(v4, o3.CLAMP_TO_EDGE, o3.LINEAR_MIPMAP_NEAREST), a4.activeTexture.set(o3.TEXTURE1), p4 ? (p4.texture.bind(v4, o3.CLAMP_TO_EDGE, o3.LINEAR_MIPMAP_NEAREST), f2 = Math.pow(2, p4.tileID.overscaledZ - _2.tileID.overscaledZ), g3 = [_2.tileID.canonical.x * f2 % 1, _2.tileID.canonical.y * f2 % 1]) : _2.texture.bind(v4, o3.CLAMP_TO_EDGE, o3.LINEAR_MIPMAP_NEAREST);
                      const x5 = t4.style.map.terrain && t4.style.map.terrain.getTerrainData(s6), y4 = x5 ? s6 : null, b3 = y4 ? y4.posMatrix : t4.transform.calculatePosMatrix(s6.toUnwrapped(), d2), w4 = Fe(b3, g3 || [0, 0], f2 || 1, m2, i5);
                      r5 instanceof J3 ? n3.draw(a4, o3.TRIANGLES, c4, Fi.disabled, l4, Bi.disabled, w4, x5, i5.id, r5.boundsBuffer, t4.quadTriangleIndexBuffer, r5.boundsSegments) : n3.draw(a4, o3.TRIANGLES, c4, h2[s6.overscaledZ], l4, Bi.disabled, w4, x5, i5.id, t4.rasterBoundsBuffer, t4.quadTriangleIndexBuffer, t4.rasterBoundsSegments);
                    }
                  }(t3, i4, s4, a3);
                  break;
                case "background":
                  !function(t4, e4, i5, s5) {
                    const a4 = i5.paint.get("background-color"), o3 = i5.paint.get("background-opacity");
                    if (0 === o3)
                      return;
                    const r5 = t4.context, n3 = r5.gl, l4 = t4.transform, h2 = l4.tileSize, c3 = i5.paint.get("background-pattern");
                    if (t4.isPatternMissing(c3))
                      return;
                    const u3 = !c3 && 1 === a4.a && 1 === o3 && t4.opaquePassEnabledForLayer() ? "opaque" : "translucent";
                    if (t4.renderPass !== u3)
                      return;
                    const d2 = Fi.disabled, _2 = t4.depthModeForSublayer(0, "opaque" === u3 ? Li.ReadWrite : Li.ReadOnly), p4 = t4.colorModeForRenderPass(), m2 = t4.useProgram(c3 ? "backgroundPattern" : "background"), f2 = s5 || l4.coveringTiles({ tileSize: h2, terrain: t4.style.map.terrain });
                    c3 && (r5.activeTexture.set(n3.TEXTURE0), t4.imageManager.bind(t4.context));
                    const g3 = i5.getCrossfadeParameters();
                    for (const e5 of f2) {
                      const l5 = s5 ? e5.posMatrix : t4.transform.calculatePosMatrix(e5.toUnwrapped()), u4 = c3 ? Ge(l5, o3, t4, c3, { tileID: e5, tileSize: h2 }, g3) : Ze(l5, o3, a4), f3 = t4.style.map.terrain && t4.style.map.terrain.getTerrainData(e5);
                      m2.draw(r5, n3.TRIANGLES, _2, d2, p4, Bi.disabled, u4, f3, i5.id, t4.tileExtentBuffer, t4.quadTriangleIndexBuffer, t4.tileExtentSegments);
                    }
                  }(t3, 0, s4, a3);
                  break;
                case "custom":
                  !function(t4, e4, i5) {
                    const s5 = t4.context, a4 = i5.implementation;
                    if ("offscreen" === t4.renderPass) {
                      const e5 = a4.prerender;
                      e5 && (t4.setCustomLayerDefaults(), s5.setColorMode(t4.colorModeForRenderPass()), e5.call(a4, s5.gl, t4.transform.customLayerMatrix()), s5.setDirty(), t4.setBaseState());
                    } else if ("translucent" === t4.renderPass) {
                      t4.setCustomLayerDefaults(), s5.setColorMode(t4.colorModeForRenderPass()), s5.setStencilMode(Fi.disabled);
                      const e5 = "3d" === a4.renderingMode ? new Li(t4.context.gl.LEQUAL, Li.ReadWrite, t4.depthRangeFor3D) : t4.depthModeForSublayer(0, Li.ReadOnly);
                      s5.setDepthMode(e5), a4.render(s5.gl, t4.transform.customLayerMatrix()), s5.setDirty(), t4.setBaseState(), s5.bindFramebuffer.set(null);
                    }
                  }(t3, 0, s4);
              }
          }
          translatePosMatrix(t3, i4, s4, a3, o3) {
            if (!s4[0] && !s4[1])
              return t3;
            const r5 = o3 ? "map" === a3 ? this.transform.angle : 0 : "viewport" === a3 ? -this.transform.angle : 0;
            if (r5) {
              const t4 = Math.sin(r5), e4 = Math.cos(r5);
              s4 = [s4[0] * e4 - s4[1] * t4, s4[0] * t4 + s4[1] * e4];
            }
            const n3 = [o3 ? s4[0] : Lt(i4, s4[0], this.transform.zoom), o3 ? s4[1] : Lt(i4, s4[1], this.transform.zoom), 0], l4 = new Float32Array(16);
            return e3.H(l4, t3, n3), l4;
          }
          saveTileTexture(t3) {
            const e4 = this._tileTextures[t3.size[0]];
            e4 ? e4.push(t3) : this._tileTextures[t3.size[0]] = [t3];
          }
          getTileTexture(t3) {
            const e4 = this._tileTextures[t3];
            return e4 && e4.length > 0 ? e4.pop() : null;
          }
          isPatternMissing(t3) {
            if (!t3)
              return false;
            if (!t3.from || !t3.to)
              return true;
            const e4 = this.imageManager.getPattern(t3.from.toString()), i4 = this.imageManager.getPattern(t3.to.toString());
            return !e4 || !i4;
          }
          useProgram(t3, e4) {
            this.cache = this.cache || {};
            const i4 = t3 + (e4 ? e4.cacheKey : "") + (this._showOverdrawInspector ? "/overdraw" : "") + (this.style.map.terrain ? "/terrain" : "");
            return this.cache[i4] || (this.cache[i4] = new fe(this.context, de[t3], e4, je[t3], this._showOverdrawInspector, this.style.map.terrain)), this.cache[i4];
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
          }
          setBaseState() {
            const t3 = this.context.gl;
            this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(t3.FUNC_ADD);
          }
          initDebugOverlayCanvas() {
            null == this.debugOverlayCanvas && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new w3(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
          }
          destroy() {
            this.debugOverlayTexture && this.debugOverlayTexture.destroy();
          }
          overLimit() {
            const { drawingBufferWidth: t3, drawingBufferHeight: e4 } = this.context.gl;
            return this.width !== t3 || this.height !== e4;
          }
        }
        class hs {
          constructor(t3, e4) {
            this.points = t3, this.planes = e4;
          }
          static fromInvProjectionMatrix(t3, i4, s4) {
            const a3 = Math.pow(2, s4), o3 = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((s5) => {
              const o4 = 1 / (s5 = e3.af([], s5, t3))[3] / i4 * a3;
              return e3.a_(s5, s5, [o4, o4, 1 / s5[3], o4]);
            }), r5 = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((t4) => {
              const e4 = function(t5, e5) {
                var i6 = e5[0], s6 = e5[1], a5 = e5[2], o4 = i6 * i6 + s6 * s6 + a5 * a5;
                return o4 > 0 && (o4 = 1 / Math.sqrt(o4)), t5[0] = e5[0] * o4, t5[1] = e5[1] * o4, t5[2] = e5[2] * o4, t5;
              }([], function(t5, e5, i6) {
                var s6 = e5[0], a5 = e5[1], o4 = e5[2], r6 = i6[0], n3 = i6[1], l4 = i6[2];
                return t5[0] = a5 * l4 - o4 * n3, t5[1] = o4 * r6 - s6 * l4, t5[2] = s6 * n3 - a5 * r6, t5;
              }([], x4([], o3[t4[0]], o3[t4[1]]), x4([], o3[t4[2]], o3[t4[1]]))), i5 = -((s5 = e4)[0] * (a4 = o3[t4[1]])[0] + s5[1] * a4[1] + s5[2] * a4[2]);
              var s5, a4;
              return e4.concat(i5);
            });
            return new hs(o3, r5);
          }
        }
        class cs {
          constructor(t3, e4) {
            this.min = t3, this.max = e4, this.center = function(t4, e5, i4) {
              return t4[0] = 0.5 * e5[0], t4[1] = 0.5 * e5[1], t4[2] = 0.5 * e5[2], t4;
            }([], function(t4, e5, i4) {
              return t4[0] = e5[0] + i4[0], t4[1] = e5[1] + i4[1], t4[2] = e5[2] + i4[2], t4;
            }([], this.min, this.max));
          }
          quadrant(t3) {
            const e4 = [t3 % 2 == 0, t3 < 2], i4 = g2(this.min), s4 = g2(this.max);
            for (let t4 = 0; t4 < e4.length; t4++)
              i4[t4] = e4[t4] ? this.min[t4] : this.center[t4], s4[t4] = e4[t4] ? this.center[t4] : this.max[t4];
            return s4[2] = this.max[2], new cs(i4, s4);
          }
          distanceX(t3) {
            return Math.max(Math.min(this.max[0], t3[0]), this.min[0]) - t3[0];
          }
          distanceY(t3) {
            return Math.max(Math.min(this.max[1], t3[1]), this.min[1]) - t3[1];
          }
          intersects(t3) {
            const i4 = [[this.min[0], this.min[1], this.min[2], 1], [this.max[0], this.min[1], this.min[2], 1], [this.max[0], this.max[1], this.min[2], 1], [this.min[0], this.max[1], this.min[2], 1], [this.min[0], this.min[1], this.max[2], 1], [this.max[0], this.min[1], this.max[2], 1], [this.max[0], this.max[1], this.max[2], 1], [this.min[0], this.max[1], this.max[2], 1]];
            let s4 = true;
            for (let a3 = 0; a3 < t3.planes.length; a3++) {
              const o3 = t3.planes[a3];
              let r5 = 0;
              for (let t4 = 0; t4 < i4.length; t4++)
                e3.a$(o3, i4[t4]) >= 0 && r5++;
              if (0 === r5)
                return 0;
              r5 !== i4.length && (s4 = false);
            }
            if (s4)
              return 2;
            for (let e4 = 0; e4 < 3; e4++) {
              let i5 = Number.MAX_VALUE, s5 = -Number.MAX_VALUE;
              for (let a3 = 0; a3 < t3.points.length; a3++) {
                const o3 = t3.points[a3][e4] - this.min[e4];
                i5 = Math.min(i5, o3), s5 = Math.max(s5, o3);
              }
              if (s5 < 0 || i5 > this.max[e4] - this.min[e4])
                return 0;
            }
            return 1;
          }
        }
        class us {
          constructor(t3 = 0, e4 = 0, i4 = 0, s4 = 0) {
            if (isNaN(t3) || t3 < 0 || isNaN(e4) || e4 < 0 || isNaN(i4) || i4 < 0 || isNaN(s4) || s4 < 0)
              throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = t3, this.bottom = e4, this.left = i4, this.right = s4;
          }
          interpolate(t3, i4, s4) {
            return null != i4.top && null != t3.top && (this.top = e3.z.number(t3.top, i4.top, s4)), null != i4.bottom && null != t3.bottom && (this.bottom = e3.z.number(t3.bottom, i4.bottom, s4)), null != i4.left && null != t3.left && (this.left = e3.z.number(t3.left, i4.left, s4)), null != i4.right && null != t3.right && (this.right = e3.z.number(t3.right, i4.right, s4)), this;
          }
          getCenter(t3, i4) {
            const s4 = e3.ac((this.left + t3 - this.right) / 2, 0, t3), a3 = e3.ac((this.top + i4 - this.bottom) / 2, 0, i4);
            return new e3.P(s4, a3);
          }
          equals(t3) {
            return this.top === t3.top && this.bottom === t3.bottom && this.left === t3.left && this.right === t3.right;
          }
          clone() {
            return new us(this.top, this.bottom, this.left, this.right);
          }
          toJSON() {
            return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
          }
        }
        class ds {
          constructor(t3, i4, s4, a3, o3) {
            this.tileSize = 512, this.maxValidLatitude = 85.051129, this._renderWorldCopies = void 0 === o3 || !!o3, this._minZoom = t3 || 0, this._maxZoom = i4 || 22, this._minPitch = null == s4 ? 0 : s4, this._maxPitch = null == a3 ? 60 : a3, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new e3.M(0, 0), this._elevation = 0, this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._unmodified = true, this._edgeInsets = new us(), this._posMatrixCache = {}, this._alignedPosMatrixCache = {}, this.minElevationForCurrentTile = 0;
          }
          clone() {
            const t3 = new ds(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
            return t3.apply(this), t3;
          }
          apply(t3) {
            this.tileSize = t3.tileSize, this.latRange = t3.latRange, this.width = t3.width, this.height = t3.height, this._center = t3._center, this._elevation = t3._elevation, this.minElevationForCurrentTile = t3.minElevationForCurrentTile, this.zoom = t3.zoom, this.angle = t3.angle, this._fov = t3._fov, this._pitch = t3._pitch, this._unmodified = t3._unmodified, this._edgeInsets = t3._edgeInsets.clone(), this._calcMatrices();
          }
          get minZoom() {
            return this._minZoom;
          }
          set minZoom(t3) {
            this._minZoom !== t3 && (this._minZoom = t3, this.zoom = Math.max(this.zoom, t3));
          }
          get maxZoom() {
            return this._maxZoom;
          }
          set maxZoom(t3) {
            this._maxZoom !== t3 && (this._maxZoom = t3, this.zoom = Math.min(this.zoom, t3));
          }
          get minPitch() {
            return this._minPitch;
          }
          set minPitch(t3) {
            this._minPitch !== t3 && (this._minPitch = t3, this.pitch = Math.max(this.pitch, t3));
          }
          get maxPitch() {
            return this._maxPitch;
          }
          set maxPitch(t3) {
            this._maxPitch !== t3 && (this._maxPitch = t3, this.pitch = Math.min(this.pitch, t3));
          }
          get renderWorldCopies() {
            return this._renderWorldCopies;
          }
          set renderWorldCopies(t3) {
            void 0 === t3 ? t3 = true : null === t3 && (t3 = false), this._renderWorldCopies = t3;
          }
          get worldSize() {
            return this.tileSize * this.scale;
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2));
          }
          get size() {
            return new e3.P(this.width, this.height);
          }
          get bearing() {
            return -this.angle / Math.PI * 180;
          }
          set bearing(t3) {
            const i4 = -e3.b0(t3, -180, 180) * Math.PI / 180;
            this.angle !== i4 && (this._unmodified = false, this.angle = i4, this._calcMatrices(), this.rotationMatrix = function() {
              var t4 = new e3.A(4);
              return e3.A != Float32Array && (t4[1] = 0, t4[2] = 0), t4[0] = 1, t4[3] = 1, t4;
            }(), function(t4, e4, i5) {
              var s4 = e4[0], a3 = e4[1], o3 = e4[2], r5 = e4[3], n3 = Math.sin(i5), l4 = Math.cos(i5);
              t4[0] = s4 * l4 + o3 * n3, t4[1] = a3 * l4 + r5 * n3, t4[2] = s4 * -n3 + o3 * l4, t4[3] = a3 * -n3 + r5 * l4;
            }(this.rotationMatrix, this.rotationMatrix, this.angle));
          }
          get pitch() {
            return this._pitch / Math.PI * 180;
          }
          set pitch(t3) {
            const i4 = e3.ac(t3, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitch !== i4 && (this._unmodified = false, this._pitch = i4, this._calcMatrices());
          }
          get fov() {
            return this._fov / Math.PI * 180;
          }
          set fov(t3) {
            t3 = Math.max(0.01, Math.min(60, t3)), this._fov !== t3 && (this._unmodified = false, this._fov = t3 / 180 * Math.PI, this._calcMatrices());
          }
          get zoom() {
            return this._zoom;
          }
          set zoom(t3) {
            const e4 = Math.min(Math.max(t3, this.minZoom), this.maxZoom);
            this._zoom !== e4 && (this._unmodified = false, this._zoom = e4, this.tileZoom = Math.max(0, Math.floor(e4)), this.scale = this.zoomScale(e4), this._constrain(), this._calcMatrices());
          }
          get center() {
            return this._center;
          }
          set center(t3) {
            t3.lat === this._center.lat && t3.lng === this._center.lng || (this._unmodified = false, this._center = t3, this._constrain(), this._calcMatrices());
          }
          get elevation() {
            return this._elevation;
          }
          set elevation(t3) {
            t3 !== this._elevation && (this._elevation = t3, this._constrain(), this._calcMatrices());
          }
          get padding() {
            return this._edgeInsets.toJSON();
          }
          set padding(t3) {
            this._edgeInsets.equals(t3) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, t3, 1), this._calcMatrices());
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this.width, this.height);
          }
          isPaddingEqual(t3) {
            return this._edgeInsets.equals(t3);
          }
          interpolatePadding(t3, e4, i4) {
            this._unmodified = false, this._edgeInsets.interpolate(t3, e4, i4), this._constrain(), this._calcMatrices();
          }
          coveringZoomLevel(t3) {
            const e4 = (t3.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / t3.tileSize));
            return Math.max(0, e4);
          }
          getVisibleUnwrappedCoordinates(t3) {
            const i4 = [new e3.b1(0, t3)];
            if (this._renderWorldCopies) {
              const s4 = this.pointCoordinate(new e3.P(0, 0)), a3 = this.pointCoordinate(new e3.P(this.width, 0)), o3 = this.pointCoordinate(new e3.P(this.width, this.height)), r5 = this.pointCoordinate(new e3.P(0, this.height)), n3 = Math.floor(Math.min(s4.x, a3.x, o3.x, r5.x)), l4 = Math.floor(Math.max(s4.x, a3.x, o3.x, r5.x)), h2 = 1;
              for (let s5 = n3 - h2; s5 <= l4 + h2; s5++)
                0 !== s5 && i4.push(new e3.b1(s5, t3));
            }
            return i4;
          }
          coveringTiles(t3) {
            var i4, s4;
            let a3 = this.coveringZoomLevel(t3);
            const o3 = a3;
            if (void 0 !== t3.minzoom && a3 < t3.minzoom)
              return [];
            void 0 !== t3.maxzoom && a3 > t3.maxzoom && (a3 = t3.maxzoom);
            const r5 = this.pointCoordinate(this.getCameraPoint()), n3 = e3.Y.fromLngLat(this.center), l4 = Math.pow(2, a3), h2 = [l4 * r5.x, l4 * r5.y, 0], c3 = [l4 * n3.x, l4 * n3.y, 0], u3 = hs.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, a3);
            let d2 = t3.minzoom || 0;
            !t3.terrain && this.pitch <= 60 && this._edgeInsets.top < 0.1 && (d2 = a3);
            const _2 = t3.terrain ? 2 / Math.min(this.tileSize, t3.tileSize) * this.tileSize : 3, p4 = (t4) => ({ aabb: new cs([t4 * l4, 0, 0], [(t4 + 1) * l4, l4, 0]), zoom: 0, x: 0, y: 0, wrap: t4, fullyVisible: false }), m2 = [], f2 = [], g3 = a3, v4 = t3.reparseOverscaled ? o3 : a3;
            if (this._renderWorldCopies)
              for (let t4 = 1; t4 <= 3; t4++)
                m2.push(p4(-t4)), m2.push(p4(t4));
            for (m2.push(p4(0)); m2.length > 0; ) {
              const a4 = m2.pop(), o4 = a4.x, r6 = a4.y;
              let n4 = a4.fullyVisible;
              if (!n4) {
                const t4 = a4.aabb.intersects(u3);
                if (0 === t4)
                  continue;
                n4 = 2 === t4;
              }
              const l5 = t3.terrain ? h2 : c3, p5 = a4.aabb.distanceX(l5), x5 = a4.aabb.distanceY(l5), b3 = Math.max(Math.abs(p5), Math.abs(x5));
              if (a4.zoom === g3 || b3 > _2 + (1 << g3 - a4.zoom) - 2 && a4.zoom >= d2) {
                const t4 = g3 - a4.zoom, i5 = h2[0] - 0.5 - (o4 << t4), s5 = h2[1] - 0.5 - (r6 << t4);
                f2.push({ tileID: new e3.Q(a4.zoom === g3 ? v4 : a4.zoom, a4.wrap, a4.zoom, o4, r6), distanceSq: y3([c3[0] - 0.5 - o4, c3[1] - 0.5 - r6]), tileDistanceToCamera: Math.sqrt(i5 * i5 + s5 * s5) });
              } else
                for (let l6 = 0; l6 < 4; l6++) {
                  const h3 = (o4 << 1) + l6 % 2, c4 = (r6 << 1) + (l6 >> 1), u4 = a4.zoom + 1;
                  let d3 = a4.aabb.quadrant(l6);
                  if (t3.terrain) {
                    const o5 = new e3.Q(u4, a4.wrap, u4, h3, c4), r7 = t3.terrain.getMinMaxElevation(o5), n5 = null !== (i4 = r7.minElevation) && void 0 !== i4 ? i4 : this.elevation, l7 = null !== (s4 = r7.maxElevation) && void 0 !== s4 ? s4 : this.elevation;
                    d3 = new cs([d3.min[0], d3.min[1], n5], [d3.max[0], d3.max[1], l7]);
                  }
                  m2.push({ aabb: d3, zoom: u4, x: h3, y: c4, wrap: a4.wrap, fullyVisible: n4 });
                }
            }
            return f2.sort((t4, e4) => t4.distanceSq - e4.distanceSq).map((t4) => t4.tileID);
          }
          resize(t3, e4) {
            this.width = t3, this.height = e4, this.pixelsToGLUnits = [2 / t3, -2 / e4], this._constrain(), this._calcMatrices();
          }
          get unmodified() {
            return this._unmodified;
          }
          zoomScale(t3) {
            return Math.pow(2, t3);
          }
          scaleZoom(t3) {
            return Math.log(t3) / Math.LN2;
          }
          project(t3) {
            const i4 = e3.ac(t3.lat, -this.maxValidLatitude, this.maxValidLatitude);
            return new e3.P(e3.N(t3.lng) * this.worldSize, e3.O(i4) * this.worldSize);
          }
          unproject(t3) {
            return new e3.Y(t3.x / this.worldSize, t3.y / this.worldSize).toLngLat();
          }
          get point() {
            return this.project(this.center);
          }
          getCameraPosition() {
            return { lngLat: this.pointLocation(this.getCameraPoint()), altitude: Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter + this.elevation };
          }
          recalculateZoom(t3) {
            const i4 = this.pointLocation(this.centerPoint, t3), s4 = t3.getElevationForLngLatZoom(i4, this.tileZoom);
            if (!(this.elevation - s4))
              return;
            const a3 = this.getCameraPosition(), o3 = e3.Y.fromLngLat(a3.lngLat, a3.altitude), r5 = e3.Y.fromLngLat(i4, s4), n3 = o3.x - r5.x, l4 = o3.y - r5.y, h2 = o3.z - r5.z, c3 = Math.sqrt(n3 * n3 + l4 * l4 + h2 * h2), u3 = this.scaleZoom(this.cameraToCenterDistance / c3 / this.tileSize);
            this._elevation = s4, this._center = i4, this.zoom = u3;
          }
          setLocationAtPoint(t3, i4) {
            const s4 = this.pointCoordinate(i4), a3 = this.pointCoordinate(this.centerPoint), o3 = this.locationCoordinate(t3), r5 = new e3.Y(o3.x - (s4.x - a3.x), o3.y - (s4.y - a3.y));
            this.center = this.coordinateLocation(r5), this._renderWorldCopies && (this.center = this.center.wrap());
          }
          locationPoint(t3, e4) {
            return e4 ? this.coordinatePoint(this.locationCoordinate(t3), e4.getElevationForLngLatZoom(t3, this.tileZoom), this.pixelMatrix3D) : this.coordinatePoint(this.locationCoordinate(t3));
          }
          pointLocation(t3, e4) {
            return this.coordinateLocation(this.pointCoordinate(t3, e4));
          }
          locationCoordinate(t3) {
            return e3.Y.fromLngLat(t3);
          }
          coordinateLocation(t3) {
            return t3 && t3.toLngLat();
          }
          pointCoordinate(t3, i4) {
            if (i4) {
              const e4 = i4.pointCoordinate(t3);
              if (null != e4)
                return e4;
            }
            const s4 = [t3.x, t3.y, 0, 1], a3 = [t3.x, t3.y, 1, 1];
            e3.af(s4, s4, this.pixelMatrixInverse), e3.af(a3, a3, this.pixelMatrixInverse);
            const o3 = s4[3], r5 = a3[3], n3 = s4[1] / o3, l4 = a3[1] / r5, h2 = s4[2] / o3, c3 = a3[2] / r5, u3 = h2 === c3 ? 0 : (0 - h2) / (c3 - h2);
            return new e3.Y(e3.z.number(s4[0] / o3, a3[0] / r5, u3) / this.worldSize, e3.z.number(n3, l4, u3) / this.worldSize);
          }
          coordinatePoint(t3, i4 = 0, s4 = this.pixelMatrix) {
            const a3 = [t3.x * this.worldSize, t3.y * this.worldSize, i4, 1];
            return e3.af(a3, a3, s4), new e3.P(a3[0] / a3[3], a3[1] / a3[3]);
          }
          getBounds() {
            const t3 = Math.max(0, this.height / 2 - this.getHorizon());
            return new V2().extend(this.pointLocation(new e3.P(0, t3))).extend(this.pointLocation(new e3.P(this.width, t3))).extend(this.pointLocation(new e3.P(this.width, this.height))).extend(this.pointLocation(new e3.P(0, this.height)));
          }
          getMaxBounds() {
            return this.latRange && 2 === this.latRange.length && this.lngRange && 2 === this.lngRange.length ? new V2([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null;
          }
          getHorizon() {
            return Math.tan(Math.PI / 2 - this._pitch) * this.cameraToCenterDistance * 0.85;
          }
          setMaxBounds(t3) {
            t3 ? (this.lngRange = [t3.getWest(), t3.getEast()], this.latRange = [t3.getSouth(), t3.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-this.maxValidLatitude, this.maxValidLatitude]);
          }
          calculatePosMatrix(t3, i4 = false) {
            const s4 = t3.key, a3 = i4 ? this._alignedPosMatrixCache : this._posMatrixCache;
            if (a3[s4])
              return a3[s4];
            const o3 = t3.canonical, r5 = this.worldSize / this.zoomScale(o3.z), n3 = o3.x + Math.pow(2, o3.z) * t3.wrap, l4 = e3.an(new Float64Array(16));
            return e3.H(l4, l4, [n3 * r5, o3.y * r5, 0]), e3.J(l4, l4, [r5 / e3.W, r5 / e3.W, 1]), e3.K(l4, i4 ? this.alignedProjMatrix : this.projMatrix, l4), a3[s4] = new Float32Array(l4), a3[s4];
          }
          customLayerMatrix() {
            return this.mercatorMatrix.slice();
          }
          _constrain() {
            if (!this.center || !this.width || !this.height || this._constraining)
              return;
            let t3 = this.lngRange;
            if (!this._renderWorldCopies && null === t3) {
              const e4 = 180 - 1e-10;
              t3 = [-e4, e4];
            }
            this._constraining = true;
            let i4, s4, a3, o3, r5 = -90, n3 = 90, l4 = -180, h2 = 180;
            const c3 = this.size, u3 = this._unmodified;
            if (this.latRange) {
              const t4 = this.latRange;
              r5 = e3.O(t4[1]) * this.worldSize, n3 = e3.O(t4[0]) * this.worldSize, i4 = n3 - r5 < c3.y ? c3.y / (n3 - r5) : 0;
            }
            t3 && (l4 = e3.b0(e3.N(t3[0]) * this.worldSize, 0, this.worldSize), h2 = e3.b0(e3.N(t3[1]) * this.worldSize, 0, this.worldSize), h2 < l4 && (h2 += this.worldSize), s4 = h2 - l4 < c3.x ? c3.x / (h2 - l4) : 0);
            const d2 = this.point, _2 = Math.max(s4 || 0, i4 || 0);
            if (_2)
              return this.center = this.unproject(new e3.P(s4 ? (h2 + l4) / 2 : d2.x, i4 ? (n3 + r5) / 2 : d2.y)), this.zoom += this.scaleZoom(_2), this._unmodified = u3, void (this._constraining = false);
            if (this.latRange) {
              const t4 = d2.y, e4 = c3.y / 2;
              t4 - e4 < r5 && (o3 = r5 + e4), t4 + e4 > n3 && (o3 = n3 - e4);
            }
            if (t3) {
              const t4 = (l4 + h2) / 2;
              let i5 = d2.x;
              this._renderWorldCopies && (i5 = e3.b0(d2.x, t4 - this.worldSize / 2, t4 + this.worldSize / 2));
              const s5 = c3.x / 2;
              i5 - s5 < l4 && (a3 = l4 + s5), i5 + s5 > h2 && (a3 = h2 - s5);
            }
            void 0 === a3 && void 0 === o3 || (this.center = this.unproject(new e3.P(void 0 !== a3 ? a3 : d2.x, void 0 !== o3 ? o3 : d2.y)).wrap()), this._unmodified = u3, this._constraining = false;
          }
          _calcMatrices() {
            if (!this.height)
              return;
            const t3 = this.centerOffset, i4 = this.point.x, s4 = this.point.y;
            this.cameraToCenterDistance = 0.5 / Math.tan(this._fov / 2) * this.height, this._pixelPerMeter = e3.b2(1, this.center.lat) * this.worldSize;
            let a3 = e3.an(new Float64Array(16));
            e3.J(a3, a3, [this.width / 2, -this.height / 2, 1]), e3.H(a3, a3, [1, -1, 0]), this.labelPlaneMatrix = a3, a3 = e3.an(new Float64Array(16)), e3.J(a3, a3, [1, -1, 1]), e3.H(a3, a3, [-1, -1, 0]), e3.J(a3, a3, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = a3;
            const o3 = this.cameraToCenterDistance + this._elevation * this._pixelPerMeter / Math.cos(this._pitch), r5 = Math.min(this.elevation, this.minElevationForCurrentTile), n3 = o3 - r5 * this._pixelPerMeter / Math.cos(this._pitch), l4 = r5 < 0 ? n3 : o3, h2 = Math.PI / 2 + this._pitch, c3 = this._fov * (0.5 + t3.y / this.height), u3 = Math.sin(c3) * l4 / Math.sin(e3.ac(Math.PI - h2 - c3, 0.01, Math.PI - 0.01)), d2 = this.getHorizon(), _2 = 2 * Math.atan(d2 / this.cameraToCenterDistance) * (0.5 + t3.y / (2 * d2)), p4 = Math.sin(_2) * l4 / Math.sin(e3.ac(Math.PI - h2 - _2, 0.01, Math.PI - 0.01)), m2 = Math.min(u3, p4), f2 = 1.01 * (Math.cos(Math.PI / 2 - this._pitch) * m2 + l4), g3 = this.height / 50;
            a3 = new Float64Array(16), e3.b3(a3, this._fov, this.width / this.height, g3, f2), a3[8] = 2 * -t3.x / this.width, a3[9] = 2 * t3.y / this.height, e3.J(a3, a3, [1, -1, 1]), e3.H(a3, a3, [0, 0, -this.cameraToCenterDistance]), e3.b4(a3, a3, this._pitch), e3.ad(a3, a3, this.angle), e3.H(a3, a3, [-i4, -s4, 0]), this.mercatorMatrix = e3.J([], a3, [this.worldSize, this.worldSize, this.worldSize]), e3.J(a3, a3, [1, 1, this._pixelPerMeter]), this.pixelMatrix = e3.K(new Float64Array(16), this.labelPlaneMatrix, a3), e3.H(a3, a3, [0, 0, -this.elevation]), this.projMatrix = a3, this.invProjMatrix = e3.ar([], a3), this.pixelMatrix3D = e3.K(new Float64Array(16), this.labelPlaneMatrix, a3);
            const v4 = this.width % 2 / 2, x5 = this.height % 2 / 2, y4 = Math.cos(this.angle), b3 = Math.sin(this.angle), w4 = i4 - Math.round(i4) + y4 * v4 + b3 * x5, T3 = s4 - Math.round(s4) + y4 * x5 + b3 * v4, I3 = new Float64Array(a3);
            if (e3.H(I3, I3, [w4 > 0.5 ? w4 - 1 : w4, T3 > 0.5 ? T3 - 1 : T3, 0]), this.alignedProjMatrix = I3, a3 = e3.ar(new Float64Array(16), this.pixelMatrix), !a3)
              throw new Error("failed to invert matrix");
            this.pixelMatrixInverse = a3, this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
          }
          maxPitchScaleFactor() {
            if (!this.pixelMatrixInverse)
              return 1;
            const t3 = this.pointCoordinate(new e3.P(0, 0)), i4 = [t3.x * this.worldSize, t3.y * this.worldSize, 0, 1];
            return e3.af(i4, i4, this.pixelMatrix)[3] / this.cameraToCenterDistance;
          }
          getCameraPoint() {
            const t3 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new e3.P(0, t3));
          }
          getCameraQueryGeometry(t3) {
            const i4 = this.getCameraPoint();
            if (1 === t3.length)
              return [t3[0], i4];
            {
              let s4 = i4.x, a3 = i4.y, o3 = i4.x, r5 = i4.y;
              for (const e4 of t3)
                s4 = Math.min(s4, e4.x), a3 = Math.min(a3, e4.y), o3 = Math.max(o3, e4.x), r5 = Math.max(r5, e4.y);
              return [new e3.P(s4, a3), new e3.P(o3, a3), new e3.P(o3, r5), new e3.P(s4, r5), new e3.P(s4, a3)];
            }
          }
          lngLatToCameraDepth(t3, i4) {
            const s4 = this.locationCoordinate(t3), a3 = [s4.x * this.worldSize, s4.y * this.worldSize, i4, 1];
            return e3.af(a3, a3, this.projMatrix), a3[2] / a3[3];
          }
        }
        function _s(t3, e4) {
          let i4, s4 = false, a3 = null, o3 = null;
          const r5 = () => {
            a3 = null, s4 && (t3.apply(o3, i4), a3 = setTimeout(r5, e4), s4 = false);
          };
          return (...t4) => (s4 = true, o3 = this, i4 = t4, a3 || r5(), a3);
        }
        class ps {
          constructor(t3) {
            this._getCurrentHash = () => {
              const t4 = window.location.hash.replace("#", "");
              if (this._hashName) {
                let e4;
                return t4.split("&").map((t5) => t5.split("=")).forEach((t5) => {
                  t5[0] === this._hashName && (e4 = t5);
                }), (e4 && e4[1] || "").split("/");
              }
              return t4.split("/");
            }, this._onHashChange = () => {
              const t4 = this._getCurrentHash();
              if (t4.length >= 3 && !t4.some((t5) => isNaN(t5))) {
                const e4 = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(t4[3] || 0) : this._map.getBearing();
                return this._map.jumpTo({ center: [+t4[2], +t4[1]], zoom: +t4[0], bearing: e4, pitch: +(t4[4] || 0) }), true;
              }
              return false;
            }, this._updateHashUnthrottled = () => {
              const t4 = window.location.href.replace(/(#.+)?$/, this.getHashString());
              try {
                window.history.replaceState(window.history.state, null, t4);
              } catch (t5) {
              }
            }, this._updateHash = _s(this._updateHashUnthrottled, 300), this._hashName = t3 && encodeURIComponent(t3);
          }
          addTo(t3) {
            return this._map = t3, addEventListener("hashchange", this._onHashChange, false), this._map.on("moveend", this._updateHash), this;
          }
          remove() {
            return removeEventListener("hashchange", this._onHashChange, false), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), delete this._map, this;
          }
          getHashString(t3) {
            const e4 = this._map.getCenter(), i4 = Math.round(100 * this._map.getZoom()) / 100, s4 = Math.ceil((i4 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), a3 = Math.pow(10, s4), o3 = Math.round(e4.lng * a3) / a3, r5 = Math.round(e4.lat * a3) / a3, n3 = this._map.getBearing(), l4 = this._map.getPitch();
            let h2 = "";
            if (h2 += t3 ? `/${o3}/${r5}/${i4}` : `${i4}/${r5}/${o3}`, (n3 || l4) && (h2 += "/" + Math.round(10 * n3) / 10), l4 && (h2 += `/${Math.round(l4)}`), this._hashName) {
              const t4 = this._hashName;
              let e5 = false;
              const i5 = window.location.hash.slice(1).split("&").map((i6) => {
                const s5 = i6.split("=")[0];
                return s5 === t4 ? (e5 = true, `${s5}=${h2}`) : i6;
              }).filter((t5) => t5);
              return e5 || i5.push(`${t4}=${h2}`), `#${i5.join("&")}`;
            }
            return `#${h2}`;
          }
        }
        const ms = { linearity: 0.3, easing: e3.b5(0, 0, 0.3, 1) }, fs = e3.e({ deceleration: 2500, maxSpeed: 1400 }, ms), gs = e3.e({ deceleration: 20, maxSpeed: 1400 }, ms), vs = e3.e({ deceleration: 1e3, maxSpeed: 360 }, ms), xs = e3.e({ deceleration: 1e3, maxSpeed: 90 }, ms);
        class ys {
          constructor(t3) {
            this._map = t3, this.clear();
          }
          clear() {
            this._inertiaBuffer = [];
          }
          record(t3) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: o2.now(), settings: t3 });
          }
          _drainInertiaBuffer() {
            const t3 = this._inertiaBuffer, e4 = o2.now();
            for (; t3.length > 0 && e4 - t3[0].time > 160; )
              t3.shift();
          }
          _onMoveEnd(t3) {
            if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2)
              return;
            const i4 = { zoom: 0, bearing: 0, pitch: 0, pan: new e3.P(0, 0), pinchAround: void 0, around: void 0 };
            for (const { settings: t4 } of this._inertiaBuffer)
              i4.zoom += t4.zoomDelta || 0, i4.bearing += t4.bearingDelta || 0, i4.pitch += t4.pitchDelta || 0, t4.panDelta && i4.pan._add(t4.panDelta), t4.around && (i4.around = t4.around), t4.pinchAround && (i4.pinchAround = t4.pinchAround);
            const s4 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, a3 = {};
            if (i4.pan.mag()) {
              const o3 = ws(i4.pan.mag(), s4, e3.e({}, fs, t3 || {}));
              a3.offset = i4.pan.mult(o3.amount / i4.pan.mag()), a3.center = this._map.transform.center, bs(a3, o3);
            }
            if (i4.zoom) {
              const t4 = ws(i4.zoom, s4, gs);
              a3.zoom = this._map.transform.zoom + t4.amount, bs(a3, t4);
            }
            if (i4.bearing) {
              const t4 = ws(i4.bearing, s4, vs);
              a3.bearing = this._map.transform.bearing + e3.ac(t4.amount, -179, 179), bs(a3, t4);
            }
            if (i4.pitch) {
              const t4 = ws(i4.pitch, s4, xs);
              a3.pitch = this._map.transform.pitch + t4.amount, bs(a3, t4);
            }
            if (a3.zoom || a3.bearing) {
              const t4 = void 0 === i4.pinchAround ? i4.around : i4.pinchAround;
              a3.around = t4 ? this._map.unproject(t4) : this._map.getCenter();
            }
            return this.clear(), e3.e(a3, { noMoveStart: true });
          }
        }
        function bs(t3, e4) {
          (!t3.duration || t3.duration < e4.duration) && (t3.duration = e4.duration, t3.easing = e4.easing);
        }
        function ws(t3, i4, s4) {
          const { maxSpeed: a3, linearity: o3, deceleration: r5 } = s4, n3 = e3.ac(t3 * o3 / (i4 / 1e3), -a3, a3), l4 = Math.abs(n3) / (r5 * o3);
          return { easing: s4.easing, duration: 1e3 * l4, amount: n3 * (l4 / 2) };
        }
        class Ts extends e3.k {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(t3, i4, s4, a3 = {}) {
            const o3 = r4.mousePos(i4.getCanvas(), s4), n3 = i4.unproject(o3);
            super(t3, e3.e({ point: o3, lngLat: n3, originalEvent: s4 }, a3)), this._defaultPrevented = false, this.target = i4;
          }
        }
        class Is extends e3.k {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(t3, i4, s4) {
            const a3 = "touchend" === t3 ? s4.changedTouches : s4.touches, o3 = r4.touchPos(i4.getCanvasContainer(), a3), n3 = o3.map((t4) => i4.unproject(t4)), l4 = o3.reduce((t4, e4, i5, s5) => t4.add(e4.div(s5.length)), new e3.P(0, 0));
            super(t3, { points: o3, point: l4, lngLats: n3, lngLat: i4.unproject(l4), originalEvent: s4 }), this._defaultPrevented = false;
          }
        }
        class Es extends e3.k {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(t3, e4, i4) {
            super(t3, { originalEvent: i4 }), this._defaultPrevented = false;
          }
        }
        class Ss {
          constructor(t3, e4) {
            this._map = t3, this._clickTolerance = e4.clickTolerance;
          }
          reset() {
            delete this._mousedownPos;
          }
          wheel(t3) {
            return this._firePreventable(new Es(t3.type, this._map, t3));
          }
          mousedown(t3, e4) {
            return this._mousedownPos = e4, this._firePreventable(new Ts(t3.type, this._map, t3));
          }
          mouseup(t3) {
            this._map.fire(new Ts(t3.type, this._map, t3));
          }
          click(t3, e4) {
            this._mousedownPos && this._mousedownPos.dist(e4) >= this._clickTolerance || this._map.fire(new Ts(t3.type, this._map, t3));
          }
          dblclick(t3) {
            return this._firePreventable(new Ts(t3.type, this._map, t3));
          }
          mouseover(t3) {
            this._map.fire(new Ts(t3.type, this._map, t3));
          }
          mouseout(t3) {
            this._map.fire(new Ts(t3.type, this._map, t3));
          }
          touchstart(t3) {
            return this._firePreventable(new Is(t3.type, this._map, t3));
          }
          touchmove(t3) {
            this._map.fire(new Is(t3.type, this._map, t3));
          }
          touchend(t3) {
            this._map.fire(new Is(t3.type, this._map, t3));
          }
          touchcancel(t3) {
            this._map.fire(new Is(t3.type, this._map, t3));
          }
          _firePreventable(t3) {
            if (this._map.fire(t3), t3.defaultPrevented)
              return {};
          }
          isEnabled() {
            return true;
          }
          isActive() {
            return false;
          }
          enable() {
          }
          disable() {
          }
        }
        class Cs {
          constructor(t3) {
            this._map = t3;
          }
          reset() {
            this._delayContextMenu = false, this._ignoreContextMenu = true, delete this._contextMenuEvent;
          }
          mousemove(t3) {
            this._map.fire(new Ts(t3.type, this._map, t3));
          }
          mousedown() {
            this._delayContextMenu = true, this._ignoreContextMenu = false;
          }
          mouseup() {
            this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new Ts("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
          }
          contextmenu(t3) {
            this._delayContextMenu ? this._contextMenuEvent = t3 : this._ignoreContextMenu || this._map.fire(new Ts(t3.type, this._map, t3)), this._map.listens("contextmenu") && t3.preventDefault();
          }
          isEnabled() {
            return true;
          }
          isActive() {
            return false;
          }
          enable() {
          }
          disable() {
          }
        }
        class Ps {
          constructor(t3) {
            this._map = t3;
          }
          get transform() {
            return this._map._requestedCameraState || this._map.transform;
          }
          get center() {
            return { lng: this.transform.center.lng, lat: this.transform.center.lat };
          }
          get zoom() {
            return this.transform.zoom;
          }
          get pitch() {
            return this.transform.pitch;
          }
          get bearing() {
            return this.transform.bearing;
          }
          unproject(t3) {
            return this.transform.pointLocation(e3.P.convert(t3), this._map.terrain);
          }
        }
        class Ds {
          constructor(t3, e4) {
            this._map = t3, this._tr = new Ps(t3), this._el = t3.getCanvasContainer(), this._container = t3.getContainer(), this._clickTolerance = e4.clickTolerance || 1;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          enable() {
            this.isEnabled() || (this._enabled = true);
          }
          disable() {
            this.isEnabled() && (this._enabled = false);
          }
          mousedown(t3, e4) {
            this.isEnabled() && t3.shiftKey && 0 === t3.button && (r4.disableDrag(), this._startPos = this._lastPos = e4, this._active = true);
          }
          mousemoveWindow(t3, e4) {
            if (!this._active)
              return;
            const i4 = e4;
            if (this._lastPos.equals(i4) || !this._box && i4.dist(this._startPos) < this._clickTolerance)
              return;
            const s4 = this._startPos;
            this._lastPos = i4, this._box || (this._box = r4.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", t3));
            const a3 = Math.min(s4.x, i4.x), o3 = Math.max(s4.x, i4.x), n3 = Math.min(s4.y, i4.y), l4 = Math.max(s4.y, i4.y);
            r4.setTransform(this._box, `translate(${a3}px,${n3}px)`), this._box.style.width = o3 - a3 + "px", this._box.style.height = l4 - n3 + "px";
          }
          mouseupWindow(t3, i4) {
            if (!this._active)
              return;
            if (0 !== t3.button)
              return;
            const s4 = this._startPos, a3 = i4;
            if (this.reset(), r4.suppressClick(), s4.x !== a3.x || s4.y !== a3.y)
              return this._map.fire(new e3.k("boxzoomend", { originalEvent: t3 })), { cameraAnimation: (t4) => t4.fitScreenCoordinates(s4, a3, this._tr.bearing, { linear: true }) };
            this._fireEvent("boxzoomcancel", t3);
          }
          keydown(t3) {
            this._active && 27 === t3.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", t3));
          }
          reset() {
            this._active = false, this._container.classList.remove("maplibregl-crosshair"), this._box && (r4.remove(this._box), this._box = null), r4.enableDrag(), delete this._startPos, delete this._lastPos;
          }
          _fireEvent(t3, i4) {
            return this._map.fire(new e3.k(t3, { originalEvent: i4 }));
          }
        }
        function zs(t3, e4) {
          if (t3.length !== e4.length)
            throw new Error(`The number of touches and points are not equal - touches ${t3.length}, points ${e4.length}`);
          const i4 = {};
          for (let s4 = 0; s4 < t3.length; s4++)
            i4[t3[s4].identifier] = e4[s4];
          return i4;
        }
        class Ms {
          constructor(t3) {
            this.reset(), this.numTouches = t3.numTouches;
          }
          reset() {
            delete this.centroid, delete this.startTime, delete this.touches, this.aborted = false;
          }
          touchstart(t3, i4, s4) {
            (this.centroid || s4.length > this.numTouches) && (this.aborted = true), this.aborted || (void 0 === this.startTime && (this.startTime = t3.timeStamp), s4.length === this.numTouches && (this.centroid = function(t4) {
              const i5 = new e3.P(0, 0);
              for (const e4 of t4)
                i5._add(e4);
              return i5.div(t4.length);
            }(i4), this.touches = zs(s4, i4)));
          }
          touchmove(t3, e4, i4) {
            if (this.aborted || !this.centroid)
              return;
            const s4 = zs(i4, e4);
            for (const t4 in this.touches) {
              const e5 = s4[t4];
              (!e5 || e5.dist(this.touches[t4]) > 30) && (this.aborted = true);
            }
          }
          touchend(t3, e4, i4) {
            if ((!this.centroid || t3.timeStamp - this.startTime > 500) && (this.aborted = true), 0 === i4.length) {
              const t4 = !this.aborted && this.centroid;
              if (this.reset(), t4)
                return t4;
            }
          }
        }
        class As {
          constructor(t3) {
            this.singleTap = new Ms(t3), this.numTaps = t3.numTaps, this.reset();
          }
          reset() {
            this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
          }
          touchstart(t3, e4, i4) {
            this.singleTap.touchstart(t3, e4, i4);
          }
          touchmove(t3, e4, i4) {
            this.singleTap.touchmove(t3, e4, i4);
          }
          touchend(t3, e4, i4) {
            const s4 = this.singleTap.touchend(t3, e4, i4);
            if (s4) {
              const e5 = t3.timeStamp - this.lastTime < 500, i5 = !this.lastTap || this.lastTap.dist(s4) < 30;
              if (e5 && i5 || this.reset(), this.count++, this.lastTime = t3.timeStamp, this.lastTap = s4, this.count === this.numTaps)
                return this.reset(), s4;
            }
          }
        }
        class Rs {
          constructor(t3) {
            this._tr = new Ps(t3), this._zoomIn = new As({ numTouches: 1, numTaps: 2 }), this._zoomOut = new As({ numTouches: 2, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
          }
          touchstart(t3, e4, i4) {
            this._zoomIn.touchstart(t3, e4, i4), this._zoomOut.touchstart(t3, e4, i4);
          }
          touchmove(t3, e4, i4) {
            this._zoomIn.touchmove(t3, e4, i4), this._zoomOut.touchmove(t3, e4, i4);
          }
          touchend(t3, e4, i4) {
            const s4 = this._zoomIn.touchend(t3, e4, i4), a3 = this._zoomOut.touchend(t3, e4, i4), o3 = this._tr;
            return s4 ? (this._active = true, t3.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (e5) => e5.easeTo({ duration: 300, zoom: o3.zoom + 1, around: o3.unproject(s4) }, { originalEvent: t3 }) }) : a3 ? (this._active = true, t3.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (e5) => e5.easeTo({ duration: 300, zoom: o3.zoom - 1, around: o3.unproject(a3) }, { originalEvent: t3 }) }) : void 0;
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Ls {
          constructor(t3) {
            this._enabled = !!t3.enable, this._moveStateManager = t3.moveStateManager, this._clickTolerance = t3.clickTolerance || 1, this._moveFunction = t3.move, this._activateOnStart = !!t3.activateOnStart, t3.assignEvents(this), this.reset();
          }
          reset(t3) {
            this._active = false, this._moved = false, delete this._lastPoint, this._moveStateManager.endMove(t3);
          }
          _move(...t3) {
            const e4 = this._moveFunction(...t3);
            if (e4.bearingDelta || e4.pitchDelta || e4.around || e4.panDelta)
              return this._active = true, e4;
          }
          dragStart(t3, e4) {
            this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(t3) && (this._moveStateManager.startMove(t3), this._lastPoint = e4.length ? e4[0] : e4, this._activateOnStart && this._lastPoint && (this._active = true));
          }
          dragMove(t3, e4) {
            if (!this.isEnabled())
              return;
            const i4 = this._lastPoint;
            if (!i4)
              return;
            if (t3.preventDefault(), !this._moveStateManager.isValidMoveEvent(t3))
              return void this.reset(t3);
            const s4 = e4.length ? e4[0] : e4;
            return !this._moved && s4.dist(i4) < this._clickTolerance ? void 0 : (this._moved = true, this._lastPoint = s4, this._move(i4, s4));
          }
          dragEnd(t3) {
            this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(t3) && (this._moved && r4.suppressClick(), this.reset(t3));
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          getClickTolerance() {
            return this._clickTolerance;
          }
        }
        const ks = { 0: 1, 2: 2 };
        class Fs {
          constructor(t3) {
            this._correctEvent = t3.checkCorrectEvent;
          }
          startMove(t3) {
            const e4 = r4.mouseButton(t3);
            this._eventButton = e4;
          }
          endMove(t3) {
            delete this._eventButton;
          }
          isValidStartEvent(t3) {
            return this._correctEvent(t3);
          }
          isValidMoveEvent(t3) {
            return !function(t4, e4) {
              const i4 = ks[e4];
              return void 0 === t4.buttons || (t4.buttons & i4) !== i4;
            }(t3, this._eventButton);
          }
          isValidEndEvent(t3) {
            return r4.mouseButton(t3) === this._eventButton;
          }
        }
        class Bs {
          constructor() {
            this._firstTouch = void 0;
          }
          _isOneFingerTouch(t3) {
            return 1 === t3.targetTouches.length;
          }
          _isSameTouchEvent(t3) {
            return t3.targetTouches[0].identifier === this._firstTouch;
          }
          startMove(t3) {
            this._firstTouch = t3.targetTouches[0].identifier;
          }
          endMove(t3) {
            delete this._firstTouch;
          }
          isValidStartEvent(t3) {
            return this._isOneFingerTouch(t3);
          }
          isValidMoveEvent(t3) {
            return this._isOneFingerTouch(t3) && this._isSameTouchEvent(t3);
          }
          isValidEndEvent(t3) {
            return this._isOneFingerTouch(t3) && this._isSameTouchEvent(t3);
          }
        }
        const Os = (t3) => {
          t3.mousedown = t3.dragStart, t3.mousemoveWindow = t3.dragMove, t3.mouseup = t3.dragEnd, t3.contextmenu = function(t4) {
            t4.preventDefault();
          };
        }, Ns = ({ enable: t3, clickTolerance: e4, bearingDegreesPerPixelMoved: i4 = 0.8 }) => {
          const s4 = new Fs({ checkCorrectEvent: (t4) => 0 === r4.mouseButton(t4) && t4.ctrlKey || 2 === r4.mouseButton(t4) });
          return new Ls({ clickTolerance: e4, move: (t4, e5) => ({ bearingDelta: (e5.x - t4.x) * i4 }), moveStateManager: s4, enable: t3, assignEvents: Os });
        }, Us = ({ enable: t3, clickTolerance: e4, pitchDegreesPerPixelMoved: i4 = -0.5 }) => {
          const s4 = new Fs({ checkCorrectEvent: (t4) => 0 === r4.mouseButton(t4) && t4.ctrlKey || 2 === r4.mouseButton(t4) });
          return new Ls({ clickTolerance: e4, move: (t4, e5) => ({ pitchDelta: (e5.y - t4.y) * i4 }), moveStateManager: s4, enable: t3, assignEvents: Os });
        };
        class Zs {
          constructor(t3, e4) {
            this._clickTolerance = t3.clickTolerance || 1, this._map = e4, this.reset();
          }
          reset() {
            this._active = false, this._touches = {}, this._sum = new e3.P(0, 0);
          }
          minTouchs() {
            return this._map.cooperativeGestures.isEnabled() ? 2 : 1;
          }
          touchstart(t3, e4, i4) {
            return this._calculateTransform(t3, e4, i4);
          }
          touchmove(t3, e4, i4) {
            if (this._active && !(i4.length < this.minTouchs()))
              return t3.preventDefault(), this._calculateTransform(t3, e4, i4);
          }
          touchend(t3, e4, i4) {
            this._calculateTransform(t3, e4, i4), this._active && i4.length < this.minTouchs() && this.reset();
          }
          touchcancel() {
            this.reset();
          }
          _calculateTransform(t3, i4, s4) {
            s4.length > 0 && (this._active = true);
            const a3 = zs(s4, i4), o3 = new e3.P(0, 0), r5 = new e3.P(0, 0);
            let n3 = 0;
            for (const t4 in a3) {
              const e4 = a3[t4], i5 = this._touches[t4];
              i5 && (o3._add(e4), r5._add(e4.sub(i5)), n3++, a3[t4] = e4);
            }
            if (this._touches = a3, n3 < this.minTouchs() || !r5.mag())
              return;
            const l4 = r5.div(n3);
            return this._sum._add(l4), this._sum.mag() < this._clickTolerance ? void 0 : { around: o3.div(n3), panDelta: l4 };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Gs {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = false, delete this._firstTwoTouches;
          }
          touchstart(t3, e4, i4) {
            this._firstTwoTouches || i4.length < 2 || (this._firstTwoTouches = [i4[0].identifier, i4[1].identifier], this._start([e4[0], e4[1]]));
          }
          touchmove(t3, e4, i4) {
            if (!this._firstTwoTouches)
              return;
            t3.preventDefault();
            const [s4, a3] = this._firstTwoTouches, o3 = js(i4, e4, s4), r5 = js(i4, e4, a3);
            if (!o3 || !r5)
              return;
            const n3 = this._aroundCenter ? null : o3.add(r5).div(2);
            return this._move([o3, r5], n3, t3);
          }
          touchend(t3, e4, i4) {
            if (!this._firstTwoTouches)
              return;
            const [s4, a3] = this._firstTwoTouches, o3 = js(i4, e4, s4), n3 = js(i4, e4, a3);
            o3 && n3 || (this._active && r4.suppressClick(), this.reset());
          }
          touchcancel() {
            this.reset();
          }
          enable(t3) {
            this._enabled = true, this._aroundCenter = !!t3 && "center" === t3.around;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
        }
        function js(t3, e4, i4) {
          for (let s4 = 0; s4 < t3.length; s4++)
            if (t3[s4].identifier === i4)
              return e4[s4];
        }
        function qs(t3, e4) {
          return Math.log(t3 / e4) / Math.LN2;
        }
        class Vs extends Gs {
          reset() {
            super.reset(), delete this._distance, delete this._startDistance;
          }
          _start(t3) {
            this._startDistance = this._distance = t3[0].dist(t3[1]);
          }
          _move(t3, e4) {
            const i4 = this._distance;
            if (this._distance = t3[0].dist(t3[1]), this._active || !(Math.abs(qs(this._distance, this._startDistance)) < 0.1))
              return this._active = true, { zoomDelta: qs(this._distance, i4), pinchAround: e4 };
          }
        }
        function Ws(t3, e4) {
          return 180 * t3.angleWith(e4) / Math.PI;
        }
        class Hs extends Gs {
          reset() {
            super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
          }
          _start(t3) {
            this._startVector = this._vector = t3[0].sub(t3[1]), this._minDiameter = t3[0].dist(t3[1]);
          }
          _move(t3, e4, i4) {
            const s4 = this._vector;
            if (this._vector = t3[0].sub(t3[1]), this._active || !this._isBelowThreshold(this._vector))
              return this._active = true, { bearingDelta: Ws(this._vector, s4), pinchAround: e4 };
          }
          _isBelowThreshold(t3) {
            this._minDiameter = Math.min(this._minDiameter, t3.mag());
            const e4 = 25 / (Math.PI * this._minDiameter) * 360, i4 = Ws(t3, this._startVector);
            return Math.abs(i4) < e4;
          }
        }
        function $s(t3) {
          return Math.abs(t3.y) > Math.abs(t3.x);
        }
        class Xs extends Gs {
          constructor(t3) {
            super(), this._currentTouchCount = 0, this._map = t3;
          }
          reset() {
            super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
          }
          touchstart(t3, e4, i4) {
            super.touchstart(t3, e4, i4), this._currentTouchCount = i4.length;
          }
          _start(t3) {
            this._lastPoints = t3, $s(t3[0].sub(t3[1])) && (this._valid = false);
          }
          _move(t3, e4, i4) {
            if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3)
              return;
            const s4 = t3[0].sub(this._lastPoints[0]), a3 = t3[1].sub(this._lastPoints[1]);
            return this._valid = this.gestureBeginsVertically(s4, a3, i4.timeStamp), this._valid ? (this._lastPoints = t3, this._active = true, { pitchDelta: (s4.y + a3.y) / 2 * -0.5 }) : void 0;
          }
          gestureBeginsVertically(t3, e4, i4) {
            if (void 0 !== this._valid)
              return this._valid;
            const s4 = t3.mag() >= 2, a3 = e4.mag() >= 2;
            if (!s4 && !a3)
              return;
            if (!s4 || !a3)
              return void 0 === this._firstMove && (this._firstMove = i4), i4 - this._firstMove < 100 && void 0;
            const o3 = t3.y > 0 == e4.y > 0;
            return $s(t3) && $s(e4) && o3;
          }
        }
        const Ks = { panStep: 100, bearingStep: 15, pitchStep: 10 };
        class Ys {
          constructor(t3) {
            this._tr = new Ps(t3);
            const e4 = Ks;
            this._panStep = e4.panStep, this._bearingStep = e4.bearingStep, this._pitchStep = e4.pitchStep, this._rotationDisabled = false;
          }
          reset() {
            this._active = false;
          }
          keydown(t3) {
            if (t3.altKey || t3.ctrlKey || t3.metaKey)
              return;
            let e4 = 0, i4 = 0, s4 = 0, a3 = 0, o3 = 0;
            switch (t3.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                e4 = 1;
                break;
              case 189:
              case 109:
              case 173:
                e4 = -1;
                break;
              case 37:
                t3.shiftKey ? i4 = -1 : (t3.preventDefault(), a3 = -1);
                break;
              case 39:
                t3.shiftKey ? i4 = 1 : (t3.preventDefault(), a3 = 1);
                break;
              case 38:
                t3.shiftKey ? s4 = 1 : (t3.preventDefault(), o3 = -1);
                break;
              case 40:
                t3.shiftKey ? s4 = -1 : (t3.preventDefault(), o3 = 1);
                break;
              default:
                return;
            }
            return this._rotationDisabled && (i4 = 0, s4 = 0), { cameraAnimation: (r5) => {
              const n3 = this._tr;
              r5.easeTo({ duration: 300, easeId: "keyboardHandler", easing: Js, zoom: e4 ? Math.round(n3.zoom) + e4 * (t3.shiftKey ? 2 : 1) : n3.zoom, bearing: n3.bearing + i4 * this._bearingStep, pitch: n3.pitch + s4 * this._pitchStep, offset: [-a3 * this._panStep, -o3 * this._panStep], center: n3.center }, { originalEvent: t3 });
            } };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          disableRotation() {
            this._rotationDisabled = true;
          }
          enableRotation() {
            this._rotationDisabled = false;
          }
        }
        function Js(t3) {
          return t3 * (2 - t3);
        }
        const Qs = 4.000244140625;
        class ta2 {
          constructor(t3, e4) {
            this._onTimeout = (t4) => {
              this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(t4);
            }, this._map = t3, this._tr = new Ps(t3), this._triggerRenderFrame = e4, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222;
          }
          setZoomRate(t3) {
            this._defaultZoomRate = t3;
          }
          setWheelZoomRate(t3) {
            this._wheelZoomRate = t3;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active || void 0 !== this._finishTimeout;
          }
          isZooming() {
            return !!this._zooming;
          }
          enable(t3) {
            this.isEnabled() || (this._enabled = true, this._aroundCenter = !!t3 && "center" === t3.around);
          }
          disable() {
            this.isEnabled() && (this._enabled = false);
          }
          wheel(t3) {
            if (!this.isEnabled())
              return;
            if (this._map.cooperativeGestures.isEnabled() && !t3[this._map.cooperativeGestures._bypassKey])
              return;
            let e4 = t3.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * t3.deltaY : t3.deltaY;
            const i4 = o2.now(), s4 = i4 - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = i4, 0 !== e4 && e4 % Qs == 0 ? this._type = "wheel" : 0 !== e4 && Math.abs(e4) < 4 ? this._type = "trackpad" : s4 > 400 ? (this._type = null, this._lastValue = e4, this._timeout = setTimeout(this._onTimeout, 40, t3)) : this._type || (this._type = Math.abs(s4 * e4) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, e4 += this._lastValue)), t3.shiftKey && e4 && (e4 /= 4), this._type && (this._lastWheelEvent = t3, this._delta -= e4, this._active || this._start(t3)), t3.preventDefault();
          }
          _start(t3) {
            if (!this._delta)
              return;
            this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const i4 = r4.mousePos(this._map.getCanvas(), t3), s4 = this._tr;
            this._around = i4.y > s4.transform.height / 2 - s4.transform.getHorizon() ? e3.M.convert(this._aroundCenter ? s4.center : s4.unproject(i4)) : e3.M.convert(s4.center), this._aroundPoint = s4.transform.locationPoint(this._around), this._frameId || (this._frameId = true, this._triggerRenderFrame());
          }
          renderFrame() {
            if (!this._frameId)
              return;
            if (this._frameId = null, !this.isActive())
              return;
            const t3 = this._tr.transform;
            if (0 !== this._delta) {
              const e4 = "wheel" === this._type && Math.abs(this._delta) > Qs ? this._wheelZoomRate : this._defaultZoomRate;
              let i5 = 2 / (1 + Math.exp(-Math.abs(this._delta * e4)));
              this._delta < 0 && 0 !== i5 && (i5 = 1 / i5);
              const s5 = "number" == typeof this._targetZoom ? t3.zoomScale(this._targetZoom) : t3.scale;
              this._targetZoom = Math.min(t3.maxZoom, Math.max(t3.minZoom, t3.scaleZoom(s5 * i5))), "wheel" === this._type && (this._startZoom = t3.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
            }
            const i4 = "number" == typeof this._targetZoom ? this._targetZoom : t3.zoom, s4 = this._startZoom, a3 = this._easing;
            let r5, n3 = false;
            if ("wheel" === this._type && s4 && a3) {
              const t4 = Math.min((o2.now() - this._lastWheelEventTime) / 200, 1), l4 = a3(t4);
              r5 = e3.z.number(s4, i4, l4), t4 < 1 ? this._frameId || (this._frameId = true) : n3 = true;
            } else
              r5 = i4, n3 = true;
            return this._active = true, n3 && (this._active = false, this._finishTimeout = setTimeout(() => {
              this._zooming = false, this._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
            }, 200)), { noInertia: true, needsRenderFrame: !n3, zoomDelta: r5 - t3.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
          }
          _smoothOutEasing(t3) {
            let i4 = e3.b6;
            if (this._prevEase) {
              const t4 = this._prevEase, s4 = (o2.now() - t4.start) / t4.duration, a3 = t4.easing(s4 + 0.01) - t4.easing(s4), r5 = 0.27 / Math.sqrt(a3 * a3 + 1e-4) * 0.01, n3 = Math.sqrt(0.0729 - r5 * r5);
              i4 = e3.b5(r5, n3, 0.25, 1);
            }
            return this._prevEase = { start: o2.now(), duration: t3, easing: i4 }, i4;
          }
          reset() {
            this._active = false, this._zooming = false, delete this._targetZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          }
        }
        class ea2 {
          constructor(t3, e4) {
            this._clickZoom = t3, this._tapZoom = e4;
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable();
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable();
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive();
          }
        }
        class ia2 {
          constructor(t3) {
            this._tr = new Ps(t3), this.reset();
          }
          reset() {
            this._active = false;
          }
          dblclick(t3, e4) {
            return t3.preventDefault(), { cameraAnimation: (i4) => {
              i4.easeTo({ duration: 300, zoom: this._tr.zoom + (t3.shiftKey ? -1 : 1), around: this._tr.unproject(e4) }, { originalEvent: t3 });
            } };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class sa2 {
          constructor() {
            this._tap = new As({ numTouches: 1, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = false, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
          }
          touchstart(t3, e4, i4) {
            if (!this._swipePoint)
              if (this._tapTime) {
                const s4 = e4[0], a3 = t3.timeStamp - this._tapTime < 500, o3 = this._tapPoint.dist(s4) < 30;
                a3 && o3 ? i4.length > 0 && (this._swipePoint = s4, this._swipeTouch = i4[0].identifier) : this.reset();
              } else
                this._tap.touchstart(t3, e4, i4);
          }
          touchmove(t3, e4, i4) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (i4[0].identifier !== this._swipeTouch)
                  return;
                const s4 = e4[0], a3 = s4.y - this._swipePoint.y;
                return this._swipePoint = s4, t3.preventDefault(), this._active = true, { zoomDelta: a3 / 128 };
              }
            } else
              this._tap.touchmove(t3, e4, i4);
          }
          touchend(t3, e4, i4) {
            if (this._tapTime)
              this._swipePoint && 0 === i4.length && this.reset();
            else {
              const s4 = this._tap.touchend(t3, e4, i4);
              s4 && (this._tapTime = t3.timeStamp, this._tapPoint = s4);
            }
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class aa2 {
          constructor(t3, e4, i4) {
            this._el = t3, this._mousePan = e4, this._touchPan = i4;
          }
          enable(t3) {
            this._inertiaOptions = t3 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled();
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive();
          }
        }
        class oa2 {
          constructor(t3, e4, i4) {
            this._pitchWithRotate = t3.pitchWithRotate, this._mouseRotate = e4, this._mousePitch = i4;
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable();
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive();
          }
        }
        class ra2 {
          constructor(t3, e4, i4, s4) {
            this._el = t3, this._touchZoom = e4, this._touchRotate = i4, this._tapDragZoom = s4, this._rotationDisabled = false, this._enabled = true;
          }
          enable(t3) {
            this._touchZoom.enable(t3), this._rotationDisabled || this._touchRotate.enable(t3), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
          }
          disableRotation() {
            this._rotationDisabled = true, this._touchRotate.disable();
          }
          enableRotation() {
            this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
          }
        }
        class na2 {
          constructor(t3, e4) {
            this._bypassKey = -1 !== "Cloudflare-Workers".indexOf("Mac") ? "metaKey" : "ctrlKey", this._map = t3, this._options = e4, this._enabled = false;
          }
          isActive() {
            return false;
          }
          reset() {
          }
          _setupUI() {
            if (this._container)
              return;
            const t3 = this._map.getCanvasContainer();
            t3.classList.add("maplibregl-cooperative-gestures"), this._container = r4.create("div", "maplibregl-cooperative-gesture-screen", t3);
            let e4 = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
            "metaKey" === this._bypassKey && (e4 = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
            const i4 = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), s4 = document.createElement("div");
            s4.className = "maplibregl-desktop-message", s4.textContent = e4, this._container.appendChild(s4);
            const a3 = document.createElement("div");
            a3.className = "maplibregl-mobile-message", a3.textContent = i4, this._container.appendChild(a3), this._container.setAttribute("aria-hidden", "true");
          }
          _destoryUI() {
            this._container && (r4.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
          }
          enable() {
            this._setupUI(), this._enabled = true;
          }
          disable() {
            this._enabled = false, this._destoryUI();
          }
          isEnabled() {
            return this._enabled;
          }
          touchmove(t3) {
            this._onCooperativeGesture(1 === t3.touches.length);
          }
          wheel(t3) {
            this._map.scrollZoom.isEnabled() && this._onCooperativeGesture(!t3[this._bypassKey]);
          }
          _onCooperativeGesture(t3) {
            this._enabled && t3 && (this._container.classList.add("maplibregl-show"), setTimeout(() => {
              this._container.classList.remove("maplibregl-show");
            }, 100));
          }
        }
        const la = (t3) => t3.zoom || t3.drag || t3.pitch || t3.rotate;
        class ha2 extends e3.k {
        }
        function ca2(t3) {
          return t3.panDelta && t3.panDelta.mag() || t3.zoomDelta || t3.bearingDelta || t3.pitchDelta;
        }
        class ua2 {
          constructor(t3, e4) {
            this.handleWindowEvent = (t4) => {
              this.handleEvent(t4, `${t4.type}Window`);
            }, this.handleEvent = (t4, e5) => {
              if ("blur" === t4.type)
                return void this.stop(true);
              this._updatingCamera = true;
              const i5 = "renderFrame" === t4.type ? void 0 : t4, s4 = { needsRenderFrame: false }, a3 = {}, o3 = {}, n3 = t4.touches, l4 = n3 ? this._getMapTouches(n3) : void 0, h2 = l4 ? r4.touchPos(this._map.getCanvas(), l4) : r4.mousePos(this._map.getCanvas(), t4);
              for (const { handlerName: r5, handler: n4, allowed: c4 } of this._handlers) {
                if (!n4.isEnabled())
                  continue;
                let u4;
                this._blockedByActive(o3, c4, r5) ? n4.reset() : n4[e5 || t4.type] && (u4 = n4[e5 || t4.type](t4, h2, l4), this.mergeHandlerResult(s4, a3, u4, r5, i5), u4 && u4.needsRenderFrame && this._triggerRenderFrame()), (u4 || n4.isActive()) && (o3[r5] = n4);
              }
              const c3 = {};
              for (const t5 in this._previousActiveHandlers)
                o3[t5] || (c3[t5] = i5);
              this._previousActiveHandlers = o3, (Object.keys(c3).length || ca2(s4)) && (this._changes.push([s4, a3, c3]), this._triggerRenderFrame()), (Object.keys(o3).length || ca2(s4)) && this._map._stop(true), this._updatingCamera = false;
              const { cameraAnimation: u3 } = s4;
              u3 && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], u3(this._map));
            }, this._map = t3, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new ys(t3), this._bearingSnap = e4.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(e4);
            const i4 = this._el;
            this._listeners = [[i4, "touchstart", { passive: true }], [i4, "touchmove", { passive: false }], [i4, "touchend", void 0], [i4, "touchcancel", void 0], [i4, "mousedown", void 0], [i4, "mousemove", void 0], [i4, "mouseup", void 0], [document, "mousemove", { capture: true }], [document, "mouseup", void 0], [i4, "mouseover", void 0], [i4, "mouseout", void 0], [i4, "dblclick", void 0], [i4, "click", void 0], [i4, "keydown", { capture: false }], [i4, "keyup", void 0], [i4, "wheel", { passive: false }], [i4, "contextmenu", void 0], [window, "blur", void 0]];
            for (const [t4, e5, i5] of this._listeners)
              r4.addEventListener(t4, e5, t4 === document ? this.handleWindowEvent : this.handleEvent, i5);
          }
          destroy() {
            for (const [t3, e4, i4] of this._listeners)
              r4.removeEventListener(t3, e4, t3 === document ? this.handleWindowEvent : this.handleEvent, i4);
          }
          _addDefaultHandlers(t3) {
            const e4 = this._map, i4 = e4.getCanvasContainer();
            this._add("mapEvent", new Ss(e4, t3));
            const s4 = e4.boxZoom = new Ds(e4, t3);
            this._add("boxZoom", s4), t3.interactive && t3.boxZoom && s4.enable();
            const a3 = e4.cooperativeGestures = new na2(e4, t3.cooperativeGestures);
            this._add("cooperativeGestures", a3), t3.cooperativeGestures && a3.enable();
            const o3 = new Rs(e4), n3 = new ia2(e4);
            e4.doubleClickZoom = new ea2(n3, o3), this._add("tapZoom", o3), this._add("clickZoom", n3), t3.interactive && t3.doubleClickZoom && e4.doubleClickZoom.enable();
            const l4 = new sa2();
            this._add("tapDragZoom", l4);
            const h2 = e4.touchPitch = new Xs(e4);
            this._add("touchPitch", h2), t3.interactive && t3.touchPitch && e4.touchPitch.enable(t3.touchPitch);
            const c3 = Ns(t3), u3 = Us(t3);
            e4.dragRotate = new oa2(t3, c3, u3), this._add("mouseRotate", c3, ["mousePitch"]), this._add("mousePitch", u3, ["mouseRotate"]), t3.interactive && t3.dragRotate && e4.dragRotate.enable();
            const d2 = (({ enable: t4, clickTolerance: e5 }) => {
              const i5 = new Fs({ checkCorrectEvent: (t5) => 0 === r4.mouseButton(t5) && !t5.ctrlKey });
              return new Ls({ clickTolerance: e5, move: (t5, e6) => ({ around: e6, panDelta: e6.sub(t5) }), activateOnStart: true, moveStateManager: i5, enable: t4, assignEvents: Os });
            })(t3), _2 = new Zs(t3, e4);
            e4.dragPan = new aa2(i4, d2, _2), this._add("mousePan", d2), this._add("touchPan", _2, ["touchZoom", "touchRotate"]), t3.interactive && t3.dragPan && e4.dragPan.enable(t3.dragPan);
            const p4 = new Hs(), m2 = new Vs();
            e4.touchZoomRotate = new ra2(i4, m2, p4, l4), this._add("touchRotate", p4, ["touchPan", "touchZoom"]), this._add("touchZoom", m2, ["touchPan", "touchRotate"]), t3.interactive && t3.touchZoomRotate && e4.touchZoomRotate.enable(t3.touchZoomRotate);
            const f2 = e4.scrollZoom = new ta2(e4, () => this._triggerRenderFrame());
            this._add("scrollZoom", f2, ["mousePan"]), t3.interactive && t3.scrollZoom && e4.scrollZoom.enable(t3.scrollZoom);
            const g3 = e4.keyboard = new Ys(e4);
            this._add("keyboard", g3), t3.interactive && t3.keyboard && e4.keyboard.enable(), this._add("blockableMapEvent", new Cs(e4));
          }
          _add(t3, e4, i4) {
            this._handlers.push({ handlerName: t3, handler: e4, allowed: i4 }), this._handlersById[t3] = e4;
          }
          stop(t3) {
            if (!this._updatingCamera) {
              for (const { handler: t4 } of this._handlers)
                t4.reset();
              this._inertia.clear(), this._fireEvents({}, {}, t3), this._changes = [];
            }
          }
          isActive() {
            for (const { handler: t3 } of this._handlers)
              if (t3.isActive())
                return true;
            return false;
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
          }
          isRotating() {
            return !!this._eventsInProgress.rotate;
          }
          isMoving() {
            return Boolean(la(this._eventsInProgress)) || this.isZooming();
          }
          _blockedByActive(t3, e4, i4) {
            for (const s4 in t3)
              if (s4 !== i4 && (!e4 || e4.indexOf(s4) < 0))
                return true;
            return false;
          }
          _getMapTouches(t3) {
            const e4 = [];
            for (const i4 of t3)
              this._el.contains(i4.target) && e4.push(i4);
            return e4;
          }
          mergeHandlerResult(t3, i4, s4, a3, o3) {
            if (!s4)
              return;
            e3.e(t3, s4);
            const r5 = { handlerName: a3, originalEvent: s4.originalEvent || o3 };
            void 0 !== s4.zoomDelta && (i4.zoom = r5), void 0 !== s4.panDelta && (i4.drag = r5), void 0 !== s4.pitchDelta && (i4.pitch = r5), void 0 !== s4.bearingDelta && (i4.rotate = r5);
          }
          _applyChanges() {
            const t3 = {}, i4 = {}, s4 = {};
            for (const [a3, o3, r5] of this._changes)
              a3.panDelta && (t3.panDelta = (t3.panDelta || new e3.P(0, 0))._add(a3.panDelta)), a3.zoomDelta && (t3.zoomDelta = (t3.zoomDelta || 0) + a3.zoomDelta), a3.bearingDelta && (t3.bearingDelta = (t3.bearingDelta || 0) + a3.bearingDelta), a3.pitchDelta && (t3.pitchDelta = (t3.pitchDelta || 0) + a3.pitchDelta), void 0 !== a3.around && (t3.around = a3.around), void 0 !== a3.pinchAround && (t3.pinchAround = a3.pinchAround), a3.noInertia && (t3.noInertia = a3.noInertia), e3.e(i4, o3), e3.e(s4, r5);
            this._updateMapTransform(t3, i4, s4), this._changes = [];
          }
          _updateMapTransform(t3, e4, i4) {
            const s4 = this._map, a3 = s4._getTransformForUpdate(), o3 = s4.terrain;
            if (!(ca2(t3) || o3 && this._terrainMovement))
              return this._fireEvents(e4, i4, true);
            let { panDelta: r5, zoomDelta: n3, bearingDelta: l4, pitchDelta: h2, around: c3, pinchAround: u3 } = t3;
            void 0 !== u3 && (c3 = u3), s4._stop(true), c3 = c3 || s4.transform.centerPoint;
            const d2 = a3.pointLocation(r5 ? c3.sub(r5) : c3);
            l4 && (a3.bearing += l4), h2 && (a3.pitch += h2), n3 && (a3.zoom += n3), o3 ? this._terrainMovement || !e4.drag && !e4.zoom ? e4.drag && this._terrainMovement ? a3.center = a3.pointLocation(a3.centerPoint.sub(r5)) : a3.setLocationAtPoint(d2, c3) : (this._terrainMovement = true, this._map._elevationFreeze = true, a3.setLocationAtPoint(d2, c3), this._map.once("moveend", () => {
              this._map._elevationFreeze = false, this._terrainMovement = false, a3.recalculateZoom(s4.terrain);
            })) : a3.setLocationAtPoint(d2, c3), s4._applyUpdatedTransform(a3), this._map._update(), t3.noInertia || this._inertia.record(t3), this._fireEvents(e4, i4, true);
          }
          _fireEvents(t3, i4, s4) {
            const a3 = la(this._eventsInProgress), r5 = la(t3), n3 = {};
            for (const e4 in t3) {
              const { originalEvent: i5 } = t3[e4];
              this._eventsInProgress[e4] || (n3[`${e4}start`] = i5), this._eventsInProgress[e4] = t3[e4];
            }
            !a3 && r5 && this._fireEvent("movestart", r5.originalEvent);
            for (const t4 in n3)
              this._fireEvent(t4, n3[t4]);
            r5 && this._fireEvent("move", r5.originalEvent);
            for (const e4 in t3) {
              const { originalEvent: i5 } = t3[e4];
              this._fireEvent(e4, i5);
            }
            const l4 = {};
            let h2;
            for (const t4 in this._eventsInProgress) {
              const { handlerName: e4, originalEvent: s5 } = this._eventsInProgress[t4];
              this._handlersById[e4].isActive() || (delete this._eventsInProgress[t4], h2 = i4[e4] || s5, l4[`${t4}end`] = h2);
            }
            for (const t4 in l4)
              this._fireEvent(t4, l4[t4]);
            const c3 = la(this._eventsInProgress);
            if (s4 && (a3 || r5) && !c3) {
              this._updatingCamera = true;
              const t4 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i5 = (t5) => 0 !== t5 && -this._bearingSnap < t5 && t5 < this._bearingSnap;
              !t4 || !t4.essential && o2.prefersReducedMotion ? (this._map.fire(new e3.k("moveend", { originalEvent: h2 })), i5(this._map.getBearing()) && this._map.resetNorth()) : (i5(t4.bearing || this._map.getBearing()) && (t4.bearing = 0), t4.freezeElevation = true, this._map.easeTo(t4, { originalEvent: h2 })), this._updatingCamera = false;
            }
          }
          _fireEvent(t3, i4) {
            this._map.fire(new e3.k(t3, i4 ? { originalEvent: i4 } : {}));
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add((t3) => {
              delete this._frameId, this.handleEvent(new ha2("renderFrame", { timeStamp: t3 })), this._applyChanges();
            });
          }
          _triggerRenderFrame() {
            void 0 === this._frameId && (this._frameId = this._requestFrame());
          }
        }
        class da2 extends e3.E {
          constructor(t3, e4) {
            super(), this._renderFrameCallback = () => {
              const t4 = Math.min((o2.now() - this._easeStart) / this._easeOptions.duration, 1);
              this._onEaseFrame(this._easeOptions.easing(t4)), t4 < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
            }, this._moving = false, this._zooming = false, this.transform = t3, this._bearingSnap = e4.bearingSnap, this.on("moveend", () => {
              delete this._requestedCameraState;
            });
          }
          getCenter() {
            return new e3.M(this.transform.center.lng, this.transform.center.lat);
          }
          setCenter(t3, e4) {
            return this.jumpTo({ center: t3 }, e4);
          }
          panBy(t3, i4, s4) {
            return t3 = e3.P.convert(t3).mult(-1), this.panTo(this.transform.center, e3.e({ offset: t3 }, i4), s4);
          }
          panTo(t3, i4, s4) {
            return this.easeTo(e3.e({ center: t3 }, i4), s4);
          }
          getZoom() {
            return this.transform.zoom;
          }
          setZoom(t3, e4) {
            return this.jumpTo({ zoom: t3 }, e4), this;
          }
          zoomTo(t3, i4, s4) {
            return this.easeTo(e3.e({ zoom: t3 }, i4), s4);
          }
          zoomIn(t3, e4) {
            return this.zoomTo(this.getZoom() + 1, t3, e4), this;
          }
          zoomOut(t3, e4) {
            return this.zoomTo(this.getZoom() - 1, t3, e4), this;
          }
          getBearing() {
            return this.transform.bearing;
          }
          setBearing(t3, e4) {
            return this.jumpTo({ bearing: t3 }, e4), this;
          }
          getPadding() {
            return this.transform.padding;
          }
          setPadding(t3, e4) {
            return this.jumpTo({ padding: t3 }, e4), this;
          }
          rotateTo(t3, i4, s4) {
            return this.easeTo(e3.e({ bearing: t3 }, i4), s4);
          }
          resetNorth(t3, i4) {
            return this.rotateTo(0, e3.e({ duration: 1e3 }, t3), i4), this;
          }
          resetNorthPitch(t3, i4) {
            return this.easeTo(e3.e({ bearing: 0, pitch: 0, duration: 1e3 }, t3), i4), this;
          }
          snapToNorth(t3, e4) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t3, e4) : this;
          }
          getPitch() {
            return this.transform.pitch;
          }
          setPitch(t3, e4) {
            return this.jumpTo({ pitch: t3 }, e4), this;
          }
          cameraForBounds(t3, e4) {
            t3 = V2.convert(t3);
            const i4 = e4 && e4.bearing || 0;
            return this._cameraForBoxAndBearing(t3.getNorthWest(), t3.getSouthEast(), i4, e4);
          }
          _cameraForBoxAndBearing(t3, i4, s4, a3) {
            const o3 = { top: 0, bottom: 0, right: 0, left: 0 };
            if ("number" == typeof (a3 = e3.e({ padding: o3, offset: [0, 0], maxZoom: this.transform.maxZoom }, a3)).padding) {
              const t4 = a3.padding;
              a3.padding = { top: t4, bottom: t4, right: t4, left: t4 };
            }
            a3.padding = e3.e(o3, a3.padding);
            const r5 = this.transform, n3 = r5.padding, l4 = new V2(t3, i4), h2 = r5.project(l4.getNorthWest()), c3 = r5.project(l4.getNorthEast()), u3 = r5.project(l4.getSouthEast()), d2 = r5.project(l4.getSouthWest()), _2 = e3.b7(-s4), p4 = h2.rotate(_2), m2 = c3.rotate(_2), f2 = u3.rotate(_2), g3 = d2.rotate(_2), v4 = new e3.P(Math.max(p4.x, m2.x, g3.x, f2.x), Math.max(p4.y, m2.y, g3.y, f2.y)), x5 = new e3.P(Math.min(p4.x, m2.x, g3.x, f2.x), Math.min(p4.y, m2.y, g3.y, f2.y)), y4 = v4.sub(x5), b3 = (r5.width - (n3.left + n3.right + a3.padding.left + a3.padding.right)) / y4.x, w4 = (r5.height - (n3.top + n3.bottom + a3.padding.top + a3.padding.bottom)) / y4.y;
            if (w4 < 0 || b3 < 0)
              return void e3.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
            const T3 = Math.min(r5.scaleZoom(r5.scale * Math.min(b3, w4)), a3.maxZoom), I3 = e3.P.convert(a3.offset), E3 = new e3.P((a3.padding.left - a3.padding.right) / 2, (a3.padding.top - a3.padding.bottom) / 2).rotate(e3.b7(s4)), S4 = I3.add(E3).mult(r5.scale / r5.zoomScale(T3));
            return { center: r5.unproject(h2.add(u3).div(2).sub(S4)), zoom: T3, bearing: s4 };
          }
          fitBounds(t3, e4, i4) {
            return this._fitInternal(this.cameraForBounds(t3, e4), e4, i4);
          }
          fitScreenCoordinates(t3, i4, s4, a3, o3) {
            return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(e3.P.convert(t3)), this.transform.pointLocation(e3.P.convert(i4)), s4, a3), a3, o3);
          }
          _fitInternal(t3, i4, s4) {
            return t3 ? (delete (i4 = e3.e(t3, i4)).padding, i4.linear ? this.easeTo(i4, s4) : this.flyTo(i4, s4)) : this;
          }
          jumpTo(t3, i4) {
            this.stop();
            const s4 = this._getTransformForUpdate();
            let a3 = false, o3 = false, r5 = false;
            return "zoom" in t3 && s4.zoom !== +t3.zoom && (a3 = true, s4.zoom = +t3.zoom), void 0 !== t3.center && (s4.center = e3.M.convert(t3.center)), "bearing" in t3 && s4.bearing !== +t3.bearing && (o3 = true, s4.bearing = +t3.bearing), "pitch" in t3 && s4.pitch !== +t3.pitch && (r5 = true, s4.pitch = +t3.pitch), null == t3.padding || s4.isPaddingEqual(t3.padding) || (s4.padding = t3.padding), this._applyUpdatedTransform(s4), this.fire(new e3.k("movestart", i4)).fire(new e3.k("move", i4)), a3 && this.fire(new e3.k("zoomstart", i4)).fire(new e3.k("zoom", i4)).fire(new e3.k("zoomend", i4)), o3 && this.fire(new e3.k("rotatestart", i4)).fire(new e3.k("rotate", i4)).fire(new e3.k("rotateend", i4)), r5 && this.fire(new e3.k("pitchstart", i4)).fire(new e3.k("pitch", i4)).fire(new e3.k("pitchend", i4)), this.fire(new e3.k("moveend", i4));
          }
          calculateCameraOptionsFromTo(t3, i4, s4, a3 = 0) {
            const o3 = e3.Y.fromLngLat(t3, i4), r5 = e3.Y.fromLngLat(s4, a3), n3 = r5.x - o3.x, l4 = r5.y - o3.y, h2 = r5.z - o3.z, c3 = Math.hypot(n3, l4, h2);
            if (0 === c3)
              throw new Error("Can't calculate camera options with same From and To");
            const u3 = Math.hypot(n3, l4), d2 = this.transform.scaleZoom(this.transform.cameraToCenterDistance / c3 / this.transform.tileSize), _2 = 180 * Math.atan2(n3, -l4) / Math.PI;
            let p4 = 180 * Math.acos(u3 / c3) / Math.PI;
            return p4 = h2 < 0 ? 90 - p4 : 90 + p4, { center: r5.toLngLat(), zoom: d2, pitch: p4, bearing: _2 };
          }
          easeTo(t3, i4) {
            this._stop(false, t3.easeId), (false === (t3 = e3.e({ offset: [0, 0], duration: 500, easing: e3.b6 }, t3)).animate || !t3.essential && o2.prefersReducedMotion) && (t3.duration = 0);
            const s4 = this._getTransformForUpdate(), a3 = this.getZoom(), r5 = this.getBearing(), n3 = this.getPitch(), l4 = this.getPadding(), h2 = "zoom" in t3 ? +t3.zoom : a3, c3 = "bearing" in t3 ? this._normalizeBearing(t3.bearing, r5) : r5, u3 = "pitch" in t3 ? +t3.pitch : n3, d2 = "padding" in t3 ? t3.padding : s4.padding, _2 = e3.P.convert(t3.offset);
            let p4 = s4.centerPoint.add(_2);
            const m2 = s4.pointLocation(p4), f2 = e3.M.convert(t3.center || m2);
            this._normalizeCenter(f2);
            const g3 = s4.project(m2), v4 = s4.project(f2).sub(g3), x5 = s4.zoomScale(h2 - a3);
            let y4, b3;
            t3.around && (y4 = e3.M.convert(t3.around), b3 = s4.locationPoint(y4));
            const w4 = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
            return this._zooming = this._zooming || h2 !== a3, this._rotating = this._rotating || r5 !== c3, this._pitching = this._pitching || u3 !== n3, this._padding = !s4.isPaddingEqual(d2), this._easeId = t3.easeId, this._prepareEase(i4, t3.noMoveStart, w4), this.terrain && this._prepareElevation(f2), this._ease((o3) => {
              if (this._zooming && (s4.zoom = e3.z.number(a3, h2, o3)), this._rotating && (s4.bearing = e3.z.number(r5, c3, o3)), this._pitching && (s4.pitch = e3.z.number(n3, u3, o3)), this._padding && (s4.interpolatePadding(l4, d2, o3), p4 = s4.centerPoint.add(_2)), this.terrain && !t3.freezeElevation && this._updateElevation(o3), y4)
                s4.setLocationAtPoint(y4, b3);
              else {
                const t4 = s4.zoomScale(s4.zoom - a3), e4 = h2 > a3 ? Math.min(2, x5) : Math.max(0.5, x5), i5 = Math.pow(e4, 1 - o3), r6 = s4.unproject(g3.add(v4.mult(o3 * i5)).mult(t4));
                s4.setLocationAtPoint(s4.renderWorldCopies ? r6.wrap() : r6, p4);
              }
              this._applyUpdatedTransform(s4), this._fireMoveEvents(i4);
            }, (t4) => {
              this.terrain && this._finalizeElevation(), this._afterEase(i4, t4);
            }, t3), this;
          }
          _prepareEase(t3, i4, s4 = {}) {
            this._moving = true, i4 || s4.moving || this.fire(new e3.k("movestart", t3)), this._zooming && !s4.zooming && this.fire(new e3.k("zoomstart", t3)), this._rotating && !s4.rotating && this.fire(new e3.k("rotatestart", t3)), this._pitching && !s4.pitching && this.fire(new e3.k("pitchstart", t3));
          }
          _prepareElevation(t3) {
            this._elevationCenter = t3, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(t3, this.transform.tileZoom), this._elevationFreeze = true;
          }
          _updateElevation(t3) {
            this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
            const i4 = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
            if (t3 < 1 && i4 !== this._elevationTarget) {
              const e4 = this._elevationTarget - this._elevationStart;
              this._elevationStart += t3 * (e4 - (i4 - (e4 * t3 + this._elevationStart)) / (1 - t3)), this._elevationTarget = i4;
            }
            this.transform.elevation = e3.z.number(this._elevationStart, this._elevationTarget, t3);
          }
          _finalizeElevation() {
            this._elevationFreeze = false, this.transform.recalculateZoom(this.terrain);
          }
          _getTransformForUpdate() {
            return this.transformCameraUpdate ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
          }
          _applyUpdatedTransform(t3) {
            if (!this.transformCameraUpdate)
              return;
            const e4 = t3.clone(), { center: i4, zoom: s4, pitch: a3, bearing: o3, elevation: r5 } = this.transformCameraUpdate(e4);
            i4 && (e4.center = i4), void 0 !== s4 && (e4.zoom = s4), void 0 !== a3 && (e4.pitch = a3), void 0 !== o3 && (e4.bearing = o3), void 0 !== r5 && (e4.elevation = r5), this.transform.apply(e4);
          }
          _fireMoveEvents(t3) {
            this.fire(new e3.k("move", t3)), this._zooming && this.fire(new e3.k("zoom", t3)), this._rotating && this.fire(new e3.k("rotate", t3)), this._pitching && this.fire(new e3.k("pitch", t3));
          }
          _afterEase(t3, i4) {
            if (this._easeId && i4 && this._easeId === i4)
              return;
            delete this._easeId;
            const s4 = this._zooming, a3 = this._rotating, o3 = this._pitching;
            this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._padding = false, s4 && this.fire(new e3.k("zoomend", t3)), a3 && this.fire(new e3.k("rotateend", t3)), o3 && this.fire(new e3.k("pitchend", t3)), this.fire(new e3.k("moveend", t3));
          }
          flyTo(t3, i4) {
            if (!t3.essential && o2.prefersReducedMotion) {
              const s5 = e3.L(t3, ["center", "zoom", "bearing", "pitch", "around"]);
              return this.jumpTo(s5, i4);
            }
            this.stop(), t3 = e3.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: e3.b6 }, t3);
            const s4 = this._getTransformForUpdate(), a3 = this.getZoom(), r5 = this.getBearing(), n3 = this.getPitch(), l4 = this.getPadding(), h2 = "zoom" in t3 ? e3.ac(+t3.zoom, s4.minZoom, s4.maxZoom) : a3, c3 = "bearing" in t3 ? this._normalizeBearing(t3.bearing, r5) : r5, u3 = "pitch" in t3 ? +t3.pitch : n3, d2 = "padding" in t3 ? t3.padding : s4.padding, _2 = s4.zoomScale(h2 - a3), p4 = e3.P.convert(t3.offset);
            let m2 = s4.centerPoint.add(p4);
            const f2 = s4.pointLocation(m2), g3 = e3.M.convert(t3.center || f2);
            this._normalizeCenter(g3);
            const v4 = s4.project(f2), x5 = s4.project(g3).sub(v4);
            let y4 = t3.curve;
            const b3 = Math.max(s4.width, s4.height), w4 = b3 / _2, T3 = x5.mag();
            if ("minZoom" in t3) {
              const i5 = e3.ac(Math.min(t3.minZoom, a3, h2), s4.minZoom, s4.maxZoom), o3 = b3 / s4.zoomScale(i5 - a3);
              y4 = Math.sqrt(o3 / T3 * 2);
            }
            const I3 = y4 * y4;
            function E3(t4) {
              const e4 = (w4 * w4 - b3 * b3 + (t4 ? -1 : 1) * I3 * I3 * T3 * T3) / (2 * (t4 ? w4 : b3) * I3 * T3);
              return Math.log(Math.sqrt(e4 * e4 + 1) - e4);
            }
            function S4(t4) {
              return (Math.exp(t4) - Math.exp(-t4)) / 2;
            }
            function C5(t4) {
              return (Math.exp(t4) + Math.exp(-t4)) / 2;
            }
            const P3 = E3(false);
            let D4 = function(t4) {
              return C5(P3) / C5(P3 + y4 * t4);
            }, z4 = function(t4) {
              return b3 * ((C5(P3) * (S4(e4 = P3 + y4 * t4) / C5(e4)) - S4(P3)) / I3) / T3;
              var e4;
            }, M3 = (E3(true) - P3) / y4;
            if (Math.abs(T3) < 1e-6 || !isFinite(M3)) {
              if (Math.abs(b3 - w4) < 1e-6)
                return this.easeTo(t3, i4);
              const e4 = w4 < b3 ? -1 : 1;
              M3 = Math.abs(Math.log(w4 / b3)) / y4, z4 = function() {
                return 0;
              }, D4 = function(t4) {
                return Math.exp(e4 * y4 * t4);
              };
            }
            return t3.duration = "duration" in t3 ? +t3.duration : 1e3 * M3 / ("screenSpeed" in t3 ? +t3.screenSpeed / y4 : +t3.speed), t3.maxDuration && t3.duration > t3.maxDuration && (t3.duration = 0), this._zooming = true, this._rotating = r5 !== c3, this._pitching = u3 !== n3, this._padding = !s4.isPaddingEqual(d2), this._prepareEase(i4, false), this.terrain && this._prepareElevation(g3), this._ease((o3) => {
              const _3 = o3 * M3, f3 = 1 / D4(_3);
              s4.zoom = 1 === o3 ? h2 : a3 + s4.scaleZoom(f3), this._rotating && (s4.bearing = e3.z.number(r5, c3, o3)), this._pitching && (s4.pitch = e3.z.number(n3, u3, o3)), this._padding && (s4.interpolatePadding(l4, d2, o3), m2 = s4.centerPoint.add(p4)), this.terrain && !t3.freezeElevation && this._updateElevation(o3);
              const y5 = 1 === o3 ? g3 : s4.unproject(v4.add(x5.mult(z4(_3))).mult(f3));
              s4.setLocationAtPoint(s4.renderWorldCopies ? y5.wrap() : y5, m2), this._applyUpdatedTransform(s4), this._fireMoveEvents(i4);
            }, () => {
              this.terrain && this._finalizeElevation(), this._afterEase(i4);
            }, t3), this;
          }
          isEasing() {
            return !!this._easeFrameId;
          }
          stop() {
            return this._stop();
          }
          _stop(t3, e4) {
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
              const t4 = this._onEaseEnd;
              delete this._onEaseEnd, t4.call(this, e4);
            }
            if (!t3) {
              const t4 = this.handlers;
              t4 && t4.stop(false);
            }
            return this;
          }
          _ease(t3, e4, i4) {
            false === i4.animate || 0 === i4.duration ? (t3(1), e4()) : (this._easeStart = o2.now(), this._easeOptions = i4, this._onEaseFrame = t3, this._onEaseEnd = e4, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
          }
          _normalizeBearing(t3, i4) {
            t3 = e3.b0(t3, -180, 180);
            const s4 = Math.abs(t3 - i4);
            return Math.abs(t3 - 360 - i4) < s4 && (t3 -= 360), Math.abs(t3 + 360 - i4) < s4 && (t3 += 360), t3;
          }
          _normalizeCenter(t3) {
            const e4 = this.transform;
            if (!e4.renderWorldCopies || e4.lngRange)
              return;
            const i4 = t3.lng - e4.center.lng;
            t3.lng += i4 > 180 ? -360 : i4 < -180 ? 360 : 0;
          }
          queryTerrainElevation(t3) {
            return this.terrain ? this.terrain.getElevationForLngLatZoom(e3.M.convert(t3), this.transform.tileZoom) - this.transform.elevation : null;
          }
        }
        const _a2 = { compact: true, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' };
        class pa2 {
          constructor(t3 = _a2) {
            this._toggleAttribution = () => {
              this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
            }, this._updateData = (t4) => {
              !t4 || "metadata" !== t4.sourceDataType && "visibility" !== t4.sourceDataType && "style" !== t4.dataType && "terrain" !== t4.type || this._updateAttributions();
            }, this._updateCompact = () => {
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? false === this._compact ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
            }, this._updateCompactMinimize = () => {
              this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
            }, this.options = t3;
          }
          getDefaultPosition() {
            return "bottom-right";
          }
          onAdd(t3) {
            return this._map = t3, this._compact = this.options.compact, this._container = r4.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = r4.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = r4.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
          }
          onRemove() {
            r4.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
          }
          _setElementTitle(t3, e4) {
            const i4 = this._map._getUIString(`AttributionControl.${e4}`);
            t3.title = i4, t3.setAttribute("aria-label", i4);
          }
          _updateAttributions() {
            if (!this._map.style)
              return;
            let t3 = [];
            if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? t3 = t3.concat(this.options.customAttribution.map((t4) => "string" != typeof t4 ? "" : t4)) : "string" == typeof this.options.customAttribution && t3.push(this.options.customAttribution)), this._map.style.stylesheet) {
              const t4 = this._map.style.stylesheet;
              this.styleOwner = t4.owner, this.styleId = t4.id;
            }
            const e4 = this._map.style.sourceCaches;
            for (const i5 in e4) {
              const s4 = e4[i5];
              if (s4.used || s4.usedForTerrain) {
                const e5 = s4.getSource();
                e5.attribution && t3.indexOf(e5.attribution) < 0 && t3.push(e5.attribution);
              }
            }
            t3 = t3.filter((t4) => String(t4).trim()), t3.sort((t4, e5) => t4.length - e5.length), t3 = t3.filter((e5, i5) => {
              for (let s4 = i5 + 1; s4 < t3.length; s4++)
                if (t3[s4].indexOf(e5) >= 0)
                  return false;
              return true;
            });
            const i4 = t3.join(" | ");
            i4 !== this._attribHTML && (this._attribHTML = i4, t3.length ? (this._innerContainer.innerHTML = i4, this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
          }
        }
        class ma2 {
          constructor(t3 = {}) {
            this._updateCompact = () => {
              const t4 = this._container.children;
              if (t4.length) {
                const e4 = t4[0];
                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? false !== this._compact && e4.classList.add("maplibregl-compact") : e4.classList.remove("maplibregl-compact");
              }
            }, this.options = t3;
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(t3) {
            this._map = t3, this._compact = this.options && this.options.compact, this._container = r4.create("div", "maplibregl-ctrl");
            const e4 = r4.create("a", "maplibregl-ctrl-logo");
            return e4.target = "_blank", e4.rel = "noopener nofollow", e4.href = "https://maplibre.org/", e4.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), e4.setAttribute("rel", "noopener nofollow"), this._container.appendChild(e4), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
          }
          onRemove() {
            r4.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
          }
        }
        class fa2 {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
          }
          add(t3) {
            const e4 = ++this._id;
            return this._queue.push({ callback: t3, id: e4, cancelled: false }), e4;
          }
          remove(t3) {
            const e4 = this._currentlyRunning, i4 = e4 ? this._queue.concat(e4) : this._queue;
            for (const e5 of i4)
              if (e5.id === t3)
                return void (e5.cancelled = true);
          }
          run(t3 = 0) {
            if (this._currentlyRunning)
              throw new Error("Attempting to run(), but is already running.");
            const e4 = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const i4 of e4)
              if (!i4.cancelled && (i4.callback(t3), this._cleared))
                break;
            this._cleared = false, this._currentlyRunning = false;
          }
          clear() {
            this._currentlyRunning && (this._cleared = true), this._queue = [];
          }
        }
        var ga = e3.X([{ name: "a_pos3d", type: "Int16", components: 3 }]);
        class va2 extends e3.E {
          constructor(t3) {
            super(), this.sourceCache = t3, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.deltaZoom = 1, t3.usedForTerrain = true, t3.tileSize = this.tileSize * 2 ** this.deltaZoom;
          }
          destruct() {
            this.sourceCache.usedForTerrain = false, this.sourceCache.tileSize = null;
          }
          update(t3, i4) {
            this.sourceCache.update(t3, i4), this._renderableTilesKeys = [];
            const s4 = {};
            for (const a3 of t3.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: false, terrain: i4 }))
              s4[a3.key] = true, this._renderableTilesKeys.push(a3.key), this._tiles[a3.key] || (a3.posMatrix = new Float64Array(16), e3.aN(a3.posMatrix, 0, e3.W, 0, e3.W, 0, 1), this._tiles[a3.key] = new rt(a3, this.tileSize));
            for (const t4 in this._tiles)
              s4[t4] || delete this._tiles[t4];
          }
          freeRtt(t3) {
            for (const e4 in this._tiles) {
              const i4 = this._tiles[e4];
              (!t3 || i4.tileID.equals(t3) || i4.tileID.isChildOf(t3) || t3.isChildOf(i4.tileID)) && (i4.rtt = []);
            }
          }
          getRenderableTiles() {
            return this._renderableTilesKeys.map((t3) => this.getTileByID(t3));
          }
          getTileByID(t3) {
            return this._tiles[t3];
          }
          getTerrainCoords(t3) {
            const i4 = {};
            for (const s4 of this._renderableTilesKeys) {
              const a3 = this._tiles[s4].tileID;
              if (a3.canonical.equals(t3.canonical)) {
                const a4 = t3.clone();
                a4.posMatrix = new Float64Array(16), e3.aN(a4.posMatrix, 0, e3.W, 0, e3.W, 0, 1), i4[s4] = a4;
              } else if (a3.canonical.isChildOf(t3.canonical)) {
                const o3 = t3.clone();
                o3.posMatrix = new Float64Array(16);
                const r5 = a3.canonical.z - t3.canonical.z, n3 = a3.canonical.x - (a3.canonical.x >> r5 << r5), l4 = a3.canonical.y - (a3.canonical.y >> r5 << r5), h2 = e3.W >> r5;
                e3.aN(o3.posMatrix, 0, h2, 0, h2, 0, 1), e3.H(o3.posMatrix, o3.posMatrix, [-n3 * h2, -l4 * h2, 0]), i4[s4] = o3;
              } else if (t3.canonical.isChildOf(a3.canonical)) {
                const o3 = t3.clone();
                o3.posMatrix = new Float64Array(16);
                const r5 = t3.canonical.z - a3.canonical.z, n3 = t3.canonical.x - (t3.canonical.x >> r5 << r5), l4 = t3.canonical.y - (t3.canonical.y >> r5 << r5), h2 = e3.W >> r5;
                e3.aN(o3.posMatrix, 0, e3.W, 0, e3.W, 0, 1), e3.H(o3.posMatrix, o3.posMatrix, [n3 * h2, l4 * h2, 0]), e3.J(o3.posMatrix, o3.posMatrix, [1 / 2 ** r5, 1 / 2 ** r5, 0]), i4[s4] = o3;
              }
            }
            return i4;
          }
          getSourceTile(t3, e4) {
            const i4 = this.sourceCache._source;
            let s4 = t3.overscaledZ - this.deltaZoom;
            if (s4 > i4.maxzoom && (s4 = i4.maxzoom), s4 < i4.minzoom)
              return null;
            this._sourceTileCache[t3.key] || (this._sourceTileCache[t3.key] = t3.scaledTo(s4).key);
            let a3 = this.sourceCache.getTileByID(this._sourceTileCache[t3.key]);
            if ((!a3 || !a3.dem) && e4)
              for (; s4 >= i4.minzoom && (!a3 || !a3.dem); )
                a3 = this.sourceCache.getTileByID(t3.scaledTo(s4--).key);
            return a3;
          }
          tilesAfterTime(t3 = Date.now()) {
            return Object.values(this._tiles).filter((e4) => e4.timeAdded >= t3);
          }
        }
        class xa2 {
          constructor(t3, e4, i4) {
            this.painter = t3, this.sourceCache = new va2(e4), this.options = i4, this.exaggeration = "number" == typeof i4.exaggeration ? i4.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
          }
          getDEMElevation(t3, i4, s4, a3 = e3.W) {
            var o3;
            if (!(i4 >= 0 && i4 < a3 && s4 >= 0 && s4 < a3))
              return 0;
            const r5 = this.getTerrainData(t3), n3 = null === (o3 = r5.tile) || void 0 === o3 ? void 0 : o3.dem;
            if (!n3)
              return 0;
            const l4 = function(t4, e4, i5) {
              var s5 = e4[0], a4 = e4[1];
              return t4[0] = i5[0] * s5 + i5[4] * a4 + i5[12], t4[1] = i5[1] * s5 + i5[5] * a4 + i5[13], t4;
            }([], [i4 / a3 * e3.W, s4 / a3 * e3.W], r5.u_terrain_matrix), h2 = [l4[0] * n3.dim, l4[1] * n3.dim], c3 = Math.floor(h2[0]), u3 = Math.floor(h2[1]), d2 = h2[0] - c3, _2 = h2[1] - u3;
            return n3.get(c3, u3) * (1 - d2) * (1 - _2) + n3.get(c3 + 1, u3) * d2 * (1 - _2) + n3.get(c3, u3 + 1) * (1 - d2) * _2 + n3.get(c3 + 1, u3 + 1) * d2 * _2;
          }
          getElevationForLngLatZoom(t3, i4) {
            const { tileID: s4, mercatorX: a3, mercatorY: o3 } = this._getOverscaledTileIDFromLngLatZoom(t3, i4);
            return this.getElevation(s4, a3 % e3.W, o3 % e3.W, e3.W);
          }
          getElevation(t3, i4, s4, a3 = e3.W) {
            return this.getDEMElevation(t3, i4, s4, a3) * this.exaggeration;
          }
          getTerrainData(t3) {
            if (!this._emptyDemTexture) {
              const t4 = this.painter.context, i5 = new e3.R({ width: 1, height: 1 }, new Uint8Array(4));
              this._emptyDepthTexture = new w3(t4, i5, t4.gl.RGBA, { premultiply: false }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new w3(t4, new e3.R({ width: 1, height: 1 }), t4.gl.RGBA, { premultiply: false }), this._emptyDemTexture.bind(t4.gl.NEAREST, t4.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = e3.an([]);
            }
            const i4 = this.sourceCache.getSourceTile(t3, true);
            if (i4 && i4.dem && (!i4.demTexture || i4.needsTerrainPrepare)) {
              const t4 = this.painter.context;
              i4.demTexture = this.painter.getTileTexture(i4.dem.stride), i4.demTexture ? i4.demTexture.update(i4.dem.getPixels(), { premultiply: false }) : i4.demTexture = new w3(t4, i4.dem.getPixels(), t4.gl.RGBA, { premultiply: false }), i4.demTexture.bind(t4.gl.NEAREST, t4.gl.CLAMP_TO_EDGE), i4.needsTerrainPrepare = false;
            }
            const s4 = i4 && i4 + i4.tileID.key + t3.key;
            if (s4 && !this._demMatrixCache[s4]) {
              const s5 = this.sourceCache.sourceCache._source.maxzoom;
              let a3 = t3.canonical.z - i4.tileID.canonical.z;
              t3.overscaledZ > t3.canonical.z && (t3.canonical.z >= s5 ? a3 = t3.canonical.z - s5 : e3.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
              const o3 = t3.canonical.x - (t3.canonical.x >> a3 << a3), r5 = t3.canonical.y - (t3.canonical.y >> a3 << a3), n3 = e3.b8(new Float64Array(16), [1 / (e3.W << a3), 1 / (e3.W << a3), 0]);
              e3.H(n3, n3, [o3 * e3.W, r5 * e3.W, 0]), this._demMatrixCache[t3.key] = { matrix: n3, coord: t3 };
            }
            return { u_depth: 2, u_terrain: 3, u_terrain_dim: i4 && i4.dem && i4.dem.dim || 1, u_terrain_matrix: s4 ? this._demMatrixCache[t3.key].matrix : this._emptyDemMatrix, u_terrain_unpack: i4 && i4.dem && i4.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (i4 && i4.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: i4 };
          }
          getFramebuffer(t3) {
            const e4 = this.painter, i4 = e4.width / devicePixelRatio, s4 = e4.height / devicePixelRatio;
            return !this._fbo || this._fbo.width === i4 && this._fbo.height === s4 || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new w3(e4.context, { width: i4, height: s4, data: null }, e4.context.gl.RGBA, { premultiply: false }), this._fboCoordsTexture.bind(e4.context.gl.NEAREST, e4.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new w3(e4.context, { width: i4, height: s4, data: null }, e4.context.gl.RGBA, { premultiply: false }), this._fboDepthTexture.bind(e4.context.gl.NEAREST, e4.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = e4.context.createFramebuffer(i4, s4, true, false), this._fbo.depthAttachment.set(e4.context.createRenderbuffer(e4.context.gl.DEPTH_COMPONENT16, i4, s4))), this._fbo.colorAttachment.set("coords" === t3 ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
          }
          getCoordsTexture() {
            const t3 = this.painter.context;
            if (this._coordsTexture)
              return this._coordsTexture;
            const i4 = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
            for (let t4 = 0, e4 = 0; t4 < this._coordsTextureSize; t4++)
              for (let s5 = 0; s5 < this._coordsTextureSize; s5++, e4 += 4)
                i4[e4 + 0] = 255 & s5, i4[e4 + 1] = 255 & t4, i4[e4 + 2] = s5 >> 8 << 4 | t4 >> 8, i4[e4 + 3] = 0;
            const s4 = new e3.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(i4.buffer)), a3 = new w3(t3, s4, t3.gl.RGBA, { premultiply: false });
            return a3.bind(t3.gl.NEAREST, t3.gl.CLAMP_TO_EDGE), this._coordsTexture = a3, a3;
          }
          pointCoordinate(t3) {
            const i4 = new Uint8Array(4), s4 = this.painter.context, a3 = s4.gl;
            s4.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), a3.readPixels(t3.x, this.painter.height / devicePixelRatio - t3.y - 1, 1, 1, a3.RGBA, a3.UNSIGNED_BYTE, i4), s4.bindFramebuffer.set(null);
            const o3 = i4[0] + (i4[2] >> 4 << 8), r5 = i4[1] + ((15 & i4[2]) << 8), n3 = this.coordsIndex[255 - i4[3]], l4 = n3 && this.sourceCache.getTileByID(n3);
            if (!l4)
              return null;
            const h2 = this._coordsTextureSize, c3 = (1 << l4.tileID.canonical.z) * h2;
            return new e3.Y((l4.tileID.canonical.x * h2 + o3) / c3 + l4.tileID.wrap, (l4.tileID.canonical.y * h2 + r5) / c3, this.getElevation(l4.tileID, o3, r5, h2));
          }
          depthAtPoint(t3) {
            const e4 = new Uint8Array(4), i4 = this.painter.context, s4 = i4.gl;
            return i4.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), s4.readPixels(t3.x, this.painter.height / devicePixelRatio - t3.y - 1, 1, 1, s4.RGBA, s4.UNSIGNED_BYTE, e4), i4.bindFramebuffer.set(null), (e4[0] / 16777216 + e4[1] / 65536 + e4[2] / 256 + e4[3]) / 256;
          }
          getTerrainMesh() {
            if (this._mesh)
              return this._mesh;
            const t3 = this.painter.context, i4 = new e3.b9(), s4 = new e3.aX(), a3 = this.meshSize, o3 = e3.W / a3, r5 = a3 * a3;
            for (let t4 = 0; t4 <= a3; t4++)
              for (let e4 = 0; e4 <= a3; e4++)
                i4.emplaceBack(e4 * o3, t4 * o3, 0);
            for (let t4 = 0; t4 < r5; t4 += a3 + 1)
              for (let e4 = 0; e4 < a3; e4++)
                s4.emplaceBack(e4 + t4, a3 + e4 + t4 + 1, a3 + e4 + t4 + 2), s4.emplaceBack(e4 + t4, a3 + e4 + t4 + 2, e4 + t4 + 1);
            const n3 = i4.length, l4 = n3 + 2 * (a3 + 1);
            for (const t4 of [0, 1])
              for (let s5 = 0; s5 <= a3; s5++)
                for (const a4 of [0, 1])
                  i4.emplaceBack(s5 * o3, t4 * e3.W, a4);
            for (let t4 = 0; t4 < 2 * a3; t4 += 2)
              s4.emplaceBack(l4 + t4, l4 + t4 + 1, l4 + t4 + 3), s4.emplaceBack(l4 + t4, l4 + t4 + 3, l4 + t4 + 2), s4.emplaceBack(n3 + t4, n3 + t4 + 3, n3 + t4 + 1), s4.emplaceBack(n3 + t4, n3 + t4 + 2, n3 + t4 + 3);
            const h2 = i4.length, c3 = h2 + 2 * (a3 + 1);
            for (const t4 of [0, 1])
              for (let s5 = 0; s5 <= a3; s5++)
                for (const a4 of [0, 1])
                  i4.emplaceBack(t4 * e3.W, s5 * o3, a4);
            for (let t4 = 0; t4 < 2 * a3; t4 += 2)
              s4.emplaceBack(h2 + t4, h2 + t4 + 1, h2 + t4 + 3), s4.emplaceBack(h2 + t4, h2 + t4 + 3, h2 + t4 + 2), s4.emplaceBack(c3 + t4, c3 + t4 + 3, c3 + t4 + 1), s4.emplaceBack(c3 + t4, c3 + t4 + 2, c3 + t4 + 3);
            return this._mesh = { indexBuffer: t3.createIndexBuffer(s4), vertexBuffer: t3.createVertexBuffer(i4, ga.members), segments: e3.$.simpleSegment(0, 0, i4.length, s4.length) }, this._mesh;
          }
          getMeshFrameDelta(t3) {
            return 2 * Math.PI * e3.ba / Math.pow(2, t3) / 5;
          }
          getMinTileElevationForLngLatZoom(t3, e4) {
            var i4;
            const { tileID: s4 } = this._getOverscaledTileIDFromLngLatZoom(t3, e4);
            return null !== (i4 = this.getMinMaxElevation(s4).minElevation) && void 0 !== i4 ? i4 : 0;
          }
          getMinMaxElevation(t3) {
            const e4 = this.getTerrainData(t3).tile, i4 = { minElevation: null, maxElevation: null };
            return e4 && e4.dem && (i4.minElevation = e4.dem.min * this.exaggeration, i4.maxElevation = e4.dem.max * this.exaggeration), i4;
          }
          _getOverscaledTileIDFromLngLatZoom(t3, i4) {
            const s4 = e3.Y.fromLngLat(t3.wrap()), a3 = (1 << i4) * e3.W, o3 = s4.x * a3, r5 = s4.y * a3, n3 = Math.floor(o3 / e3.W), l4 = Math.floor(r5 / e3.W);
            return { tileID: new e3.Q(i4, 0, i4, n3, l4), mercatorX: o3, mercatorY: r5 };
          }
        }
        class ya2 {
          constructor(t3, e4, i4) {
            this._context = t3, this._size = e4, this._tileSize = i4, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
          }
          destruct() {
            for (const t3 of this._objects)
              t3.texture.destroy(), t3.fbo.destroy();
          }
          _createObject(t3) {
            const e4 = this._context.createFramebuffer(this._tileSize, this._tileSize, true, true), i4 = new w3(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
            return i4.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), e4.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), e4.colorAttachment.set(i4.texture), { id: t3, fbo: e4, texture: i4, stamp: -1, inUse: false };
          }
          getObjectForId(t3) {
            return this._objects[t3];
          }
          useObject(t3) {
            t3.inUse = true, this._recentlyUsed = this._recentlyUsed.filter((e4) => t3.id !== e4), this._recentlyUsed.push(t3.id);
          }
          stampObject(t3) {
            t3.stamp = ++this._stamp;
          }
          getOrCreateFreeObject() {
            for (const t4 of this._recentlyUsed)
              if (!this._objects[t4].inUse)
                return this._objects[t4];
            if (this._objects.length >= this._size)
              throw new Error("No free RenderPool available, call freeAllObjects() required!");
            const t3 = this._createObject(this._objects.length);
            return this._objects.push(t3), t3;
          }
          freeObject(t3) {
            t3.inUse = false;
          }
          freeAllObjects() {
            for (const t3 of this._objects)
              this.freeObject(t3);
          }
          isFull() {
            return !(this._objects.length < this._size) && false === this._objects.some((t3) => !t3.inUse);
          }
        }
        const ba2 = { background: true, fill: true, line: true, raster: true, hillshade: true };
        class wa2 {
          constructor(t3, e4) {
            this.painter = t3, this.terrain = e4, this.pool = new ya2(t3.context, 30, e4.sourceCache.tileSize * e4.qualityFactor);
          }
          destruct() {
            this.pool.destruct();
          }
          getTexture(t3) {
            return this.pool.getObjectForId(t3.rtt[this._stacks.length - 1].id).texture;
          }
          prepareForRender(t3, e4) {
            this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = t3._order.filter((i4) => !t3._layers[i4].isHidden(e4)), this._coordsDescendingInv = {};
            for (const e5 in t3.sourceCaches) {
              this._coordsDescendingInv[e5] = {};
              const i4 = t3.sourceCaches[e5].getVisibleCoordinates();
              for (const t4 of i4) {
                const i5 = this.terrain.sourceCache.getTerrainCoords(t4);
                for (const t5 in i5)
                  this._coordsDescendingInv[e5][t5] || (this._coordsDescendingInv[e5][t5] = []), this._coordsDescendingInv[e5][t5].push(i5[t5]);
              }
            }
            this._coordsDescendingInvStr = {};
            for (const e5 of t3._order) {
              const i4 = t3._layers[e5], s4 = i4.source;
              if (ba2[i4.type] && !this._coordsDescendingInvStr[s4]) {
                this._coordsDescendingInvStr[s4] = {};
                for (const t4 in this._coordsDescendingInv[s4])
                  this._coordsDescendingInvStr[s4][t4] = this._coordsDescendingInv[s4][t4].map((t5) => t5.key).sort().join();
              }
            }
            for (const t4 of this._renderableTiles)
              for (const e5 in this._coordsDescendingInvStr) {
                const i4 = this._coordsDescendingInvStr[e5][t4.tileID.key];
                i4 && i4 !== t4.rttCoords[e5] && (t4.rtt = []);
              }
          }
          renderLayer(t3) {
            if (t3.isHidden(this.painter.transform.zoom))
              return false;
            const i4 = t3.type, s4 = this.painter, a3 = this._renderableLayerIds[this._renderableLayerIds.length - 1] === t3.id;
            if (ba2[i4] && (this._prevType && ba2[this._prevType] || this._stacks.push([]), this._prevType = i4, this._stacks[this._stacks.length - 1].push(t3.id), !a3))
              return true;
            if (ba2[this._prevType] || ba2[i4] && a3) {
              this._prevType = i4;
              const t4 = this._stacks.length - 1, a4 = this._stacks[t4] || [];
              for (const i5 of this._renderableTiles) {
                if (this.pool.isFull() && (ns(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(i5), i5.rtt[t4]) {
                  const e4 = this.pool.getObjectForId(i5.rtt[t4].id);
                  if (e4.stamp === i5.rtt[t4].stamp) {
                    this.pool.useObject(e4);
                    continue;
                  }
                }
                const o3 = this.pool.getOrCreateFreeObject();
                this.pool.useObject(o3), this.pool.stampObject(o3), i5.rtt[t4] = { id: o3.id, stamp: o3.stamp }, s4.context.bindFramebuffer.set(o3.fbo.framebuffer), s4.context.clear({ color: e3.aO.transparent, stencil: 0 }), s4.currentStencilSource = void 0;
                for (let t5 = 0; t5 < a4.length; t5++) {
                  const e4 = s4.style._layers[a4[t5]], r5 = e4.source ? this._coordsDescendingInv[e4.source][i5.tileID.key] : [i5.tileID];
                  s4.context.viewport.set([0, 0, o3.fbo.width, o3.fbo.height]), s4._renderTileClippingMasks(e4, r5), s4.renderLayer(s4, s4.style.sourceCaches[e4.source], e4, r5), e4.source && (i5.rttCoords[e4.source] = this._coordsDescendingInvStr[e4.source][i5.tileID.key]);
                }
              }
              return ns(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects(), ba2[i4];
            }
            return false;
          }
        }
        const Ta2 = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use \u2318 + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" }, Ia2 = i3, Ea2 = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, interactive: true, scrollZoom: true, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: false, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: true, hash: false, attributionControl: _a2, maplibreLogo: false, failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false, trackResize: true, renderWorldCopies: true, refreshExpiredTiles: true, maxTileCacheSize: null, maxTileCacheZoomLevels: e3.a.MAX_TILE_CACHE_ZOOM_LEVELS, localIdeographFontFamily: "sans-serif", transformRequest: null, transformCameraUpdate: null, fadeDuration: 300, crossSourceCollisions: true, validateStyle: true, maxCanvasSize: [4096, 4096] }, Sa2 = (t3) => {
          t3.touchstart = t3.dragStart, t3.touchmoveWindow = t3.dragMove, t3.touchend = t3.dragEnd;
        }, Ca2 = { showCompass: true, showZoom: true, visualizePitch: false };
        class Pa2 {
          constructor(t3, i4, s4 = false) {
            this.mousedown = (t4) => {
              this.startMouse(e3.e({}, t4, { ctrlKey: true, preventDefault: () => t4.preventDefault() }), r4.mousePos(this.element, t4)), r4.addEventListener(window, "mousemove", this.mousemove), r4.addEventListener(window, "mouseup", this.mouseup);
            }, this.mousemove = (t4) => {
              this.moveMouse(t4, r4.mousePos(this.element, t4));
            }, this.mouseup = (t4) => {
              this.mouseRotate.dragEnd(t4), this.mousePitch && this.mousePitch.dragEnd(t4), this.offTemp();
            }, this.touchstart = (t4) => {
              1 !== t4.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = r4.touchPos(this.element, t4.targetTouches)[0], this.startTouch(t4, this._startPos), r4.addEventListener(window, "touchmove", this.touchmove, { passive: false }), r4.addEventListener(window, "touchend", this.touchend));
            }, this.touchmove = (t4) => {
              1 !== t4.targetTouches.length ? this.reset() : (this._lastPos = r4.touchPos(this.element, t4.targetTouches)[0], this.moveTouch(t4, this._lastPos));
            }, this.touchend = (t4) => {
              0 === t4.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this.reset = () => {
              this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), this.touchRotate.reset(), this.touchPitch && this.touchPitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this._clickTolerance = 10;
            const a3 = t3.dragRotate._mouseRotate.getClickTolerance(), o3 = t3.dragRotate._mousePitch.getClickTolerance();
            this.element = i4, this.mouseRotate = Ns({ clickTolerance: a3, enable: true }), this.touchRotate = (({ enable: t4, clickTolerance: e4, bearingDegreesPerPixelMoved: i5 = 0.8 }) => {
              const s5 = new Bs();
              return new Ls({ clickTolerance: e4, move: (t5, e5) => ({ bearingDelta: (e5.x - t5.x) * i5 }), moveStateManager: s5, enable: t4, assignEvents: Sa2 });
            })({ clickTolerance: a3, enable: true }), this.map = t3, s4 && (this.mousePitch = Us({ clickTolerance: o3, enable: true }), this.touchPitch = (({ enable: t4, clickTolerance: e4, pitchDegreesPerPixelMoved: i5 = -0.5 }) => {
              const s5 = new Bs();
              return new Ls({ clickTolerance: e4, move: (t5, e5) => ({ pitchDelta: (e5.y - t5.y) * i5 }), moveStateManager: s5, enable: t4, assignEvents: Sa2 });
            })({ clickTolerance: o3, enable: true })), r4.addEventListener(i4, "mousedown", this.mousedown), r4.addEventListener(i4, "touchstart", this.touchstart, { passive: false }), r4.addEventListener(i4, "touchcancel", this.reset);
          }
          startMouse(t3, e4) {
            this.mouseRotate.dragStart(t3, e4), this.mousePitch && this.mousePitch.dragStart(t3, e4), r4.disableDrag();
          }
          startTouch(t3, e4) {
            this.touchRotate.dragStart(t3, e4), this.touchPitch && this.touchPitch.dragStart(t3, e4), r4.disableDrag();
          }
          moveMouse(t3, e4) {
            const i4 = this.map, { bearingDelta: s4 } = this.mouseRotate.dragMove(t3, e4) || {};
            if (s4 && i4.setBearing(i4.getBearing() + s4), this.mousePitch) {
              const { pitchDelta: s5 } = this.mousePitch.dragMove(t3, e4) || {};
              s5 && i4.setPitch(i4.getPitch() + s5);
            }
          }
          moveTouch(t3, e4) {
            const i4 = this.map, { bearingDelta: s4 } = this.touchRotate.dragMove(t3, e4) || {};
            if (s4 && i4.setBearing(i4.getBearing() + s4), this.touchPitch) {
              const { pitchDelta: s5 } = this.touchPitch.dragMove(t3, e4) || {};
              s5 && i4.setPitch(i4.getPitch() + s5);
            }
          }
          off() {
            const t3 = this.element;
            r4.removeEventListener(t3, "mousedown", this.mousedown), r4.removeEventListener(t3, "touchstart", this.touchstart, { passive: false }), r4.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), r4.removeEventListener(window, "touchend", this.touchend), r4.removeEventListener(t3, "touchcancel", this.reset), this.offTemp();
          }
          offTemp() {
            r4.enableDrag(), r4.removeEventListener(window, "mousemove", this.mousemove), r4.removeEventListener(window, "mouseup", this.mouseup), r4.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), r4.removeEventListener(window, "touchend", this.touchend);
          }
        }
        let Da2;
        function za2(t3, i4, s4) {
          const a3 = new e3.M(t3.lng, t3.lat);
          if (t3 = new e3.M(t3.lng, t3.lat), i4) {
            const a4 = new e3.M(t3.lng - 360, t3.lat), o3 = new e3.M(t3.lng + 360, t3.lat), r5 = s4.locationPoint(t3).distSqr(i4);
            s4.locationPoint(a4).distSqr(i4) < r5 ? t3 = a4 : s4.locationPoint(o3).distSqr(i4) < r5 && (t3 = o3);
          }
          for (; Math.abs(t3.lng - s4.center.lng) > 180; ) {
            const e4 = s4.locationPoint(t3);
            if (e4.x >= 0 && e4.y >= 0 && e4.x <= s4.width && e4.y <= s4.height)
              break;
            t3.lng > s4.center.lng ? t3.lng -= 360 : t3.lng += 360;
          }
          return t3.lng !== a3.lng && s4.locationPoint(t3).y > s4.height / 2 - s4.getHorizon() ? t3 : a3;
        }
        const Ma2 = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
        function Aa2(t3, e4, i4) {
          const s4 = t3.classList;
          for (const t4 in Ma2)
            s4.remove(`maplibregl-${i4}-anchor-${t4}`);
          s4.add(`maplibregl-${i4}-anchor-${e4}`);
        }
        class Ra2 extends e3.E {
          constructor(t3) {
            if (super(), this._onKeyPress = (t4) => {
              const e4 = t4.code, i4 = t4.charCode || t4.keyCode;
              "Space" !== e4 && "Enter" !== e4 && 32 !== i4 && 13 !== i4 || this.togglePopup();
            }, this._onMapClick = (t4) => {
              const e4 = t4.originalEvent.target, i4 = this._element;
              this._popup && (e4 === i4 || i4.contains(e4)) && this.togglePopup();
            }, this._update = (t4) => {
              var e4;
              if (!this._map)
                return;
              const i4 = this._map.loaded() && !this._map.isMoving();
              ("terrain" === (null == t4 ? void 0 : t4.type) || "render" === (null == t4 ? void 0 : t4.type) && !i4) && this._map.once("render", this._update), this._lngLat = this._map.transform.renderWorldCopies ? za2(this._lngLat, this._flatPos, this._map.transform) : null === (e4 = this._lngLat) || void 0 === e4 ? void 0 : e4.wrap(), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationPoint(this._lngLat)._add(this._offset));
              let s4 = "";
              "viewport" === this._rotationAlignment || "auto" === this._rotationAlignment ? s4 = `rotateZ(${this._rotation}deg)` : "map" === this._rotationAlignment && (s4 = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
              let a3 = "";
              "viewport" === this._pitchAlignment || "auto" === this._pitchAlignment ? a3 = "rotateX(0deg)" : "map" === this._pitchAlignment && (a3 = `rotateX(${this._map.getPitch()}deg)`), t4 && "moveend" !== t4.type || (this._pos = this._pos.round()), r4.setTransform(this._element, `${Ma2[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${a3} ${s4}`), o2.frameAsync(new AbortController()).then(() => {
                this._updateOpacity(t4 && "moveend" === t4.type);
              }).catch(() => {
              });
            }, this._onMove = (t4) => {
              if (!this._isDragging) {
                const e4 = this._clickTolerance || this._map._clickTolerance;
                this._isDragging = t4.point.dist(this._pointerdownPos) >= e4;
              }
              this._isDragging && (this._pos = t4.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new e3.k("dragstart"))), this.fire(new e3.k("drag")));
            }, this._onUp = () => {
              this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), "active" === this._state && this.fire(new e3.k("dragend")), this._state = "inactive";
            }, this._addDragHandler = (t4) => {
              this._element.contains(t4.originalEvent.target) && (t4.preventDefault(), this._positionDelta = t4.point.sub(this._pos).add(this._offset), this._pointerdownPos = t4.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
            }, this._anchor = t3 && t3.anchor || "center", this._color = t3 && t3.color || "#3FB1CE", this._scale = t3 && t3.scale || 1, this._draggable = t3 && t3.draggable || false, this._clickTolerance = t3 && t3.clickTolerance || 0, this._isDragging = false, this._state = "inactive", this._rotation = t3 && t3.rotation || 0, this._rotationAlignment = t3 && t3.rotationAlignment || "auto", this._pitchAlignment = t3 && t3.pitchAlignment && "auto" !== t3.pitchAlignment ? t3.pitchAlignment : this._rotationAlignment, this.setOpacity(), this.setOpacity(null == t3 ? void 0 : t3.opacity, null == t3 ? void 0 : t3.opacityWhenCovered), t3 && t3.element)
              this._element = t3.element, this._offset = e3.P.convert(t3 && t3.offset || [0, 0]);
            else {
              this._defaultMarker = true, this._element = r4.create("div"), this._element.setAttribute("aria-label", "Map marker");
              const i4 = r4.createNS("http://www.w3.org/2000/svg", "svg"), s4 = 41, a3 = 27;
              i4.setAttributeNS(null, "display", "block"), i4.setAttributeNS(null, "height", `${s4}px`), i4.setAttributeNS(null, "width", `${a3}px`), i4.setAttributeNS(null, "viewBox", `0 0 ${a3} ${s4}`);
              const o3 = r4.createNS("http://www.w3.org/2000/svg", "g");
              o3.setAttributeNS(null, "stroke", "none"), o3.setAttributeNS(null, "stroke-width", "1"), o3.setAttributeNS(null, "fill", "none"), o3.setAttributeNS(null, "fill-rule", "evenodd");
              const n3 = r4.createNS("http://www.w3.org/2000/svg", "g");
              n3.setAttributeNS(null, "fill-rule", "nonzero");
              const l4 = r4.createNS("http://www.w3.org/2000/svg", "g");
              l4.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), l4.setAttributeNS(null, "fill", "#000000");
              const h2 = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
              for (const t4 of h2) {
                const e4 = r4.createNS("http://www.w3.org/2000/svg", "ellipse");
                e4.setAttributeNS(null, "opacity", "0.04"), e4.setAttributeNS(null, "cx", "10.5"), e4.setAttributeNS(null, "cy", "5.80029008"), e4.setAttributeNS(null, "rx", t4.rx), e4.setAttributeNS(null, "ry", t4.ry), l4.appendChild(e4);
              }
              const c3 = r4.createNS("http://www.w3.org/2000/svg", "g");
              c3.setAttributeNS(null, "fill", this._color);
              const u3 = r4.createNS("http://www.w3.org/2000/svg", "path");
              u3.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), c3.appendChild(u3);
              const d2 = r4.createNS("http://www.w3.org/2000/svg", "g");
              d2.setAttributeNS(null, "opacity", "0.25"), d2.setAttributeNS(null, "fill", "#000000");
              const _2 = r4.createNS("http://www.w3.org/2000/svg", "path");
              _2.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), d2.appendChild(_2);
              const p4 = r4.createNS("http://www.w3.org/2000/svg", "g");
              p4.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), p4.setAttributeNS(null, "fill", "#FFFFFF");
              const m2 = r4.createNS("http://www.w3.org/2000/svg", "g");
              m2.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
              const f2 = r4.createNS("http://www.w3.org/2000/svg", "circle");
              f2.setAttributeNS(null, "fill", "#000000"), f2.setAttributeNS(null, "opacity", "0.25"), f2.setAttributeNS(null, "cx", "5.5"), f2.setAttributeNS(null, "cy", "5.5"), f2.setAttributeNS(null, "r", "5.4999962");
              const g3 = r4.createNS("http://www.w3.org/2000/svg", "circle");
              g3.setAttributeNS(null, "fill", "#FFFFFF"), g3.setAttributeNS(null, "cx", "5.5"), g3.setAttributeNS(null, "cy", "5.5"), g3.setAttributeNS(null, "r", "5.4999962"), m2.appendChild(f2), m2.appendChild(g3), n3.appendChild(l4), n3.appendChild(c3), n3.appendChild(d2), n3.appendChild(p4), n3.appendChild(m2), i4.appendChild(n3), i4.setAttributeNS(null, "height", s4 * this._scale + "px"), i4.setAttributeNS(null, "width", a3 * this._scale + "px"), this._element.appendChild(i4), this._offset = e3.P.convert(t3 && t3.offset || [0, -14]);
            }
            if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (t4) => {
              t4.preventDefault();
            }), this._element.addEventListener("mousedown", (t4) => {
              t4.preventDefault();
            }), Aa2(this._element, this._anchor, "marker"), t3 && t3.className)
              for (const e4 of t3.className.split(" "))
                this._element.classList.add(e4);
            this._popup = null;
          }
          addTo(t3) {
            return this.remove(), this._map = t3, t3.getCanvasContainer().appendChild(this._element), t3.on("move", this._update), t3.on("moveend", this._update), t3.on("terrain", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
          }
          remove() {
            return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), r4.remove(this._element), this._popup && this._popup.remove(), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(t3) {
            return this._lngLat = e3.M.convert(t3), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
          }
          getElement() {
            return this._element;
          }
          setPopup(t3) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), t3) {
              if (!("offset" in t3.options)) {
                const e4 = 38.1, i4 = 13.5, s4 = Math.abs(i4) / Math.SQRT2;
                t3.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -e4], "bottom-left": [s4, -1 * (e4 - i4 + s4)], "bottom-right": [-s4, -1 * (e4 - i4 + s4)], left: [i4, -1 * (e4 - i4)], right: [-i4, -1 * (e4 - i4)] } : this._offset;
              }
              this._popup = t3, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
            }
            return this;
          }
          getPopup() {
            return this._popup;
          }
          togglePopup() {
            const t3 = this._popup;
            return t3 ? (t3.isOpen() ? t3.remove() : (t3.setLngLat(this._lngLat), t3.addTo(this._map)), this) : this;
          }
          _updateOpacity(t3 = false) {
            var i4;
            if (!(null === (i4 = this._map) || void 0 === i4 ? void 0 : i4.terrain))
              return void (this._element.style.opacity !== this._opacity && (this._element.style.opacity = this._opacity));
            if (t3)
              this._opacityTimeout = null;
            else {
              if (this._opacityTimeout)
                return;
              this._opacityTimeout = setTimeout(() => {
                this._opacityTimeout = null;
              }, 100);
            }
            const s4 = this._map, a3 = s4.terrain.depthAtPoint(this._pos), o3 = s4.terrain.getElevationForLngLatZoom(this._lngLat, s4.transform.tileZoom);
            if (s4.transform.lngLatToCameraDepth(this._lngLat, o3) - a3 < 6e-3)
              return void (this._element.style.opacity = this._opacity);
            const r5 = -this._offset.y / s4.transform._pixelPerMeter, n3 = Math.sin(s4.getPitch() * Math.PI / 180) * r5, l4 = s4.terrain.depthAtPoint(new e3.P(this._pos.x, this._pos.y - this._offset.y)), h2 = s4.transform.lngLatToCameraDepth(this._lngLat, o3 + n3);
            this._element.style.opacity = h2 - l4 > 6e-3 ? this._opacityWhenCovered : this._opacity;
          }
          getOffset() {
            return this._offset;
          }
          setOffset(t3) {
            return this._offset = e3.P.convert(t3), this._update(), this;
          }
          addClassName(t3) {
            this._element.classList.add(t3);
          }
          removeClassName(t3) {
            this._element.classList.remove(t3);
          }
          toggleClassName(t3) {
            return this._element.classList.toggle(t3);
          }
          setDraggable(t3) {
            return this._draggable = !!t3, this._map && (t3 ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
          }
          isDraggable() {
            return this._draggable;
          }
          setRotation(t3) {
            return this._rotation = t3 || 0, this._update(), this;
          }
          getRotation() {
            return this._rotation;
          }
          setRotationAlignment(t3) {
            return this._rotationAlignment = t3 || "auto", this._update(), this;
          }
          getRotationAlignment() {
            return this._rotationAlignment;
          }
          setPitchAlignment(t3) {
            return this._pitchAlignment = t3 && "auto" !== t3 ? t3 : this._rotationAlignment, this._update(), this;
          }
          getPitchAlignment() {
            return this._pitchAlignment;
          }
          setOpacity(t3, e4) {
            return void 0 === t3 && void 0 === e4 && (this._opacity = "1", this._opacityWhenCovered = "0.2"), void 0 !== t3 && (this._opacity = t3), void 0 !== e4 && (this._opacityWhenCovered = e4), this._map && this._updateOpacity(true), this;
          }
        }
        const La = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true };
        let ka2 = 0, Fa2 = false;
        const Ba2 = { maxWidth: 100, unit: "metric" };
        function Oa2(t3, e4, i4) {
          const s4 = i4 && i4.maxWidth || 100, a3 = t3._container.clientHeight / 2, o3 = t3.unproject([0, a3]), r5 = t3.unproject([s4, a3]), n3 = o3.distanceTo(r5);
          if (i4 && "imperial" === i4.unit) {
            const i5 = 3.2808 * n3;
            i5 > 5280 ? Na2(e4, s4, i5 / 5280, t3._getUIString("ScaleControl.Miles")) : Na2(e4, s4, i5, t3._getUIString("ScaleControl.Feet"));
          } else
            i4 && "nautical" === i4.unit ? Na2(e4, s4, n3 / 1852, t3._getUIString("ScaleControl.NauticalMiles")) : n3 >= 1e3 ? Na2(e4, s4, n3 / 1e3, t3._getUIString("ScaleControl.Kilometers")) : Na2(e4, s4, n3, t3._getUIString("ScaleControl.Meters"));
        }
        function Na2(t3, e4, i4, s4) {
          const a3 = function(t4) {
            const e5 = Math.pow(10, `${Math.floor(t4)}`.length - 1);
            let i5 = t4 / e5;
            return i5 = i5 >= 10 ? 10 : i5 >= 5 ? 5 : i5 >= 3 ? 3 : i5 >= 2 ? 2 : i5 >= 1 ? 1 : function(t5) {
              const e6 = Math.pow(10, Math.ceil(-Math.log(t5) / Math.LN10));
              return Math.round(t5 * e6) / e6;
            }(i5), e5 * i5;
          }(i4);
          t3.style.width = e4 * (a3 / i4) + "px", t3.innerHTML = `${a3}&nbsp;${s4}`;
        }
        const Ua2 = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px", subpixelPositioning: false }, Za2 = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
        function Ga2(t3) {
          if (t3) {
            if ("number" == typeof t3) {
              const i4 = Math.round(Math.abs(t3) / Math.SQRT2);
              return { center: new e3.P(0, 0), top: new e3.P(0, t3), "top-left": new e3.P(i4, i4), "top-right": new e3.P(-i4, i4), bottom: new e3.P(0, -t3), "bottom-left": new e3.P(i4, -i4), "bottom-right": new e3.P(-i4, -i4), left: new e3.P(t3, 0), right: new e3.P(-t3, 0) };
            }
            if (t3 instanceof e3.P || Array.isArray(t3)) {
              const i4 = e3.P.convert(t3);
              return { center: i4, top: i4, "top-left": i4, "top-right": i4, bottom: i4, "bottom-left": i4, "bottom-right": i4, left: i4, right: i4 };
            }
            return { center: e3.P.convert(t3.center || [0, 0]), top: e3.P.convert(t3.top || [0, 0]), "top-left": e3.P.convert(t3["top-left"] || [0, 0]), "top-right": e3.P.convert(t3["top-right"] || [0, 0]), bottom: e3.P.convert(t3.bottom || [0, 0]), "bottom-left": e3.P.convert(t3["bottom-left"] || [0, 0]), "bottom-right": e3.P.convert(t3["bottom-right"] || [0, 0]), left: e3.P.convert(t3.left || [0, 0]), right: e3.P.convert(t3.right || [0, 0]) };
          }
          return Ga2(new e3.P(0, 0));
        }
        const ja = i3;
        t2.AJAXError = e3.bd, t2.Evented = e3.E, t2.LngLat = e3.M, t2.MercatorCoordinate = e3.Y, t2.Point = e3.P, t2.addProtocol = e3.be, t2.config = e3.a, t2.removeProtocol = e3.bf, t2.AttributionControl = pa2, t2.BoxZoomHandler = Ds, t2.CanvasSource = tt, t2.CooperativeGesturesHandler = na2, t2.DoubleClickZoomHandler = ea2, t2.DragPanHandler = aa2, t2.DragRotateHandler = oa2, t2.EdgeInsets = us, t2.FullscreenControl = class extends e3.E {
          constructor(t3 = {}) {
            super(), this._onFullscreenChange = () => {
              var t4;
              let e4 = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
              for (; null === (t4 = null == e4 ? void 0 : e4.shadowRoot) || void 0 === t4 ? void 0 : t4.fullscreenElement; )
                e4 = e4.shadowRoot.fullscreenElement;
              e4 === this._container !== this._fullscreen && this._handleFullscreenChange();
            }, this._onClickFullscreen = () => {
              this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
            }, this._fullscreen = false, t3 && t3.container && (t3.container instanceof HTMLElement ? this._container = t3.container : e3.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
          }
          onAdd(t3) {
            return this._map = t3, this._container || (this._container = this._map.getContainer()), this._controlContainer = r4.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
          }
          onRemove() {
            r4.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _setupUI() {
            const t3 = this._fullscreenButton = r4.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
            r4.create("span", "maplibregl-ctrl-icon", t3).setAttribute("aria-hidden", "true"), t3.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _updateTitle() {
            const t3 = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", t3), this._fullscreenButton.title = t3;
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
          }
          _isFullscreen() {
            return this._fullscreen;
          }
          _handleFullscreenChange() {
            this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new e3.k("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new e3.k("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
          }
          _exitFullscreen() {
            window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
          }
          _requestFullscreen() {
            this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
          }
          _togglePseudoFullScreen() {
            this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
          }
        }, t2.GeoJSONSource = K2, t2.GeolocateControl = class extends e3.E {
          constructor(t3) {
            super(), this._onSuccess = (t4) => {
              if (this._map) {
                if (this._isOutOfMapMaxBounds(t4))
                  return this._setErrorState(), this.fire(new e3.k("outofmaxbounds", t4)), this._updateMarker(), void this._finish();
                if (this.options.trackUserLocation)
                  switch (this._lastKnownPosition = t4, this._watchState) {
                    case "WAITING_ACTIVE":
                    case "ACTIVE_LOCK":
                    case "ACTIVE_ERROR":
                      this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                      break;
                    case "BACKGROUND":
                    case "BACKGROUND_ERROR":
                      this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                      break;
                    default:
                      throw new Error(`Unexpected watchState ${this._watchState}`);
                  }
                this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(t4), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(t4), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new e3.k("geolocate", t4)), this._finish();
              }
            }, this._updateCamera = (t4) => {
              const i4 = new e3.M(t4.coords.longitude, t4.coords.latitude), s4 = t4.coords.accuracy, a3 = this._map.getBearing(), o3 = e3.e({ bearing: a3 }, this.options.fitBoundsOptions), r5 = V2.fromLngLat(i4, s4);
              this._map.fitBounds(r5, o3, { geolocateSource: true });
            }, this._updateMarker = (t4) => {
              if (t4) {
                const i4 = new e3.M(t4.coords.longitude, t4.coords.latitude);
                this._accuracyCircleMarker.setLngLat(i4).addTo(this._map), this._userLocationDotMarker.setLngLat(i4).addTo(this._map), this._accuracy = t4.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
              } else
                this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
            }, this._onZoom = () => {
              this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            }, this._onError = (t4) => {
              if (this._map) {
                if (this.options.trackUserLocation)
                  if (1 === t4.code) {
                    this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                    const t5 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                    this._geolocateButton.title = t5, this._geolocateButton.setAttribute("aria-label", t5), void 0 !== this._geolocationWatchID && this._clearWatch();
                  } else {
                    if (3 === t4.code && Fa2)
                      return;
                    this._setErrorState();
                  }
                "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new e3.k("error", t4)), this._finish();
              }
            }, this._finish = () => {
              this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
            }, this._setupUI = (t4) => {
              if (this._map) {
                if (this._container.addEventListener("contextmenu", (t5) => t5.preventDefault()), this._geolocateButton = r4.create("button", "maplibregl-ctrl-geolocate", this._container), r4.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", false === t4) {
                  e3.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                  const t5 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.disabled = true, this._geolocateButton.title = t5, this._geolocateButton.setAttribute("aria-label", t5);
                } else {
                  const t5 = this._map._getUIString("GeolocateControl.FindMyLocation");
                  this._geolocateButton.title = t5, this._geolocateButton.setAttribute("aria-label", t5);
                }
                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = r4.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new Ra2({ element: this._dotElement }), this._circleElement = r4.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Ra2({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", () => this.trigger()), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", (t5) => {
                  t5.geolocateSource || "ACTIVE_LOCK" !== this._watchState || t5.originalEvent && "resize" === t5.originalEvent.type || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new e3.k("trackuserlocationend")));
                });
              }
            }, this.options = e3.e({}, La, t3);
          }
          onAdd(t3) {
            return this._map = t3, this._container = r4.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), function(t4 = false) {
              return e3._(this, void 0, void 0, function* () {
                if (void 0 !== Da2 && !t4)
                  return Da2;
                if (void 0 === window.navigator.permissions)
                  return Da2 = !!window.navigator.geolocation, Da2;
                try {
                  const t5 = yield window.navigator.permissions.query({ name: "geolocation" });
                  Da2 = "denied" !== t5.state;
                } catch (t5) {
                  Da2 = !!window.navigator.geolocation;
                }
                return Da2;
              });
            }().then((t4) => this._setupUI(t4)), this._container;
          }
          onRemove() {
            void 0 !== this._geolocationWatchID && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), r4.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, ka2 = 0, Fa2 = false;
          }
          _isOutOfMapMaxBounds(t3) {
            const e4 = this._map.getMaxBounds(), i4 = t3.coords;
            return e4 && (i4.longitude < e4.getWest() || i4.longitude > e4.getEast() || i4.latitude < e4.getSouth() || i4.latitude > e4.getNorth());
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "ACTIVE_ERROR":
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
          }
          _updateCircleRadius() {
            const t3 = this._map.getBounds(), e4 = t3.getSouthEast(), i4 = t3.getNorthEast(), s4 = e4.distanceTo(i4), a3 = Math.ceil(this._accuracy / (s4 / this._map._container.clientHeight) * 2);
            this._circleElement.style.width = `${a3}px`, this._circleElement.style.height = `${a3}px`;
          }
          trigger() {
            if (!this._setup)
              return e3.w("Geolocate control triggered before added to a map"), false;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new e3.k("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  ka2--, Fa2 = false, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new e3.k("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new e3.k("trackuserlocationstart"));
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "OFF":
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID)
                this._clearWatch();
              else if (void 0 === this._geolocationWatchID) {
                let t3;
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), ka2++, ka2 > 1 ? (t3 = { maximumAge: 6e5, timeout: 0 }, Fa2 = true) : (t3 = this.options.positionOptions, Fa2 = false), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, t3);
              }
            } else
              window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return true;
          }
          _clearWatch() {
            window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
          }
        }, t2.Hash = ps, t2.ImageSource = J3, t2.KeyboardHandler = Ys, t2.LngLatBounds = V2, t2.LogoControl = ma2, t2.Map = class extends da2 {
          constructor(t3) {
            if (e3.bb.mark(e3.bc.create), null != (t3 = e3.e({}, Ea2, t3)).minZoom && null != t3.maxZoom && t3.minZoom > t3.maxZoom)
              throw new Error("maxZoom must be greater than or equal to minZoom");
            if (null != t3.minPitch && null != t3.maxPitch && t3.minPitch > t3.maxPitch)
              throw new Error("maxPitch must be greater than or equal to minPitch");
            if (null != t3.minPitch && t3.minPitch < 0)
              throw new Error("minPitch must be greater than or equal to 0");
            if (null != t3.maxPitch && t3.maxPitch > 85)
              throw new Error("maxPitch must be less than or equal to 85");
            if (super(new ds(t3.minZoom, t3.maxZoom, t3.minPitch, t3.maxPitch, t3.renderWorldCopies), { bearingSnap: t3.bearingSnap }), this._contextLost = (t4) => {
              t4.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new e3.k("webglcontextlost", { originalEvent: t4 }));
            }, this._contextRestored = (t4) => {
              this._setupPainter(), this.resize(), this._update(), this.fire(new e3.k("webglcontextrestored", { originalEvent: t4 }));
            }, this._onMapScroll = (t4) => {
              if (t4.target === this._container)
                return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
            }, this._onWindowOnline = () => {
              this._update();
            }, this._interactive = t3.interactive, this._maxTileCacheSize = t3.maxTileCacheSize, this._maxTileCacheZoomLevels = t3.maxTileCacheZoomLevels, this._failIfMajorPerformanceCaveat = t3.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = t3.preserveDrawingBuffer, this._antialias = t3.antialias, this._trackResize = t3.trackResize, this._bearingSnap = t3.bearingSnap, this._refreshExpiredTiles = t3.refreshExpiredTiles, this._fadeDuration = t3.fadeDuration, this._crossSourceCollisions = t3.crossSourceCollisions, this._crossFadingFactor = 1, this._collectResourceTiming = t3.collectResourceTiming, this._renderTaskQueue = new fa2(), this._controls = [], this._mapId = e3.a3(), this._locale = e3.e({}, Ta2, t3.locale), this._clickTolerance = t3.clickTolerance, this._overridePixelRatio = t3.pixelRatio, this._maxCanvasSize = t3.maxCanvasSize, this.transformCameraUpdate = t3.transformCameraUpdate, this._imageQueueHandle = _.addThrottleControl(() => this.isMoving()), this._requestManager = new m(t3.transformRequest), "string" == typeof t3.container) {
              if (this._container = document.getElementById(t3.container), !this._container)
                throw new Error(`Container '${t3.container}' not found.`);
            } else {
              if (!(t3.container instanceof HTMLElement))
                throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = t3.container;
            }
            if (t3.maxBounds && this.setMaxBounds(t3.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", () => this._update(false)), this.on("moveend", () => this._update(false)), this.on("zoom", () => this._update(true)), this.on("terrain", () => {
              this.painter.terrainFacilitator.dirty = true, this._update(true);
            }), this.once("idle", () => {
              this._idleTriggered = true;
            }), "undefined" != typeof window) {
              addEventListener("online", this._onWindowOnline, false);
              let t4 = false;
              const e4 = _s((t5) => {
                this._trackResize && !this._removed && this.resize(t5)._update();
              }, 50);
              this._resizeObserver = new ResizeObserver((i4) => {
                t4 ? e4(i4) : t4 = true;
              }), this._resizeObserver.observe(this._container);
            }
            this.handlers = new ua2(this, t3), this._hash = t3.hash && new ps("string" == typeof t3.hash && t3.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: t3.center, zoom: t3.zoom, bearing: t3.bearing, pitch: t3.pitch }), t3.bounds && (this.resize(), this.fitBounds(t3.bounds, e3.e({}, t3.fitBoundsOptions, { duration: 0 })))), this.resize(), this._localIdeographFontFamily = t3.localIdeographFontFamily, this._validateStyle = t3.validateStyle, t3.style && this.setStyle(t3.style, { localIdeographFontFamily: t3.localIdeographFontFamily }), t3.attributionControl && this.addControl(new pa2("boolean" == typeof t3.attributionControl ? void 0 : t3.attributionControl)), t3.maplibreLogo && this.addControl(new ma2(), t3.logoPosition), this.on("style.load", () => {
              this.transform.unmodified && this.jumpTo(this.style.stylesheet);
            }), this.on("data", (t4) => {
              this._update("style" === t4.dataType), this.fire(new e3.k(`${t4.dataType}data`, t4));
            }), this.on("dataloading", (t4) => {
              this.fire(new e3.k(`${t4.dataType}dataloading`, t4));
            }), this.on("dataabort", (t4) => {
              this.fire(new e3.k("sourcedataabort", t4));
            });
          }
          _getMapId() {
            return this._mapId;
          }
          addControl(t3, i4) {
            if (void 0 === i4 && (i4 = t3.getDefaultPosition ? t3.getDefaultPosition() : "top-right"), !t3 || !t3.onAdd)
              return this.fire(new e3.j(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const s4 = t3.onAdd(this);
            this._controls.push(t3);
            const a3 = this._controlPositions[i4];
            return -1 !== i4.indexOf("bottom") ? a3.insertBefore(s4, a3.firstChild) : a3.appendChild(s4), this;
          }
          removeControl(t3) {
            if (!t3 || !t3.onRemove)
              return this.fire(new e3.j(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const i4 = this._controls.indexOf(t3);
            return i4 > -1 && this._controls.splice(i4, 1), t3.onRemove(this), this;
          }
          hasControl(t3) {
            return this._controls.indexOf(t3) > -1;
          }
          calculateCameraOptionsFromTo(t3, e4, i4, s4) {
            return null == s4 && this.terrain && (s4 = this.terrain.getElevationForLngLatZoom(i4, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(t3, e4, i4, s4);
          }
          resize(t3) {
            var i4;
            const s4 = this._containerDimensions(), a3 = s4[0], o3 = s4[1], r5 = this._getClampedPixelRatio(a3, o3);
            if (this._resizeCanvas(a3, o3, r5), this.painter.resize(a3, o3, r5), this.painter.overLimit()) {
              const t4 = this.painter.context.gl;
              this._maxCanvasSize = [t4.drawingBufferWidth, t4.drawingBufferHeight];
              const e4 = this._getClampedPixelRatio(a3, o3);
              this._resizeCanvas(a3, o3, e4), this.painter.resize(a3, o3, e4);
            }
            this.transform.resize(a3, o3), null === (i4 = this._requestedCameraState) || void 0 === i4 || i4.resize(a3, o3);
            const n3 = !this._moving;
            return n3 && (this.stop(), this.fire(new e3.k("movestart", t3)).fire(new e3.k("move", t3))), this.fire(new e3.k("resize", t3)), n3 && this.fire(new e3.k("moveend", t3)), this;
          }
          _getClampedPixelRatio(t3, e4) {
            const { 0: i4, 1: s4 } = this._maxCanvasSize, a3 = this.getPixelRatio(), o3 = t3 * a3, r5 = e4 * a3;
            return Math.min(o3 > i4 ? i4 / o3 : 1, r5 > s4 ? s4 / r5 : 1) * a3;
          }
          getPixelRatio() {
            var t3;
            return null !== (t3 = this._overridePixelRatio) && void 0 !== t3 ? t3 : devicePixelRatio;
          }
          setPixelRatio(t3) {
            this._overridePixelRatio = t3, this.resize();
          }
          getBounds() {
            return this.transform.getBounds();
          }
          getMaxBounds() {
            return this.transform.getMaxBounds();
          }
          setMaxBounds(t3) {
            return this.transform.setMaxBounds(V2.convert(t3)), this._update();
          }
          setMinZoom(t3) {
            if ((t3 = null == t3 ? -2 : t3) >= -2 && t3 <= this.transform.maxZoom)
              return this.transform.minZoom = t3, this._update(), this.getZoom() < t3 && this.setZoom(t3), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
          }
          getMinZoom() {
            return this.transform.minZoom;
          }
          setMaxZoom(t3) {
            if ((t3 = null == t3 ? 22 : t3) >= this.transform.minZoom)
              return this.transform.maxZoom = t3, this._update(), this.getZoom() > t3 && this.setZoom(t3), this;
            throw new Error("maxZoom must be greater than the current minZoom");
          }
          getMaxZoom() {
            return this.transform.maxZoom;
          }
          setMinPitch(t3) {
            if ((t3 = null == t3 ? 0 : t3) < 0)
              throw new Error("minPitch must be greater than or equal to 0");
            if (t3 >= 0 && t3 <= this.transform.maxPitch)
              return this.transform.minPitch = t3, this._update(), this.getPitch() < t3 && this.setPitch(t3), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
          }
          getMinPitch() {
            return this.transform.minPitch;
          }
          setMaxPitch(t3) {
            if ((t3 = null == t3 ? 60 : t3) > 85)
              throw new Error("maxPitch must be less than or equal to 85");
            if (t3 >= this.transform.minPitch)
              return this.transform.maxPitch = t3, this._update(), this.getPitch() > t3 && this.setPitch(t3), this;
            throw new Error("maxPitch must be greater than the current minPitch");
          }
          getMaxPitch() {
            return this.transform.maxPitch;
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies;
          }
          setRenderWorldCopies(t3) {
            return this.transform.renderWorldCopies = t3, this._update();
          }
          project(t3) {
            return this.transform.locationPoint(e3.M.convert(t3), this.style && this.terrain);
          }
          unproject(t3) {
            return this.transform.pointLocation(e3.P.convert(t3), this.terrain);
          }
          isMoving() {
            var t3;
            return this._moving || (null === (t3 = this.handlers) || void 0 === t3 ? void 0 : t3.isMoving());
          }
          isZooming() {
            var t3;
            return this._zooming || (null === (t3 = this.handlers) || void 0 === t3 ? void 0 : t3.isZooming());
          }
          isRotating() {
            var t3;
            return this._rotating || (null === (t3 = this.handlers) || void 0 === t3 ? void 0 : t3.isRotating());
          }
          _createDelegatedListener(t3, e4, i4) {
            if ("mouseenter" === t3 || "mouseover" === t3) {
              let s4 = false;
              const a3 = (a4) => {
                const o3 = this.getLayer(e4) ? this.queryRenderedFeatures(a4.point, { layers: [e4] }) : [];
                o3.length ? s4 || (s4 = true, i4.call(this, new Ts(t3, this, a4.originalEvent, { features: o3 }))) : s4 = false;
              };
              return { layer: e4, listener: i4, delegates: { mousemove: a3, mouseout: () => {
                s4 = false;
              } } };
            }
            if ("mouseleave" === t3 || "mouseout" === t3) {
              let s4 = false;
              const a3 = (a4) => {
                (this.getLayer(e4) ? this.queryRenderedFeatures(a4.point, { layers: [e4] }) : []).length ? s4 = true : s4 && (s4 = false, i4.call(this, new Ts(t3, this, a4.originalEvent)));
              }, o3 = (e5) => {
                s4 && (s4 = false, i4.call(this, new Ts(t3, this, e5.originalEvent)));
              };
              return { layer: e4, listener: i4, delegates: { mousemove: a3, mouseout: o3 } };
            }
            {
              const s4 = (t4) => {
                const s5 = this.getLayer(e4) ? this.queryRenderedFeatures(t4.point, { layers: [e4] }) : [];
                s5.length && (t4.features = s5, i4.call(this, t4), delete t4.features);
              };
              return { layer: e4, listener: i4, delegates: { [t3]: s4 } };
            }
          }
          on(t3, e4, i4) {
            if (void 0 === i4)
              return super.on(t3, e4);
            const s4 = this._createDelegatedListener(t3, e4, i4);
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[t3] = this._delegatedListeners[t3] || [], this._delegatedListeners[t3].push(s4);
            for (const t4 in s4.delegates)
              this.on(t4, s4.delegates[t4]);
            return this;
          }
          once(t3, e4, i4) {
            if (void 0 === i4)
              return super.once(t3, e4);
            const s4 = this._createDelegatedListener(t3, e4, i4);
            for (const t4 in s4.delegates)
              this.once(t4, s4.delegates[t4]);
            return this;
          }
          off(t3, e4, i4) {
            return void 0 === i4 ? super.off(t3, e4) : (this._delegatedListeners && this._delegatedListeners[t3] && ((s4) => {
              const a3 = this._delegatedListeners[t3];
              for (let t4 = 0; t4 < a3.length; t4++) {
                const s5 = a3[t4];
                if (s5.layer === e4 && s5.listener === i4) {
                  for (const t5 in s5.delegates)
                    this.off(t5, s5.delegates[t5]);
                  return a3.splice(t4, 1), this;
                }
              }
            })(), this);
          }
          queryRenderedFeatures(t3, i4) {
            if (!this.style)
              return [];
            let s4;
            const a3 = t3 instanceof e3.P || Array.isArray(t3), o3 = a3 ? t3 : [[0, 0], [this.transform.width, this.transform.height]];
            if (i4 = i4 || (a3 ? {} : t3) || {}, o3 instanceof e3.P || "number" == typeof o3[0])
              s4 = [e3.P.convert(o3)];
            else {
              const t4 = e3.P.convert(o3[0]), i5 = e3.P.convert(o3[1]);
              s4 = [t4, new e3.P(i5.x, t4.y), i5, new e3.P(t4.x, i5.y), t4];
            }
            return this.style.queryRenderedFeatures(s4, i4, this.transform);
          }
          querySourceFeatures(t3, e4) {
            return this.style.querySourceFeatures(t3, e4);
          }
          setStyle(t3, i4) {
            return false !== (i4 = e3.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, i4)).diff && i4.localIdeographFontFamily === this._localIdeographFontFamily && this.style && t3 ? (this._diffStyle(t3, i4), this) : (this._localIdeographFontFamily = i4.localIdeographFontFamily, this._updateStyle(t3, i4));
          }
          setTransformRequest(t3) {
            return this._requestManager.setTransformRequest(t3), this;
          }
          _getUIString(t3) {
            const e4 = this._locale[t3];
            if (null == e4)
              throw new Error(`Missing UI string '${t3}'`);
            return e4;
          }
          _updateStyle(t3, e4) {
            if (e4.transformStyle && this.style && !this.style._loaded)
              return void this.style.once("style.load", () => this._updateStyle(t3, e4));
            const i4 = this.style && e4.transformStyle ? this.style.serialize() : void 0;
            return this.style && (this.style.setEventedParent(null), this.style._remove(!t3)), t3 ? (this.style = new he2(this, e4 || {}), this.style.setEventedParent(this, { style: this.style }), "string" == typeof t3 ? this.style.loadURL(t3, e4, i4) : this.style.loadJSON(t3, e4, i4), this) : (delete this.style, this);
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new he2(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
          }
          _diffStyle(t3, i4) {
            if ("string" == typeof t3) {
              const s4 = this._requestManager.transformRequest(t3, p3.Style);
              e3.h(s4, new AbortController()).then((t4) => {
                this._updateDiff(t4.data, i4);
              }).catch((t4) => {
                t4 && this.fire(new e3.j(t4));
              });
            } else
              "object" == typeof t3 && this._updateDiff(t3, i4);
          }
          _updateDiff(t3, i4) {
            try {
              this.style.setState(t3, i4) && this._update(true);
            } catch (s4) {
              e3.w(`Unable to perform style diff: ${s4.message || s4.error || s4}.  Rebuilding the style from scratch.`), this._updateStyle(t3, i4);
            }
          }
          getStyle() {
            if (this.style)
              return this.style.serialize();
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : e3.w("There is no style added to the map.");
          }
          addSource(t3, e4) {
            return this._lazyInitEmptyStyle(), this.style.addSource(t3, e4), this._update(true);
          }
          isSourceLoaded(t3) {
            const i4 = this.style && this.style.sourceCaches[t3];
            if (void 0 !== i4)
              return i4.loaded();
            this.fire(new e3.j(new Error(`There is no source with ID '${t3}'`)));
          }
          setTerrain(t3) {
            if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), t3) {
              const i4 = this.style.sourceCaches[t3.source];
              if (!i4)
                throw new Error(`cannot load terrain, because there exists no source with ID: ${t3.source}`);
              null === this.terrain && i4.reload();
              for (const i5 in this.style._layers) {
                const s4 = this.style._layers[i5];
                "hillshade" === s4.type && s4.source === t3.source && e3.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
              }
              this.terrain = new xa2(this.painter, i4, t3), this.painter.renderToTexture = new wa2(this.painter, this.terrain), this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._terrainDataCallback = (e4) => {
                "style" === e4.dataType ? this.terrain.sourceCache.freeRtt() : "source" === e4.dataType && e4.tile && (e4.sourceId !== t3.source || this._elevationFreeze || (this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.terrain.sourceCache.freeRtt(e4.tile.tileID));
              }, this.style.on("data", this._terrainDataCallback);
            } else
              this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.minElevationForCurrentTile = 0, this.transform.elevation = 0;
            return this.fire(new e3.k("terrain", { terrain: t3 })), this;
          }
          getTerrain() {
            var t3, e4;
            return null !== (e4 = null === (t3 = this.terrain) || void 0 === t3 ? void 0 : t3.options) && void 0 !== e4 ? e4 : null;
          }
          areTilesLoaded() {
            const t3 = this.style && this.style.sourceCaches;
            for (const e4 in t3) {
              const i4 = t3[e4]._tiles;
              for (const t4 in i4) {
                const e5 = i4[t4];
                if ("loaded" !== e5.state && "errored" !== e5.state)
                  return false;
              }
            }
            return true;
          }
          removeSource(t3) {
            return this.style.removeSource(t3), this._update(true);
          }
          getSource(t3) {
            return this.style.getSource(t3);
          }
          addImage(t3, i4, s4 = {}) {
            const { pixelRatio: a3 = 1, sdf: r5 = false, stretchX: n3, stretchY: l4, content: h2 } = s4;
            if (this._lazyInitEmptyStyle(), !(i4 instanceof HTMLImageElement || e3.b(i4))) {
              if (void 0 === i4.width || void 0 === i4.height)
                return this.fire(new e3.j(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              {
                const { width: s5, height: o3, data: c3 } = i4, u3 = i4;
                return this.style.addImage(t3, { data: new e3.R({ width: s5, height: o3 }, new Uint8Array(c3)), pixelRatio: a3, stretchX: n3, stretchY: l4, content: h2, sdf: r5, version: 0, userImage: u3 }), u3.onAdd && u3.onAdd(this, t3), this;
              }
            }
            {
              const { width: s5, height: c3, data: u3 } = o2.getImageData(i4);
              this.style.addImage(t3, { data: new e3.R({ width: s5, height: c3 }, u3), pixelRatio: a3, stretchX: n3, stretchY: l4, content: h2, sdf: r5, version: 0 });
            }
          }
          updateImage(t3, i4) {
            const s4 = this.style.getImage(t3);
            if (!s4)
              return this.fire(new e3.j(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const a3 = i4 instanceof HTMLImageElement || e3.b(i4) ? o2.getImageData(i4) : i4, { width: r5, height: n3, data: l4 } = a3;
            if (void 0 === r5 || void 0 === n3)
              return this.fire(new e3.j(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            if (r5 !== s4.data.width || n3 !== s4.data.height)
              return this.fire(new e3.j(new Error("The width and height of the updated image must be that same as the previous version of the image")));
            const h2 = !(i4 instanceof HTMLImageElement || e3.b(i4));
            return s4.data.replace(l4, h2), this.style.updateImage(t3, s4), this;
          }
          getImage(t3) {
            return this.style.getImage(t3);
          }
          hasImage(t3) {
            return t3 ? !!this.style.getImage(t3) : (this.fire(new e3.j(new Error("Missing required image id"))), false);
          }
          removeImage(t3) {
            this.style.removeImage(t3);
          }
          loadImage(t3) {
            return _.getImage(this._requestManager.transformRequest(t3, p3.Image), new AbortController());
          }
          listImages() {
            return this.style.listImages();
          }
          addLayer(t3, e4) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(t3, e4), this._update(true);
          }
          moveLayer(t3, e4) {
            return this.style.moveLayer(t3, e4), this._update(true);
          }
          removeLayer(t3) {
            return this.style.removeLayer(t3), this._update(true);
          }
          getLayer(t3) {
            return this.style.getLayer(t3);
          }
          getLayersOrder() {
            return this.style.getLayersOrder();
          }
          setLayerZoomRange(t3, e4, i4) {
            return this.style.setLayerZoomRange(t3, e4, i4), this._update(true);
          }
          setFilter(t3, e4, i4 = {}) {
            return this.style.setFilter(t3, e4, i4), this._update(true);
          }
          getFilter(t3) {
            return this.style.getFilter(t3);
          }
          setPaintProperty(t3, e4, i4, s4 = {}) {
            return this.style.setPaintProperty(t3, e4, i4, s4), this._update(true);
          }
          getPaintProperty(t3, e4) {
            return this.style.getPaintProperty(t3, e4);
          }
          setLayoutProperty(t3, e4, i4, s4 = {}) {
            return this.style.setLayoutProperty(t3, e4, i4, s4), this._update(true);
          }
          getLayoutProperty(t3, e4) {
            return this.style.getLayoutProperty(t3, e4);
          }
          setGlyphs(t3, e4 = {}) {
            return this._lazyInitEmptyStyle(), this.style.setGlyphs(t3, e4), this._update(true);
          }
          getGlyphs() {
            return this.style.getGlyphsUrl();
          }
          addSprite(t3, e4, i4 = {}) {
            return this._lazyInitEmptyStyle(), this.style.addSprite(t3, e4, i4, (t4) => {
              t4 || this._update(true);
            }), this;
          }
          removeSprite(t3) {
            return this._lazyInitEmptyStyle(), this.style.removeSprite(t3), this._update(true);
          }
          getSprite() {
            return this.style.getSprite();
          }
          setSprite(t3, e4 = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSprite(t3, e4, (t4) => {
              t4 || this._update(true);
            }), this;
          }
          setLight(t3, e4 = {}) {
            return this._lazyInitEmptyStyle(), this.style.setLight(t3, e4), this._update(true);
          }
          getLight() {
            return this.style.getLight();
          }
          setFeatureState(t3, e4) {
            return this.style.setFeatureState(t3, e4), this._update();
          }
          removeFeatureState(t3, e4) {
            return this.style.removeFeatureState(t3, e4), this._update();
          }
          getFeatureState(t3) {
            return this.style.getFeatureState(t3);
          }
          getContainer() {
            return this._container;
          }
          getCanvasContainer() {
            return this._canvasContainer;
          }
          getCanvas() {
            return this._canvas;
          }
          _containerDimensions() {
            let t3 = 0, e4 = 0;
            return this._container && (t3 = this._container.clientWidth || 400, e4 = this._container.clientHeight || 300), [t3, e4];
          }
          _setupContainer() {
            const t3 = this._container;
            t3.classList.add("maplibregl-map");
            const e4 = this._canvasContainer = r4.create("div", "maplibregl-canvas-container", t3);
            this._interactive && e4.classList.add("maplibregl-interactive"), this._canvas = r4.create("canvas", "maplibregl-canvas", e4), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", "Map"), this._canvas.setAttribute("role", "region");
            const i4 = this._containerDimensions(), s4 = this._getClampedPixelRatio(i4[0], i4[1]);
            this._resizeCanvas(i4[0], i4[1], s4);
            const a3 = this._controlContainer = r4.create("div", "maplibregl-control-container", t3), o3 = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((t4) => {
              o3[t4] = r4.create("div", `maplibregl-ctrl-${t4} `, a3);
            }), this._container.addEventListener("scroll", this._onMapScroll, false);
          }
          _resizeCanvas(t3, e4, i4) {
            this._canvas.width = Math.floor(i4 * t3), this._canvas.height = Math.floor(i4 * e4), this._canvas.style.width = `${t3}px`, this._canvas.style.height = `${e4}px`;
          }
          _setupPainter() {
            const t3 = { alpha: true, stencil: true, depth: true, failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || false };
            let e4 = null;
            this._canvas.addEventListener("webglcontextcreationerror", (i5) => {
              e4 = { requestedAttributes: t3 }, i5 && (e4.statusMessage = i5.statusMessage, e4.type = i5.type);
            }, { once: true });
            const i4 = this._canvas.getContext("webgl2", t3) || this._canvas.getContext("webgl", t3);
            if (!i4) {
              const t4 = "Failed to initialize WebGL";
              throw e4 ? (e4.message = t4, new Error(JSON.stringify(e4))) : new Error(t4);
            }
            this.painter = new ls(i4, this.transform), n2.testSupport(i4);
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
          }
          _update(t3) {
            return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || t3, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
          }
          _requestRenderFrame(t3) {
            return this._update(), this._renderTaskQueue.add(t3);
          }
          _cancelRenderFrame(t3) {
            this._renderTaskQueue.remove(t3);
          }
          _render(t3) {
            const i4 = this._idleTriggered ? this._fadeDuration : 0;
            if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(t3), this._removed)
              return;
            let s4 = false;
            if (this.style && this._styleDirty) {
              this._styleDirty = false;
              const t4 = this.transform.zoom, a4 = o2.now();
              this.style.zoomHistory.update(t4, a4);
              const r5 = new e3.a8(t4, { now: a4, fadeDuration: i4, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), n3 = r5.crossFadingFactor();
              1 === n3 && n3 === this._crossFadingFactor || (s4 = true, this._crossFadingFactor = n3), this.style.update(r5);
            }
            this.style && this._sourcesDirty && (this._sourcesDirty = false, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._elevationFreeze || (this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.minElevationForCurrentTile = 0, this.transform.elevation = 0), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, i4, this._crossSourceCollisions), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: i4, showPadding: this.showPadding }), this.fire(new e3.k("render")), this.loaded() && !this._loaded && (this._loaded = true, e3.bb.mark(e3.bc.load), this.fire(new e3.k("load"))), this.style && (this.style.hasTransitions() || s4) && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
            const a3 = this._sourcesDirty || this._styleDirty || this._placementDirty;
            return a3 || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new e3.k("idle")), !this._loaded || this._fullyLoaded || a3 || (this._fullyLoaded = true, e3.bb.mark(e3.bc.fullLoad)), this;
          }
          redraw() {
            return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
          }
          remove() {
            var t3;
            this._hash && this._hash.remove();
            for (const t4 of this._controls)
              t4.onRemove(this);
            this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), "undefined" != typeof window && removeEventListener("online", this._onWindowOnline, false), _.removeThrottleControl(this._imageQueueHandle), null === (t3 = this._resizeObserver) || void 0 === t3 || t3.disconnect();
            const i4 = this.painter.context.gl.getExtension("WEBGL_lose_context");
            i4 && i4.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), r4.remove(this._canvasContainer), r4.remove(this._controlContainer), this._container.classList.remove("maplibregl-map"), e3.bb.clearMetrics(), this._removed = true, this.fire(new e3.k("remove"));
          }
          triggerRepaint() {
            this.style && !this._frameRequest && (this._frameRequest = new AbortController(), o2.frameAsync(this._frameRequest).then((t3) => {
              e3.bb.frame(t3), this._frameRequest = null, this._render(t3);
            }).catch(() => {
            }));
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries;
          }
          set showTileBoundaries(t3) {
            this._showTileBoundaries !== t3 && (this._showTileBoundaries = t3, this._update());
          }
          get showPadding() {
            return !!this._showPadding;
          }
          set showPadding(t3) {
            this._showPadding !== t3 && (this._showPadding = t3, this._update());
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes;
          }
          set showCollisionBoxes(t3) {
            this._showCollisionBoxes !== t3 && (this._showCollisionBoxes = t3, t3 ? this.style._generateCollisionBoxes() : this._update());
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector;
          }
          set showOverdrawInspector(t3) {
            this._showOverdrawInspector !== t3 && (this._showOverdrawInspector = t3, this._update());
          }
          get repaint() {
            return !!this._repaint;
          }
          set repaint(t3) {
            this._repaint !== t3 && (this._repaint = t3, this.triggerRepaint());
          }
          get vertices() {
            return !!this._vertices;
          }
          set vertices(t3) {
            this._vertices = t3, this._update();
          }
          get version() {
            return Ia2;
          }
          getCameraTargetElevation() {
            return this.transform.elevation;
          }
        }, t2.MapMouseEvent = Ts, t2.MapTouchEvent = Is, t2.MapWheelEvent = Es, t2.Marker = Ra2, t2.NavigationControl = class {
          constructor(t3) {
            this._updateZoomButtons = () => {
              const t4 = this._map.getZoom(), e4 = t4 === this._map.getMaxZoom(), i4 = t4 === this._map.getMinZoom();
              this._zoomInButton.disabled = e4, this._zoomOutButton.disabled = i4, this._zoomInButton.setAttribute("aria-disabled", e4.toString()), this._zoomOutButton.setAttribute("aria-disabled", i4.toString());
            }, this._rotateCompassArrow = () => {
              const t4 = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${this._map.transform.angle * (180 / Math.PI)}deg)` : `rotate(${this._map.transform.angle * (180 / Math.PI)}deg)`;
              this._compassIcon.style.transform = t4;
            }, this._setButtonTitle = (t4, e4) => {
              const i4 = this._map._getUIString(`NavigationControl.${e4}`);
              t4.title = i4, t4.setAttribute("aria-label", i4);
            }, this.options = e3.e({}, Ca2, t3), this._container = r4.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (t4) => t4.preventDefault()), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (t4) => this._map.zoomIn({}, { originalEvent: t4 })), r4.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (t4) => this._map.zoomOut({}, { originalEvent: t4 })), r4.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (t4) => {
              this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: t4 }) : this._map.resetNorth({}, { originalEvent: t4 });
            }), this._compassIcon = r4.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
          }
          onAdd(t3) {
            return this._map = t3, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Pa2(this._map, this._compass, this.options.visualizePitch)), this._container;
          }
          onRemove() {
            r4.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
          }
          _createButton(t3, e4) {
            const i4 = r4.create("button", t3, this._container);
            return i4.type = "button", i4.addEventListener("click", e4), i4;
          }
        }, t2.Popup = class extends e3.E {
          constructor(t3) {
            super(), this.remove = () => (this._content && r4.remove(this._content), this._container && (r4.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map), this.fire(new e3.k("close")), this), this._onMouseUp = (t4) => {
              this._update(t4.point);
            }, this._onMouseMove = (t4) => {
              this._update(t4.point);
            }, this._onDrag = (t4) => {
              this._update(t4.point);
            }, this._update = (t4) => {
              var e4;
              if (!this._map || !this._lngLat && !this._trackPointer || !this._content)
                return;
              if (!this._container) {
                if (this._container = r4.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = r4.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className)
                  for (const t5 of this.options.className.split(" "))
                    this._container.classList.add(t5);
                this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
              }
              if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = this._map.transform.renderWorldCopies && !this._trackPointer ? za2(this._lngLat, this._flatPos, this._map.transform) : null === (e4 = this._lngLat) || void 0 === e4 ? void 0 : e4.wrap(), this._trackPointer && !t4)
                return;
              const i4 = this._flatPos = this._pos = this._trackPointer && t4 ? t4 : this._map.project(this._lngLat);
              this._map.terrain && (this._flatPos = this._trackPointer && t4 ? t4 : this._map.transform.locationPoint(this._lngLat));
              let s4 = this.options.anchor;
              const a3 = Ga2(this.options.offset);
              if (!s4) {
                const t5 = this._container.offsetWidth, e5 = this._container.offsetHeight;
                let o4;
                o4 = i4.y + a3.bottom.y < e5 ? ["top"] : i4.y > this._map.transform.height - e5 ? ["bottom"] : [], i4.x < t5 / 2 ? o4.push("left") : i4.x > this._map.transform.width - t5 / 2 && o4.push("right"), s4 = 0 === o4.length ? "bottom" : o4.join("-");
              }
              let o3 = i4.add(a3[s4]);
              this.options.subpixelPositioning || (o3 = o3.round()), r4.setTransform(this._container, `${Ma2[s4]} translate(${o3.x}px,${o3.y}px)`), Aa2(this._container, s4, "popup");
            }, this._onClose = () => {
              this.remove();
            }, this.options = e3.e(Object.create(Ua2), t3);
          }
          addTo(t3) {
            return this._map && this.remove(), this._map = t3, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new e3.k("open")), this;
          }
          isOpen() {
            return !!this._map;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(t3) {
            return this._lngLat = e3.M.convert(t3), this._pos = null, this._flatPos = null, this._trackPointer = false, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
          }
          trackPointer() {
            return this._trackPointer = true, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
          }
          getElement() {
            return this._container;
          }
          setText(t3) {
            return this.setDOMContent(document.createTextNode(t3));
          }
          setHTML(t3) {
            const e4 = document.createDocumentFragment(), i4 = document.createElement("body");
            let s4;
            for (i4.innerHTML = t3; s4 = i4.firstChild, s4; )
              e4.appendChild(s4);
            return this.setDOMContent(e4);
          }
          getMaxWidth() {
            var t3;
            return null === (t3 = this._container) || void 0 === t3 ? void 0 : t3.style.maxWidth;
          }
          setMaxWidth(t3) {
            return this.options.maxWidth = t3, this._update(), this;
          }
          setDOMContent(t3) {
            if (this._content)
              for (; this._content.hasChildNodes(); )
                this._content.firstChild && this._content.removeChild(this._content.firstChild);
            else
              this._content = r4.create("div", "maplibregl-popup-content", this._container);
            return this._content.appendChild(t3), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
          }
          addClassName(t3) {
            this._container && this._container.classList.add(t3);
          }
          removeClassName(t3) {
            this._container && this._container.classList.remove(t3);
          }
          setOffset(t3) {
            return this.options.offset = t3, this._update(), this;
          }
          toggleClassName(t3) {
            if (this._container)
              return this._container.classList.toggle(t3);
          }
          setSubpixelPositioning(t3) {
            this.options.subpixelPositioning = t3;
          }
          _createCloseButton() {
            this.options.closeButton && (this._closeButton = r4.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.setAttribute("aria-label", "Close popup"), this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container)
              return;
            const t3 = this._container.querySelector(Za2);
            t3 && t3.focus();
          }
        }, t2.RasterDEMTileSource = X3, t2.RasterTileSource = $, t2.ScaleControl = class {
          constructor(t3) {
            this._onMove = () => {
              Oa2(this._map, this._container, this.options);
            }, this.setUnit = (t4) => {
              this.options.unit = t4, Oa2(this._map, this._container, this.options);
            }, this.options = e3.e({}, Ba2, t3);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(t3) {
            return this._map = t3, this._container = r4.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", t3.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
          }
          onRemove() {
            r4.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
          }
        }, t2.ScrollZoomHandler = ta2, t2.Style = he2, t2.TerrainControl = class {
          constructor(t3) {
            this._toggleTerrain = () => {
              this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
            }, this._updateTerrainIcon = () => {
              this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
            }, this.options = t3;
          }
          onAdd(t3) {
            return this._map = t3, this._container = r4.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = r4.create("button", "maplibregl-ctrl-terrain", this._container), r4.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
          }
          onRemove() {
            r4.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
          }
        }, t2.TwoFingersTouchPitchHandler = Xs, t2.TwoFingersTouchRotateHandler = Hs, t2.TwoFingersTouchZoomHandler = Vs, t2.TwoFingersTouchZoomRotateHandler = ra2, t2.VectorTileSource = H3, t2.VideoSource = Q2, t2.addSourceType = (t3, i4) => e3._(void 0, void 0, void 0, function* () {
          if (it(t3))
            throw new Error(`A source type called "${t3}" already exists.`);
          ((t4, e4) => {
            et2[t4] = e4;
          })(t3, i4);
        }), t2.clearPrewarmedResources = function() {
          const t3 = F3;
          t3 && (t3.isPreloaded() && 1 === t3.numActive() ? (t3.release(R3), F3 = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
        }, t2.getMaxParallelImageRequests = function() {
          return e3.a.MAX_PARALLEL_IMAGE_REQUESTS;
        }, t2.getRTLTextPluginStatus = function() {
          return ot().getRTLTextPluginStatus();
        }, t2.getVersion = function() {
          return ja;
        }, t2.getWorkerCount = function() {
          return L2.workerCount;
        }, t2.getWorkerUrl = function() {
          return e3.a.WORKER_URL;
        }, t2.importScriptInWorkers = function(t3) {
          return U2().broadcast("importScript", t3);
        }, t2.prewarm = function() {
          O2().acquire(R3);
        }, t2.setMaxParallelImageRequests = function(t3) {
          e3.a.MAX_PARALLEL_IMAGE_REQUESTS = t3;
        }, t2.setRTLTextPlugin = function(t3, e4) {
          return ot().setRTLTextPlugin(t3, e4);
        }, t2.setWorkerCount = function(t3) {
          L2.workerCount = t3;
        }, t2.setWorkerUrl = function(t3) {
          e3.a.WORKER_URL = t3;
        };
      });
      var maplibregl$1 = maplibregl2;
      return maplibregl$1;
    });
  }
});
function flush2(collection2) {
  var result, len, i3;
  if (!collection2) {
    return void 0;
  }
  if (Array.isArray(collection2)) {
    result = [];
    len = collection2.length;
    for (i3 = 0; i3 < len; i3++) {
      var elem = collection2[i3];
      if (elem != null) {
        result.push(elem);
      }
    }
    return result;
  }
  if (typeof collection2 == "object") {
    result = {};
    var keys = Object.keys(collection2);
    len = keys.length;
    for (i3 = 0; i3 < len; i3++) {
      var key2 = keys[i3];
      var value = collection2[key2];
      if (value != null) {
        result[key2] = value;
      }
    }
    return result;
  }
  return void 0;
}
var collectionFlush;
var init_just_flush = __esm({
  "node_modules/just-flush/index.mjs"() {
    collectionFlush = flush2;
  }
});
function compare(value1, value2) {
  if (value1 === value2) {
    return true;
  }
  if (value1 !== value1 && value2 !== value2) {
    return true;
  }
  if (typeof value1 != typeof value2 || // primitive != primitive wrapper
  {}.toString.call(value1) != {}.toString.call(value2)) {
    return false;
  }
  if (value1 !== Object(value1)) {
    return false;
  }
  if (!value1) {
    return false;
  }
  if (Array.isArray(value1)) {
    return compareArrays(value1, value2);
  }
  if ({}.toString.call(value1) == "[object Set]") {
    return compareArrays(Array.from(value1), Array.from(value2));
  }
  if ({}.toString.call(value1) == "[object Object]") {
    return compareObjects(value1, value2);
  }
  return compareNativeSubtypes(value1, value2);
}
function compareNativeSubtypes(value1, value2) {
  return value1.toString() === value2.toString();
}
function compareArrays(value1, value2) {
  var len = value1.length;
  if (len != value2.length) {
    return false;
  }
  for (var i3 = 0; i3 < len; i3++) {
    if (!compare(value1[i3], value2[i3])) {
      return false;
    }
  }
  return true;
}
function compareObjects(value1, value2) {
  var keys1 = Object.keys(value1);
  var len = keys1.length;
  if (len != Object.keys(value2).length) {
    return false;
  }
  for (var i3 = 0; i3 < len; i3++) {
    var key1 = keys1[i3];
    if (!(value2.hasOwnProperty(key1) && compare(value1[key1], value2[key1]))) {
      return false;
    }
  }
  return true;
}
var collectionCompare;
var init_just_compare = __esm({
  "node_modules/just-compare/index.mjs"() {
    collectionCompare = compare;
  }
});
var u8;
var u16;
var i32;
var fleb;
var fdeb;
var clim;
var freb;
var _a;
var fl;
var revfl;
var _b;
var fd2;
var revfd;
var rev;
var x3;
var i2;
var flt;
var i2;
var i2;
var i2;
var i2;
var fdt;
var i2;
var et;
var td2;
var tds;
var init_dist3 = __esm({
  "node_modules/pmtiles/dist/index.js"() {
    u8 = Uint8Array;
    u16 = Uint16Array;
    i32 = Int32Array;
    fleb = new u8([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      3,
      3,
      3,
      3,
      4,
      4,
      4,
      4,
      5,
      5,
      5,
      5,
      0,
      /* unused */
      0,
      0,
      /* impossible */
      0
    ]);
    fdeb = new u8([
      0,
      0,
      0,
      0,
      1,
      1,
      2,
      2,
      3,
      3,
      4,
      4,
      5,
      5,
      6,
      6,
      7,
      7,
      8,
      8,
      9,
      9,
      10,
      10,
      11,
      11,
      12,
      12,
      13,
      13,
      /* unused */
      0,
      0
    ]);
    clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    freb = function(eb2, start) {
      var b2 = new u16(31);
      for (var i3 = 0; i3 < 31; ++i3) {
        b2[i3] = start += 1 << eb2[i3 - 1];
      }
      var r4 = new i32(b2[30]);
      for (var i3 = 1; i3 < 30; ++i3) {
        for (var j2 = b2[i3]; j2 < b2[i3 + 1]; ++j2) {
          r4[j2] = j2 - b2[i3] << 5 | i3;
        }
      }
      return { b: b2, r: r4 };
    };
    _a = freb(fleb, 2);
    fl = _a.b;
    revfl = _a.r;
    fl[28] = 258, revfl[258] = 28;
    _b = freb(fdeb, 0);
    fd2 = _b.b;
    revfd = _b.r;
    rev = new u16(32768);
    for (i2 = 0; i2 < 32768; ++i2) {
      x3 = (i2 & 43690) >> 1 | (i2 & 21845) << 1;
      x3 = (x3 & 52428) >> 2 | (x3 & 13107) << 2;
      x3 = (x3 & 61680) >> 4 | (x3 & 3855) << 4;
      rev[i2] = ((x3 & 65280) >> 8 | (x3 & 255) << 8) >> 1;
    }
    flt = new u8(288);
    for (i2 = 0; i2 < 144; ++i2)
      flt[i2] = 8;
    for (i2 = 144; i2 < 256; ++i2)
      flt[i2] = 9;
    for (i2 = 256; i2 < 280; ++i2)
      flt[i2] = 7;
    for (i2 = 280; i2 < 288; ++i2)
      flt[i2] = 8;
    fdt = new u8(32);
    for (i2 = 0; i2 < 32; ++i2)
      fdt[i2] = 5;
    et = /* @__PURE__ */ new u8(0);
    td2 = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder();
    tds = 0;
    try {
      td2.decode(et, { stream: true });
      tds = 1;
    } catch (e3) {
    }
  }
});
var page_svelte_exports6 = {};
__export(page_svelte_exports6, {
  default: () => Page6
});
function mapContext$1() {
  return getContext(MAP_CONTEXT_KEY$1);
}
function eventTopMost(layerInfo) {
  let tracker = /* @__PURE__ */ new WeakMap();
  return (event) => {
    let id2 = tracker.get(event.originalEvent);
    if (id2 !== void 0) {
      return id2;
    }
    let features = event.target.queryRenderedFeatures(event.point);
    let topId = features.find((f) => layerInfo.get(f.layer.id)?.interactive)?.layer.id;
    tracker.set(event.originalEvent, topId);
    return topId;
  };
}
function createMapContext() {
  let layerInfo = /* @__PURE__ */ new Map();
  return setContext(MAP_CONTEXT_KEY$1, {
    map: writable(null),
    source: readable(null),
    layer: readable(null),
    popupTarget: readable(null),
    cluster: writable(),
    loadedImages: writable(/* @__PURE__ */ new Set()),
    minzoom: writable(0),
    maxzoom: writable(24),
    layerEvent: writable(null),
    layerInfo,
    eventTopMost: eventTopMost(layerInfo)
  });
}
function readableFromWritable(writable2) {
  return {
    subscribe: writable2.subscribe
  };
}
function updatedContext({ key: key2, setPopupTarget = false, setCluster = false, setMouseEvent = false }) {
  let currentContext = mapContext$1();
  let newValue = writable(null);
  let ctxValue = readableFromWritable(newValue);
  let newCtx = {
    ...currentContext,
    [key2]: readableFromWritable(newValue)
  };
  if (setPopupTarget) {
    newCtx.popupTarget = ctxValue;
  }
  if (setMouseEvent) {
    let layerEvent = writable(null);
    newCtx.layerEvent = layerEvent;
    currentContext.layerEvent = layerEvent;
  }
  if (setCluster) {
    newCtx.cluster = writable();
  }
  setContext(MAP_CONTEXT_KEY$1, newCtx);
  return {
    ...currentContext,
    self: newValue
  };
}
function updatedMarkerContext() {
  return updatedContext({ key: "popupTarget", setPopupTarget: true, setMouseEvent: true });
}
function isDeckGlMouseEvent(event) {
  return "layerType" in event && event.layerType === "deckgl";
}
function mapContext() {
  return getContext(MAP_CONTEXT_KEY);
}
var import_maplibre_gl;
var CommandList;
var Command_list;
var LoadingSpinner;
var SearchLocation;
var MAP_CONTEXT_KEY$1;
var DefaultMarker;
var FullscreenControl;
var GeolocateControl;
var NavigationControl;
var ScaleControl;
var css$12;
var MapLibre;
var Popup;
var MAP_CONTEXT_KEY;
var LocateControl;
var css2;
var Map$1;
var Page6;
var init_page_svelte6 = __esm({
  ".svelte-kit/output/server/entries/pages/(dashboard)/_project_/lokasi/_page.svelte.js"() {
    init_ssr();
    init_mode_toggle();
    init_lifecycle();
    init_command_input();
    init_dist();
    init_index3();
    init_MagnifyingGlass();
    import_maplibre_gl = __toESM(require_maplibre_gl(), 1);
    init_just_flush();
    init_index2();
    init_just_compare();
    init_dist3();
    init_stores();
    CommandList = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["el", "asChild"]);
      let $$unsubscribe_state;
      const { ids } = getCtx2();
      const state = getState();
      $$unsubscribe_state = subscribe(state, (value) => value);
      let { el = void 0 } = $$props;
      let { asChild = false } = $$props;
      function sizerAction(node) {
        let animationFrame;
        const listEl = node.closest("[data-cmdk-list]");
        if (!isHTMLElement3(listEl)) {
          return;
        }
        const observer = new ResizeObserver(() => {
          animationFrame = requestAnimationFrame(() => {
            const height = node.offsetHeight;
            listEl.style.setProperty("--cmdk-list-height", height.toFixed(1) + "px");
          });
        });
        observer.observe(node);
        return {
          destroy() {
            cancelAnimationFrame(animationFrame);
            observer.unobserve(node);
          }
        };
      }
      const listAttrs = {
        "data-cmdk-list": "",
        role: "listbox",
        "aria-label": "Suggestions",
        id: ids.list,
        "aria-labelledby": ids.input
      };
      const sizerAttrs = { "data-cmdk-list-sizer": "" };
      const list = { attrs: listAttrs };
      const sizer = { attrs: sizerAttrs, action: sizerAction };
      if ($$props.el === void 0 && $$bindings.el && el !== void 0)
        $$bindings.el(el);
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      $$unsubscribe_state();
      return `${asChild ? `${slots.default ? slots.default({ list, sizer }) : ``}` : `<div${spread([escape_object(listAttrs), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}><div${spread([escape_object(sizerAttrs)], {})}>${slots.default ? slots.default({}) : ``}</div></div>`}`;
    });
    Command_list = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class"]);
      let { class: className = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      return `${validate_component(CommandList, "CommandPrimitive.List").$$render(
        $$result,
        Object.assign(
          {},
          {
            class: cn("max-h-[300px] overflow-y-auto overflow-x-hidden", className)
          },
          $$restProps
        ),
        {},
        {
          default: () => {
            return `${slots.default ? slots.default({}) : ``}`;
          }
        }
      )}`;
    });
    LoadingSpinner = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, []);
      return `<div${add_attribute("class", $$restProps.class, 0)}><svg aria-hidden="true" class="h-5 w-5 animate-spin fill-blue-600 text-gray-200 dark:text-gray-600" viewBox="0 0 100 101" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z" fill="currentColor"></path><path d="M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z" fill="currentFill"></path></svg> <span class="sr-only" data-svelte-h="svelte-1wtojot">Loading...</span></div>`;
    });
    SearchLocation = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["lngLat"]);
      let { lngLat } = $$props;
      let timer;
      let foundedCities = [];
      let value = "";
      let isFetching = false;
      let isShowingResult = false;
      const debounce2 = (val) => {
        clearTimeout(timer);
        timer = setTimeout(
          async () => {
            isFetching = true;
            const apiUrl = `https://nominatim.openstreetmap.org/search?format=geojson&accept-language=id&countrycodes=id&limit=5&q=${val}`;
            const data2 = await fetch(apiUrl).then((res) => res.json()).catch(() => console.error("An exception occurred"));
            foundedCities = data2?.features;
            isFetching = false;
            isShowingResult = true;
          },
          500
        );
      };
      if ($$props.lngLat === void 0 && $$bindings.lngLat && lngLat !== void 0)
        $$bindings.lngLat(lngLat);
      let $$settled;
      let $$rendered;
      let previous_head = $$result.head;
      do {
        $$settled = true;
        $$result.head = previous_head;
        {
          {
            isShowingResult = false;
            if (value.length > 1) {
              debounce2(value);
            }
          }
        }
        $$rendered = `<div${add_attribute("class", $$restProps.class, 0)}>${validate_component(Command, "Command.Root").$$render(
          $$result,
          {
            class: cn("w-full rounded-lg border border-b-0 bg-card shadow", isShowingResult && "rounded-lg focus-within:rounded-b-none"),
            shouldFilter: false
          },
          {},
          {
            default: () => {
              return `${validate_component(Command_input, "Command.Input").$$render(
                $$result,
                {
                  placeholder: "Search location...",
                  class: "peer rounded-none",
                  value
                },
                {
                  value: ($$value) => {
                    value = $$value;
                    $$settled = false;
                  }
                },
                {}
              )} ${isFetching ? `${validate_component(LoadingSpinner, "LoadingSpinner").$$render(
                $$result,
                {
                  class: "absolute right-2 top-1/2 -translate-y-1/2"
                },
                {},
                {}
              )}` : ``} ${isShowingResult ? `${validate_component(Command_list, "Command.List").$$render(
                $$result,
                {
                  class: "invisible absolute left-0 top-10 z-10 box-border w-full rounded-b-lg border bg-card shadow hover:visible peer-focus-within:visible"
                },
                {},
                {
                  default: () => {
                    return `${validate_component(Command_empty, "Command.Empty").$$render($$result, {}, {}, {
                      default: () => {
                        return `Not Found.`;
                      }
                    })} ${validate_component(Command_group, "Command.Group").$$render($$result, {}, {}, {
                      default: () => {
                        return `${each(foundedCities, (city) => {
                          return `${validate_component(Command_item, "Command.Item").$$render(
                            $$result,
                            {
                              onSelect: () => {
                                lngLat = city.geometry.coordinates;
                                isShowingResult = false;
                              }
                            },
                            {},
                            {
                              default: () => {
                                return `${validate_component(MagnifyingGlass$1, "MagnifyingGlass").$$render(
                                  $$result,
                                  {
                                    class: "mr-2 h-4 w-4 shrink-0 opacity-50"
                                  },
                                  {},
                                  {}
                                )} <span class="truncate">${escape(city.properties.display_name)}</span> <span class="hidden">${escape(city.properties.place_id)}</span> `;
                              }
                            }
                          )}`;
                        })}`;
                      }
                    })}`;
                  }
                }
              )}` : ``}`;
            }
          }
        )}</div>`;
      } while (!$$settled);
      return $$rendered;
    });
    MAP_CONTEXT_KEY$1 = Symbol.for("svelte-maplibre");
    DefaultMarker = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $layerEvent, $$unsubscribe_layerEvent;
      let $marker, $$unsubscribe_marker;
      let $map, $$unsubscribe_map;
      let { lngLat } = $$props;
      let { class: classNames = void 0 } = $$props;
      let { draggable = false } = $$props;
      let { feature = null } = $$props;
      let { offset: offset2 = void 0 } = $$props;
      let { rotation = 0 } = $$props;
      let { opacity = 1 } = $$props;
      const dispatch = createEventDispatcher();
      const { map, layerEvent, self: marker } = updatedMarkerContext();
      $$unsubscribe_map = subscribe(map, (value) => $map = value);
      $$unsubscribe_layerEvent = subscribe(layerEvent, (value) => $layerEvent = value);
      $$unsubscribe_marker = subscribe(marker, (value) => $marker = value);
      const dragStartListener = () => sendEvent("dragstart");
      const dragListener = () => {
        propagateLngLatChange();
        sendEvent("drag");
      };
      const dragEndListener = () => {
        propagateLngLatChange();
        sendEvent("dragend");
      };
      set_store_value(
        marker,
        $marker = new import_maplibre_gl.default.Marker(collectionFlush({
          draggable,
          rotation,
          className: classNames,
          offset: offset2,
          opacity: opacity.toString()
        })).setLngLat(lngLat).addTo($map),
        $marker
      );
      if (draggable) {
        $marker.on("dragstart", dragStartListener);
        $marker.on("drag", dragListener);
        $marker.on("dragend", dragEndListener);
      }
      onDestroy(() => $marker?.remove());
      function propagateLngLatChange() {
        let newPos = $marker?.getLngLat();
        if (!newPos) {
          return;
        }
        if (Array.isArray(lngLat)) {
          lngLat = [newPos.lng, newPos.lat];
        } else if (lngLat && "lon" in lngLat) {
          lngLat = { lon: newPos.lng, lat: newPos.lat };
        } else {
          lngLat = newPos;
        }
      }
      function sendEvent(eventName) {
        let loc = $marker?.getLngLat();
        if (!loc) {
          return;
        }
        const lngLat2 = [loc.lng, loc.lat];
        let data2 = {
          map: $map,
          marker: $marker,
          lngLat: lngLat2,
          features: [
            {
              type: "Feature",
              properties: feature?.properties ?? {},
              geometry: { type: "Point", coordinates: lngLat2 }
            }
          ]
        };
        set_store_value(
          layerEvent,
          $layerEvent = {
            ...data2,
            layerType: "marker",
            type: eventName
          },
          $layerEvent
        );
        dispatch(eventName, data2);
      }
      if ($$props.lngLat === void 0 && $$bindings.lngLat && lngLat !== void 0)
        $$bindings.lngLat(lngLat);
      if ($$props.class === void 0 && $$bindings.class && classNames !== void 0)
        $$bindings.class(classNames);
      if ($$props.draggable === void 0 && $$bindings.draggable && draggable !== void 0)
        $$bindings.draggable(draggable);
      if ($$props.feature === void 0 && $$bindings.feature && feature !== void 0)
        $$bindings.feature(feature);
      if ($$props.offset === void 0 && $$bindings.offset && offset2 !== void 0)
        $$bindings.offset(offset2);
      if ($$props.rotation === void 0 && $$bindings.rotation && rotation !== void 0)
        $$bindings.rotation(rotation);
      if ($$props.opacity === void 0 && $$bindings.opacity && opacity !== void 0)
        $$bindings.opacity(opacity);
      {
        $marker?.setLngLat(lngLat);
      }
      {
        $marker?.setOffset(offset2 ?? [0, 0]);
      }
      {
        $marker?.setRotation(rotation);
      }
      {
        $marker?.setOpacity(opacity.toString());
      }
      $$unsubscribe_layerEvent();
      $$unsubscribe_marker();
      $$unsubscribe_map();
      return `${slots.default ? slots.default({}) : ``}`;
    });
    FullscreenControl = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $map, $$unsubscribe_map;
      const { map } = mapContext$1();
      $$unsubscribe_map = subscribe(map, (value) => $map = value);
      let { position = "top-left" } = $$props;
      let { container = void 0 } = $$props;
      let control = null;
      onDestroy(() => {
        if ($map?.loaded() && control) {
          $map.removeControl(control);
        }
      });
      if ($$props.position === void 0 && $$bindings.position && position !== void 0)
        $$bindings.position(position);
      if ($$props.container === void 0 && $$bindings.container && container !== void 0)
        $$bindings.container(container);
      {
        if ($map && !control) {
          let containerEl;
          if (typeof container === "string") {
            containerEl = document.querySelector(container) ?? void 0;
          } else {
            containerEl = container;
          }
          control = new import_maplibre_gl.default.FullscreenControl({ container: containerEl });
          $map.addControl(control, position);
        }
      }
      $$unsubscribe_map();
      return ``;
    });
    GeolocateControl = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $map, $$unsubscribe_map;
      const { map } = mapContext$1();
      $$unsubscribe_map = subscribe(map, (value) => $map = value);
      let { position = "top-left" } = $$props;
      let { positionOptions = void 0 } = $$props;
      let { fitBoundsOptions = void 0 } = $$props;
      let { trackUserLocation = false } = $$props;
      let { showAccuracyCircle = true } = $$props;
      let { showUserLocation = true } = $$props;
      let control = null;
      onDestroy(() => {
        if ($map?.loaded() && control) {
          $map.removeControl(control);
        }
      });
      if ($$props.position === void 0 && $$bindings.position && position !== void 0)
        $$bindings.position(position);
      if ($$props.positionOptions === void 0 && $$bindings.positionOptions && positionOptions !== void 0)
        $$bindings.positionOptions(positionOptions);
      if ($$props.fitBoundsOptions === void 0 && $$bindings.fitBoundsOptions && fitBoundsOptions !== void 0)
        $$bindings.fitBoundsOptions(fitBoundsOptions);
      if ($$props.trackUserLocation === void 0 && $$bindings.trackUserLocation && trackUserLocation !== void 0)
        $$bindings.trackUserLocation(trackUserLocation);
      if ($$props.showAccuracyCircle === void 0 && $$bindings.showAccuracyCircle && showAccuracyCircle !== void 0)
        $$bindings.showAccuracyCircle(showAccuracyCircle);
      if ($$props.showUserLocation === void 0 && $$bindings.showUserLocation && showUserLocation !== void 0)
        $$bindings.showUserLocation(showUserLocation);
      {
        if ($map && !control) {
          control = new import_maplibre_gl.default.GeolocateControl({
            positionOptions,
            fitBoundsOptions,
            trackUserLocation,
            showAccuracyCircle,
            showUserLocation
          });
          $map.addControl(control, position);
        }
      }
      $$unsubscribe_map();
      return ``;
    });
    NavigationControl = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $map, $$unsubscribe_map;
      const { map } = mapContext$1();
      $$unsubscribe_map = subscribe(map, (value) => $map = value);
      let { position = "top-left" } = $$props;
      let { showCompass = true } = $$props;
      let { showZoom = true } = $$props;
      let { visualizePitch = false } = $$props;
      let control = null;
      onDestroy(() => {
        if ($map?.loaded() && control) {
          $map.removeControl(control);
        }
      });
      if ($$props.position === void 0 && $$bindings.position && position !== void 0)
        $$bindings.position(position);
      if ($$props.showCompass === void 0 && $$bindings.showCompass && showCompass !== void 0)
        $$bindings.showCompass(showCompass);
      if ($$props.showZoom === void 0 && $$bindings.showZoom && showZoom !== void 0)
        $$bindings.showZoom(showZoom);
      if ($$props.visualizePitch === void 0 && $$bindings.visualizePitch && visualizePitch !== void 0)
        $$bindings.visualizePitch(visualizePitch);
      {
        if ($map && !control) {
          control = new import_maplibre_gl.default.NavigationControl({ showCompass, showZoom, visualizePitch }), $map.addControl(control, position);
        }
      }
      $$unsubscribe_map();
      return ``;
    });
    ScaleControl = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $map, $$unsubscribe_map;
      const { map } = mapContext$1();
      $$unsubscribe_map = subscribe(map, (value) => $map = value);
      let { position = "bottom-left" } = $$props;
      let { maxWidth = void 0 } = $$props;
      let { unit = "metric" } = $$props;
      let control = null;
      onDestroy(() => {
        if ($map?.loaded() && control) {
          $map.removeControl(control);
        }
      });
      if ($$props.position === void 0 && $$bindings.position && position !== void 0)
        $$bindings.position(position);
      if ($$props.maxWidth === void 0 && $$bindings.maxWidth && maxWidth !== void 0)
        $$bindings.maxWidth(maxWidth);
      if ($$props.unit === void 0 && $$bindings.unit && unit !== void 0)
        $$bindings.unit(unit);
      {
        if ($map && !control) {
          control = new import_maplibre_gl.default.ScaleControl({ maxWidth, unit });
          $map.addControl(control, position);
        }
      }
      $$unsubscribe_map();
      return ``;
    });
    css$12 = {
      code: ".expand-map.svelte-p00lfq{position:absolute;top:0;bottom:0;left:0;right:0}",
      map: null
    };
    MapLibre = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let standardControlsPosition;
      let allImagesLoaded;
      let $mapInstance, $$unsubscribe_mapInstance;
      let $loadedImages, $$unsubscribe_loadedImages;
      let { map = null } = $$props;
      let { class: classNames = void 0 } = $$props;
      let { style } = $$props;
      let { diffStyleUpdates = false } = $$props;
      let { center = void 0 } = $$props;
      let { zoom = void 0 } = $$props;
      let { pitch = 0 } = $$props;
      let { bearing = 0 } = $$props;
      let { bounds = void 0 } = $$props;
      let { hash: hash2 = false } = $$props;
      let { loaded = false } = $$props;
      let { minZoom = 0 } = $$props;
      let { maxZoom = 22 } = $$props;
      let { zoomOnDoubleClick = true } = $$props;
      let { locale = void 0 } = $$props;
      let { interactive = true } = $$props;
      let { attributionControl = true } = $$props;
      let { cooperativeGestures = false } = $$props;
      let { preserveDrawingBuffer = false } = $$props;
      let { maxBounds = void 0 } = $$props;
      let { images = [] } = $$props;
      let { standardControls = false } = $$props;
      let { filterLayers = void 0 } = $$props;
      let { transformRequest = void 0 } = $$props;
      const dispatch = createEventDispatcher();
      const { map: mapInstance, loadedImages } = createMapContext();
      $$unsubscribe_mapInstance = subscribe(mapInstance, (value) => $mapInstance = value);
      $$unsubscribe_loadedImages = subscribe(loadedImages, (value) => $loadedImages = value);
      let loadingImages = /* @__PURE__ */ new Set();
      async function loadImage(image) {
        if (!$mapInstance?.loaded()) {
          return;
        }
        if ("url" in image) {
          loadingImages.add(image.id);
          try {
            let imageData = await $mapInstance.loadImage(image.url);
            $mapInstance?.addImage(image.id, imageData.data, image.options);
            $loadedImages.add(image.id);
            loadedImages.set($loadedImages);
          } catch (e3) {
            dispatch("error", e3);
          } finally {
            loadingImages.delete(image.id);
          }
        } else {
          $mapInstance.addImage(image.id, image.data, image.options);
          $loadedImages.add(image.id);
          loadedImages.set($loadedImages);
        }
      }
      let lastStyle = style;
      if ($$props.map === void 0 && $$bindings.map && map !== void 0)
        $$bindings.map(map);
      if ($$props.class === void 0 && $$bindings.class && classNames !== void 0)
        $$bindings.class(classNames);
      if ($$props.style === void 0 && $$bindings.style && style !== void 0)
        $$bindings.style(style);
      if ($$props.diffStyleUpdates === void 0 && $$bindings.diffStyleUpdates && diffStyleUpdates !== void 0)
        $$bindings.diffStyleUpdates(diffStyleUpdates);
      if ($$props.center === void 0 && $$bindings.center && center !== void 0)
        $$bindings.center(center);
      if ($$props.zoom === void 0 && $$bindings.zoom && zoom !== void 0)
        $$bindings.zoom(zoom);
      if ($$props.pitch === void 0 && $$bindings.pitch && pitch !== void 0)
        $$bindings.pitch(pitch);
      if ($$props.bearing === void 0 && $$bindings.bearing && bearing !== void 0)
        $$bindings.bearing(bearing);
      if ($$props.bounds === void 0 && $$bindings.bounds && bounds !== void 0)
        $$bindings.bounds(bounds);
      if ($$props.hash === void 0 && $$bindings.hash && hash2 !== void 0)
        $$bindings.hash(hash2);
      if ($$props.loaded === void 0 && $$bindings.loaded && loaded !== void 0)
        $$bindings.loaded(loaded);
      if ($$props.minZoom === void 0 && $$bindings.minZoom && minZoom !== void 0)
        $$bindings.minZoom(minZoom);
      if ($$props.maxZoom === void 0 && $$bindings.maxZoom && maxZoom !== void 0)
        $$bindings.maxZoom(maxZoom);
      if ($$props.zoomOnDoubleClick === void 0 && $$bindings.zoomOnDoubleClick && zoomOnDoubleClick !== void 0)
        $$bindings.zoomOnDoubleClick(zoomOnDoubleClick);
      if ($$props.locale === void 0 && $$bindings.locale && locale !== void 0)
        $$bindings.locale(locale);
      if ($$props.interactive === void 0 && $$bindings.interactive && interactive !== void 0)
        $$bindings.interactive(interactive);
      if ($$props.attributionControl === void 0 && $$bindings.attributionControl && attributionControl !== void 0)
        $$bindings.attributionControl(attributionControl);
      if ($$props.cooperativeGestures === void 0 && $$bindings.cooperativeGestures && cooperativeGestures !== void 0)
        $$bindings.cooperativeGestures(cooperativeGestures);
      if ($$props.preserveDrawingBuffer === void 0 && $$bindings.preserveDrawingBuffer && preserveDrawingBuffer !== void 0)
        $$bindings.preserveDrawingBuffer(preserveDrawingBuffer);
      if ($$props.maxBounds === void 0 && $$bindings.maxBounds && maxBounds !== void 0)
        $$bindings.maxBounds(maxBounds);
      if ($$props.images === void 0 && $$bindings.images && images !== void 0)
        $$bindings.images(images);
      if ($$props.standardControls === void 0 && $$bindings.standardControls && standardControls !== void 0)
        $$bindings.standardControls(standardControls);
      if ($$props.filterLayers === void 0 && $$bindings.filterLayers && filterLayers !== void 0)
        $$bindings.filterLayers(filterLayers);
      if ($$props.transformRequest === void 0 && $$bindings.transformRequest && transformRequest !== void 0)
        $$bindings.transformRequest(transformRequest);
      $$result.css.add(css$12);
      standardControlsPosition = typeof standardControls === "boolean" ? void 0 : standardControls;
      map = $mapInstance;
      {
        if (loaded && $mapInstance?.loaded()) {
          for (let image of images) {
            if (!loadingImages.has(image.id) && !$mapInstance.hasImage(image.id)) {
              loadImage(image);
            }
          }
        }
      }
      allImagesLoaded = images.every((image) => $loadedImages.has(image.id));
      {
        if ($mapInstance && !collectionCompare(style, lastStyle)) {
          $mapInstance.getStyle();
          lastStyle = style;
          $mapInstance.setStyle(style, { diff: diffStyleUpdates });
        }
      }
      {
        if (center && !collectionCompare(center, $mapInstance?.getCenter()))
          $mapInstance?.panTo(center);
      }
      {
        if (zoom && !collectionCompare(zoom, $mapInstance?.getZoom()))
          $mapInstance?.zoomTo(zoom);
      }
      {
        if (bounds && !collectionCompare(bounds, $mapInstance?.getBounds()))
          $mapInstance?.fitBounds(bounds);
      }
      {
        zoomOnDoubleClick ? $mapInstance?.doubleClickZoom.enable() : $mapInstance?.doubleClickZoom.disable();
      }
      $$unsubscribe_mapInstance();
      $$unsubscribe_loadedImages();
      return `<div class="${[
        escape(null_to_empty(classNames), true) + " svelte-p00lfq",
        !classNames ? "expand-map" : ""
      ].join(" ").trim()}">${$mapInstance && loaded ? `${standardControls ? `${validate_component(NavigationControl, "NavigationControl").$$render($$result, { position: standardControlsPosition }, {}, {})} ${validate_component(GeolocateControl, "GeolocateControl").$$render(
        $$result,
        {
          position: standardControlsPosition,
          fitBoundsOptions: { maxZoom: 12 }
        },
        {},
        {}
      )} ${validate_component(FullscreenControl, "FullscreenControl").$$render($$result, { position: standardControlsPosition }, {}, {})} ${validate_component(ScaleControl, "ScaleControl").$$render($$result, { position: standardControlsPosition }, {}, {})}` : ``} ${slots.default ? slots.default({
        map: $mapInstance,
        loadedImages: $loadedImages,
        allImagesLoaded
      }) : ``}` : ``} </div>`;
    });
    Popup = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let actualCloseButton;
      let hoveringOnLayer;
      let $$slots = compute_slots(slots);
      let $map, $$unsubscribe_map;
      let $layerEvent, $$unsubscribe_layerEvent;
      let $popupTarget, $$unsubscribe_popupTarget;
      let $layer, $$unsubscribe_layer;
      let { closeButton = void 0 } = $$props;
      let { closeOnClickOutside = true } = $$props;
      let { closeOnClickInside = false } = $$props;
      let { closeOnMove = false } = $$props;
      let { openOn = "click" } = $$props;
      let { openIfTopMost = true } = $$props;
      let { focusAfterOpen = true } = $$props;
      let { anchor = void 0 } = $$props;
      let { offset: offset2 = void 0 } = $$props;
      let { popupClass = void 0 } = $$props;
      let { maxWidth = void 0 } = $$props;
      let { lngLat = void 0 } = $$props;
      let { html = void 0 } = $$props;
      let { open = false } = $$props;
      const { map, popupTarget, layerEvent, layer, eventTopMost: eventTopMost2 } = mapContext$1();
      $$unsubscribe_map = subscribe(map, (value) => $map = value);
      $$unsubscribe_popupTarget = subscribe(popupTarget, (value) => $popupTarget = value);
      $$unsubscribe_layerEvent = subscribe(layerEvent, (value) => $layerEvent = value);
      $$unsubscribe_layer = subscribe(layer, (value) => $layer = value);
      const clickEvents = ["click", "dblclick", "contextmenu"];
      let popup;
      let hoveringOnPopup = false;
      let popupElement;
      function setPopupClickHandler() {
        if (!popup) {
          return;
        }
        let el = popup.getElement();
        if (!el || el === popupElement) {
          return;
        }
        popupElement = el;
        if (openOn === "hover") {
          popupElement.style.pointerEvents = "none";
        }
        popupElement.addEventListener(
          "mouseenter",
          () => {
            hoveringOnPopup = true;
          },
          { passive: true }
        );
        popupElement.addEventListener(
          "mouseleave",
          () => {
            hoveringOnPopup = false;
          },
          { passive: true }
        );
        popupElement.addEventListener(
          "click",
          () => {
            if (closeOnClickInside) {
              open = false;
            }
          },
          { passive: true }
        );
      }
      function skipHandlingEvent(e3) {
        if (!openIfTopMost) {
          return false;
        }
        return !("marker" in e3) && !isDeckGlMouseEvent(e3) && eventTopMost2(e3) !== $layer;
      }
      let features = null;
      function handleLayerClick(e3) {
        if (e3.type !== openOn) {
          return;
        }
        if (skipHandlingEvent(e3)) {
          return;
        }
        if ("layerType" in e3) {
          if (e3.layerType === "deckgl") {
            lngLat = e3.coordinate;
            features = e3.object ? [e3.object] : null;
          } else {
            lngLat = e3.lngLat;
            features = e3.features ?? [];
          }
        } else {
          lngLat = e3.lngLat;
          features = e3.features ?? [];
        }
        setTimeout(() => open = true);
      }
      onDestroy(() => {
        if ($map && popup?.isOpen()) {
          popup.remove();
        }
      });
      let popupEl;
      if ($$props.closeButton === void 0 && $$bindings.closeButton && closeButton !== void 0)
        $$bindings.closeButton(closeButton);
      if ($$props.closeOnClickOutside === void 0 && $$bindings.closeOnClickOutside && closeOnClickOutside !== void 0)
        $$bindings.closeOnClickOutside(closeOnClickOutside);
      if ($$props.closeOnClickInside === void 0 && $$bindings.closeOnClickInside && closeOnClickInside !== void 0)
        $$bindings.closeOnClickInside(closeOnClickInside);
      if ($$props.closeOnMove === void 0 && $$bindings.closeOnMove && closeOnMove !== void 0)
        $$bindings.closeOnMove(closeOnMove);
      if ($$props.openOn === void 0 && $$bindings.openOn && openOn !== void 0)
        $$bindings.openOn(openOn);
      if ($$props.openIfTopMost === void 0 && $$bindings.openIfTopMost && openIfTopMost !== void 0)
        $$bindings.openIfTopMost(openIfTopMost);
      if ($$props.focusAfterOpen === void 0 && $$bindings.focusAfterOpen && focusAfterOpen !== void 0)
        $$bindings.focusAfterOpen(focusAfterOpen);
      if ($$props.anchor === void 0 && $$bindings.anchor && anchor !== void 0)
        $$bindings.anchor(anchor);
      if ($$props.offset === void 0 && $$bindings.offset && offset2 !== void 0)
        $$bindings.offset(offset2);
      if ($$props.popupClass === void 0 && $$bindings.popupClass && popupClass !== void 0)
        $$bindings.popupClass(popupClass);
      if ($$props.maxWidth === void 0 && $$bindings.maxWidth && maxWidth !== void 0)
        $$bindings.maxWidth(maxWidth);
      if ($$props.lngLat === void 0 && $$bindings.lngLat && lngLat !== void 0)
        $$bindings.lngLat(lngLat);
      if ($$props.html === void 0 && $$bindings.html && html !== void 0)
        $$bindings.html(html);
      if ($$props.open === void 0 && $$bindings.open && open !== void 0)
        $$bindings.open(open);
      actualCloseButton = closeButton ?? (!closeOnClickOutside && !closeOnClickInside);
      {
        if (!popup) {
          popup = new import_maplibre_gl.default.Popup({
            closeButton: actualCloseButton,
            // We handle this ourselves to improve behavior on mobile.
            closeOnClick: false,
            closeOnMove,
            focusAfterOpen,
            maxWidth,
            className: popupClass,
            anchor,
            offset: offset2
          });
          popupElement = popup.getElement();
          popup.on("open", () => {
            open = true;
            setPopupClickHandler();
          });
          popup.on("close", (e3) => {
            open = false;
          });
        }
      }
      {
        if (popup && $popupTarget instanceof import_maplibre_gl.default.Marker) {
          if (openOn === "click") {
            $popupTarget.setPopup(popup);
          } else if ($popupTarget.getPopup() === popup) {
            $popupTarget.setPopup(void 0);
          }
        }
      }
      {
        if (clickEvents.includes(openOn) && $layerEvent?.type === openOn) {
          handleLayerClick($layerEvent);
          set_store_value(layerEvent, $layerEvent = null, $layerEvent);
        }
      }
      hoveringOnLayer = openOn === "hover" && ($layerEvent?.type === "mousemove" || $layerEvent?.type === "mouseenter");
      {
        if (openOn === "hover" && layerEvent) {
          if (hoveringOnLayer && $layerEvent) {
            if ($layerEvent.layerType === "deckgl") {
              lngLat = $layerEvent.coordinate;
              features = $layerEvent.object ? [$layerEvent.object] : null;
            } else {
              lngLat = $layerEvent.lngLat;
              features = $layerEvent.features ?? [];
            }
          }
          open = (hoveringOnLayer || hoveringOnPopup) ?? false;
        }
      }
      {
        if (html) {
          popup.setHTML(html);
        }
      }
      {
        if (lngLat)
          popup.setLngLat(lngLat);
      }
      {
        if ($map) {
          let isOpen = popup.isOpen();
          if (open && !isOpen) {
            popup.addTo($map);
          } else if (!open && isOpen) {
            popup.remove();
          }
        }
      }
      $$unsubscribe_map();
      $$unsubscribe_layerEvent();
      $$unsubscribe_popupTarget();
      $$unsubscribe_layer();
      return `${$$slots.default ? `<div${add_attribute("this", popupEl, 0)}>${features || $popupTarget instanceof import_maplibre_gl.default.Marker ? `${slots.default ? slots.default({
        features,
        data: features?.[0],
        map: $map,
        close: () => open = false
      }) : ``}` : ``}</div>` : ``}`;
    });
    MAP_CONTEXT_KEY = Symbol.for("svelte-maplibre");
    LocateControl = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $map, $$unsubscribe_map;
      let { defaultStyling = true } = $$props;
      let { position = "top-right" } = $$props;
      let { class: classNames = void 0 } = $$props;
      let { lngLat } = $$props;
      const { map } = mapContext();
      $$unsubscribe_map = subscribe(map, (value) => $map = value);
      let el;
      let control = {
        onAdd() {
          return el;
        },
        onRemove() {
        }
      };
      let timer;
      const debounce2 = (lngLat2) => {
        clearTimeout(timer);
        timer = setTimeout(
          async () => {
            $map?.flyTo({ center: lngLat2 });
          },
          250
        );
      };
      onDestroy(() => {
        $map?.removeControl(control);
      });
      if ($$props.defaultStyling === void 0 && $$bindings.defaultStyling && defaultStyling !== void 0)
        $$bindings.defaultStyling(defaultStyling);
      if ($$props.position === void 0 && $$bindings.position && position !== void 0)
        $$bindings.position(position);
      if ($$props.class === void 0 && $$bindings.class && classNames !== void 0)
        $$bindings.class(classNames);
      if ($$props.lngLat === void 0 && $$bindings.lngLat && lngLat !== void 0)
        $$bindings.lngLat(lngLat);
      {
        if ($map && el) {
          $map.addControl(control, position);
        }
      }
      {
        {
          debounce2(lngLat);
        }
      }
      $$unsubscribe_map();
      return `<div class="${[
        escape(classNames, true),
        (defaultStyling ? "maplibregl-ctrl" : "") + " " + (defaultStyling ? "maplibregl-ctrl-group" : "")
      ].join(" ").trim()}"${add_attribute("this", el, 0)}><button class="maplibregl-ctrl-geolocate" type="button" title="Find my location" aria-label="Find my location" data-svelte-h="svelte-19qxjw5"><span class="maplibregl-ctrl-icon" aria-hidden="true"></span></button></div>`;
    });
    css2 = {
      code: ".maplibregl-canvas{border-radius:var(--radius)}",
      map: null
    };
    Map$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let style;
      let $$restProps = compute_rest_props($$props, ["lngLat"]);
      let $mode, $$unsubscribe_mode;
      $$unsubscribe_mode = subscribe(derivedMode, (value) => $mode = value);
      let { lngLat } = $$props;
      const staticLngLat = lngLat;
      if ($$props.lngLat === void 0 && $$bindings.lngLat && lngLat !== void 0)
        $$bindings.lngLat(lngLat);
      $$result.css.add(css2);
      let $$settled;
      let $$rendered;
      let previous_head = $$result.head;
      do {
        $$settled = true;
        $$result.head = previous_head;
        style = `${$mode === "dark" ? "https://api.maptiler.com/maps/49f63854-b0c2-414b-9b03-7db05ff33738/style.json?key=pCvzMcEFa2VIKsE1kbGn" : "https://api.maptiler.com/maps/507eef78-4030-433b-aecf-3cb65c91e1b5/style.json?key=pCvzMcEFa2VIKsE1kbGn"}`;
        $$rendered = ` ${validate_component(MapLibre, "MapLibre").$$render(
          $$result,
          {
            center: staticLngLat,
            zoom: 8,
            standardControls: false,
            attributionControl: false,
            style,
            class: $$restProps.class
          },
          {},
          {
            default: () => {
              return `${validate_component(NavigationControl, "NavigationControl").$$render($$result, { position: "top-left" }, {}, {})} ${validate_component(LocateControl, "LocateControl").$$render(
                $$result,
                { position: "top-left", lngLat },
                {
                  lngLat: ($$value) => {
                    lngLat = $$value;
                    $$settled = false;
                  }
                },
                {}
              )} ${validate_component(FullscreenControl, "FullscreenControl").$$render($$result, { position: "top-left" }, {}, {})} ${validate_component(ScaleControl, "ScaleControl").$$render($$result, {}, {}, {})} ${validate_component(DefaultMarker, "DefaultMarker").$$render(
                $$result,
                { draggable: true, lngLat },
                {
                  lngLat: ($$value) => {
                    lngLat = $$value;
                    $$settled = false;
                  }
                },
                {
                  default: () => {
                    return `${validate_component(Popup, "Popup").$$render($$result, { offset: [0, -10] }, {}, {
                      default: () => {
                        return `<div class="text-lg font-bold text-black">${escape(lngLat)}</div>`;
                      }
                    })}`;
                  }
                }
              )}`;
            }
          }
        )}`;
      } while (!$$settled);
      $$unsubscribe_mode();
      return $$rendered;
    });
    Page6 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let lngLat = [110.44302165, -7.0597536];
      let $$settled;
      let $$rendered;
      let previous_head = $$result.head;
      do {
        $$settled = true;
        $$result.head = previous_head;
        $$rendered = `<div class="mb-4 flex items-center"><h1 class="text-xl font-semibold" data-svelte-h="svelte-wfgxf5">Lokasi</h1> ${validate_component(Mode_toggle, "ModeToggle").$$render($$result, {}, {}, {})}</div> ${validate_component(SearchLocation, "SearchLocation").$$render(
          $$result,
          {
            class: "relative mb-4 w-full lg:max-w-[50%] overflow-visible",
            lngLat
          },
          {
            lngLat: ($$value) => {
              lngLat = $$value;
              $$settled = false;
            }
          },
          {}
        )} <div class="flex max-h-[720px] w-full gap-4">  ${validate_component(Map$1, "Map").$$render(
          $$result,
          {
            class: "min-h-[480px] w-full rounded-lg border shadow-md",
            lngLat
          },
          {
            lngLat: ($$value) => {
              lngLat = $$value;
              $$settled = false;
            }
          },
          {}
        )}</div>`;
      } while (!$$settled);
      return $$rendered;
    });
  }
});
var __exports10 = {};
__export(__exports10, {
  component: () => component10,
  fonts: () => fonts10,
  imports: () => imports10,
  index: () => index10,
  stylesheets: () => stylesheets10
});
var index10;
var component_cache10;
var component10;
var imports10;
var stylesheets10;
var fonts10;
var init__10 = __esm({
  ".svelte-kit/output/server/nodes/9.js"() {
    index10 = 9;
    component10 = async () => component_cache10 ??= (await Promise.resolve().then(() => (init_page_svelte6(), page_svelte_exports6))).default;
    imports10 = ["_app/immutable/nodes/9.DRHX016P.js", "_app/immutable/chunks/scheduler.Cglc-E-6.js", "_app/immutable/chunks/index.9iPnfnGV.js", "_app/immutable/chunks/mode-toggle.Cs9G0DsI.js", "_app/immutable/chunks/mode.BQ9atwLW.js", "_app/immutable/chunks/index.C4PciY-_.js", "_app/immutable/chunks/index.BALLBs5G.js", "_app/immutable/chunks/each.Dtgx6mEA.js", "_app/immutable/chunks/command-input.CeEokZ8F.js", "_app/immutable/chunks/MagnifyingGlass.1BoxrdsM.js", "_app/immutable/chunks/_commonjsHelpers.Cpj98o6Y.js"];
    stylesheets10 = ["_app/immutable/assets/9.aorRUjmI.css"];
    fonts10 = [];
  }
});
var page_svelte_exports7 = {};
__export(page_svelte_exports7, {
  default: () => Page7
});
var Page7;
var init_page_svelte7 = __esm({
  ".svelte-kit/output/server/entries/pages/(dashboard)/_project_/progress/_page.svelte.js"() {
    init_ssr();
    init_mode_toggle();
    Page7 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `<div class="mb-4 flex items-center"><h1 class="text-xl font-semibold" data-svelte-h="svelte-im0b83">Progress</h1> ${validate_component(Mode_toggle, "ModeToggle").$$render($$result, {}, {}, {})}</div>`;
    });
  }
});
var __exports11 = {};
__export(__exports11, {
  component: () => component11,
  fonts: () => fonts11,
  imports: () => imports11,
  index: () => index11,
  stylesheets: () => stylesheets11
});
var index11;
var component_cache11;
var component11;
var imports11;
var stylesheets11;
var fonts11;
var init__11 = __esm({
  ".svelte-kit/output/server/nodes/10.js"() {
    index11 = 10;
    component11 = async () => component_cache11 ??= (await Promise.resolve().then(() => (init_page_svelte7(), page_svelte_exports7))).default;
    imports11 = ["_app/immutable/nodes/10.CRvePVVZ.js", "_app/immutable/chunks/scheduler.Cglc-E-6.js", "_app/immutable/chunks/index.9iPnfnGV.js", "_app/immutable/chunks/mode-toggle.Cs9G0DsI.js", "_app/immutable/chunks/mode.BQ9atwLW.js", "_app/immutable/chunks/index.C4PciY-_.js", "_app/immutable/chunks/index.BALLBs5G.js"];
    stylesheets11 = [];
    fonts11 = [];
  }
});
var page_svelte_exports8 = {};
__export(page_svelte_exports8, {
  default: () => Page8
});
var Page8;
var init_page_svelte8 = __esm({
  ".svelte-kit/output/server/entries/pages/(dashboard)/_project_/realisasi-biaya/_page.svelte.js"() {
    init_ssr();
    init_mode_toggle();
    Page8 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `<div class="mb-4 flex items-center"><h1 class="text-xl font-semibold" data-svelte-h="svelte-1i14zz1">Realisasi Biaya</h1> ${validate_component(Mode_toggle, "ModeToggle").$$render($$result, {}, {}, {})}</div>`;
    });
  }
});
var __exports12 = {};
__export(__exports12, {
  component: () => component12,
  fonts: () => fonts12,
  imports: () => imports12,
  index: () => index12,
  stylesheets: () => stylesheets12
});
var index12;
var component_cache12;
var component12;
var imports12;
var stylesheets12;
var fonts12;
var init__12 = __esm({
  ".svelte-kit/output/server/nodes/11.js"() {
    index12 = 11;
    component12 = async () => component_cache12 ??= (await Promise.resolve().then(() => (init_page_svelte8(), page_svelte_exports8))).default;
    imports12 = ["_app/immutable/nodes/11.Dn-De8Y9.js", "_app/immutable/chunks/scheduler.Cglc-E-6.js", "_app/immutable/chunks/index.9iPnfnGV.js", "_app/immutable/chunks/mode-toggle.Cs9G0DsI.js", "_app/immutable/chunks/mode.BQ9atwLW.js", "_app/immutable/chunks/index.C4PciY-_.js", "_app/immutable/chunks/index.BALLBs5G.js"];
    stylesheets12 = [];
    fonts12 = [];
  }
});
var page_svelte_exports9 = {};
__export(page_svelte_exports9, {
  default: () => Page9
});
function createMenuBuilder(opts) {
  const { name: name5, selector } = createElHelpers(opts.selector);
  const { preventScroll, arrowSize, positioning, closeOnEscape, closeOnOutsideClick, portal, forceVisible, typeahead, loop, closeFocus, disableFocusFirstItem, closeOnItemClick, onOutsideClick } = opts.rootOptions;
  const rootOpen = opts.rootOpen;
  const rootActiveTrigger = opts.rootActiveTrigger;
  const nextFocusable = opts.nextFocusable;
  const prevFocusable = opts.prevFocusable;
  const isUsingKeyboard = withGet.writable(false);
  const lastPointerX = withGet(writable(0));
  const pointerGraceIntent = withGet(writable(null));
  const pointerDir = withGet(writable("right"));
  const currentFocusedItem = withGet(writable(null));
  const pointerMovingToSubmenu = withGet(derived([pointerDir, pointerGraceIntent], ([$pointerDir, $pointerGraceIntent]) => {
    return (e3) => {
      const isMovingTowards = $pointerDir === $pointerGraceIntent?.side;
      return isMovingTowards && isPointerInGraceArea(e3, $pointerGraceIntent?.area);
    };
  }));
  const { typed, handleTypeaheadSearch } = createTypeaheadSearch();
  const rootIds = toWritableStores({ ...generateIds(menuIdParts), ...opts.ids });
  const isVisible = derivedVisible({
    open: rootOpen,
    forceVisible,
    activeTrigger: rootActiveTrigger
  });
  const rootMenu = makeElement(name5(), {
    stores: [isVisible, portal, rootIds.menu, rootIds.trigger],
    returned: ([$isVisible, $portal, $rootMenuId, $rootTriggerId]) => {
      return {
        role: "menu",
        hidden: $isVisible ? void 0 : true,
        style: styleToString({
          display: $isVisible ? void 0 : "none"
        }),
        id: $rootMenuId,
        "aria-labelledby": $rootTriggerId,
        "data-state": $isVisible ? "open" : "closed",
        "data-portal": portalAttr($portal),
        tabindex: -1
      };
    },
    action: (node) => {
      let unsubPopper = noop2;
      const unsubDerived = effect([isVisible, rootActiveTrigger, positioning, closeOnOutsideClick, portal, closeOnEscape], ([$isVisible, $rootActiveTrigger, $positioning, $closeOnOutsideClick, $portal, $closeOnEscape]) => {
        unsubPopper();
        if (!$isVisible || !$rootActiveTrigger)
          return;
        tick().then(() => {
          setMeltMenuAttribute(node, selector);
          const popper = usePopper(node, {
            anchorElement: $rootActiveTrigger,
            open: rootOpen,
            options: {
              floating: $positioning,
              modal: {
                closeOnInteractOutside: $closeOnOutsideClick,
                shouldCloseOnInteractOutside: (e3) => {
                  onOutsideClick.get()?.(e3);
                  if (e3.defaultPrevented)
                    return false;
                  if (isHTMLElement($rootActiveTrigger) && $rootActiveTrigger.contains(e3.target)) {
                    return false;
                  }
                  return true;
                },
                onClose: () => {
                  rootOpen.set(false);
                  $rootActiveTrigger.focus();
                },
                open: $isVisible
              },
              portal: getPortalDestination(node, $portal),
              escapeKeydown: $closeOnEscape ? void 0 : null
            }
          });
          if (popper && popper.destroy) {
            unsubPopper = popper.destroy;
          }
        });
      });
      const unsubEvents = executeCallbacks(addMeltEventListener(node, "keydown", (e3) => {
        const target = e3.target;
        const menuEl = e3.currentTarget;
        if (!isHTMLElement(target) || !isHTMLElement(menuEl))
          return;
        const isKeyDownInside = target.closest('[role="menu"]') === menuEl;
        if (!isKeyDownInside)
          return;
        if (FIRST_LAST_KEYS.includes(e3.key)) {
          handleMenuNavigation(e3, loop.get() ?? false);
        }
        if (e3.key === kbd.TAB) {
          e3.preventDefault();
          rootOpen.set(false);
          handleTabNavigation(e3, nextFocusable, prevFocusable);
          return;
        }
        const isCharacterKey = e3.key.length === 1;
        const isModifierKey = e3.ctrlKey || e3.altKey || e3.metaKey;
        if (!isModifierKey && isCharacterKey && typeahead.get() === true) {
          handleTypeaheadSearch(e3.key, getMenuItems(menuEl));
        }
      }));
      return {
        destroy() {
          unsubDerived();
          unsubEvents();
          unsubPopper();
        }
      };
    }
  });
  const rootTrigger = makeElement(name5("trigger"), {
    stores: [rootOpen, rootIds.menu, rootIds.trigger],
    returned: ([$rootOpen, $rootMenuId, $rootTriggerId]) => {
      return {
        "aria-controls": $rootMenuId,
        "aria-expanded": $rootOpen,
        "data-state": $rootOpen ? "open" : "closed",
        id: $rootTriggerId,
        tabindex: 0
      };
    },
    action: (node) => {
      applyAttrsIfDisabled(node);
      rootActiveTrigger.update((p3) => {
        if (p3)
          return p3;
        return node;
      });
      const unsub = executeCallbacks(addMeltEventListener(node, "click", (e3) => {
        const $rootOpen = rootOpen.get();
        const triggerEl = e3.currentTarget;
        if (!isHTMLElement(triggerEl))
          return;
        handleOpen(triggerEl);
        if (!$rootOpen)
          e3.preventDefault();
      }), addMeltEventListener(node, "keydown", (e3) => {
        const triggerEl = e3.currentTarget;
        if (!isHTMLElement(triggerEl))
          return;
        if (!(SELECTION_KEYS.includes(e3.key) || e3.key === kbd.ARROW_DOWN))
          return;
        e3.preventDefault();
        handleOpen(triggerEl);
        const menuId = triggerEl.getAttribute("aria-controls");
        if (!menuId)
          return;
        const menu = document.getElementById(menuId);
        if (!menu)
          return;
        const menuItems = getMenuItems(menu);
        if (!menuItems.length)
          return;
        handleRovingFocus(menuItems[0]);
      }));
      return {
        destroy: unsub
      };
    }
  });
  const rootArrow = makeElement(name5("arrow"), {
    stores: arrowSize,
    returned: ($arrowSize) => ({
      "data-arrow": true,
      style: styleToString({
        position: "absolute",
        width: `var(--arrow-size, ${$arrowSize}px)`,
        height: `var(--arrow-size, ${$arrowSize}px)`
      })
    })
  });
  const overlay = makeElement(name5("overlay"), {
    stores: [isVisible],
    returned: ([$isVisible]) => {
      return {
        hidden: $isVisible ? void 0 : true,
        tabindex: -1,
        style: styleToString({
          display: $isVisible ? void 0 : "none"
        }),
        "aria-hidden": "true",
        "data-state": stateAttr2($isVisible)
      };
    },
    action: (node) => {
      let unsubEscapeKeydown = noop2;
      if (closeOnEscape.get()) {
        const escapeKeydown = useEscapeKeydown(node, {
          handler: () => {
            rootOpen.set(false);
            const $rootActiveTrigger = rootActiveTrigger.get();
            if ($rootActiveTrigger)
              $rootActiveTrigger.focus();
          }
        });
        if (escapeKeydown && escapeKeydown.destroy) {
          unsubEscapeKeydown = escapeKeydown.destroy;
        }
      }
      const unsubPortal = effect([portal], ([$portal]) => {
        if ($portal === null)
          return noop2;
        const portalDestination = getPortalDestination(node, $portal);
        if (portalDestination === null)
          return noop2;
        const portalAction = usePortal(node, portalDestination);
        if (portalAction && portalAction.destroy) {
          return portalAction.destroy;
        } else {
          return noop2;
        }
      });
      return {
        destroy() {
          unsubEscapeKeydown();
          unsubPortal();
        }
      };
    }
  });
  const item = makeElement(name5("item"), {
    returned: () => {
      return {
        role: "menuitem",
        tabindex: -1,
        "data-orientation": "vertical"
      };
    },
    action: (node) => {
      setMeltMenuAttribute(node, selector);
      applyAttrsIfDisabled(node);
      const unsub = executeCallbacks(addMeltEventListener(node, "pointerdown", (e3) => {
        const itemEl = e3.currentTarget;
        if (!isHTMLElement(itemEl))
          return;
        if (isElementDisabled(itemEl)) {
          e3.preventDefault();
          return;
        }
      }), addMeltEventListener(node, "click", (e3) => {
        const itemEl = e3.currentTarget;
        if (!isHTMLElement(itemEl))
          return;
        if (isElementDisabled(itemEl)) {
          e3.preventDefault();
          return;
        }
        if (e3.defaultPrevented) {
          handleRovingFocus(itemEl);
          return;
        }
        if (closeOnItemClick.get()) {
          sleep(1).then(() => {
            rootOpen.set(false);
          });
        }
      }), addMeltEventListener(node, "keydown", (e3) => {
        onItemKeyDown(e3);
      }), addMeltEventListener(node, "pointermove", (e3) => {
        onMenuItemPointerMove(e3);
      }), addMeltEventListener(node, "pointerleave", (e3) => {
        onMenuItemPointerLeave(e3);
      }), addMeltEventListener(node, "focusin", (e3) => {
        onItemFocusIn(e3);
      }), addMeltEventListener(node, "focusout", (e3) => {
        onItemFocusOut(e3);
      }));
      return {
        destroy: unsub
      };
    }
  });
  const group = makeElement(name5("group"), {
    returned: () => {
      return (groupId) => ({
        role: "group",
        "aria-labelledby": groupId
      });
    }
  });
  const groupLabel = makeElement(name5("group-label"), {
    returned: () => {
      return (groupId) => ({
        id: groupId
      });
    }
  });
  const checkboxItemDefaults = {
    defaultChecked: false,
    disabled: false
  };
  const createCheckboxItem = (props) => {
    const withDefaults = { ...checkboxItemDefaults, ...props };
    const checkedWritable = withDefaults.checked ?? writable(withDefaults.defaultChecked ?? null);
    const checked = overridable(checkedWritable, withDefaults.onCheckedChange);
    const disabled = writable(withDefaults.disabled);
    const checkboxItem = makeElement(name5("checkbox-item"), {
      stores: [checked, disabled],
      returned: ([$checked, $disabled]) => {
        return {
          role: "menuitemcheckbox",
          tabindex: -1,
          "data-orientation": "vertical",
          "aria-checked": isIndeterminate($checked) ? "mixed" : $checked ? "true" : "false",
          "data-disabled": disabledAttr($disabled),
          "data-state": getCheckedState($checked)
        };
      },
      action: (node) => {
        setMeltMenuAttribute(node, selector);
        applyAttrsIfDisabled(node);
        const unsub = executeCallbacks(addMeltEventListener(node, "pointerdown", (e3) => {
          const itemEl = e3.currentTarget;
          if (!isHTMLElement(itemEl))
            return;
          if (isElementDisabled(itemEl)) {
            e3.preventDefault();
            return;
          }
        }), addMeltEventListener(node, "click", (e3) => {
          const itemEl = e3.currentTarget;
          if (!isHTMLElement(itemEl))
            return;
          if (isElementDisabled(itemEl)) {
            e3.preventDefault();
            return;
          }
          if (e3.defaultPrevented) {
            handleRovingFocus(itemEl);
            return;
          }
          checked.update((prev2) => {
            if (isIndeterminate(prev2))
              return true;
            return !prev2;
          });
          if (closeOnItemClick.get()) {
            tick().then(() => {
              rootOpen.set(false);
            });
          }
        }), addMeltEventListener(node, "keydown", (e3) => {
          onItemKeyDown(e3);
        }), addMeltEventListener(node, "pointermove", (e3) => {
          const itemEl = e3.currentTarget;
          if (!isHTMLElement(itemEl))
            return;
          if (isElementDisabled(itemEl)) {
            onItemLeave(e3);
            return;
          }
          onMenuItemPointerMove(e3, itemEl);
        }), addMeltEventListener(node, "pointerleave", (e3) => {
          onMenuItemPointerLeave(e3);
        }), addMeltEventListener(node, "focusin", (e3) => {
          onItemFocusIn(e3);
        }), addMeltEventListener(node, "focusout", (e3) => {
          onItemFocusOut(e3);
        }));
        return {
          destroy: unsub
        };
      }
    });
    const isChecked = derived(checked, ($checked) => $checked === true);
    const _isIndeterminate = derived(checked, ($checked) => $checked === "indeterminate");
    return {
      elements: {
        checkboxItem
      },
      states: {
        checked
      },
      helpers: {
        isChecked,
        isIndeterminate: _isIndeterminate
      },
      options: {
        disabled
      }
    };
  };
  const createMenuRadioGroup = (args = {}) => {
    const valueWritable = args.value ?? writable(args.defaultValue ?? null);
    const value = overridable(valueWritable, args.onValueChange);
    const radioGroup = makeElement(name5("radio-group"), {
      returned: () => ({
        role: "group"
      })
    });
    const radioItemDefaults = {
      disabled: false
    };
    const radioItem = makeElement(name5("radio-item"), {
      stores: [value],
      returned: ([$value]) => {
        return (itemProps) => {
          const { value: itemValue, disabled } = { ...radioItemDefaults, ...itemProps };
          const checked = $value === itemValue;
          return {
            disabled,
            role: "menuitemradio",
            "data-state": checked ? "checked" : "unchecked",
            "aria-checked": checked,
            "data-disabled": disabledAttr(disabled),
            "data-value": itemValue,
            "data-orientation": "vertical",
            tabindex: -1
          };
        };
      },
      action: (node) => {
        setMeltMenuAttribute(node, selector);
        const unsub = executeCallbacks(addMeltEventListener(node, "pointerdown", (e3) => {
          const itemEl = e3.currentTarget;
          if (!isHTMLElement(itemEl))
            return;
          const itemValue = node.dataset.value;
          const disabled = node.dataset.disabled;
          if (disabled || itemValue === void 0) {
            e3.preventDefault();
            return;
          }
        }), addMeltEventListener(node, "click", (e3) => {
          const itemEl = e3.currentTarget;
          if (!isHTMLElement(itemEl))
            return;
          const itemValue = node.dataset.value;
          const disabled = node.dataset.disabled;
          if (disabled || itemValue === void 0) {
            e3.preventDefault();
            return;
          }
          if (e3.defaultPrevented) {
            if (!isHTMLElement(itemEl))
              return;
            handleRovingFocus(itemEl);
            return;
          }
          value.set(itemValue);
          if (closeOnItemClick.get()) {
            tick().then(() => {
              rootOpen.set(false);
            });
          }
        }), addMeltEventListener(node, "keydown", (e3) => {
          onItemKeyDown(e3);
        }), addMeltEventListener(node, "pointermove", (e3) => {
          const itemEl = e3.currentTarget;
          if (!isHTMLElement(itemEl))
            return;
          const itemValue = node.dataset.value;
          const disabled = node.dataset.disabled;
          if (disabled || itemValue === void 0) {
            onItemLeave(e3);
            return;
          }
          onMenuItemPointerMove(e3, itemEl);
        }), addMeltEventListener(node, "pointerleave", (e3) => {
          onMenuItemPointerLeave(e3);
        }), addMeltEventListener(node, "focusin", (e3) => {
          onItemFocusIn(e3);
        }), addMeltEventListener(node, "focusout", (e3) => {
          onItemFocusOut(e3);
        }));
        return {
          destroy: unsub
        };
      }
    });
    const isChecked = derived(value, ($value) => {
      return (itemValue) => {
        return $value === itemValue;
      };
    });
    return {
      elements: {
        radioGroup,
        radioItem
      },
      states: {
        value
      },
      helpers: {
        isChecked
      }
    };
  };
  const { elements: { root: separator } } = createSeparator({
    orientation: "horizontal"
  });
  const subMenuDefaults = {
    ...defaults$12,
    disabled: false,
    positioning: {
      placement: "right-start",
      gutter: 8
    }
  };
  const createSubmenu = (args) => {
    const withDefaults = { ...subMenuDefaults, ...args };
    const subOpenWritable = withDefaults.open ?? writable(false);
    const subOpen = overridable(subOpenWritable, withDefaults?.onOpenChange);
    const options2 = toWritableStores(omit(withDefaults, "ids"));
    const { positioning: positioning2, arrowSize: arrowSize2, disabled } = options2;
    const subActiveTrigger = withGet(writable(null));
    const subOpenTimer = withGet(writable(null));
    const pointerGraceTimer = withGet(writable(0));
    const subIds = toWritableStores({ ...generateIds(menuIdParts), ...withDefaults.ids });
    safeOnMount(() => {
      const subTrigger2 = document.getElementById(subIds.trigger.get());
      if (subTrigger2) {
        subActiveTrigger.set(subTrigger2);
      }
    });
    const subIsVisible = derivedVisible({
      open: subOpen,
      forceVisible,
      activeTrigger: subActiveTrigger
    });
    const subMenu = makeElement(name5("submenu"), {
      stores: [subIsVisible, subIds.menu, subIds.trigger],
      returned: ([$subIsVisible, $subMenuId, $subTriggerId]) => {
        return {
          role: "menu",
          hidden: $subIsVisible ? void 0 : true,
          style: styleToString({
            display: $subIsVisible ? void 0 : "none"
          }),
          id: $subMenuId,
          "aria-labelledby": $subTriggerId,
          "data-state": $subIsVisible ? "open" : "closed",
          // unit tests fail on `.closest` if the id starts with a number
          // so using a data attribute
          "data-id": $subMenuId,
          tabindex: -1
        };
      },
      action: (node) => {
        let unsubPopper = noop2;
        const unsubDerived = effect([subIsVisible, positioning2], ([$subIsVisible, $positioning]) => {
          unsubPopper();
          if (!$subIsVisible)
            return;
          const activeTrigger = subActiveTrigger.get();
          if (!activeTrigger)
            return;
          tick().then(() => {
            const parentMenuEl = getParentMenu(activeTrigger);
            const popper = usePopper(node, {
              anchorElement: activeTrigger,
              open: subOpen,
              options: {
                floating: $positioning,
                portal: isHTMLElement(parentMenuEl) ? parentMenuEl : void 0,
                modal: null,
                focusTrap: null,
                escapeKeydown: null
              }
            });
            if (popper && popper.destroy) {
              unsubPopper = popper.destroy;
            }
          });
        });
        const unsubEvents = executeCallbacks(addMeltEventListener(node, "keydown", (e3) => {
          if (e3.key === kbd.ESCAPE) {
            return;
          }
          const target = e3.target;
          const menuEl = e3.currentTarget;
          if (!isHTMLElement(target) || !isHTMLElement(menuEl))
            return;
          const isKeyDownInside = target.closest('[role="menu"]') === menuEl;
          if (!isKeyDownInside)
            return;
          if (FIRST_LAST_KEYS.includes(e3.key)) {
            e3.stopImmediatePropagation();
            handleMenuNavigation(e3, loop.get() ?? false);
            return;
          }
          const isCloseKey = SUB_CLOSE_KEYS["ltr"].includes(e3.key);
          const isModifierKey = e3.ctrlKey || e3.altKey || e3.metaKey;
          const isCharacterKey = e3.key.length === 1;
          if (isCloseKey) {
            const $subActiveTrigger = subActiveTrigger.get();
            e3.preventDefault();
            subOpen.update(() => {
              if ($subActiveTrigger) {
                handleRovingFocus($subActiveTrigger);
              }
              return false;
            });
            return;
          }
          if (e3.key === kbd.TAB) {
            e3.preventDefault();
            rootOpen.set(false);
            handleTabNavigation(e3, nextFocusable, prevFocusable);
            return;
          }
          if (!isModifierKey && isCharacterKey && typeahead.get() === true) {
            handleTypeaheadSearch(e3.key, getMenuItems(menuEl));
          }
        }), addMeltEventListener(node, "pointermove", (e3) => {
          onMenuPointerMove(e3);
        }), addMeltEventListener(node, "focusout", (e3) => {
          const $subActiveTrigger = subActiveTrigger.get();
          if (isUsingKeyboard.get()) {
            const target = e3.target;
            const submenuEl = document.getElementById(subIds.menu.get());
            if (!isHTMLElement(submenuEl) || !isHTMLElement(target))
              return;
            if (!submenuEl.contains(target) && target !== $subActiveTrigger) {
              subOpen.set(false);
            }
          } else {
            const menuEl = e3.currentTarget;
            const relatedTarget = e3.relatedTarget;
            if (!isHTMLElement(relatedTarget) || !isHTMLElement(menuEl))
              return;
            if (!menuEl.contains(relatedTarget) && relatedTarget !== $subActiveTrigger) {
              subOpen.set(false);
            }
          }
        }));
        return {
          destroy() {
            unsubDerived();
            unsubPopper();
            unsubEvents();
          }
        };
      }
    });
    const subTrigger = makeElement(name5("subtrigger"), {
      stores: [subOpen, disabled, subIds.menu, subIds.trigger],
      returned: ([$subOpen, $disabled, $subMenuId, $subTriggerId]) => {
        return {
          role: "menuitem",
          id: $subTriggerId,
          tabindex: -1,
          "aria-controls": $subMenuId,
          "aria-expanded": $subOpen,
          "data-state": $subOpen ? "open" : "closed",
          "data-disabled": disabledAttr($disabled),
          "aria-haspopop": "menu"
        };
      },
      action: (node) => {
        setMeltMenuAttribute(node, selector);
        applyAttrsIfDisabled(node);
        subActiveTrigger.update((p3) => {
          if (p3)
            return p3;
          return node;
        });
        const unsubTimer = () => {
          clearTimerStore(subOpenTimer);
          window.clearTimeout(pointerGraceTimer.get());
          pointerGraceIntent.set(null);
        };
        const unsubEvents = executeCallbacks(addMeltEventListener(node, "click", (e3) => {
          if (e3.defaultPrevented)
            return;
          const triggerEl = e3.currentTarget;
          if (!isHTMLElement(triggerEl) || isElementDisabled(triggerEl))
            return;
          handleRovingFocus(triggerEl);
          if (!subOpen.get()) {
            subOpen.update((prev2) => {
              const isAlreadyOpen = prev2;
              if (!isAlreadyOpen) {
                subActiveTrigger.set(triggerEl);
                return !prev2;
              }
              return prev2;
            });
          }
        }), addMeltEventListener(node, "keydown", (e3) => {
          const $typed = typed.get();
          const triggerEl = e3.currentTarget;
          if (!isHTMLElement(triggerEl) || isElementDisabled(triggerEl))
            return;
          const isTypingAhead = $typed.length > 0;
          if (isTypingAhead && e3.key === kbd.SPACE)
            return;
          if (SUB_OPEN_KEYS["ltr"].includes(e3.key)) {
            if (!subOpen.get()) {
              triggerEl.click();
              e3.preventDefault();
              return;
            }
            const menuId = triggerEl.getAttribute("aria-controls");
            if (!menuId)
              return;
            const menuEl = document.getElementById(menuId);
            if (!isHTMLElement(menuEl))
              return;
            const firstItem = getMenuItems(menuEl)[0];
            handleRovingFocus(firstItem);
          }
        }), addMeltEventListener(node, "pointermove", (e3) => {
          if (!isMouse(e3))
            return;
          onItemEnter(e3);
          if (e3.defaultPrevented)
            return;
          const triggerEl = e3.currentTarget;
          if (!isHTMLElement(triggerEl))
            return;
          if (!isFocusWithinSubmenu(subIds.menu.get())) {
            handleRovingFocus(triggerEl);
          }
          const openTimer = subOpenTimer.get();
          if (!subOpen.get() && !openTimer && !isElementDisabled(triggerEl)) {
            subOpenTimer.set(window.setTimeout(() => {
              subOpen.update(() => {
                subActiveTrigger.set(triggerEl);
                return true;
              });
              clearTimerStore(subOpenTimer);
            }, 100));
          }
        }), addMeltEventListener(node, "pointerleave", (e3) => {
          if (!isMouse(e3))
            return;
          clearTimerStore(subOpenTimer);
          const submenuEl = document.getElementById(subIds.menu.get());
          const contentRect = submenuEl?.getBoundingClientRect();
          if (contentRect) {
            const side = submenuEl?.dataset.side;
            const rightSide = side === "right";
            const bleed = rightSide ? -5 : 5;
            const contentNearEdge = contentRect[rightSide ? "left" : "right"];
            const contentFarEdge = contentRect[rightSide ? "right" : "left"];
            pointerGraceIntent.set({
              area: [
                // Apply a bleed on clientX to ensure that our exit point is
                // consistently within polygon bounds
                { x: e3.clientX + bleed, y: e3.clientY },
                { x: contentNearEdge, y: contentRect.top },
                { x: contentFarEdge, y: contentRect.top },
                { x: contentFarEdge, y: contentRect.bottom },
                { x: contentNearEdge, y: contentRect.bottom }
              ],
              side
            });
            window.clearTimeout(pointerGraceTimer.get());
            pointerGraceTimer.set(window.setTimeout(() => {
              pointerGraceIntent.set(null);
            }, 300));
          } else {
            onTriggerLeave(e3);
            if (e3.defaultPrevented)
              return;
            pointerGraceIntent.set(null);
          }
        }), addMeltEventListener(node, "focusout", (e3) => {
          const triggerEl = e3.currentTarget;
          if (!isHTMLElement(triggerEl))
            return;
          removeHighlight(triggerEl);
          const relatedTarget = e3.relatedTarget;
          if (!isHTMLElement(relatedTarget))
            return;
          const menuId = triggerEl.getAttribute("aria-controls");
          if (!menuId)
            return;
          const menu = document.getElementById(menuId);
          if (menu && !menu.contains(relatedTarget)) {
            subOpen.set(false);
          }
        }), addMeltEventListener(node, "focusin", (e3) => {
          onItemFocusIn(e3);
        }));
        return {
          destroy() {
            unsubTimer();
            unsubEvents();
          }
        };
      }
    });
    const subArrow = makeElement(name5("subarrow"), {
      stores: arrowSize2,
      returned: ($arrowSize) => ({
        "data-arrow": true,
        style: styleToString({
          position: "absolute",
          width: `var(--arrow-size, ${$arrowSize}px)`,
          height: `var(--arrow-size, ${$arrowSize}px)`
        })
      })
    });
    effect([rootOpen], ([$rootOpen]) => {
      if (!$rootOpen) {
        subActiveTrigger.set(null);
        subOpen.set(false);
      }
    });
    effect([pointerGraceIntent], ([$pointerGraceIntent]) => {
      if (!isBrowser2 || $pointerGraceIntent)
        return;
      window.clearTimeout(pointerGraceTimer.get());
    });
    effect([subOpen], ([$subOpen]) => {
      if (!isBrowser2)
        return;
      if ($subOpen && isUsingKeyboard.get()) {
        sleep(1).then(() => {
          const menuEl = document.getElementById(subIds.menu.get());
          if (!menuEl)
            return;
          const menuItems = getMenuItems(menuEl);
          if (!menuItems.length)
            return;
          handleRovingFocus(menuItems[0]);
        });
      }
      if (!$subOpen) {
        const focusedItem = currentFocusedItem.get();
        const subTriggerEl = document.getElementById(subIds.trigger.get());
        if (focusedItem) {
          sleep(1).then(() => {
            const menuEl = document.getElementById(subIds.menu.get());
            if (!menuEl)
              return;
            if (menuEl.contains(focusedItem)) {
              removeHighlight(focusedItem);
            }
          });
        }
        if (!subTriggerEl || document.activeElement === subTriggerEl)
          return;
        removeHighlight(subTriggerEl);
      }
    });
    return {
      ids: subIds,
      elements: {
        subTrigger,
        subMenu,
        subArrow
      },
      states: {
        subOpen
      },
      options: options2
    };
  };
  safeOnMount(() => {
    const triggerEl = document.getElementById(rootIds.trigger.get());
    if (isHTMLElement(triggerEl) && rootOpen.get()) {
      rootActiveTrigger.set(triggerEl);
    }
    const unsubs = [];
    const handlePointer = () => isUsingKeyboard.set(false);
    const handleKeyDown = () => {
      isUsingKeyboard.set(true);
      unsubs.push(executeCallbacks(addEventListener2(document, "pointerdown", handlePointer, { capture: true, once: true }), addEventListener2(document, "pointermove", handlePointer, { capture: true, once: true })));
    };
    const keydownListener = (e3) => {
      if (e3.key === kbd.ESCAPE && closeOnEscape.get()) {
        rootOpen.set(false);
        return;
      }
    };
    unsubs.push(addEventListener2(document, "keydown", handleKeyDown, { capture: true }));
    unsubs.push(addEventListener2(document, "keydown", keydownListener));
    return () => {
      unsubs.forEach((unsub) => unsub());
    };
  });
  effect([rootOpen, currentFocusedItem], ([$rootOpen, $currentFocusedItem]) => {
    if (!$rootOpen && $currentFocusedItem) {
      removeHighlight($currentFocusedItem);
    }
  });
  effect([rootOpen], ([$rootOpen]) => {
    if (!isBrowser2)
      return;
    if (!$rootOpen) {
      const $rootActiveTrigger = rootActiveTrigger.get();
      if (!$rootActiveTrigger)
        return;
      const $closeFocus = closeFocus.get();
      if (!$rootOpen && $rootActiveTrigger) {
        handleFocus({ prop: $closeFocus, defaultEl: $rootActiveTrigger });
      }
    }
  });
  effect([rootOpen, preventScroll], ([$rootOpen, $preventScroll]) => {
    if (!isBrowser2)
      return;
    const unsubs = [];
    if (opts.removeScroll && $rootOpen && $preventScroll) {
      unsubs.push(removeScroll());
    }
    sleep(1).then(() => {
      const menuEl = document.getElementById(rootIds.menu.get());
      if (menuEl && $rootOpen && isUsingKeyboard.get()) {
        if (disableFocusFirstItem.get()) {
          handleRovingFocus(menuEl);
          return;
        }
        const menuItems = getMenuItems(menuEl);
        if (!menuItems.length)
          return;
        handleRovingFocus(menuItems[0]);
      }
    });
    return () => {
      unsubs.forEach((unsub) => unsub());
    };
  });
  effect(rootOpen, ($rootOpen) => {
    if (!isBrowser2)
      return;
    const handlePointer = () => isUsingKeyboard.set(false);
    const handleKeyDown = (e3) => {
      isUsingKeyboard.set(true);
      if (e3.key === kbd.ESCAPE && $rootOpen && closeOnEscape.get()) {
        rootOpen.set(false);
        return;
      }
    };
    return executeCallbacks(addEventListener2(document, "pointerdown", handlePointer, { capture: true, once: true }), addEventListener2(document, "pointermove", handlePointer, { capture: true, once: true }), addEventListener2(document, "keydown", handleKeyDown, { capture: true }));
  });
  function handleOpen(triggerEl) {
    rootOpen.update((prev2) => {
      const isOpen = !prev2;
      if (isOpen) {
        nextFocusable.set(getNextFocusable(triggerEl));
        prevFocusable.set(getPreviousFocusable(triggerEl));
        rootActiveTrigger.set(triggerEl);
      }
      return isOpen;
    });
  }
  function onItemFocusIn(e3) {
    const itemEl = e3.currentTarget;
    if (!isHTMLElement(itemEl))
      return;
    const $currentFocusedItem = currentFocusedItem.get();
    if ($currentFocusedItem) {
      removeHighlight($currentFocusedItem);
    }
    addHighlight(itemEl);
    currentFocusedItem.set(itemEl);
  }
  function onItemFocusOut(e3) {
    const itemEl = e3.currentTarget;
    if (!isHTMLElement(itemEl))
      return;
    removeHighlight(itemEl);
  }
  function onItemEnter(e3) {
    if (isPointerMovingToSubmenu(e3)) {
      e3.preventDefault();
    }
  }
  function onItemLeave(e3) {
    if (isPointerMovingToSubmenu(e3)) {
      return;
    }
    const target = e3.target;
    if (!isHTMLElement(target))
      return;
    const parentMenuEl = getParentMenu(target);
    if (!parentMenuEl)
      return;
    handleRovingFocus(parentMenuEl);
  }
  function onTriggerLeave(e3) {
    if (isPointerMovingToSubmenu(e3)) {
      e3.preventDefault();
    }
  }
  function onMenuPointerMove(e3) {
    if (!isMouse(e3))
      return;
    const target = e3.target;
    const currentTarget = e3.currentTarget;
    if (!isHTMLElement(currentTarget) || !isHTMLElement(target))
      return;
    const $lastPointerX = lastPointerX.get();
    const pointerXHasChanged = $lastPointerX !== e3.clientX;
    if (currentTarget.contains(target) && pointerXHasChanged) {
      const newDir = e3.clientX > $lastPointerX ? "right" : "left";
      pointerDir.set(newDir);
      lastPointerX.set(e3.clientX);
    }
  }
  function onMenuItemPointerMove(e3, currTarget = null) {
    if (!isMouse(e3))
      return;
    onItemEnter(e3);
    if (e3.defaultPrevented)
      return;
    if (currTarget) {
      handleRovingFocus(currTarget);
      return;
    }
    const currentTarget = e3.currentTarget;
    if (!isHTMLElement(currentTarget))
      return;
    handleRovingFocus(currentTarget);
  }
  function onMenuItemPointerLeave(e3) {
    if (!isMouse(e3))
      return;
    onItemLeave(e3);
  }
  function onItemKeyDown(e3) {
    const $typed = typed.get();
    const isTypingAhead = $typed.length > 0;
    if (isTypingAhead && e3.key === kbd.SPACE) {
      e3.preventDefault();
      return;
    }
    if (SELECTION_KEYS.includes(e3.key)) {
      e3.preventDefault();
      const itemEl = e3.currentTarget;
      if (!isHTMLElement(itemEl))
        return;
      itemEl.click();
    }
  }
  function isIndeterminate(checked) {
    return checked === "indeterminate";
  }
  function getCheckedState(checked) {
    return isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
  }
  function isPointerMovingToSubmenu(e3) {
    return pointerMovingToSubmenu.get()(e3);
  }
  function getParentMenu(element) {
    const parentMenuEl = element.closest('[role="menu"]');
    if (!isHTMLElement(parentMenuEl))
      return null;
    return parentMenuEl;
  }
  return {
    elements: {
      trigger: rootTrigger,
      menu: rootMenu,
      overlay,
      item,
      group,
      groupLabel,
      arrow: rootArrow,
      separator
    },
    builders: {
      createCheckboxItem,
      createSubmenu,
      createMenuRadioGroup
    },
    states: {
      open: rootOpen
    },
    helpers: {
      handleTypeaheadSearch
    },
    ids: rootIds,
    options: opts.rootOptions
  };
}
function handleTabNavigation(e3, nextFocusable, prevFocusable) {
  if (e3.shiftKey) {
    const $prevFocusable = prevFocusable.get();
    if ($prevFocusable) {
      e3.preventDefault();
      sleep(1).then(() => $prevFocusable.focus());
      prevFocusable.set(null);
    }
  } else {
    const $nextFocusable = nextFocusable.get();
    if ($nextFocusable) {
      e3.preventDefault();
      sleep(1).then(() => $nextFocusable.focus());
      nextFocusable.set(null);
    }
  }
}
function getMenuItems(menuElement) {
  return Array.from(menuElement.querySelectorAll(`[data-melt-menu-id="${menuElement.id}"]`)).filter((item) => isHTMLElement(item));
}
function applyAttrsIfDisabled(element) {
  if (!element || !isElementDisabled(element))
    return;
  element.setAttribute("data-disabled", "");
  element.setAttribute("aria-disabled", "true");
}
function clearTimerStore(timerStore) {
  if (!isBrowser2)
    return;
  const timer = timerStore.get();
  if (timer) {
    window.clearTimeout(timer);
    timerStore.set(null);
  }
}
function isMouse(e3) {
  return e3.pointerType === "mouse";
}
function setMeltMenuAttribute(element, selector) {
  if (!element)
    return;
  const menuEl = element.closest(`${selector()}, ${selector("submenu")}`);
  if (!isHTMLElement(menuEl))
    return;
  element.setAttribute("data-melt-menu-id", menuEl.id);
}
function handleMenuNavigation(e3, loop) {
  e3.preventDefault();
  const currentFocusedItem = document.activeElement;
  const currentTarget = e3.currentTarget;
  if (!isHTMLElement(currentFocusedItem) || !isHTMLElement(currentTarget))
    return;
  const menuItems = getMenuItems(currentTarget);
  if (!menuItems.length)
    return;
  const candidateNodes = menuItems.filter((item) => {
    if (item.hasAttribute("data-disabled") || item.getAttribute("disabled") === "true") {
      return false;
    }
    return true;
  });
  const currentIndex = candidateNodes.indexOf(currentFocusedItem);
  let nextIndex;
  switch (e3.key) {
    case kbd.ARROW_DOWN:
      if (loop) {
        nextIndex = currentIndex < candidateNodes.length - 1 ? currentIndex + 1 : 0;
      } else {
        nextIndex = currentIndex < candidateNodes.length - 1 ? currentIndex + 1 : currentIndex;
      }
      break;
    case kbd.ARROW_UP:
      if (loop) {
        nextIndex = currentIndex > 0 ? currentIndex - 1 : candidateNodes.length - 1;
      } else {
        nextIndex = currentIndex < 0 ? candidateNodes.length - 1 : currentIndex > 0 ? currentIndex - 1 : 0;
      }
      break;
    case kbd.HOME:
      nextIndex = 0;
      break;
    case kbd.END:
      nextIndex = candidateNodes.length - 1;
      break;
    default:
      return;
  }
  handleRovingFocus(candidateNodes[nextIndex]);
}
function isPointerInGraceArea(e3, area) {
  if (!area)
    return false;
  const cursorPos = { x: e3.clientX, y: e3.clientY };
  return isPointInPolygon(cursorPos, area);
}
function isPointInPolygon(point, polygon) {
  const { x: x4, y: y3 } = point;
  let inside = false;
  for (let i3 = 0, j2 = polygon.length - 1; i3 < polygon.length; j2 = i3++) {
    const xi = polygon[i3].x;
    const yi = polygon[i3].y;
    const xj = polygon[j2].x;
    const yj = polygon[j2].y;
    const intersect = yi > y3 !== yj > y3 && x4 < (xj - xi) * (y3 - yi) / (yj - yi) + xi;
    if (intersect)
      inside = !inside;
  }
  return inside;
}
function isFocusWithinSubmenu(submenuId) {
  const activeEl = document.activeElement;
  if (!isHTMLElement(activeEl))
    return false;
  const submenuEl = activeEl.closest(`[data-id="${submenuId}"]`);
  return isHTMLElement(submenuEl);
}
function stateAttr2(open) {
  return open ? "open" : "closed";
}
function createDropdownMenu(props) {
  const withDefaults = { ...defaults5, ...props };
  const rootOptions = toWritableStores(omit(withDefaults, "ids"));
  const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);
  const rootOpen = overridable(openWritable, withDefaults?.onOpenChange);
  const rootActiveTrigger = withGet(writable(null));
  const nextFocusable = withGet(writable(null));
  const prevFocusable = withGet(writable(null));
  const { elements, builders, ids, states, options: options2 } = createMenuBuilder({
    rootOptions,
    rootOpen,
    rootActiveTrigger: withGet(rootActiveTrigger),
    nextFocusable: withGet(nextFocusable),
    prevFocusable: withGet(prevFocusable),
    selector: "dropdown-menu",
    removeScroll: true,
    ids: withDefaults.ids
  });
  return {
    ids,
    elements,
    states,
    builders,
    options: options2
  };
}
function generateId4() {
  return nanoid(10);
}
function getMenuData() {
  const NAME2 = "menu";
  const SUB_NAME = "menu-submenu";
  const RADIO_GROUP_NAME = "menu-radiogroup";
  const CHECKBOX_ITEM_NAME = "menu-checkboxitem";
  const RADIO_ITEM_NAME = "menu-radioitem";
  const GROUP_NAME2 = "menu-group";
  const PARTS2 = [
    "arrow",
    "checkbox-indicator",
    "checkbox-item",
    "content",
    "group",
    "item",
    "label",
    "radio-group",
    "radio-item",
    "radio-indicator",
    "separator",
    "sub-content",
    "sub-trigger",
    "trigger"
  ];
  return {
    NAME: NAME2,
    SUB_NAME,
    RADIO_GROUP_NAME,
    CHECKBOX_ITEM_NAME,
    RADIO_ITEM_NAME,
    GROUP_NAME: GROUP_NAME2,
    PARTS: PARTS2
  };
}
function getCtx4() {
  const { NAME: NAME2 } = getMenuData();
  return getContext(NAME2);
}
function setCtx3(props) {
  const { NAME: NAME2, PARTS: PARTS2 } = getMenuData();
  const getAttrs2 = createBitAttrs("menu", PARTS2);
  const dropdownMenu = {
    ...createDropdownMenu({ ...removeUndefined2(props), forceVisible: true }),
    getAttrs: getAttrs2
  };
  setContext(NAME2, dropdownMenu);
  return {
    ...dropdownMenu,
    updateOption: getOptionUpdater(dropdownMenu.options)
  };
}
function setCheckboxItem(props) {
  const { CHECKBOX_ITEM_NAME } = getMenuData();
  const { builders: { createCheckboxItem }, getAttrs: getAttrs2 } = getCtx4();
  const checkboxItem = createCheckboxItem(removeUndefined2(props));
  setContext(CHECKBOX_ITEM_NAME, checkboxItem.states.checked);
  return {
    ...checkboxItem,
    updateOption: getOptionUpdater(checkboxItem.options),
    getAttrs: getAttrs2
  };
}
function getCheckboxIndicator() {
  const { CHECKBOX_ITEM_NAME } = getMenuData();
  return getContext(CHECKBOX_ITEM_NAME);
}
function getGroupLabel() {
  const { GROUP_NAME: GROUP_NAME2 } = getMenuData();
  const id2 = getContext(GROUP_NAME2) ?? generateId4();
  const { elements: { groupLabel }, getAttrs: getAttrs2 } = getCtx4();
  return { groupLabel, id: id2, getAttrs: getAttrs2 };
}
function updatePositioning3(props) {
  const defaultPlacement = {
    side: "bottom",
    align: "center"
  };
  const withDefaults = { ...defaultPlacement, ...props };
  const { options: { positioning } } = getCtx4();
  const updater = getPositioningUpdater(positioning);
  updater(withDefaults);
}
function createRender(component15, props) {
  return new ComponentRenderConfig(component15, props);
}
function keyed(parent, path) {
  const keyTokens = getTokens(path);
  if (keyTokens.some((token) => token === "__proto__")) {
    throw new Error('key cannot include "__proto__"');
  }
  const branchTokens = keyTokens.slice(0, keyTokens.length - 1);
  const leafToken = keyTokens[keyTokens.length - 1];
  const keyedValue = derived(parent, ($parent) => getNested($parent, keyTokens));
  const set = (value) => {
    parent.update(($parent) => {
      if ($parent == null) {
        return $parent;
      }
      const newParent = Array.isArray($parent) ? [...$parent] : clonedWithPrototype($parent);
      getNested(newParent, branchTokens)[leafToken] = value;
      return newParent;
    });
  };
  const update2 = (fn) => {
    parent.update(($parent) => {
      if ($parent == null) {
        return $parent;
      }
      const newValue = fn(getNested($parent, keyTokens));
      const newParent = Array.isArray($parent) ? [...$parent] : clonedWithPrototype($parent);
      getNested(newParent, branchTokens)[leafToken] = newValue;
      return newParent;
    });
  };
  return {
    subscribe: keyedValue.subscribe,
    set,
    update: update2
  };
}
var ArrowDown;
var ArrowDown$1;
var ArrowUp;
var ArrowUp$1;
var ChevronLeft;
var ChevronLeft$1;
var ChevronRight;
var ChevronRight$1;
var Printer;
var Edit;
var SUB_OPEN_KEYS;
var SUB_CLOSE_KEYS;
var menuIdParts;
var defaults$12;
var defaults5;
var Menu_label;
var Menu_separator;
var Menu_checkbox_item;
var Menu_checkbox_indicator;
var Dialog_title$1;
var Menu;
var Menu_content;
var Menu_trigger;
var Dialog_title;
var Dialog_footer;
var Dialog_header;
var derivedKeys;
var Subscribe;
var PropsRenderer;
var isReadable2;
var Undefined;
var ComponentRenderer;
var Render;
var ComponentRenderConfig;
var Column;
var FlatColumn;
var DataColumn;
var DisplayColumn;
var GroupColumn;
var getFlatColumnIds;
var getFlatColumns;
var getCounter;
var getDuplicates;
var stringifyCss;
var mergeAttributes;
var finalizeAttributes;
var TableComponent;
var BodyCell;
var DataBodyCell;
var DisplayBodyCell;
var nonUndefined;
var BodyRow;
var DataBodyRow;
var getBodyRows;
var getColumnedBodyRows;
var NBSP;
var HeaderCell;
var FlatHeaderCell;
var DataHeaderCell;
var FlatDisplayHeaderCell;
var GroupHeaderCell;
var GroupDisplayHeaderCell;
var sum;
var getNullMatrix;
var getTransposed;
var HeaderRow;
var getHeaderRows;
var getHeaderRowMatrix;
var loadHeaderRowMatrix;
var getOrderedColumnMatrix;
var populateGroupHeaderCellIds;
var headerRowsForRowMatrix;
var getMergedRow;
var createViewModel;
var Table$1;
var createTable;
var getTokens;
var getNested;
var clonedWithPrototype;
var getFilteredRows$1;
var addColumnFilters;
var textPrefixFilter;
var recordSetStore;
var isShiftClick;
var addHiddenColumns;
var MIN_PAGE_SIZE;
var createPageStore;
var addPagination;
var compare2;
var compareArray;
var DEFAULT_TOGGLE_ORDER;
var createSortKeysStore;
var getSortedRows;
var addSortBy;
var getFilteredRows;
var addTableFilter;
var Table2;
var Table_body;
var Table_cell;
var Table_head;
var Table_header;
var Table_row;
var Dropdown_menu_label;
var Dropdown_menu_content;
var Dropdown_menu_separator;
var Dropdown_menu_checkbox_item;
var Root4;
var Trigger3;
var Data_table_print;
var data;
var css3;
var Data_table_toolbar;
var Data_table_actions;
var Data_table_pagination;
var Data_table_column_header;
var Badge;
var badgeVariants;
var Data_table_status;
var Data_table;
var Page9;
var init_page_svelte9 = __esm({
  ".svelte-kit/output/server/entries/pages/(dashboard)/_project_/tim-pelaksana/_page.svelte.js"() {
    init_ssr();
    init_mode_toggle();
    init_lifecycle();
    init_index2();
    init_index3();
    init_clsx();
    init_index5();
    init_dist();
    init_input();
    init_non_secure();
    init_scheduler();
    init_MagnifyingGlass();
    init_dist2();
    ArrowDown = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["color", "size"]);
      let { color = "currentColor" } = $$props;
      let { size: size3 = 15 } = $$props;
      if ($$props.color === void 0 && $$bindings.color && color !== void 0)
        $$bindings.color(color);
      if ($$props.size === void 0 && $$bindings.size && size3 !== void 0)
        $$bindings.size(size3);
      return `<svg${spread(
        [
          { width: escape_attribute_value(size3) },
          { height: escape_attribute_value(size3) },
          { viewBox: "0 0 15 15" },
          { fill: "none" },
          { xmlns: "http://www.w3.org/2000/svg" },
          escape_object($$restProps)
        ],
        {}
      )}><path fill-rule="evenodd" clip-rule="evenodd" d="M7.5 2C7.77614 2 8 2.22386 8 2.5L8 11.2929L11.1464 8.14645C11.3417 7.95118 11.6583 7.95118 11.8536 8.14645C12.0488 8.34171 12.0488 8.65829 11.8536 8.85355L7.85355 12.8536C7.75979 12.9473 7.63261 13 7.5 13C7.36739 13 7.24021 12.9473 7.14645 12.8536L3.14645 8.85355C2.95118 8.65829 2.95118 8.34171 3.14645 8.14645C3.34171 7.95118 3.65829 7.95118 3.85355 8.14645L7 11.2929L7 2.5C7 2.22386 7.22386 2 7.5 2Z"${add_attribute("fill", color, 0)}></path></svg>`;
    });
    ArrowDown$1 = ArrowDown;
    ArrowUp = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["color", "size"]);
      let { color = "currentColor" } = $$props;
      let { size: size3 = 15 } = $$props;
      if ($$props.color === void 0 && $$bindings.color && color !== void 0)
        $$bindings.color(color);
      if ($$props.size === void 0 && $$bindings.size && size3 !== void 0)
        $$bindings.size(size3);
      return `<svg${spread(
        [
          { width: escape_attribute_value(size3) },
          { height: escape_attribute_value(size3) },
          { viewBox: "0 0 15 15" },
          { fill: "none" },
          { xmlns: "http://www.w3.org/2000/svg" },
          escape_object($$restProps)
        ],
        {}
      )}><path fill-rule="evenodd" clip-rule="evenodd" d="M7.14645 2.14645C7.34171 1.95118 7.65829 1.95118 7.85355 2.14645L11.8536 6.14645C12.0488 6.34171 12.0488 6.65829 11.8536 6.85355C11.6583 7.04882 11.3417 7.04882 11.1464 6.85355L8 3.70711L8 12.5C8 12.7761 7.77614 13 7.5 13C7.22386 13 7 12.7761 7 12.5L7 3.70711L3.85355 6.85355C3.65829 7.04882 3.34171 7.04882 3.14645 6.85355C2.95118 6.65829 2.95118 6.34171 3.14645 6.14645L7.14645 2.14645Z"${add_attribute("fill", color, 0)}></path></svg>`;
    });
    ArrowUp$1 = ArrowUp;
    ChevronLeft = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["color", "size"]);
      let { color = "currentColor" } = $$props;
      let { size: size3 = 15 } = $$props;
      if ($$props.color === void 0 && $$bindings.color && color !== void 0)
        $$bindings.color(color);
      if ($$props.size === void 0 && $$bindings.size && size3 !== void 0)
        $$bindings.size(size3);
      return `<svg${spread(
        [
          { width: escape_attribute_value(size3) },
          { height: escape_attribute_value(size3) },
          { viewBox: "0 0 15 15" },
          { fill: "none" },
          { xmlns: "http://www.w3.org/2000/svg" },
          escape_object($$restProps)
        ],
        {}
      )}><path fill-rule="evenodd" clip-rule="evenodd" d="M8.84182 3.13514C9.04327 3.32401 9.05348 3.64042 8.86462 3.84188L5.43521 7.49991L8.86462 11.1579C9.05348 11.3594 9.04327 11.6758 8.84182 11.8647C8.64036 12.0535 8.32394 12.0433 8.13508 11.8419L4.38508 7.84188C4.20477 7.64955 4.20477 7.35027 4.38508 7.15794L8.13508 3.15794C8.32394 2.95648 8.64036 2.94628 8.84182 3.13514Z"${add_attribute("fill", color, 0)}></path></svg>`;
    });
    ChevronLeft$1 = ChevronLeft;
    ChevronRight = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["color", "size"]);
      let { color = "currentColor" } = $$props;
      let { size: size3 = 15 } = $$props;
      if ($$props.color === void 0 && $$bindings.color && color !== void 0)
        $$bindings.color(color);
      if ($$props.size === void 0 && $$bindings.size && size3 !== void 0)
        $$bindings.size(size3);
      return `<svg${spread(
        [
          { width: escape_attribute_value(size3) },
          { height: escape_attribute_value(size3) },
          { viewBox: "0 0 15 15" },
          { fill: "none" },
          { xmlns: "http://www.w3.org/2000/svg" },
          escape_object($$restProps)
        ],
        {}
      )}><path fill-rule="evenodd" clip-rule="evenodd" d="M6.1584 3.13508C6.35985 2.94621 6.67627 2.95642 6.86514 3.15788L10.6151 7.15788C10.7954 7.3502 10.7954 7.64949 10.6151 7.84182L6.86514 11.8418C6.67627 12.0433 6.35985 12.0535 6.1584 11.8646C5.95694 11.6757 5.94673 11.3593 6.1356 11.1579L9.565 7.49985L6.1356 3.84182C5.94673 3.64036 5.95694 3.32394 6.1584 3.13508Z"${add_attribute("fill", color, 0)}></path></svg>`;
    });
    ChevronRight$1 = ChevronRight;
    Printer = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, []);
      return `<svg${add_attribute("class", $$restProps.class, 0)} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 6 2 18 2 18 9"></polyline><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"></path><rect width="12" height="8" x="6" y="14"></rect></svg>`;
    });
    Edit = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, []);
      return `<svg${add_attribute("class", $$restProps.class, 0)} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 13.5V4a2 2 0 0 1 2-2h8.5L20 7.5V20a2 2 0 0 1-2 2h-5.5"></path><polyline points="14 2 14 8 20 8"></polyline><path d="M10.42 12.61a2.1 2.1 0 1 1 2.97 2.97L7.95 21 4 22l.99-3.95 5.43-5.44Z"></path></svg>`;
    });
    SUB_OPEN_KEYS = {
      ltr: [...SELECTION_KEYS, kbd.ARROW_RIGHT],
      rtl: [...SELECTION_KEYS, kbd.ARROW_LEFT]
    };
    SUB_CLOSE_KEYS = {
      ltr: [kbd.ARROW_LEFT],
      rtl: [kbd.ARROW_RIGHT]
    };
    menuIdParts = ["menu", "trigger"];
    defaults$12 = {
      arrowSize: 8,
      positioning: {
        placement: "bottom"
      },
      preventScroll: true,
      closeOnEscape: true,
      closeOnOutsideClick: true,
      portal: void 0,
      loop: false,
      dir: "ltr",
      defaultOpen: false,
      typeahead: true,
      closeOnItemClick: true,
      onOutsideClick: void 0
    };
    defaults5 = {
      arrowSize: 8,
      positioning: {
        placement: "bottom"
      },
      preventScroll: true,
      closeOnEscape: true,
      closeOnOutsideClick: true,
      portal: void 0,
      loop: false,
      dir: "ltr",
      defaultOpen: false,
      forceVisible: false,
      typeahead: true,
      closeFocus: void 0,
      disableFocusFirstItem: false,
      closeOnItemClick: true,
      onOutsideClick: void 0
    };
    Menu_label = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let builder;
      let $$restProps = compute_rest_props($$props, ["asChild", "el"]);
      let $groupLabel, $$unsubscribe_groupLabel;
      let { asChild = false } = $$props;
      let { el = void 0 } = $$props;
      const { groupLabel, id: id2, getAttrs: getAttrs2 } = getGroupLabel();
      $$unsubscribe_groupLabel = subscribe(groupLabel, (value) => $groupLabel = value);
      const attrs = getAttrs2("label");
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      if ($$props.el === void 0 && $$bindings.el && el !== void 0)
        $$bindings.el(el);
      builder = $groupLabel(id2);
      {
        Object.assign(builder, attrs);
      }
      $$unsubscribe_groupLabel();
      return `${asChild ? `${slots.default ? slots.default({ builder }) : ``}` : `<div${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}>${slots.default ? slots.default({ builder }) : ``}</div>`}`;
    });
    Menu_separator = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let builder;
      let $$restProps = compute_rest_props($$props, ["asChild", "el"]);
      let $separator, $$unsubscribe_separator;
      let { asChild = false } = $$props;
      let { el = void 0 } = $$props;
      const { elements: { separator }, getAttrs: getAttrs2 } = getCtx4();
      $$unsubscribe_separator = subscribe(separator, (value) => $separator = value);
      const attrs = getAttrs2("separator");
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      if ($$props.el === void 0 && $$bindings.el && el !== void 0)
        $$bindings.el(el);
      builder = $separator;
      {
        Object.assign(builder, attrs);
      }
      $$unsubscribe_separator();
      return `${asChild ? `${slots.default ? slots.default({ builder }) : ``}` : `<div${spread([escape_object($separator), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}></div>`}`;
    });
    Menu_checkbox_item = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let builder;
      let $$restProps = compute_rest_props($$props, ["checked", "onCheckedChange", "disabled", "asChild", "el"]);
      let $checkboxItem, $$unsubscribe_checkboxItem;
      let { checked = void 0 } = $$props;
      let { onCheckedChange = void 0 } = $$props;
      let { disabled = void 0 } = $$props;
      let { asChild = false } = $$props;
      let { el = void 0 } = $$props;
      const { elements: { checkboxItem }, states: { checked: localChecked }, updateOption, getAttrs: getAttrs2 } = setCheckboxItem({
        disabled,
        defaultChecked: checked,
        onCheckedChange: ({ next: next2 }) => {
          if (checked !== next2) {
            onCheckedChange?.(next2);
            checked = next2;
          }
          return next2;
        }
      });
      $$unsubscribe_checkboxItem = subscribe(checkboxItem, (value) => $checkboxItem = value);
      createDispatcher();
      const attrs = getAttrs2("checkbox-item");
      if ($$props.checked === void 0 && $$bindings.checked && checked !== void 0)
        $$bindings.checked(checked);
      if ($$props.onCheckedChange === void 0 && $$bindings.onCheckedChange && onCheckedChange !== void 0)
        $$bindings.onCheckedChange(onCheckedChange);
      if ($$props.disabled === void 0 && $$bindings.disabled && disabled !== void 0)
        $$bindings.disabled(disabled);
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      if ($$props.el === void 0 && $$bindings.el && el !== void 0)
        $$bindings.el(el);
      checked !== void 0 && localChecked.set(checked);
      {
        updateOption("disabled", disabled);
      }
      builder = $checkboxItem;
      {
        Object.assign(builder, attrs);
      }
      $$unsubscribe_checkboxItem();
      return `${asChild ? `${slots.default ? slots.default({ builder }) : ``}` : `<div${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}>${slots.default ? slots.default({ builder }) : ``}</div>`}`;
    });
    Menu_checkbox_indicator = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["asChild", "el"]);
      let $checked, $$unsubscribe_checked;
      let { asChild = false } = $$props;
      let { el = void 0 } = $$props;
      const checked = getCheckboxIndicator();
      $$unsubscribe_checked = subscribe(checked, (value) => $checked = value);
      const { getAttrs: getAttrs2 } = getCtx4();
      const attrs = getAttrs2("checkbox-indicator");
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      if ($$props.el === void 0 && $$bindings.el && el !== void 0)
        $$bindings.el(el);
      $$unsubscribe_checked();
      return `${asChild ? `${slots.default ? slots.default({ attrs, checked: $checked }) : ``}` : `<div${spread([escape_object($$restProps), escape_object(attrs)], {})}${add_attribute("this", el, 0)}>${$checked ? `${slots.default ? slots.default({ attrs, checked: $checked }) : ``}` : ``}</div>`}`;
    });
    Dialog_title$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let builder;
      let $$restProps = compute_rest_props($$props, ["level", "asChild", "id", "el"]);
      let $title, $$unsubscribe_title;
      let { level = "h2" } = $$props;
      let { asChild = false } = $$props;
      let { id: id2 = void 0 } = $$props;
      let { el = void 0 } = $$props;
      const { elements: { title }, ids, getAttrs: getAttrs2 } = getCtx$1();
      $$unsubscribe_title = subscribe(title, (value) => $title = value);
      const attrs = getAttrs2("title");
      if ($$props.level === void 0 && $$bindings.level && level !== void 0)
        $$bindings.level(level);
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      if ($$props.id === void 0 && $$bindings.id && id2 !== void 0)
        $$bindings.id(id2);
      if ($$props.el === void 0 && $$bindings.el && el !== void 0)
        $$bindings.el(el);
      {
        if (id2) {
          ids.title.set(id2);
        }
      }
      builder = $title;
      {
        Object.assign(builder, attrs);
      }
      $$unsubscribe_title();
      return `${asChild ? `${slots.default ? slots.default({ builder }) : ``}` : `${((tag) => {
        return tag ? `<${level}${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}>${is_void(tag) ? "" : `${slots.default ? slots.default({ builder }) : ``}`}${is_void(tag) ? "" : `</${tag}>`}` : "";
      })(level)}`}`;
    });
    Menu = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $idValues, $$unsubscribe_idValues;
      let { closeOnOutsideClick = void 0 } = $$props;
      let { closeOnEscape = void 0 } = $$props;
      let { portal = void 0 } = $$props;
      let { open = void 0 } = $$props;
      let { onOpenChange = void 0 } = $$props;
      let { preventScroll = void 0 } = $$props;
      let { loop = void 0 } = $$props;
      let { dir = void 0 } = $$props;
      let { typeahead = void 0 } = $$props;
      let { closeFocus = void 0 } = $$props;
      let { disableFocusFirstItem = void 0 } = $$props;
      let { closeOnItemClick = void 0 } = $$props;
      let { onOutsideClick = void 0 } = $$props;
      const { states: { open: localOpen }, updateOption, ids } = setCtx3({
        closeOnOutsideClick,
        closeOnEscape,
        portal,
        forceVisible: true,
        defaultOpen: open,
        preventScroll,
        loop,
        dir,
        typeahead,
        closeFocus,
        disableFocusFirstItem,
        closeOnItemClick,
        onOutsideClick,
        onOpenChange: ({ next: next2 }) => {
          if (open !== next2) {
            onOpenChange?.(next2);
            open = next2;
          }
          return next2;
        }
      });
      const idValues = derived([ids.menu, ids.trigger], ([$menuId, $triggerId]) => ({ menu: $menuId, trigger: $triggerId }));
      $$unsubscribe_idValues = subscribe(idValues, (value) => $idValues = value);
      if ($$props.closeOnOutsideClick === void 0 && $$bindings.closeOnOutsideClick && closeOnOutsideClick !== void 0)
        $$bindings.closeOnOutsideClick(closeOnOutsideClick);
      if ($$props.closeOnEscape === void 0 && $$bindings.closeOnEscape && closeOnEscape !== void 0)
        $$bindings.closeOnEscape(closeOnEscape);
      if ($$props.portal === void 0 && $$bindings.portal && portal !== void 0)
        $$bindings.portal(portal);
      if ($$props.open === void 0 && $$bindings.open && open !== void 0)
        $$bindings.open(open);
      if ($$props.onOpenChange === void 0 && $$bindings.onOpenChange && onOpenChange !== void 0)
        $$bindings.onOpenChange(onOpenChange);
      if ($$props.preventScroll === void 0 && $$bindings.preventScroll && preventScroll !== void 0)
        $$bindings.preventScroll(preventScroll);
      if ($$props.loop === void 0 && $$bindings.loop && loop !== void 0)
        $$bindings.loop(loop);
      if ($$props.dir === void 0 && $$bindings.dir && dir !== void 0)
        $$bindings.dir(dir);
      if ($$props.typeahead === void 0 && $$bindings.typeahead && typeahead !== void 0)
        $$bindings.typeahead(typeahead);
      if ($$props.closeFocus === void 0 && $$bindings.closeFocus && closeFocus !== void 0)
        $$bindings.closeFocus(closeFocus);
      if ($$props.disableFocusFirstItem === void 0 && $$bindings.disableFocusFirstItem && disableFocusFirstItem !== void 0)
        $$bindings.disableFocusFirstItem(disableFocusFirstItem);
      if ($$props.closeOnItemClick === void 0 && $$bindings.closeOnItemClick && closeOnItemClick !== void 0)
        $$bindings.closeOnItemClick(closeOnItemClick);
      if ($$props.onOutsideClick === void 0 && $$bindings.onOutsideClick && onOutsideClick !== void 0)
        $$bindings.onOutsideClick(onOutsideClick);
      open !== void 0 && localOpen.set(open);
      {
        updateOption("closeOnOutsideClick", closeOnOutsideClick);
      }
      {
        updateOption("closeOnEscape", closeOnEscape);
      }
      {
        updateOption("portal", portal);
      }
      {
        updateOption("preventScroll", preventScroll);
      }
      {
        updateOption("loop", loop);
      }
      {
        updateOption("dir", dir);
      }
      {
        updateOption("closeFocus", closeFocus);
      }
      {
        updateOption("disableFocusFirstItem", disableFocusFirstItem);
      }
      {
        updateOption("typeahead", typeahead);
      }
      {
        updateOption("closeOnItemClick", closeOnItemClick);
      }
      {
        updateOption("onOutsideClick", onOutsideClick);
      }
      $$unsubscribe_idValues();
      return `${slots.default ? slots.default({ ids: $idValues }) : ``}`;
    });
    Menu_content = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let builder;
      let $$restProps = compute_rest_props($$props, [
        "transition",
        "transitionConfig",
        "inTransition",
        "inTransitionConfig",
        "outTransition",
        "outTransitionConfig",
        "asChild",
        "id",
        "side",
        "align",
        "sideOffset",
        "alignOffset",
        "collisionPadding",
        "avoidCollisions",
        "collisionBoundary",
        "sameWidth",
        "fitViewport",
        "strategy",
        "overlap",
        "el"
      ]);
      let $open, $$unsubscribe_open;
      let $menu, $$unsubscribe_menu;
      let { transition = void 0 } = $$props;
      let { transitionConfig = void 0 } = $$props;
      let { inTransition = void 0 } = $$props;
      let { inTransitionConfig = void 0 } = $$props;
      let { outTransition = void 0 } = $$props;
      let { outTransitionConfig = void 0 } = $$props;
      let { asChild = false } = $$props;
      let { id: id2 = void 0 } = $$props;
      let { side = "bottom" } = $$props;
      let { align = "center" } = $$props;
      let { sideOffset = 0 } = $$props;
      let { alignOffset = 0 } = $$props;
      let { collisionPadding = 8 } = $$props;
      let { avoidCollisions = true } = $$props;
      let { collisionBoundary = void 0 } = $$props;
      let { sameWidth = false } = $$props;
      let { fitViewport = false } = $$props;
      let { strategy = "absolute" } = $$props;
      let { overlap = false } = $$props;
      let { el = void 0 } = $$props;
      const { elements: { menu }, states: { open }, ids, getAttrs: getAttrs2 } = getCtx4();
      $$unsubscribe_menu = subscribe(menu, (value) => $menu = value);
      $$unsubscribe_open = subscribe(open, (value) => $open = value);
      createDispatcher();
      const attrs = getAttrs2("content");
      if ($$props.transition === void 0 && $$bindings.transition && transition !== void 0)
        $$bindings.transition(transition);
      if ($$props.transitionConfig === void 0 && $$bindings.transitionConfig && transitionConfig !== void 0)
        $$bindings.transitionConfig(transitionConfig);
      if ($$props.inTransition === void 0 && $$bindings.inTransition && inTransition !== void 0)
        $$bindings.inTransition(inTransition);
      if ($$props.inTransitionConfig === void 0 && $$bindings.inTransitionConfig && inTransitionConfig !== void 0)
        $$bindings.inTransitionConfig(inTransitionConfig);
      if ($$props.outTransition === void 0 && $$bindings.outTransition && outTransition !== void 0)
        $$bindings.outTransition(outTransition);
      if ($$props.outTransitionConfig === void 0 && $$bindings.outTransitionConfig && outTransitionConfig !== void 0)
        $$bindings.outTransitionConfig(outTransitionConfig);
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      if ($$props.id === void 0 && $$bindings.id && id2 !== void 0)
        $$bindings.id(id2);
      if ($$props.side === void 0 && $$bindings.side && side !== void 0)
        $$bindings.side(side);
      if ($$props.align === void 0 && $$bindings.align && align !== void 0)
        $$bindings.align(align);
      if ($$props.sideOffset === void 0 && $$bindings.sideOffset && sideOffset !== void 0)
        $$bindings.sideOffset(sideOffset);
      if ($$props.alignOffset === void 0 && $$bindings.alignOffset && alignOffset !== void 0)
        $$bindings.alignOffset(alignOffset);
      if ($$props.collisionPadding === void 0 && $$bindings.collisionPadding && collisionPadding !== void 0)
        $$bindings.collisionPadding(collisionPadding);
      if ($$props.avoidCollisions === void 0 && $$bindings.avoidCollisions && avoidCollisions !== void 0)
        $$bindings.avoidCollisions(avoidCollisions);
      if ($$props.collisionBoundary === void 0 && $$bindings.collisionBoundary && collisionBoundary !== void 0)
        $$bindings.collisionBoundary(collisionBoundary);
      if ($$props.sameWidth === void 0 && $$bindings.sameWidth && sameWidth !== void 0)
        $$bindings.sameWidth(sameWidth);
      if ($$props.fitViewport === void 0 && $$bindings.fitViewport && fitViewport !== void 0)
        $$bindings.fitViewport(fitViewport);
      if ($$props.strategy === void 0 && $$bindings.strategy && strategy !== void 0)
        $$bindings.strategy(strategy);
      if ($$props.overlap === void 0 && $$bindings.overlap && overlap !== void 0)
        $$bindings.overlap(overlap);
      if ($$props.el === void 0 && $$bindings.el && el !== void 0)
        $$bindings.el(el);
      {
        if (id2) {
          ids.menu.set(id2);
        }
      }
      builder = $menu;
      {
        Object.assign(builder, attrs);
      }
      {
        if ($open) {
          updatePositioning3({
            side,
            align,
            sideOffset,
            alignOffset,
            collisionPadding,
            avoidCollisions,
            collisionBoundary,
            sameWidth,
            fitViewport,
            strategy,
            overlap
          });
        }
      }
      $$unsubscribe_open();
      $$unsubscribe_menu();
      return `${asChild && $open ? `${slots.default ? slots.default({ builder }) : ``}` : `${transition && $open ? `<div${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}>${slots.default ? slots.default({ builder }) : ``}</div>` : `${inTransition && outTransition && $open ? `<div${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}>${slots.default ? slots.default({ builder }) : ``}</div>` : `${inTransition && $open ? `<div${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}>${slots.default ? slots.default({ builder }) : ``}</div>` : `${outTransition && $open ? `<div${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}>${slots.default ? slots.default({ builder }) : ``}</div>` : `${$open ? `<div${spread([escape_object(builder), escape_object($$restProps)], {})}${add_attribute("this", el, 0)}>${slots.default ? slots.default({ builder }) : ``}</div>` : ``}`}`}`}`}`}`;
    });
    Menu_trigger = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let builder;
      let $$restProps = compute_rest_props($$props, ["asChild", "id", "el"]);
      let $trigger, $$unsubscribe_trigger;
      let { asChild = false } = $$props;
      let { id: id2 = void 0 } = $$props;
      let { el = void 0 } = $$props;
      const { elements: { trigger }, ids, getAttrs: getAttrs2 } = getCtx4();
      $$unsubscribe_trigger = subscribe(trigger, (value) => $trigger = value);
      createDispatcher();
      const attrs = getAttrs2("trigger");
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      if ($$props.id === void 0 && $$bindings.id && id2 !== void 0)
        $$bindings.id(id2);
      if ($$props.el === void 0 && $$bindings.el && el !== void 0)
        $$bindings.el(el);
      {
        if (id2) {
          ids.trigger.set(id2);
        }
      }
      builder = $trigger;
      {
        Object.assign(builder, attrs);
      }
      $$unsubscribe_trigger();
      return `${asChild ? `${slots.default ? slots.default({ builder }) : ``}` : `<button${spread([escape_object(builder), { type: "button" }, escape_object($$restProps)], {})}${add_attribute("this", el, 0)}>${slots.default ? slots.default({ builder }) : ``}</button>`}`;
    });
    Dialog_title = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class"]);
      let { class: className = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      return `${validate_component(Dialog_title$1, "DialogPrimitive.Title").$$render(
        $$result,
        Object.assign(
          {},
          {
            class: cn("text-lg font-semibold leading-none tracking-tight", className)
          },
          $$restProps
        ),
        {},
        {
          default: () => {
            return `${slots.default ? slots.default({}) : ``}`;
          }
        }
      )}`;
    });
    Dialog_footer = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class"]);
      let { class: className = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      return `<div${spread(
        [
          {
            class: escape_attribute_value(cn("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2", className))
          },
          escape_object($$restProps)
        ],
        {}
      )}>${slots.default ? slots.default({}) : ``}</div>`;
    });
    Dialog_header = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class"]);
      let { class: className = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      return `<div${spread(
        [
          {
            class: escape_attribute_value(cn("flex flex-col space-y-1.5 text-center sm:text-left", className))
          },
          escape_object($$restProps)
        ],
        {}
      )}>${slots.default ? slots.default({}) : ``}</div>`;
    });
    derivedKeys = (storeMap) => {
      const entries = Object.entries(storeMap);
      const keys = entries.map(([key2]) => key2);
      return derived(entries.map(([, store]) => store), ($stores) => {
        return Object.fromEntries($stores.map((store, idx) => [keys[idx], store]));
      });
    };
    Subscribe = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, []);
      let $values, $$unsubscribe_values;
      const values = derivedKeys($$restProps);
      $$unsubscribe_values = subscribe(values, (value) => $values = value);
      $$unsubscribe_values();
      return `${slots.default ? slots.default({ ...$values }) : ``}`;
    });
    PropsRenderer = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { instance = void 0 } = $$props;
      let { config } = $$props;
      let { props = void 0 } = $$props;
      if ($$props.instance === void 0 && $$bindings.instance && instance !== void 0)
        $$bindings.instance(instance);
      if ($$props.config === void 0 && $$bindings.config && config !== void 0)
        $$bindings.config(config);
      if ($$props.props === void 0 && $$bindings.props && props !== void 0)
        $$bindings.props(props);
      let $$settled;
      let $$rendered;
      let previous_head = $$result.head;
      do {
        $$settled = true;
        $$result.head = previous_head;
        $$rendered = `${config.children.length === 0 ? `${validate_component(config.component || missing_component, "svelte:component").$$render(
          $$result,
          Object.assign({}, props ?? {}, { this: instance }),
          {
            this: ($$value) => {
              instance = $$value;
              $$settled = false;
            }
          },
          {}
        )}` : `${validate_component(config.component || missing_component, "svelte:component").$$render(
          $$result,
          Object.assign({}, props ?? {}, { this: instance }),
          {
            this: ($$value) => {
              instance = $$value;
              $$settled = false;
            }
          },
          {
            default: () => {
              return `${each(config.children, (child) => {
                return `${validate_component(Render, "Render").$$render($$result, { of: child }, {}, {})}`;
              })}`;
            }
          }
        )}`}`;
      } while (!$$settled);
      return $$rendered;
    });
    isReadable2 = (value) => {
      return value?.subscribe instanceof Function;
    };
    Undefined = readable(void 0);
    ComponentRenderer = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { config } = $$props;
      let instance;
      if ($$props.config === void 0 && $$bindings.config && config !== void 0)
        $$bindings.config(config);
      let $$settled;
      let $$rendered;
      let previous_head = $$result.head;
      do {
        $$settled = true;
        $$result.head = previous_head;
        $$rendered = `${isReadable2(config.props) ? `${validate_component(Subscribe, "Subscribe").$$render($$result, { props: config.props }, {}, {
          default: ({ props }) => {
            return `${validate_component(PropsRenderer, "PropsRenderer").$$render(
              $$result,
              { config, props, instance },
              {
                instance: ($$value) => {
                  instance = $$value;
                  $$settled = false;
                }
              },
              {}
            )}`;
          }
        })}` : `${validate_component(PropsRenderer, "PropsRenderer").$$render(
          $$result,
          { config, props: config.props, instance },
          {
            instance: ($$value) => {
              instance = $$value;
              $$settled = false;
            }
          },
          {}
        )}`}`;
      } while (!$$settled);
      return $$rendered;
    });
    Render = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $readableConfig, $$unsubscribe_readableConfig;
      let { of: config } = $$props;
      const readableConfig = isReadable2(config) ? config : Undefined;
      $$unsubscribe_readableConfig = subscribe(readableConfig, (value) => $readableConfig = value);
      if ($$props.of === void 0 && $$bindings.of && config !== void 0)
        $$bindings.of(config);
      $$unsubscribe_readableConfig();
      return `${isReadable2(config) ? ` ${escape($readableConfig)}` : `${typeof config !== "object" ? `${escape(config)}` : `${validate_component(ComponentRenderer, "ComponentRenderer").$$render($$result, { config }, {}, {})}`}`}`;
    });
    ComponentRenderConfig = class {
      component;
      props;
      constructor(component15, props) {
        this.component = component15;
        this.props = props;
      }
      eventHandlers = [];
      on(type, handler) {
        this.eventHandlers.push([type, handler]);
        return this;
      }
      children = [];
      slot(...children) {
        this.children = children;
        return this;
      }
    };
    Column = class {
      header;
      footer;
      height;
      plugins;
      constructor({ header, footer, height, plugins }) {
        this.header = header;
        this.footer = footer;
        this.height = height;
        this.plugins = plugins;
      }
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      isFlat() {
        return "__flat" in this;
      }
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      isData() {
        return "__data" in this;
      }
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      isDisplay() {
        return "__display" in this;
      }
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      isGroup() {
        return "__group" in this;
      }
    };
    FlatColumn = class extends Column {
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      __flat = true;
      id;
      constructor({ header, footer, plugins, id: id2 }) {
        super({ header, footer, plugins, height: 1 });
        this.id = id2 ?? String(header);
      }
    };
    DataColumn = class extends FlatColumn {
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      __data = true;
      cell;
      accessorKey;
      accessorFn;
      constructor({ header, footer, plugins, cell, accessor, id: id2 }) {
        super({ header, footer, plugins, id: "Initialization not complete" });
        this.cell = cell;
        if (accessor instanceof Function) {
          this.accessorFn = accessor;
        } else {
          this.accessorKey = accessor;
        }
        if (id2 === void 0 && this.accessorKey === void 0 && header === void 0) {
          throw new Error("A column id, string accessor, or header is required");
        }
        const accessorKeyId = typeof this.accessorKey === "string" ? this.accessorKey : null;
        this.id = id2 ?? accessorKeyId ?? String(header);
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      getValue(item) {
        if (this.accessorFn !== void 0) {
          return this.accessorFn(item);
        }
        if (this.accessorKey !== void 0) {
          return item[this.accessorKey];
        }
        return void 0;
      }
    };
    DisplayColumn = class extends FlatColumn {
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      __display = true;
      cell;
      data;
      constructor({ header, footer, plugins, id: id2, cell, data: data2 }) {
        super({ header, footer, plugins, id: id2 });
        this.cell = cell;
        this.data = data2;
      }
    };
    GroupColumn = class extends Column {
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      __group = true;
      columns;
      ids;
      constructor({ header, footer, columns, plugins }) {
        const height = Math.max(...columns.map((c2) => c2.height)) + 1;
        super({ header, footer, height, plugins });
        this.columns = columns;
        this.ids = getFlatColumnIds(columns);
      }
    };
    getFlatColumnIds = (columns) => columns.flatMap((c2) => c2.isFlat() ? [c2.id] : c2.isGroup() ? c2.ids : []);
    getFlatColumns = (columns) => {
      return columns.flatMap((c2) => c2.isFlat() ? [c2] : c2.isGroup() ? getFlatColumns(c2.columns) : []);
    };
    getCounter = (items) => {
      const result = /* @__PURE__ */ new Map();
      items.forEach((item) => {
        result.set(item, (result.get(item) ?? 0) + 1);
      });
      return result;
    };
    getDuplicates = (items) => {
      return Array.from(getCounter(items).entries()).filter(([, count]) => count !== 1).map(([key2]) => key2);
    };
    stringifyCss = (style) => {
      return Object.entries(style).map(([name5, value]) => `${name5}:${value}`).join(";");
    };
    mergeAttributes = (a2, b2) => {
      if (a2.style === void 0 && b2.style === void 0) {
        return { ...a2, ...b2 };
      }
      return {
        ...a2,
        ...b2,
        style: {
          ...typeof a2.style === "object" ? a2.style : {},
          ...typeof b2.style === "object" ? b2.style : {}
        }
      };
    };
    finalizeAttributes = (attrs) => {
      if (attrs.style === void 0 || typeof attrs.style !== "object") {
        return attrs;
      }
      return {
        ...attrs,
        style: stringifyCss(attrs.style)
      };
    };
    TableComponent = class {
      id;
      constructor({ id: id2 }) {
        this.id = id2;
      }
      attrsForName = {};
      attrs() {
        return derived(Object.values(this.attrsForName), ($attrsArray) => {
          let $mergedAttrs = {};
          $attrsArray.forEach(($attrs) => {
            $mergedAttrs = mergeAttributes($mergedAttrs, $attrs);
          });
          return finalizeAttributes($mergedAttrs);
        });
      }
      propsForName = {};
      props() {
        return derivedKeys(this.propsForName);
      }
      state;
      injectState(state) {
        this.state = state;
      }
      applyHook(pluginName, hook) {
        if (hook.props !== void 0) {
          this.propsForName[pluginName] = hook.props;
        }
        if (hook.attrs !== void 0) {
          this.attrsForName[pluginName] = hook.attrs;
        }
      }
    };
    BodyCell = class extends TableComponent {
      row;
      constructor({ id: id2, row }) {
        super({ id: id2 });
        this.row = row;
      }
      attrs() {
        return derived(super.attrs(), ($baseAttrs) => {
          return {
            ...$baseAttrs,
            role: "cell"
          };
        });
      }
      rowColId() {
        return `${this.row.id}:${this.column.id}`;
      }
      dataRowColId() {
        if (!this.row.isData()) {
          return void 0;
        }
        return `${this.row.dataId}:${this.column.id}`;
      }
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      isData() {
        return "__data" in this;
      }
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      isDisplay() {
        return "__display" in this;
      }
    };
    DataBodyCell = class _DataBodyCell extends BodyCell {
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      __data = true;
      column;
      label;
      value;
      constructor({ row, column, label, value }) {
        super({ id: column.id, row });
        this.column = column;
        this.label = label;
        this.value = value;
      }
      render() {
        if (this.label === void 0) {
          return `${this.value}`;
        }
        if (this.state === void 0) {
          throw new Error("Missing `state` reference");
        }
        return this.label(this, this.state);
      }
      clone() {
        const clonedCell = new _DataBodyCell({
          row: this.row,
          column: this.column,
          label: this.label,
          value: this.value
        });
        return clonedCell;
      }
    };
    DisplayBodyCell = class _DisplayBodyCell extends BodyCell {
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      __display = true;
      column;
      label;
      constructor({ row, column, label }) {
        super({ id: column.id, row });
        this.column = column;
        this.label = label;
      }
      render() {
        if (this.state === void 0) {
          throw new Error("Missing `state` reference");
        }
        return this.label(this, this.state);
      }
      clone() {
        const clonedCell = new _DisplayBodyCell({
          row: this.row,
          column: this.column,
          label: this.label
        });
        return clonedCell;
      }
    };
    nonUndefined = (value) => value !== void 0;
    BodyRow = class extends TableComponent {
      cells;
      /**
       * Get the cell with a given column id.
       *
       * **This includes hidden cells.**
       */
      cellForId;
      depth;
      parentRow;
      subRows;
      constructor({ id: id2, cells, cellForId, depth = 0, parentRow }) {
        super({ id: id2 });
        this.cells = cells;
        this.cellForId = cellForId;
        this.depth = depth;
        this.parentRow = parentRow;
      }
      attrs() {
        return derived(super.attrs(), ($baseAttrs) => {
          return {
            ...$baseAttrs,
            role: "row"
          };
        });
      }
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      isData() {
        return "__data" in this;
      }
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      isDisplay() {
        return "__display" in this;
      }
    };
    DataBodyRow = class _DataBodyRow extends BodyRow {
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      __data = true;
      dataId;
      original;
      constructor({ id: id2, dataId, original, cells, cellForId, depth = 0, parentRow }) {
        super({ id: id2, cells, cellForId, depth, parentRow });
        this.dataId = dataId;
        this.original = original;
      }
      clone({ includeCells = false, includeSubRows = false } = {}) {
        const clonedRow = new _DataBodyRow({
          id: this.id,
          dataId: this.dataId,
          cellForId: this.cellForId,
          cells: this.cells,
          original: this.original,
          depth: this.depth
        });
        if (includeCells) {
          const clonedCellsForId = Object.fromEntries(Object.entries(clonedRow.cellForId).map(([id2, cell]) => {
            const clonedCell = cell.clone();
            clonedCell.row = clonedRow;
            return [id2, clonedCell];
          }));
          const clonedCells = clonedRow.cells.map(({ id: id2 }) => clonedCellsForId[id2]);
          clonedRow.cellForId = clonedCellsForId;
          clonedRow.cells = clonedCells;
        }
        if (includeSubRows) {
          const clonedSubRows = this.subRows?.map((row) => row.clone({ includeCells, includeSubRows }));
          clonedRow.subRows = clonedSubRows;
        } else {
          clonedRow.subRows = this.subRows;
        }
        return clonedRow;
      }
    };
    getBodyRows = (data2, flatColumns, { rowDataId } = {}) => {
      const rows = data2.map((item, idx) => {
        const id2 = idx.toString();
        return new DataBodyRow({
          id: id2,
          dataId: rowDataId !== void 0 ? rowDataId(item, idx) : id2,
          original: item,
          cells: [],
          cellForId: {}
        });
      });
      data2.forEach((item, rowIdx) => {
        const cells = flatColumns.map((col) => {
          if (col.isData()) {
            const dataCol = col;
            const value = dataCol.getValue(item);
            return new DataBodyCell({
              row: rows[rowIdx],
              column: dataCol,
              label: col.cell,
              value
            });
          }
          if (col.isDisplay()) {
            const displayCol = col;
            return new DisplayBodyCell({
              row: rows[rowIdx],
              column: displayCol,
              label: col.cell
            });
          }
          throw new Error("Unrecognized `FlatColumn` implementation");
        });
        rows[rowIdx].cells = cells;
        flatColumns.forEach((c2, colIdx) => {
          rows[rowIdx].cellForId[c2.id] = cells[colIdx];
        });
      });
      return rows;
    };
    getColumnedBodyRows = (rows, columnIdOrder) => {
      const columnedRows = rows.map((row) => {
        const clonedRow = row.clone();
        clonedRow.cells = [];
        clonedRow.cellForId = {};
        return clonedRow;
      });
      if (rows.length === 0 || columnIdOrder.length === 0)
        return rows;
      rows.forEach((row, rowIdx) => {
        const cells = row.cells.map((cell) => {
          const clonedCell = cell.clone();
          clonedCell.row = columnedRows[rowIdx];
          return clonedCell;
        });
        const visibleCells = columnIdOrder.map((cid) => {
          return cells.find((c2) => c2.id === cid);
        }).filter(nonUndefined);
        columnedRows[rowIdx].cells = visibleCells;
        cells.forEach((cell) => {
          columnedRows[rowIdx].cellForId[cell.id] = cell;
        });
      });
      return columnedRows;
    };
    NBSP = " ";
    HeaderCell = class extends TableComponent {
      label;
      colspan;
      colstart;
      constructor({ id: id2, label, colspan, colstart }) {
        super({ id: id2 });
        this.label = label;
        this.colspan = colspan;
        this.colstart = colstart;
      }
      render() {
        if (this.label instanceof Function) {
          if (this.state === void 0) {
            throw new Error("Missing `state` reference");
          }
          return this.label(this, this.state);
        }
        return this.label;
      }
      attrs() {
        return derived(super.attrs(), ($baseAttrs) => {
          return {
            ...$baseAttrs,
            role: "columnheader",
            colspan: this.colspan
          };
        });
      }
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      isFlat() {
        return "__flat" in this;
      }
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      isData() {
        return "__data" in this;
      }
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      isFlatDisplay() {
        return "__flat" in this && "__display" in this;
      }
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      isGroup() {
        return "__group" in this;
      }
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      isGroupDisplay() {
        return "__group" in this && "__display" in this;
      }
    };
    FlatHeaderCell = class _FlatHeaderCell extends HeaderCell {
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      __flat = true;
      constructor({ id: id2, label, colstart }) {
        super({ id: id2, label, colspan: 1, colstart });
      }
      clone() {
        return new _FlatHeaderCell({
          id: this.id,
          label: this.label,
          colstart: this.colstart
        });
      }
    };
    DataHeaderCell = class _DataHeaderCell extends FlatHeaderCell {
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      __data = true;
      accessorKey;
      accessorFn;
      constructor({ id: id2, label, accessorKey, accessorFn, colstart }) {
        super({ id: id2, label, colstart });
        this.accessorKey = accessorKey;
        this.accessorFn = accessorFn;
      }
      clone() {
        return new _DataHeaderCell({
          id: this.id,
          label: this.label,
          accessorFn: this.accessorFn,
          accessorKey: this.accessorKey,
          colstart: this.colstart
        });
      }
    };
    FlatDisplayHeaderCell = class _FlatDisplayHeaderCell extends FlatHeaderCell {
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      __display = true;
      constructor({ id: id2, label = NBSP, colstart }) {
        super({ id: id2, label, colstart });
      }
      clone() {
        return new _FlatDisplayHeaderCell({
          id: this.id,
          label: this.label,
          colstart: this.colstart
        });
      }
    };
    GroupHeaderCell = class _GroupHeaderCell extends HeaderCell {
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      __group = true;
      ids;
      allId;
      allIds;
      constructor({ label, ids, allIds, colspan, colstart }) {
        super({ id: `[${ids.join(",")}]`, label, colspan, colstart });
        this.ids = ids;
        this.allId = `[${allIds.join(",")}]`;
        this.allIds = allIds;
      }
      setIds(ids) {
        this.ids = ids;
        this.id = `[${this.ids.join(",")}]`;
      }
      pushId(id2) {
        this.ids = [...this.ids, id2];
        this.id = `[${this.ids.join(",")}]`;
      }
      clone() {
        return new _GroupHeaderCell({
          label: this.label,
          ids: this.ids,
          allIds: this.allIds,
          colspan: this.colspan,
          colstart: this.colstart
        });
      }
    };
    GroupDisplayHeaderCell = class _GroupDisplayHeaderCell extends GroupHeaderCell {
      // TODO Workaround for https://github.com/vitejs/vite/issues/9528
      __display = true;
      constructor({ label = NBSP, ids, allIds, colspan = 1, colstart }) {
        super({ label, ids, allIds, colspan, colstart });
      }
      clone() {
        return new _GroupDisplayHeaderCell({
          label: this.label,
          ids: this.ids,
          allIds: this.allIds,
          colspan: this.colspan,
          colstart: this.colstart
        });
      }
    };
    sum = (nums) => nums.reduce((a2, b2) => a2 + b2, 0);
    getNullMatrix = (width, height) => {
      const result = [];
      for (let i3 = 0; i3 < height; i3++) {
        result.push(Array(width).fill(null));
      }
      return result;
    };
    getTransposed = (matrix) => {
      const height = matrix.length;
      if (height === 0) {
        return matrix;
      }
      const width = matrix[0].length;
      const result = getNullMatrix(height, width);
      for (let i3 = 0; i3 < width; i3++) {
        for (let j2 = 0; j2 < height; j2++) {
          result[i3][j2] = matrix[j2][i3];
        }
      }
      return result;
    };
    HeaderRow = class _HeaderRow extends TableComponent {
      cells;
      constructor({ id: id2, cells }) {
        super({ id: id2 });
        this.cells = cells;
      }
      attrs() {
        return derived(super.attrs(), ($baseAttrs) => {
          return {
            ...$baseAttrs,
            role: "row"
          };
        });
      }
      clone() {
        return new _HeaderRow({
          id: this.id,
          cells: this.cells
        });
      }
    };
    getHeaderRows = (columns, flatColumnIds = []) => {
      const rowMatrix = getHeaderRowMatrix(columns);
      let columnMatrix = getTransposed(rowMatrix);
      columnMatrix = getOrderedColumnMatrix(columnMatrix, flatColumnIds);
      populateGroupHeaderCellIds(columnMatrix);
      return headerRowsForRowMatrix(getTransposed(columnMatrix));
    };
    getHeaderRowMatrix = (columns) => {
      const maxColspan = sum(columns.map((c2) => c2.isGroup() ? c2.ids.length : 1));
      const maxHeight = Math.max(...columns.map((c2) => c2.height));
      const rowMatrix = getNullMatrix(maxColspan, maxHeight);
      let cellOffset = 0;
      columns.forEach((c2) => {
        const heightOffset = maxHeight - c2.height;
        loadHeaderRowMatrix(rowMatrix, c2, heightOffset, cellOffset);
        cellOffset += c2.isGroup() ? c2.ids.length : 1;
      });
      return rowMatrix.map((cells, rowIdx) => cells.map((cell, columnIdx) => {
        if (cell !== null)
          return cell;
        if (rowIdx === maxHeight - 1)
          return new FlatDisplayHeaderCell({ id: columnIdx.toString(), colstart: columnIdx });
        const flatId = rowMatrix[maxHeight - 1][columnIdx]?.id ?? columnIdx.toString();
        return new GroupDisplayHeaderCell({ ids: [], allIds: [flatId], colstart: columnIdx });
      }));
    };
    loadHeaderRowMatrix = (rowMatrix, column, rowOffset, cellOffset) => {
      if (column.isData()) {
        rowMatrix[rowMatrix.length - 1][cellOffset] = new DataHeaderCell({
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          label: column.header,
          accessorFn: column.accessorFn,
          accessorKey: column.accessorKey,
          id: column.id,
          colstart: cellOffset
        });
        return;
      }
      if (column.isDisplay()) {
        rowMatrix[rowMatrix.length - 1][cellOffset] = new FlatDisplayHeaderCell({
          id: column.id,
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          label: column.header,
          colstart: cellOffset
        });
        return;
      }
      if (column.isGroup()) {
        for (let i3 = 0; i3 < column.ids.length; i3++) {
          rowMatrix[rowOffset][cellOffset + i3] = new GroupHeaderCell({
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            label: column.header,
            colspan: 1,
            allIds: column.ids,
            ids: [],
            colstart: cellOffset
          });
        }
        let childCellOffset = 0;
        column.columns.forEach((c2) => {
          loadHeaderRowMatrix(rowMatrix, c2, rowOffset + 1, cellOffset + childCellOffset);
          childCellOffset += c2.isGroup() ? c2.ids.length : 1;
        });
        return;
      }
    };
    getOrderedColumnMatrix = (columnMatrix, flatColumnIds) => {
      if (flatColumnIds.length === 0) {
        return columnMatrix;
      }
      const orderedColumnMatrix = [];
      flatColumnIds.forEach((key2, columnIdx) => {
        const nextColumn = columnMatrix.find((columnCells) => {
          const flatCell = columnCells[columnCells.length - 1];
          if (!flatCell.isFlat()) {
            throw new Error("The last element of each column must be a `FlatHeaderCell`");
          }
          return flatCell.id === key2;
        });
        if (nextColumn !== void 0) {
          orderedColumnMatrix.push(nextColumn.map((column) => {
            const clonedColumn = column.clone();
            clonedColumn.colstart = columnIdx;
            return clonedColumn;
          }));
        }
      });
      return orderedColumnMatrix;
    };
    populateGroupHeaderCellIds = (columnMatrix) => {
      columnMatrix.forEach((columnCells) => {
        const lastCell = columnCells[columnCells.length - 1];
        if (!lastCell.isFlat()) {
          throw new Error("The last element of each column must be a `FlatHeaderCell`");
        }
        columnCells.forEach((c2) => {
          if (c2.isGroup()) {
            c2.pushId(lastCell.id);
          }
        });
      });
    };
    headerRowsForRowMatrix = (rowMatrix) => {
      return rowMatrix.map((rowCells, rowIdx) => {
        return new HeaderRow({ id: rowIdx.toString(), cells: getMergedRow(rowCells) });
      });
    };
    getMergedRow = (cells) => {
      if (cells.length === 0) {
        return cells;
      }
      const mergedCells = [];
      let startIdx = 0;
      let endIdx = 1;
      while (startIdx < cells.length) {
        const cell = cells[startIdx].clone();
        if (!cell.isGroup()) {
          mergedCells.push(cell);
          startIdx++;
          continue;
        }
        endIdx = startIdx + 1;
        const ids = [...cell.ids];
        while (endIdx < cells.length) {
          const nextCell = cells[endIdx];
          if (!nextCell.isGroup()) {
            break;
          }
          if (cell.allId !== nextCell.allId) {
            break;
          }
          ids.push(...nextCell.ids);
          endIdx++;
        }
        cell.setIds(ids);
        cell.colspan = endIdx - startIdx;
        mergedCells.push(cell);
        startIdx = endIdx;
      }
      return mergedCells;
    };
    createViewModel = (table, columns, { rowDataId } = {}) => {
      const { data: data2, plugins } = table;
      const $flatColumns = getFlatColumns(columns);
      const flatColumns = readable($flatColumns);
      const originalRows = derived([data2, flatColumns], ([$data, $flatColumns2]) => {
        return getBodyRows($data, $flatColumns2, { rowDataId });
      });
      const _visibleColumns = writable([]);
      const _headerRows = writable();
      const _rows = writable([]);
      const _pageRows = writable([]);
      const _tableAttrs = writable({
        role: "table"
      });
      const _tableHeadAttrs = writable({});
      const _tableBodyAttrs = writable({
        role: "rowgroup"
      });
      const pluginInitTableState = {
        data: data2,
        columns,
        flatColumns: $flatColumns,
        tableAttrs: _tableAttrs,
        tableHeadAttrs: _tableHeadAttrs,
        tableBodyAttrs: _tableBodyAttrs,
        visibleColumns: _visibleColumns,
        headerRows: _headerRows,
        originalRows,
        rows: _rows,
        pageRows: _pageRows
      };
      const pluginInstances = Object.fromEntries(Object.entries(plugins).map(([pluginName, plugin]) => {
        const columnOptions = Object.fromEntries($flatColumns.map((c2) => {
          const option = c2.plugins?.[pluginName];
          if (option === void 0)
            return void 0;
          return [c2.id, option];
        }).filter(nonUndefined));
        return [
          pluginName,
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          plugin({ pluginName, tableState: pluginInitTableState, columnOptions })
        ];
      }));
      const pluginStates = Object.fromEntries(Object.entries(pluginInstances).map(([key2, pluginInstance]) => [
        key2,
        pluginInstance.pluginState
      ]));
      const tableState = {
        data: data2,
        columns,
        flatColumns: $flatColumns,
        tableAttrs: _tableAttrs,
        tableHeadAttrs: _tableHeadAttrs,
        tableBodyAttrs: _tableBodyAttrs,
        visibleColumns: _visibleColumns,
        headerRows: _headerRows,
        originalRows,
        rows: _rows,
        pageRows: _pageRows,
        pluginStates
      };
      const deriveTableAttrsFns = Object.values(pluginInstances).map((pluginInstance) => pluginInstance.deriveTableAttrs).filter(nonUndefined);
      let tableAttrs = readable({
        role: "table"
      });
      deriveTableAttrsFns.forEach((fn) => {
        tableAttrs = fn(tableAttrs);
      });
      const finalizedTableAttrs = derived(tableAttrs, ($tableAttrs) => {
        const $finalizedAttrs = finalizeAttributes($tableAttrs);
        _tableAttrs.set($finalizedAttrs);
        return $finalizedAttrs;
      });
      const deriveTableHeadAttrsFns = Object.values(pluginInstances).map((pluginInstance) => pluginInstance.deriveTableBodyAttrs).filter(nonUndefined);
      let tableHeadAttrs = readable({});
      deriveTableHeadAttrsFns.forEach((fn) => {
        tableHeadAttrs = fn(tableHeadAttrs);
      });
      const finalizedTableHeadAttrs = derived(tableHeadAttrs, ($tableHeadAttrs) => {
        const $finalizedAttrs = finalizeAttributes($tableHeadAttrs);
        _tableHeadAttrs.set($finalizedAttrs);
        return $finalizedAttrs;
      });
      const deriveTableBodyAttrsFns = Object.values(pluginInstances).map((pluginInstance) => pluginInstance.deriveTableBodyAttrs).filter(nonUndefined);
      let tableBodyAttrs = readable({
        role: "rowgroup"
      });
      deriveTableBodyAttrsFns.forEach((fn) => {
        tableBodyAttrs = fn(tableBodyAttrs);
      });
      const finalizedTableBodyAttrs = derived(tableBodyAttrs, ($tableBodyAttrs) => {
        const $finalizedAttrs = finalizeAttributes($tableBodyAttrs);
        _tableBodyAttrs.set($finalizedAttrs);
        return $finalizedAttrs;
      });
      const deriveFlatColumnsFns = Object.values(pluginInstances).map((pluginInstance) => pluginInstance.deriveFlatColumns).filter(nonUndefined);
      let visibleColumns = flatColumns;
      deriveFlatColumnsFns.forEach((fn) => {
        visibleColumns = fn(visibleColumns);
      });
      const injectedColumns = derived(visibleColumns, ($visibleColumns) => {
        _visibleColumns.set($visibleColumns);
        return $visibleColumns;
      });
      const columnedRows = derived([originalRows, injectedColumns], ([$originalRows, $injectedColumns]) => {
        return getColumnedBodyRows($originalRows, $injectedColumns.map((c2) => c2.id));
      });
      const deriveRowsFns = Object.values(pluginInstances).map((pluginInstance) => pluginInstance.deriveRows).filter(nonUndefined);
      let rows = columnedRows;
      deriveRowsFns.forEach((fn) => {
        rows = fn(rows);
      });
      const injectedRows = derived(rows, ($rows) => {
        $rows.forEach((row) => {
          row.injectState(tableState);
          row.cells.forEach((cell) => {
            cell.injectState(tableState);
          });
        });
        Object.entries(pluginInstances).forEach(([pluginName, pluginInstance]) => {
          $rows.forEach((row) => {
            if (pluginInstance.hooks?.["tbody.tr"] !== void 0) {
              row.applyHook(pluginName, pluginInstance.hooks["tbody.tr"](row));
            }
            row.cells.forEach((cell) => {
              if (pluginInstance.hooks?.["tbody.tr.td"] !== void 0) {
                cell.applyHook(pluginName, pluginInstance.hooks["tbody.tr.td"](cell));
              }
            });
          });
        });
        _rows.set($rows);
        return $rows;
      });
      const derivePageRowsFns = Object.values(pluginInstances).map((pluginInstance) => pluginInstance.derivePageRows).filter(nonUndefined);
      let pageRows = injectedRows;
      derivePageRowsFns.forEach((fn) => {
        pageRows = fn(pageRows);
      });
      const injectedPageRows = derived(pageRows, ($pageRows) => {
        $pageRows.forEach((row) => {
          row.injectState(tableState);
          row.cells.forEach((cell) => {
            cell.injectState(tableState);
          });
        });
        Object.entries(pluginInstances).forEach(([pluginName, pluginInstance]) => {
          $pageRows.forEach((row) => {
            if (pluginInstance.hooks?.["tbody.tr"] !== void 0) {
              row.applyHook(pluginName, pluginInstance.hooks["tbody.tr"](row));
            }
            row.cells.forEach((cell) => {
              if (pluginInstance.hooks?.["tbody.tr.td"] !== void 0) {
                cell.applyHook(pluginName, pluginInstance.hooks["tbody.tr.td"](cell));
              }
            });
          });
        });
        _pageRows.set($pageRows);
        return $pageRows;
      });
      const headerRows = derived(injectedColumns, ($injectedColumns) => {
        const $headerRows = getHeaderRows(columns, $injectedColumns.map((c2) => c2.id));
        $headerRows.forEach((row) => {
          row.injectState(tableState);
          row.cells.forEach((cell) => {
            cell.injectState(tableState);
          });
        });
        Object.entries(pluginInstances).forEach(([pluginName, pluginInstance]) => {
          $headerRows.forEach((row) => {
            if (pluginInstance.hooks?.["thead.tr"] !== void 0) {
              row.applyHook(pluginName, pluginInstance.hooks["thead.tr"](row));
            }
            row.cells.forEach((cell) => {
              if (pluginInstance.hooks?.["thead.tr.th"] !== void 0) {
                cell.applyHook(pluginName, pluginInstance.hooks["thead.tr.th"](cell));
              }
            });
          });
        });
        _headerRows.set($headerRows);
        return $headerRows;
      });
      return {
        tableAttrs: finalizedTableAttrs,
        tableHeadAttrs: finalizedTableHeadAttrs,
        tableBodyAttrs: finalizedTableBodyAttrs,
        visibleColumns: injectedColumns,
        flatColumns: $flatColumns,
        headerRows,
        originalRows,
        rows: injectedRows,
        pageRows: injectedPageRows,
        pluginStates
      };
    };
    Table$1 = class Table {
      data;
      plugins;
      constructor(data2, plugins) {
        this.data = data2;
        this.plugins = plugins;
      }
      createColumns(columns) {
        const ids = getFlatColumnIds(columns);
        const duplicateIds = getDuplicates(ids);
        if (duplicateIds.length !== 0) {
          throw new Error(`Duplicate column ids not allowed: "${duplicateIds.join('", "')}"`);
        }
        return columns;
      }
      column(def) {
        return new DataColumn(def);
      }
      group(def) {
        return new GroupColumn(def);
      }
      display(def) {
        return new DisplayColumn(def);
      }
      createViewModel(columns, options2) {
        return createViewModel(this, columns, options2);
      }
    };
    createTable = (data2, plugins = {}) => {
      return new Table$1(data2, plugins);
    };
    getTokens = (key2) => {
      let keyWithoutBracket = key2.replace(/\[(\d+)\]/g, ".$1");
      if (keyWithoutBracket.startsWith(".")) {
        keyWithoutBracket = keyWithoutBracket.slice(1);
      }
      return keyWithoutBracket.split(".");
    };
    getNested = (root, keyTokens) => {
      let current = root;
      for (const key2 of keyTokens) {
        if (current == null) {
          return void 0;
        }
        current = current[key2];
      }
      return current;
    };
    clonedWithPrototype = (source) => {
      const clone3 = Object.create(source);
      Object.assign(clone3, source);
      return clone3;
    };
    getFilteredRows$1 = (rows, filterValues, columnOptions) => {
      const $filteredRows = rows.map((row) => {
        const { subRows } = row;
        if (subRows === void 0) {
          return row;
        }
        const filteredSubRows = getFilteredRows$1(subRows, filterValues, columnOptions);
        const clonedRow = row.clone();
        clonedRow.subRows = filteredSubRows;
        return clonedRow;
      }).filter((row) => {
        if ((row.subRows?.length ?? 0) !== 0) {
          return true;
        }
        for (const [columnId, columnOption] of Object.entries(columnOptions)) {
          const bodyCell = row.cellForId[columnId];
          if (!bodyCell.isData()) {
            continue;
          }
          const { value } = bodyCell;
          const filterValue = filterValues[columnId];
          if (filterValue === void 0) {
            continue;
          }
          const isMatch = columnOption.fn({ value, filterValue });
          if (!isMatch) {
            return false;
          }
        }
        return true;
      });
      return $filteredRows;
    };
    addColumnFilters = ({ serverSide = false } = {}) => ({ columnOptions, tableState }) => {
      const filterValues = writable({});
      const preFilteredRows = writable([]);
      const filteredRows = writable([]);
      const pluginState = { filterValues, preFilteredRows };
      const deriveRows = (rows) => {
        return derived([rows, filterValues], ([$rows, $filterValues]) => {
          preFilteredRows.set($rows);
          if (serverSide) {
            filteredRows.set($rows);
            return $rows;
          }
          const _filteredRows = getFilteredRows$1($rows, $filterValues, columnOptions);
          filteredRows.set(_filteredRows);
          return _filteredRows;
        });
      };
      return {
        pluginState,
        deriveRows,
        hooks: {
          "thead.tr.th": (headerCell) => {
            const filterValue = keyed(filterValues, headerCell.id);
            const props = derived([], () => {
              const columnOption = columnOptions[headerCell.id];
              if (columnOption === void 0) {
                return void 0;
              }
              filterValue.set(columnOption.initialFilterValue);
              const preFilteredValues = derived(preFilteredRows, ($rows) => {
                if (headerCell.isData()) {
                  return $rows.map((row) => {
                    const cell = row.cellForId[headerCell.id];
                    return cell?.value;
                  });
                }
                return [];
              });
              const values = derived(filteredRows, ($rows) => {
                if (headerCell.isData()) {
                  return $rows.map((row) => {
                    const cell = row.cellForId[headerCell.id];
                    return cell?.value;
                  });
                }
                return [];
              });
              const render = columnOption.render?.({
                id: headerCell.id,
                filterValue,
                ...tableState,
                values,
                preFilteredRows,
                preFilteredValues
              });
              return { render };
            });
            return { props };
          }
        }
      };
    };
    textPrefixFilter = ({ filterValue, value }) => {
      if (filterValue === "") {
        return true;
      }
      return String(value).toLowerCase().startsWith(String(filterValue).toLowerCase());
    };
    readable(void 0);
    recordSetStore = (initial2 = {}) => {
      const withFalseRemoved = (record) => {
        return Object.fromEntries(Object.entries(record).filter(([, v3]) => v3));
      };
      const { subscribe: subscribe2, update: update2, set } = writable(withFalseRemoved(initial2));
      const updateAndRemoveFalse = (fn) => {
        update2(($recordSet) => {
          const newRecordSet = fn($recordSet);
          return withFalseRemoved(newRecordSet);
        });
      };
      const toggle2 = (item) => {
        update2(($recordSet) => {
          if ($recordSet[item] === true) {
            delete $recordSet[item];
            return $recordSet;
          }
          return {
            ...$recordSet,
            [item]: true
          };
        });
      };
      const add = (item) => {
        update2(($recordSet) => ({
          ...$recordSet,
          [item]: true
        }));
      };
      const addAll = (items) => {
        update2(($recordSet) => ({
          ...$recordSet,
          ...Object.fromEntries(items.map((item) => [item, true]))
        }));
      };
      const remove = (item) => {
        update2(($recordSet) => {
          delete $recordSet[item];
          return $recordSet;
        });
      };
      const removeAll = (items) => {
        update2(($recordSet) => {
          for (const item of items) {
            delete $recordSet[item];
          }
          return $recordSet;
        });
      };
      const clear = () => {
        set({});
      };
      return {
        subscribe: subscribe2,
        update: updateAndRemoveFalse,
        set: (newValue) => updateAndRemoveFalse(() => newValue),
        toggle: toggle2,
        add,
        addAll,
        remove,
        removeAll,
        clear
      };
    };
    isShiftClick = (event) => {
      if (!(event instanceof MouseEvent))
        return false;
      return event.shiftKey;
    };
    addHiddenColumns = ({ initialHiddenColumnIds = [] } = {}) => () => {
      const hiddenColumnIds = writable(initialHiddenColumnIds);
      const pluginState = { hiddenColumnIds };
      const deriveFlatColumns = (flatColumns) => {
        return derived([flatColumns, hiddenColumnIds], ([$flatColumns, $hiddenColumnIds]) => {
          if ($hiddenColumnIds.length === 0) {
            return $flatColumns;
          }
          return $flatColumns.filter((c2) => !$hiddenColumnIds.includes(c2.id));
        });
      };
      return {
        pluginState,
        deriveFlatColumns
      };
    };
    MIN_PAGE_SIZE = 1;
    createPageStore = ({ items, initialPageSize, initialPageIndex, serverSide, serverItemCount }) => {
      const pageSize = writable(initialPageSize);
      const updatePageSize = (fn) => {
        pageSize.update(($pageSize) => {
          const newPageSize = fn($pageSize);
          return Math.max(newPageSize, MIN_PAGE_SIZE);
        });
      };
      const setPageSize = (newPageSize) => updatePageSize(() => newPageSize);
      const pageIndex = writable(initialPageIndex);
      function calcPageCountAndLimitIndex([$pageSize, $itemCount]) {
        const $pageCount = Math.ceil($itemCount / $pageSize);
        pageIndex.update(($pageIndex) => {
          if ($pageCount > 0 && $pageIndex >= $pageCount) {
            return $pageCount - 1;
          }
          return $pageIndex;
        });
        return $pageCount;
      }
      let pageCount;
      if (serverSide && serverItemCount != null) {
        pageCount = derived([pageSize, serverItemCount], calcPageCountAndLimitIndex);
      } else {
        const itemCount = derived(items, ($items) => $items.length);
        pageCount = derived([pageSize, itemCount], calcPageCountAndLimitIndex);
      }
      const hasPreviousPage = derived(pageIndex, ($pageIndex) => {
        return $pageIndex > 0;
      });
      const hasNextPage = derived([pageIndex, pageCount], ([$pageIndex, $pageCount]) => {
        return $pageIndex < $pageCount - 1;
      });
      return {
        pageSize: {
          subscribe: pageSize.subscribe,
          update: updatePageSize,
          set: setPageSize
        },
        pageIndex,
        pageCount,
        serverItemCount,
        hasPreviousPage,
        hasNextPage
      };
    };
    addPagination = ({ initialPageIndex = 0, initialPageSize = 10, serverSide = false, serverItemCount } = {}) => () => {
      const prePaginatedRows = writable([]);
      const paginatedRows = writable([]);
      const { pageSize, pageIndex, pageCount, hasPreviousPage, hasNextPage } = createPageStore({
        items: prePaginatedRows,
        initialPageIndex,
        initialPageSize,
        serverSide,
        serverItemCount
      });
      const pluginState = {
        pageSize,
        pageIndex,
        pageCount,
        hasPreviousPage,
        hasNextPage
      };
      const derivePageRows = (rows) => {
        return derived([rows, pageSize, pageIndex], ([$rows, $pageSize, $pageIndex]) => {
          prePaginatedRows.set($rows);
          if (serverSide) {
            paginatedRows.set($rows);
            return $rows;
          }
          const startIdx = $pageIndex * $pageSize;
          const _paginatedRows = $rows.slice(startIdx, startIdx + $pageSize);
          paginatedRows.set(_paginatedRows);
          return _paginatedRows;
        });
      };
      return {
        pluginState,
        derivePageRows
      };
    };
    compare2 = (a2, b2) => {
      if (Array.isArray(a2) && Array.isArray(b2)) {
        return compareArray(a2, b2);
      }
      if (typeof a2 === "number" && typeof b2 === "number")
        return a2 - b2;
      return a2 < b2 ? -1 : a2 > b2 ? 1 : 0;
    };
    compareArray = (a2, b2) => {
      const minLength = Math.min(a2.length, b2.length);
      for (let i3 = 0; i3 < minLength; i3++) {
        const order = compare2(a2[i3], b2[i3]);
        if (order !== 0)
          return order;
      }
      return 0;
    };
    DEFAULT_TOGGLE_ORDER = ["asc", "desc", void 0];
    createSortKeysStore = (initKeys) => {
      const { subscribe: subscribe2, update: update2, set } = writable(initKeys);
      const toggleId = (id2, { multiSort = true, toggleOrder = DEFAULT_TOGGLE_ORDER } = {}) => {
        update2(($sortKeys) => {
          const keyIdx = $sortKeys.findIndex((key22) => key22.id === id2);
          const key2 = $sortKeys[keyIdx];
          const order = key2?.order;
          const orderIdx = toggleOrder.findIndex((o2) => o2 === order);
          const nextOrderIdx = (orderIdx + 1) % toggleOrder.length;
          const nextOrder = toggleOrder[nextOrderIdx];
          if (!multiSort) {
            if (nextOrder === void 0) {
              return [];
            }
            return [{ id: id2, order: nextOrder }];
          }
          if (keyIdx === -1 && nextOrder !== void 0) {
            return [...$sortKeys, { id: id2, order: nextOrder }];
          }
          if (nextOrder === void 0) {
            return [...$sortKeys.slice(0, keyIdx), ...$sortKeys.slice(keyIdx + 1)];
          }
          return [
            ...$sortKeys.slice(0, keyIdx),
            { id: id2, order: nextOrder },
            ...$sortKeys.slice(keyIdx + 1)
          ];
        });
      };
      const clearId = (id2) => {
        update2(($sortKeys) => {
          const keyIdx = $sortKeys.findIndex((key2) => key2.id === id2);
          if (keyIdx === -1) {
            return $sortKeys;
          }
          return [...$sortKeys.slice(0, keyIdx), ...$sortKeys.slice(keyIdx + 1)];
        });
      };
      return {
        subscribe: subscribe2,
        update: update2,
        set,
        toggleId,
        clearId
      };
    };
    getSortedRows = (rows, sortKeys, columnOptions) => {
      const $sortedRows = [...rows];
      $sortedRows.sort((a2, b2) => {
        for (const key2 of sortKeys) {
          const invert = columnOptions[key2.id]?.invert ?? false;
          const cellA = a2.cellForId[key2.id];
          const cellB = b2.cellForId[key2.id];
          let order = 0;
          const compareFn = columnOptions[key2.id]?.compareFn;
          const getSortValue = columnOptions[key2.id]?.getSortValue;
          if (!cellA.isData()) {
            return 0;
          }
          const valueA = cellA.value;
          const valueB = cellB.value;
          if (compareFn !== void 0) {
            order = compareFn(valueA, valueB);
          } else if (getSortValue !== void 0) {
            const sortValueA = getSortValue(valueA);
            const sortValueB = getSortValue(valueB);
            order = compare2(sortValueA, sortValueB);
          } else if (typeof valueA === "string" || typeof valueA === "number") {
            order = compare2(valueA, valueB);
          } else if (valueA instanceof Date || valueB instanceof Date) {
            const sortValueA = valueA instanceof Date ? valueA.getTime() : 0;
            const sortValueB = valueB instanceof Date ? valueB.getTime() : 0;
            order = compare2(sortValueA, sortValueB);
          }
          if (order !== 0) {
            let orderFactor = 1;
            if (key2.order === "desc") {
              orderFactor *= -1;
            }
            if (invert) {
              orderFactor *= -1;
            }
            return order * orderFactor;
          }
        }
        return 0;
      });
      for (let i3 = 0; i3 < $sortedRows.length; i3++) {
        const { subRows } = $sortedRows[i3];
        if (subRows === void 0) {
          continue;
        }
        const sortedSubRows = getSortedRows(subRows, sortKeys, columnOptions);
        const clonedRow = $sortedRows[i3].clone();
        clonedRow.subRows = sortedSubRows;
        $sortedRows[i3] = clonedRow;
      }
      return $sortedRows;
    };
    addSortBy = ({ initialSortKeys = [], disableMultiSort = false, isMultiSortEvent = isShiftClick, toggleOrder, serverSide = false } = {}) => ({ columnOptions }) => {
      const disabledSortIds = Object.entries(columnOptions).filter(([, option]) => option.disable === true).map(([columnId]) => columnId);
      const sortKeys = createSortKeysStore(initialSortKeys);
      const preSortedRows = writable([]);
      const deriveRows = (rows) => {
        return derived([rows, sortKeys], ([$rows, $sortKeys]) => {
          preSortedRows.set($rows);
          if (serverSide) {
            return $rows;
          }
          return getSortedRows($rows, $sortKeys, columnOptions);
        });
      };
      const pluginState = { sortKeys, preSortedRows };
      return {
        pluginState,
        deriveRows,
        hooks: {
          "thead.tr.th": (cell) => {
            const disabled = disabledSortIds.includes(cell.id);
            const props = derived(sortKeys, ($sortKeys) => {
              const key2 = $sortKeys.find((k2) => k2.id === cell.id);
              const toggle2 = (event) => {
                if (!cell.isData())
                  return;
                if (disabled)
                  return;
                sortKeys.toggleId(cell.id, {
                  multiSort: disableMultiSort ? false : isMultiSortEvent(event),
                  toggleOrder
                });
              };
              const clear = () => {
                if (!cell.isData())
                  return;
                if (disabledSortIds.includes(cell.id))
                  return;
                sortKeys.clearId(cell.id);
              };
              return {
                order: key2?.order,
                toggle: toggle2,
                clear,
                disabled
              };
            });
            return { props };
          },
          "tbody.tr.td": (cell) => {
            const props = derived(sortKeys, ($sortKeys) => {
              const key2 = $sortKeys.find((k2) => k2.id === cell.id);
              return {
                order: key2?.order
              };
            });
            return { props };
          }
        }
      };
    };
    getFilteredRows = (rows, filterValue, columnOptions, { tableCellMatches, fn, includeHiddenColumns }) => {
      const $filteredRows = rows.map((row) => {
        const { subRows } = row;
        if (subRows === void 0) {
          return row;
        }
        const filteredSubRows = getFilteredRows(subRows, filterValue, columnOptions, {
          tableCellMatches,
          fn,
          includeHiddenColumns
        });
        const clonedRow = row.clone();
        clonedRow.subRows = filteredSubRows;
        return clonedRow;
      }).filter((row) => {
        if ((row.subRows?.length ?? 0) !== 0) {
          return true;
        }
        const rowCellMatches = Object.values(row.cellForId).map((cell) => {
          const options2 = columnOptions[cell.id];
          if (options2?.exclude === true) {
            return false;
          }
          const isHidden3 = row.cells.find((c2) => c2.id === cell.id) === void 0;
          if (isHidden3 && !includeHiddenColumns) {
            return false;
          }
          if (!cell.isData()) {
            return false;
          }
          let value = cell.value;
          if (options2?.getFilterValue !== void 0) {
            value = options2?.getFilterValue(value);
          }
          const matches2 = fn({ value: String(value), filterValue });
          if (matches2) {
            const dataRowColId = cell.dataRowColId();
            if (dataRowColId !== void 0) {
              tableCellMatches[dataRowColId] = matches2;
            }
          }
          return matches2;
        });
        return rowCellMatches.includes(true);
      });
      return $filteredRows;
    };
    addTableFilter = ({ fn = textPrefixFilter, initialFilterValue = "", includeHiddenColumns = false, serverSide = false } = {}) => ({ columnOptions }) => {
      const filterValue = writable(initialFilterValue);
      const preFilteredRows = writable([]);
      const tableCellMatches = recordSetStore();
      const pluginState = { filterValue, preFilteredRows };
      const deriveRows = (rows) => {
        return derived([rows, filterValue], ([$rows, $filterValue]) => {
          preFilteredRows.set($rows);
          tableCellMatches.clear();
          const $tableCellMatches = {};
          const $filteredRows = getFilteredRows($rows, $filterValue, columnOptions, {
            tableCellMatches: $tableCellMatches,
            fn,
            includeHiddenColumns
          });
          tableCellMatches.set($tableCellMatches);
          if (serverSide) {
            return $rows;
          }
          return $filteredRows;
        });
      };
      return {
        pluginState,
        deriveRows,
        hooks: {
          "tbody.tr.td": (cell) => {
            const props = derived([filterValue, tableCellMatches], ([$filterValue, $tableCellMatches]) => {
              const dataRowColId = cell.dataRowColId();
              return {
                matches: $filterValue !== "" && dataRowColId !== void 0 && ($tableCellMatches[dataRowColId] ?? false)
              };
            });
            return { props };
          }
        }
      };
    };
    Table2 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class"]);
      let { class: className = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      return `<div class="w-full overflow-auto"><table${spread(
        [
          {
            class: escape_attribute_value(cn("w-full caption-bottom text-sm", className))
          },
          escape_object($$restProps)
        ],
        {}
      )}>${slots.default ? slots.default({}) : ``}</table></div>`;
    });
    Table_body = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class"]);
      let { class: className = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      return `<tbody${spread(
        [
          {
            class: escape_attribute_value(cn("[&_tr:last-child]:border-0", className))
          },
          escape_object($$restProps)
        ],
        {}
      )}>${slots.default ? slots.default({}) : ``}</tbody>`;
    });
    Table_cell = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class"]);
      let { class: className = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      return `<td${spread(
        [
          {
            class: escape_attribute_value(cn("p-2 align-middle [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]", className))
          },
          escape_object($$restProps)
        ],
        {}
      )}>${slots.default ? slots.default({}) : ``}</td>`;
    });
    Table_head = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class"]);
      let { class: className = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      return `<th${spread(
        [
          {
            class: escape_attribute_value(cn("h-10 px-2 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]", className))
          },
          escape_object($$restProps)
        ],
        {}
      )}>${slots.default ? slots.default({}) : ``}</th>`;
    });
    Table_header = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class"]);
      let { class: className = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      return ` <thead${spread(
        [
          {
            class: escape_attribute_value(cn("[&_tr]:border-b", className))
          },
          escape_object($$restProps)
        ],
        {}
      )}>${slots.default ? slots.default({}) : ``}</thead>`;
    });
    Table_row = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class"]);
      let { class: className = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      return `<tr${spread(
        [
          {
            class: escape_attribute_value(cn("border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted", className))
          },
          escape_object($$restProps)
        ],
        {}
      )}>${slots.default ? slots.default({}) : ``}</tr>`;
    });
    Dropdown_menu_label = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class", "inset"]);
      let { class: className = void 0 } = $$props;
      let { inset = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.inset === void 0 && $$bindings.inset && inset !== void 0)
        $$bindings.inset(inset);
      return `${validate_component(Menu_label, "DropdownMenuPrimitive.Label").$$render(
        $$result,
        Object.assign(
          {},
          {
            class: cn("px-2 py-1.5 text-sm font-semibold", inset && "pl-8", className)
          },
          $$restProps
        ),
        {},
        {
          default: () => {
            return `${slots.default ? slots.default({}) : ``}`;
          }
        }
      )}`;
    });
    Dropdown_menu_content = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class", "sideOffset", "transition", "transitionConfig"]);
      let { class: className = void 0 } = $$props;
      let { sideOffset = 4 } = $$props;
      let { transition = flyAndScale } = $$props;
      let { transitionConfig = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.sideOffset === void 0 && $$bindings.sideOffset && sideOffset !== void 0)
        $$bindings.sideOffset(sideOffset);
      if ($$props.transition === void 0 && $$bindings.transition && transition !== void 0)
        $$bindings.transition(transition);
      if ($$props.transitionConfig === void 0 && $$bindings.transitionConfig && transitionConfig !== void 0)
        $$bindings.transitionConfig(transitionConfig);
      return `${validate_component(Menu_content, "DropdownMenuPrimitive.Content").$$render(
        $$result,
        Object.assign(
          {},
          { transition },
          { transitionConfig },
          { sideOffset },
          {
            class: cn("z-50 min-w-[8rem] rounded-md border bg-popover p-1 text-popover-foreground shadow-md focus:outline-none", className)
          },
          $$restProps
        ),
        {},
        {
          default: () => {
            return `${slots.default ? slots.default({}) : ``}`;
          }
        }
      )}`;
    });
    Dropdown_menu_separator = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class"]);
      let { class: className = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      return `${validate_component(Menu_separator, "DropdownMenuPrimitive.Separator").$$render(
        $$result,
        Object.assign(
          {},
          {
            class: cn("-mx-1 my-1 h-px bg-muted", className)
          },
          $$restProps
        ),
        {},
        {}
      )}`;
    });
    Dropdown_menu_checkbox_item = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class", "checked"]);
      let { class: className = void 0 } = $$props;
      let { checked = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.checked === void 0 && $$bindings.checked && checked !== void 0)
        $$bindings.checked(checked);
      let $$settled;
      let $$rendered;
      let previous_head = $$result.head;
      do {
        $$settled = true;
        $$result.head = previous_head;
        $$rendered = `${validate_component(Menu_checkbox_item, "DropdownMenuPrimitive.CheckboxItem").$$render(
          $$result,
          Object.assign(
            {},
            {
              class: cn("relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none data-[disabled]:pointer-events-none data-[highlighted]:bg-accent data-[highlighted]:text-accent-foreground data-[disabled]:opacity-50", className)
            },
            $$restProps,
            { checked }
          ),
          {
            checked: ($$value) => {
              checked = $$value;
              $$settled = false;
            }
          },
          {
            default: () => {
              return `<span class="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">${validate_component(Menu_checkbox_indicator, "DropdownMenuPrimitive.CheckboxIndicator").$$render($$result, {}, {}, {
                default: () => {
                  return `${validate_component(Check$1, "Check").$$render($$result, { class: "h-4 w-4" }, {}, {})}`;
                }
              })}</span> ${slots.default ? slots.default({}) : ``}`;
            }
          }
        )}`;
      } while (!$$settled);
      return $$rendered;
    });
    Root4 = Menu;
    Trigger3 = Menu_trigger;
    Data_table_print = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { data: data2 } = $$props;
      if ($$props.data === void 0 && $$bindings.data && data2 !== void 0)
        $$bindings.data(data2);
      return `${validate_component(Table2, "Table").$$render(
        $$result,
        {
          class: "border-collapse border border-black"
        },
        {},
        {
          default: () => {
            return `${validate_component(Table_header, "TableHeader").$$render($$result, {}, {}, {
              default: () => {
                return `${validate_component(Table_row, "TableRow").$$render($$result, { class: "bg-[#7030A0]" }, {}, {
                  default: () => {
                    return `${validate_component(Table_head, "TableHead").$$render(
                      $$result,
                      {
                        class: "w-[50px] border border-black text-center text-lg font-bold text-white"
                      },
                      {},
                      {
                        default: () => {
                          return `NO.`;
                        }
                      }
                    )} ${validate_component(Table_head, "TableHead").$$render(
                      $$result,
                      {
                        class: "border border-black text-center text-lg font-bold text-white"
                      },
                      {},
                      {
                        default: () => {
                          return `PEKERJAAN`;
                        }
                      }
                    )} ${validate_component(Table_head, "TableHead").$$render(
                      $$result,
                      {
                        class: "border border-black text-center text-lg font-bold text-white"
                      },
                      {},
                      {
                        default: () => {
                          return `PELAKSANA`;
                        }
                      }
                    )} ${validate_component(Table_head, "TableHead").$$render(
                      $$result,
                      {
                        class: "border border-black text-center text-lg font-bold text-white"
                      },
                      {},
                      {
                        default: () => {
                          return `STATUS`;
                        }
                      }
                    )}`;
                  }
                })}`;
              }
            })} ${validate_component(Table_body, "TableBody").$$render($$result, { class: "font-semibold text-black" }, {}, {
              default: () => {
                return `${each(data2, ({ id: id2, pekerjaan, spk, pelaksana, status }) => {
                  return `${validate_component(Table_row, "TableRow").$$render($$result, { class: "border-none" }, {}, {
                    default: () => {
                      return `${validate_component(Table_cell, "TableCell").$$render(
                        $$result,
                        {
                          class: "border-t border-black text-center"
                        },
                        {},
                        {
                          default: () => {
                            return `${escape(id2)}.`;
                          }
                        }
                      )} ${validate_component(Table_cell, "TableCell").$$render($$result, { class: "border border-black" }, {}, {
                        default: () => {
                          return `${escape(pekerjaan)}`;
                        }
                      })} ${validate_component(Table_cell, "TableCell").$$render($$result, { class: "border border-black" }, {}, {
                        default: () => {
                          return `${escape(pelaksana)}`;
                        }
                      })} ${validate_component(Table_cell, "TableCell").$$render(
                        $$result,
                        {
                          class: cn("border-t border-black text-center", status === "Finish" && "bg-[#FFFF00]")
                        },
                        {},
                        {
                          default: () => {
                            return `${escape(status)} `;
                          }
                        }
                      )} `;
                    }
                  })} ${validate_component(Table_row, "TableRow").$$render($$result, {}, {}, {
                    default: () => {
                      return `${validate_component(Table_cell, "TableCell").$$render($$result, {}, {}, {})} ${validate_component(Table_cell, "TableCell").$$render($$result, { class: "border border-black" }, {}, {
                        default: () => {
                          return `SPK`;
                        }
                      })} ${validate_component(Table_cell, "TableCell").$$render($$result, { class: "border border-black" }, {}, {
                        default: () => {
                          return `${escape(spk)}`;
                        }
                      })} ${validate_component(Table_cell, "TableCell").$$render(
                        $$result,
                        {
                          class: cn(status === "Finish" && "bg-[#FFFF00]")
                        },
                        {},
                        {}
                      )} `;
                    }
                  })}`;
                })}`;
              }
            })}`;
          }
        }
      )}`;
    });
    data = [
      {
        "id": 1,
        "pekerjaan": "Gambar Arsitek",
        "spk": "K019/SPK-ARS/IV/2023",
        "pelaksana": "Anggraini Dini",
        "gambar": "",
        "status": "Finish"
      },
      {
        "id": 2,
        "pekerjaan": "Gambar Interior",
        "spk": "K019/SPK-IND/IV/2023",
        "pelaksana": "Nurul Septiani",
        "gambar": "",
        "status": "Finish"
      },
      {
        "id": 3,
        "pekerjaan": "Gambar Struktur",
        "spk": "K019/SPK-STR/IV/2023",
        "pelaksana": "Adnan Ardiansyah",
        "gambar": "",
        "status": "Finish"
      },
      {
        "id": 4,
        "pekerjaan": "Analisa Struktur",
        "spk": "K019/SPK-ENG/IV/2023",
        "pelaksana": "Dona Lisa",
        "gambar": "",
        "status": "Finish"
      },
      {
        "id": 5,
        "pekerjaan": "Rencana Anggaran",
        "spk": "K019/SPK-EST/IV/2023",
        "pelaksana": "Isnaini T Q",
        "gambar": "",
        "status": "Finish"
      },
      {
        "id": 6,
        "pekerjaan": "Jadwal Project",
        "spk": "K019/SPK-PLA/IV/2023",
        "pelaksana": "Isnaini T Q",
        "gambar": "",
        "status": "Finish"
      },
      {
        "id": 7,
        "pekerjaan": "Procurement",
        "spk": "K019/SPK-PRC/IV/2023",
        "pelaksana": "Hertia Lestari",
        "gambar": "",
        "status": "On Progress"
      },
      {
        "id": 8,
        "pekerjaan": "Konstruksi",
        "spk": "K019/SPK-PRO/IV/2022",
        "pelaksana": "M Jamaludin",
        "gambar": "",
        "status": "On Progress"
      },
      {
        "id": 9,
        "pekerjaan": "Interior",
        "spk": "K019/SPK-INT/IV/2022",
        "pelaksana": "Akbar Fauzi",
        "gambar": "",
        "status": "On Progress"
      }
    ];
    css3 = {
      code: "@page{size:auto;margin:0mm}@media print{body{visibility:hidden;-webkit-print-color-adjust:exact;print-color-adjust:exact}}",
      map: null
    };
    Data_table_toolbar = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $hiddenColumnIds, $$unsubscribe_hiddenColumnIds;
      let $filterValue, $$unsubscribe_filterValue;
      let { tableModel } = $$props;
      const { pluginStates, flatColumns } = tableModel;
      const { hiddenColumnIds } = pluginStates.hide;
      $$unsubscribe_hiddenColumnIds = subscribe(hiddenColumnIds, (value) => $hiddenColumnIds = value);
      const { filterValue } = pluginStates.filter;
      $$unsubscribe_filterValue = subscribe(filterValue, (value) => $filterValue = value);
      const ids = flatColumns.map((col) => col.id);
      const hidableCols = ["spk", "pelaksana", "status"];
      let hideForId = Object.fromEntries(ids.map((id2) => [id2, true]));
      if ($$props.tableModel === void 0 && $$bindings.tableModel && tableModel !== void 0)
        $$bindings.tableModel(tableModel);
      $$result.css.add(css3);
      let $$settled;
      let $$rendered;
      let previous_head = $$result.head;
      do {
        $$settled = true;
        $$result.head = previous_head;
        set_store_value(hiddenColumnIds, $hiddenColumnIds = Object.entries(hideForId).filter(([, hide2]) => !hide2).map(([id2]) => id2), $hiddenColumnIds);
        $$rendered = `<div class="flex flex-col items-center justify-between space-y-3 p-4 md:flex-row md:space-x-4 md:space-y-0"><div class="w-full md:w-1/2"><form class="flex items-center"><label for="simple-search" class="sr-only" data-svelte-h="svelte-1teuda">Search</label> <div class="relative w-full"><div class="pointer-events-none absolute inset-y-0 left-0 flex items-center pl-3">${validate_component(MagnifyingGlass$1, "MagnifyingGlass").$$render($$result, { class: "h-5 w-5 text-muted-foreground" }, {}, {})}</div> ${validate_component(Input, "Input").$$render(
          $$result,
          {
            type: "text",
            id: "simple-search",
            class: "bg-tertiary pl-10 text-sm transition-none focus-visible:ring-2",
            placeholder: "Search",
            required: true,
            value: $filterValue
          },
          {
            value: ($$value) => {
              $filterValue = $$value;
              $$settled = false;
            }
          },
          {}
        )}</div></form></div> <div class="flex w-full flex-shrink-0 flex-col items-stretch justify-end space-y-2 md:w-auto md:flex-row md:items-center md:space-x-3 md:space-y-0"><div class="flex w-full items-center space-x-3 md:w-auto">${validate_component(Button, "Button").$$render(
          $$result,
          {
            variant: "default",
            class: "w-full items-center focus-visible:ring-2 md:w-auto",
            type: "button"
          },
          {},
          {
            default: () => {
              return `${validate_component(Printer, "Printer").$$render($$result, { class: "-ml-0.5 mr-2 h-4 w-4" }, {}, {})}
				Print Data`;
            }
          }
        )}  ${validate_component(Root4, "DropdownMenu.Root").$$render($$result, {}, {}, {
          default: () => {
            return `${validate_component(Trigger3, "DropdownMenu.Trigger").$$render($$result, { asChild: true }, {}, {
              default: ({ builder }) => {
                return `${validate_component(Button, "Button").$$render(
                  $$result,
                  {
                    variant: "secondary",
                    class: "w-full items-center focus-visible:ring-2 md:w-auto",
                    type: "button",
                    builders: [builder]
                  },
                  {},
                  {
                    default: () => {
                      return `${validate_component(Plus, "Plus").$$render($$result, { class: "-ml-1 mr-1.5 h-4 w-4" }, {}, {})}
						Add Data`;
                    }
                  }
                )}`;
              }
            })} ${validate_component(Dropdown_menu_content, "DropdownMenu.Content").$$render($$result, {}, {}, {
              default: () => {
                return `${validate_component(Dropdown_menu_label, "DropdownMenu.Label").$$render($$result, {}, {}, {
                  default: () => {
                    return `Toggle columns`;
                  }
                })} ${validate_component(Dropdown_menu_separator, "DropdownMenu.Separator").$$render($$result, {}, {}, {})} ${each(flatColumns, (col) => {
                  return `${hidableCols.includes(col.id) ? `${validate_component(Dropdown_menu_checkbox_item, "DropdownMenu.CheckboxItem").$$render(
                    $$result,
                    { checked: hideForId[col.id] },
                    {
                      checked: ($$value) => {
                        hideForId[col.id] = $$value;
                        $$settled = false;
                      }
                    },
                    {
                      default: () => {
                        return `${escape(col.header)} `;
                      }
                    }
                  )}` : ``}`;
                })}`;
              }
            })}`;
          }
        })}</div></div></div> <div class="invisible fixed left-0 top-0 w-full p-6 print:visible" id="section-to-print">${validate_component(Data_table_print, "DataTablePrint").$$render($$result, { data }, {}, {})} </div>`;
      } while (!$$settled);
      $$unsubscribe_hiddenColumnIds();
      $$unsubscribe_filterValue();
      return $$rendered;
    });
    Data_table_actions = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `  ${validate_component(Root$1, "Dialog.Root").$$render($$result, {}, {}, {
        default: () => {
          return `${validate_component(Trigger, "Dialog.Trigger").$$render(
            $$result,
            {
              class: cn(buttonVariants({ variant: "ghost" }), "relative h-auto w-fit p-0.5 hover:bg-transparent")
            },
            {},
            {
              default: () => {
                return `<span class="sr-only" data-svelte-h="svelte-rsbkxi">Open menu</span> ${validate_component(Edit, "Edit").$$render($$result, { class: "h-[14px]" }, {}, {})}`;
              }
            }
          )} ${validate_component(Dialog_content, "Dialog.Content").$$render($$result, { class: "sm:max-w-[425px]" }, {}, {
            default: () => {
              return `${validate_component(Dialog_header, "Dialog.Header").$$render($$result, {}, {}, {
                default: () => {
                  return `${validate_component(Dialog_title, "Dialog.Title").$$render($$result, {}, {}, {
                    default: () => {
                      return `Edit Data`;
                    }
                  })}`;
                }
              })} ${validate_component(Dialog_footer, "Dialog.Footer").$$render($$result, {}, {}, {
                default: () => {
                  return `${validate_component(Button, "Button").$$render($$result, { type: "submit" }, {}, {
                    default: () => {
                      return `Save changes`;
                    }
                  })}`;
                }
              })}`;
            }
          })}`;
        }
      })}`;
    });
    Data_table_pagination = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $pageIndex, $$unsubscribe_pageIndex;
      let $pageCount, $$unsubscribe_pageCount;
      let $hasPreviousPage, $$unsubscribe_hasPreviousPage;
      let $hasNextPage, $$unsubscribe_hasNextPage;
      let { tableModel } = $$props;
      const { pluginStates } = tableModel;
      const { hasNextPage, hasPreviousPage, pageIndex, pageCount, pageSize } = pluginStates.page;
      $$unsubscribe_hasNextPage = subscribe(hasNextPage, (value) => $hasNextPage = value);
      $$unsubscribe_hasPreviousPage = subscribe(hasPreviousPage, (value) => $hasPreviousPage = value);
      $$unsubscribe_pageIndex = subscribe(pageIndex, (value) => $pageIndex = value);
      $$unsubscribe_pageCount = subscribe(pageCount, (value) => $pageCount = value);
      if ($$props.tableModel === void 0 && $$bindings.tableModel && tableModel !== void 0)
        $$bindings.tableModel(tableModel);
      $$unsubscribe_pageIndex();
      $$unsubscribe_pageCount();
      $$unsubscribe_hasPreviousPage();
      $$unsubscribe_hasNextPage();
      return `<div class="flex flex-col items-center justify-between gap-4 border-t p-4 min-[420px]:flex-row"><div class="flex w-full flex-1 items-center justify-between text-sm text-muted-foreground"><div class="flex items-center justify-center text-sm font-medium">Page ${escape($pageIndex + 1)} of ${escape($pageCount)}</div> <div class="flex items-center space-x-2"><p class="sr-only text-sm font-medium" data-svelte-h="svelte-qkerdp">Rows per page</p> ${validate_component(Root2, "Select.Root").$$render(
        $$result,
        {
          onSelectedChange: (selected) => pageSize.set(Number(selected?.value)),
          selected: { value: "9", label: "9" }
        },
        {},
        {
          default: () => {
            return `${validate_component(Select_trigger, "Select.Trigger").$$render($$result, { class: "w-[80px]" }, {}, {
              default: () => {
                return `${validate_component(Value, "Select.Value").$$render($$result, { placeholder: "Select page size" }, {}, {})}`;
              }
            })} ${validate_component(Select_content, "Select.Content").$$render($$result, {}, {}, {
              default: () => {
                return `${validate_component(Select_item, "Select.Item").$$render($$result, { value: "3" }, {}, {
                  default: () => {
                    return `3`;
                  }
                })} ${validate_component(Select_item, "Select.Item").$$render($$result, { value: "6" }, {}, {
                  default: () => {
                    return `6`;
                  }
                })} ${validate_component(Select_item, "Select.Item").$$render($$result, { value: "9" }, {}, {
                  default: () => {
                    return `9`;
                  }
                })}`;
              }
            })}`;
          }
        }
      )}</div></div> <ul class="inline-flex items-stretch -space-x-px"><li>${validate_component(Button, "Button").$$render(
        $$result,
        {
          variant: "outline",
          class: "rounded-r-none bg-transparent px-3 py-1.5",
          disabled: !$hasPreviousPage
        },
        {},
        {
          default: () => {
            return `<span class="sr-only" data-svelte-h="svelte-z31jm6">Previous</span> ${validate_component(ChevronLeft$1, "ChevronLeft").$$render($$result, { class: "h-4 w-4" }, {}, {})}`;
          }
        }
      )}</li> ${each({ length: $pageCount }, (_, i3) => {
        return `<li>${validate_component(Button, "Button").$$render(
          $$result,
          {
            variant: "ghost",
            class: cn("rounded-none border px-3.5 py-2", $pageIndex === i3 && "bg-accent"),
            disabled: $pageIndex === i3
          },
          {},
          {
            default: () => {
              return `${escape(i3 + 1)} `;
            }
          }
        )} </li>`;
      })} <li>${validate_component(Button, "Button").$$render(
        $$result,
        {
          variant: "outline",
          class: "rounded-l-none bg-transparent px-3 py-1.5",
          disabled: !$hasNextPage
        },
        {},
        {
          default: () => {
            return `<span class="sr-only" data-svelte-h="svelte-xiiv6y">Next</span> ${validate_component(ChevronRight$1, "ChevronRight").$$render($$result, { class: "h-4 w-4" }, {}, {})}`;
          }
        }
      )}</li></ul></div>`;
    });
    Data_table_column_header = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { props } = $$props;
      if ($$props.props === void 0 && $$bindings.props && props !== void 0)
        $$bindings.props(props);
      return `${!props.sort.disabled ? `<div class="flex items-center">${validate_component(Button, "Button").$$render(
        $$result,
        {
          variant: "ghost",
          class: "h-8 p-0 text-xs font-bold uppercase text-muted-foreground hover:bg-transparent data-[state=open]:bg-accent"
        },
        {},
        {
          default: () => {
            return `${slots.default ? slots.default({}) : ``} ${props.sort.order === "desc" ? `${validate_component(ArrowDown$1, "ArrowDown").$$render($$result, { class: "ml-2 h-4 w-4" }, {}, {})}` : `${props.sort.order === "asc" ? `${validate_component(ArrowUp$1, "ArrowUp").$$render($$result, { class: "ml-2 h-4 w-4" }, {}, {})}` : `${validate_component(CaretSort$1, "CaretSort").$$render($$result, { class: "ml-2 h-4 w-4" }, {}, {})}`}`}`;
          }
        }
      )}</div>` : `${slots.default ? slots.default({}) : ``}`}`;
    });
    Badge = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class", "href", "variant"]);
      let { class: className = void 0 } = $$props;
      let { href = void 0 } = $$props;
      let { variant = "default" } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.href === void 0 && $$bindings.href && href !== void 0)
        $$bindings.href(href);
      if ($$props.variant === void 0 && $$bindings.variant && variant !== void 0)
        $$bindings.variant(variant);
      return `${((tag) => {
        return tag ? `<${href ? "a" : "span"}${spread(
          [
            { href: escape_attribute_value(href) },
            {
              class: escape_attribute_value(cn(badgeVariants({ variant, className })))
            },
            escape_object($$restProps)
          ],
          {}
        )}>${is_void(tag) ? "" : `${slots.default ? slots.default({}) : ``}`}${is_void(tag) ? "" : `</${tag}>`}` : "";
      })(href ? "a" : "span")}`;
    });
    badgeVariants = ce2({
      base: "inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 select-none",
      variants: {
        variant: {
          default: "border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80",
          secondary: "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
          tertiary: "border-transparent bg-tertiary text-tertiary-foreground hover:bg-tertiary/80",
          destructive: "border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80",
          outline: "text-foreground"
        }
      },
      defaultVariants: {
        variant: "default"
      }
    });
    Data_table_status = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { status } = $$props;
      if ($$props.status === void 0 && $$bindings.status && status !== void 0)
        $$bindings.status(status);
      return `${validate_component(Badge, "Badge").$$render(
        $$result,
        {
          variant: status === "Finish" ? "secondary" : "tertiary",
          class: "rounded-full "
        },
        {},
        {
          default: () => {
            return `${escape(status)}`;
          }
        }
      )}`;
    });
    Data_table = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $tableAttrs, $$unsubscribe_tableAttrs;
      let $headerRows, $$unsubscribe_headerRows;
      let $tableBodyAttrs, $$unsubscribe_tableBodyAttrs;
      let $pageRows, $$unsubscribe_pageRows;
      let { data: data2 } = $$props;
      const table = createTable(readable(data2), {
        filter: addTableFilter({
          fn: ({ filterValue, value }) => value.toLowerCase().includes(filterValue.toLowerCase())
        }),
        sort: addSortBy({ toggleOrder: ["asc", "desc"] }),
        // todo: set this to localStorage
        page: addPagination({ initialPageSize: 9 }),
        colFilter: addColumnFilters(),
        hide: addHiddenColumns()
      });
      const columns = table.createColumns([
        table.column({ accessor: "id", header: "No", id: "no" }),
        table.column({
          accessor: "pekerjaan",
          header: "Pekerjaan"
        }),
        table.column({ accessor: "spk", header: "SPK" }),
        table.column({
          accessor: "pelaksana",
          header: "Pelaksana"
        }),
        table.column({
          accessor: "status",
          header: "Status",
          cell: ({ value }) => createRender(Data_table_status, { status: value })
        }),
        table.column({ accessor: "gambar", header: "Gambar" }),
        table.column({
          accessor: ({ id: id2 }) => id2,
          header: "",
          cell: ({ value }) => createRender(Data_table_actions, { id: value }),
          plugins: { sort: { disable: true } }
        })
      ]);
      const tableModel = table.createViewModel(columns);
      const { headerRows, pageRows, tableAttrs, tableBodyAttrs } = tableModel;
      $$unsubscribe_headerRows = subscribe(headerRows, (value) => $headerRows = value);
      $$unsubscribe_pageRows = subscribe(pageRows, (value) => $pageRows = value);
      $$unsubscribe_tableAttrs = subscribe(tableAttrs, (value) => $tableAttrs = value);
      $$unsubscribe_tableBodyAttrs = subscribe(tableBodyAttrs, (value) => $tableBodyAttrs = value);
      if ($$props.data === void 0 && $$bindings.data && data2 !== void 0)
        $$bindings.data(data2);
      $$unsubscribe_tableAttrs();
      $$unsubscribe_headerRows();
      $$unsubscribe_tableBodyAttrs();
      $$unsubscribe_pageRows();
      return `<div class="relative overflow-hidden rounded-lg bg-card shadow-md">${validate_component(Data_table_toolbar, "DataTableToolbar").$$render($$result, { tableModel }, {}, {})} ${validate_component(Table2, "Table.Root").$$render($$result, Object.assign({}, $tableAttrs, { class: "text-left" }), {}, {
        default: () => {
          return `${validate_component(Table_header, "Table.Header").$$render($$result, { class: "bg-tertiary border-t" }, {}, {
            default: () => {
              return `${each($headerRows, (headerRow) => {
                return `${validate_component(Subscribe, "Subscribe").$$render($$result, { rowAttrs: headerRow.attrs() }, {}, {
                  default: () => {
                    return `${validate_component(Table_row, "Table.Row").$$render($$result, {}, {}, {
                      default: () => {
                        return `${each(headerRow.cells, (cell) => {
                          return `${validate_component(Subscribe, "Subscribe").$$render($$result, { attrs: cell.attrs(), props: cell.props() }, {}, {
                            default: ({ attrs, props }) => {
                              return `${validate_component(Table_head, "Table.Head").$$render($$result, Object.assign({}, attrs, { class: "px-4" }), {}, {
                                default: () => {
                                  return `${validate_component(Data_table_column_header, "DataTableColumnHeader").$$render($$result, { props }, {}, {
                                    default: () => {
                                      return `${validate_component(Render, "Render").$$render($$result, { of: cell.render() }, {}, {})} `;
                                    }
                                  })} `;
                                }
                              })} `;
                            }
                          })}`;
                        })} `;
                      }
                    })} `;
                  }
                })}`;
              })}`;
            }
          })} ${validate_component(Table_body, "Table.Body").$$render($$result, Object.assign({}, $tableBodyAttrs), {}, {
            default: () => {
              return `${each($pageRows, (row) => {
                return `${validate_component(Subscribe, "Subscribe").$$render($$result, { rowAttrs: row.attrs() }, {}, {
                  default: ({ rowAttrs }) => {
                    return `${validate_component(Table_row, "Table.Row").$$render($$result, Object.assign({}, rowAttrs), {}, {
                      default: () => {
                        return `${each(row.cells, (cell) => {
                          return `${validate_component(Subscribe, "Subscribe").$$render($$result, { attrs: cell.attrs() }, {}, {
                            default: ({ attrs }) => {
                              return `${validate_component(Table_cell, "Table.Cell").$$render($$result, Object.assign({}, attrs, { class: "whitespace-nowrap px-4 py-3" }), {}, {
                                default: () => {
                                  return `${cell.id === "task" ? `${validate_component(Render, "Render").$$render($$result, { of: cell.render() }, {}, {})}` : `${cell.id === "" ? `<div class="flex justify-end">${validate_component(Render, "Render").$$render($$result, { of: cell.render() }, {}, {})} </div>` : `${validate_component(Render, "Render").$$render($$result, { of: cell.render() }, {}, {})}`}`} `;
                                }
                              })} `;
                            }
                          })}`;
                        })} `;
                      }
                    })} `;
                  }
                })}`;
              })}`;
            }
          })}`;
        }
      })} ${validate_component(Data_table_pagination, "DataTablePagination").$$render($$result, { tableModel }, {}, {})}</div>`;
    });
    Page9 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `<div class="mb-4 flex items-center"><h1 class="text-xl font-semibold" data-svelte-h="svelte-1ljq728">Tim Pelaksana</h1> ${validate_component(Mode_toggle, "ModeToggle").$$render($$result, {}, {}, {})}</div> ${validate_component(Data_table, "DataTable").$$render($$result, { data }, {}, {})}`;
    });
  }
});
var __exports13 = {};
__export(__exports13, {
  component: () => component13,
  fonts: () => fonts13,
  imports: () => imports13,
  index: () => index13,
  stylesheets: () => stylesheets13
});
var index13;
var component_cache13;
var component13;
var imports13;
var stylesheets13;
var fonts13;
var init__13 = __esm({
  ".svelte-kit/output/server/nodes/12.js"() {
    index13 = 12;
    component13 = async () => component_cache13 ??= (await Promise.resolve().then(() => (init_page_svelte9(), page_svelte_exports9))).default;
    imports13 = ["_app/immutable/nodes/12.Wt61_zyJ.js", "_app/immutable/chunks/scheduler.Cglc-E-6.js", "_app/immutable/chunks/index.9iPnfnGV.js", "_app/immutable/chunks/mode-toggle.Cs9G0DsI.js", "_app/immutable/chunks/mode.BQ9atwLW.js", "_app/immutable/chunks/index.C4PciY-_.js", "_app/immutable/chunks/index.BALLBs5G.js", "_app/immutable/chunks/each.Dtgx6mEA.js", "_app/immutable/chunks/index.BlvzRe2p.js", "_app/immutable/chunks/input.CyNn_tG7.js", "_app/immutable/chunks/MagnifyingGlass.1BoxrdsM.js"];
    stylesheets13 = ["_app/immutable/assets/12.BhQtB7QA.css"];
    fonts13 = [];
  }
});
var page_server_ts_exports2 = {};
__export(page_server_ts_exports2, {
  actions: () => actions2,
  load: () => load3
});
var import_memoize_weak5;
var load3;
var actions2;
var init_page_server_ts2 = __esm({
  ".svelte-kit/output/server/entries/pages/(login)/_page.server.ts.js"() {
    init_chunks();
    init_client();
    init_index4();
    init_just_clone();
    init_esm();
    init_devalue();
    init_superValidate();
    import_memoize_weak5 = __toESM(require_memoize_weak(), 1);
    load3 = async () => {
      return {
        form: await superValidate(zod(loginSchema))
      };
    };
    actions2 = {
      default: async (event) => {
        const form = await superValidate(event, zod(loginSchema));
        const password = form.data.password;
        if (!form.valid) {
          return fail2(400, { form });
        }
        if (password !== "admin") {
          form.errors = { password: ["Password salah. Silakan coba lagi."] };
          return fail2(400, { form });
        }
        const token = password;
        event.cookies.set("session", `${token}`, {
          httpOnly: true,
          path: "/",
          secure: true,
          sameSite: "strict",
          maxAge: 60 * 60 * 24
          // 1 day
        });
        return { form };
      }
    };
  }
});
var page_svelte_exports10 = {};
__export(page_svelte_exports10, {
  default: () => Page10
});
var import_memoize_weak6;
var Description;
var Field_errors;
var Form_description;
var Form_field_errors;
var Card;
var Card_content;
var LoginForm;
var Page10;
var init_page_svelte10 = __esm({
  ".svelte-kit/output/server/entries/pages/(login)/_page.svelte.js"() {
    init_ssr();
    init_lifecycle();
    init_index3();
    init_clsx();
    init_stores2();
    init_index6();
    init_input();
    init_index4();
    init_just_clone();
    init_esm();
    init_chunks();
    init_devalue();
    import_memoize_weak6 = __toESM(require_memoize_weak(), 1);
    Description = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let descriptionAttrs;
      let $$restProps = compute_rest_props($$props, ["id", "asChild", "el"]);
      let $errors, $$unsubscribe_errors;
      let $descriptionId, $$unsubscribe_descriptionId;
      const { descriptionId, errors } = getFormField();
      $$unsubscribe_descriptionId = subscribe(descriptionId, (value) => $descriptionId = value);
      $$unsubscribe_errors = subscribe(errors, (value) => $errors = value);
      let { id: id2 = generateId3() } = $$props;
      let { asChild = false } = $$props;
      let { el = void 0 } = $$props;
      if ($$props.id === void 0 && $$bindings.id && id2 !== void 0)
        $$bindings.id(id2);
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      if ($$props.el === void 0 && $$bindings.el && el !== void 0)
        $$bindings.el(el);
      {
        descriptionId.set(id2);
      }
      descriptionAttrs = {
        id: $descriptionId,
        "data-fs-error": getDataFsError($errors),
        "data-fs-description": "",
        ...$$restProps
      };
      $$unsubscribe_errors();
      $$unsubscribe_descriptionId();
      return ` ${asChild ? `${slots.default ? slots.default({ descriptionAttrs }) : ``}` : `<div${spread([escape_object(descriptionAttrs)], {})}${add_attribute("this", el, 0)}>${slots.default ? slots.default({ descriptionAttrs }) : ``}</div>`}`;
    });
    Field_errors = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let errorAttr;
      let fieldErrorsAttrs;
      let errorAttrs;
      let $$restProps = compute_rest_props($$props, ["id", "asChild", "el"]);
      let $fieldErrorsId, $$unsubscribe_fieldErrorsId;
      let $errors, $$unsubscribe_errors;
      const { fieldErrorsId, errors } = getFormField();
      $$unsubscribe_fieldErrorsId = subscribe(fieldErrorsId, (value) => $fieldErrorsId = value);
      $$unsubscribe_errors = subscribe(errors, (value) => $errors = value);
      let { id: id2 = generateId3() } = $$props;
      let { asChild = false } = $$props;
      let { el = void 0 } = $$props;
      if ($$props.id === void 0 && $$bindings.id && id2 !== void 0)
        $$bindings.id(id2);
      if ($$props.asChild === void 0 && $$bindings.asChild && asChild !== void 0)
        $$bindings.asChild(asChild);
      if ($$props.el === void 0 && $$bindings.el && el !== void 0)
        $$bindings.el(el);
      errorAttr = getDataFsError($errors);
      {
        fieldErrorsId.set(id2);
      }
      fieldErrorsAttrs = {
        id: $fieldErrorsId,
        "data-fs-error": errorAttr,
        "data-fs-field-errors": "",
        "aria-live": "assertive",
        ...$$restProps
      };
      errorAttrs = {
        "data-fs-field-error": "",
        "data-fs-error": errorAttr
      };
      $$unsubscribe_fieldErrorsId();
      $$unsubscribe_errors();
      return ` ${asChild ? `${slots.default ? slots.default({
        errors: $errors,
        fieldErrorsAttrs,
        errorAttrs
      }) : ``}` : `<div${spread([escape_object(fieldErrorsAttrs)], {})}${add_attribute("this", el, 0)}>${slots.default ? slots.default({
        errors: $errors,
        fieldErrorsAttrs,
        errorAttrs
      }) : ` ${each($errors, (error) => {
        return `<div${spread([escape_object(errorAttrs)], {})}>${escape(error)}</div>`;
      })} `}</div>`}`;
    });
    Form_description = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class"]);
      let { class: className = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      return `${validate_component(Description, "FormPrimitive.Description").$$render(
        $$result,
        Object.assign(
          {},
          {
            class: cn("text-[0.8rem] text-muted-foreground", className)
          },
          $$restProps
        ),
        {},
        {
          default: ({ descriptionAttrs }) => {
            return `${slots.default ? slots.default({ descriptionAttrs }) : ``}`;
          }
        }
      )}`;
    });
    Form_field_errors = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class", "errorClasses"]);
      let { class: className = void 0 } = $$props;
      let { errorClasses = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      if ($$props.errorClasses === void 0 && $$bindings.errorClasses && errorClasses !== void 0)
        $$bindings.errorClasses(errorClasses);
      return `${validate_component(Field_errors, "FormPrimitive.FieldErrors").$$render(
        $$result,
        Object.assign(
          {},
          {
            class: cn("text-[0.8rem] font-medium text-destructive", className)
          },
          $$restProps
        ),
        {},
        {
          default: ({ errors, fieldErrorsAttrs, errorAttrs }) => {
            return `${slots.default ? slots.default({ errors, fieldErrorsAttrs, errorAttrs }) : ` ${each(errors, (error) => {
              return `<div${spread(
                [
                  escape_object(errorAttrs),
                  {
                    class: escape_attribute_value(cn(errorClasses))
                  }
                ],
                {}
              )}>${escape(error)}</div>`;
            })} `}`;
          }
        }
      )}`;
    });
    Card = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class"]);
      let { class: className = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      return ` <div${spread(
        [
          {
            class: escape_attribute_value(cn("rounded-xl border bg-card text-card-foreground shadow", className))
          },
          escape_object($$restProps)
        ],
        {}
      )}>${slots.default ? slots.default({}) : ``}</div>`;
    });
    Card_content = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["class"]);
      let { class: className = void 0 } = $$props;
      if ($$props.class === void 0 && $$bindings.class && className !== void 0)
        $$bindings.class(className);
      return `<div${spread(
        [
          {
            class: escape_attribute_value(cn("p-6 pt-0", className))
          },
          escape_object($$restProps)
        ],
        {}
      )}>${slots.default ? slots.default({}) : ``}</div>`;
    });
    LoginForm = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $formData, $$unsubscribe_formData;
      let $delayed, $$unsubscribe_delayed;
      let $navigating, $$unsubscribe_navigating;
      $$unsubscribe_navigating = subscribe(navigating, (value) => $navigating = value);
      let { data: data2 } = $$props;
      const form = superForm(data2, {
        validators: zodClient(loginSchema),
        delayMs: 150
      });
      const { form: formData, enhance: enhance2, delayed } = form;
      $$unsubscribe_formData = subscribe(formData, (value) => $formData = value);
      $$unsubscribe_delayed = subscribe(delayed, (value) => $delayed = value);
      if ($$props.data === void 0 && $$bindings.data && data2 !== void 0)
        $$bindings.data(data2);
      let $$settled;
      let $$rendered;
      let previous_head = $$result.head;
      do {
        $$settled = true;
        $$result.head = previous_head;
        $$rendered = `  <form method="POST">${validate_component(Form_field, "Form.Field").$$render($$result, { form, name: "password" }, {}, {
          default: () => {
            return `${validate_component(Control, "Form.Control").$$render($$result, {}, {}, {
              default: ({ attrs }) => {
                return `${validate_component(Form_label, "Form.Label").$$render($$result, {}, {}, {
                  default: () => {
                    return `Password`;
                  }
                })} ${validate_component(Input, "Input").$$render(
                  $$result,
                  Object.assign({}, attrs, { type: "password" }, { class: "bg-accent focus-visible:ring-2" }, { value: $formData.password }),
                  {
                    value: ($$value) => {
                      $formData.password = $$value;
                      $$settled = false;
                    }
                  },
                  {}
                )}`;
              }
            })} ${validate_component(Form_description, "Form.Description").$$render($$result, { class: "sr-only" }, {}, {
              default: () => {
                return `Enter the password to login.`;
              }
            })} ${validate_component(Form_field_errors, "Form.FieldErrors").$$render($$result, {}, {}, {})}`;
          }
        })} ${validate_component(Form_button, "Form.Button").$$render(
          $$result,
          {
            class: "mt-2 w-full focus-visible:ring-2",
            disabled: $delayed || !!$navigating
          },
          {},
          {
            default: () => {
              return `${$delayed || $navigating ? `${validate_component(Spinners, "Spinner").$$render($$result, { class: "mr-2 h-4 w-4 animate-spin" }, {}, {})}` : ``}
		Masuk`;
            }
          }
        )}</form>`;
      } while (!$$settled);
      $$unsubscribe_formData();
      $$unsubscribe_delayed();
      $$unsubscribe_navigating();
      return $$rendered;
    });
    Page10 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { data: data2 } = $$props;
      if ($$props.data === void 0 && $$bindings.data && data2 !== void 0)
        $$bindings.data(data2);
      return `<main class="flex min-h-[100dvh] flex-col items-center justify-center">${validate_component(Card, "Card").$$render(
        $$result,
        {
          class: "w-[400px] max-w-full max-sm:border-none max-sm:bg-background max-sm:shadow-none"
        },
        {},
        {
          default: () => {
            return `${validate_component(Card_content, "CardContent").$$render($$result, { class: "p-6" }, {}, {
              default: () => {
                return `${validate_component(LoginForm, "LoginForm").$$render($$result, { data: data2.form }, {}, {})}`;
              }
            })}`;
          }
        }
      )}</main>`;
    });
  }
});
var __exports14 = {};
__export(__exports14, {
  component: () => component14,
  fonts: () => fonts14,
  imports: () => imports14,
  index: () => index14,
  server: () => page_server_ts_exports2,
  server_id: () => server_id4,
  stylesheets: () => stylesheets14
});
var index14;
var component_cache14;
var component14;
var server_id4;
var imports14;
var stylesheets14;
var fonts14;
var init__14 = __esm({
  ".svelte-kit/output/server/nodes/13.js"() {
    init_page_server_ts2();
    index14 = 13;
    component14 = async () => component_cache14 ??= (await Promise.resolve().then(() => (init_page_svelte10(), page_svelte_exports10))).default;
    server_id4 = "src/routes/(login)/+page.server.ts";
    imports14 = ["_app/immutable/nodes/13.BDNUS7Qu.js", "_app/immutable/chunks/scheduler.Cglc-E-6.js", "_app/immutable/chunks/index.9iPnfnGV.js", "_app/immutable/chunks/index.BALLBs5G.js", "_app/immutable/chunks/index.C4PciY-_.js", "_app/immutable/chunks/stores.-qfiZ27n.js", "_app/immutable/chunks/entry.BIRdqJCX.js", "_app/immutable/chunks/index.BMlfrsHg.js", "_app/immutable/chunks/_commonjsHelpers.Cpj98o6Y.js", "_app/immutable/chunks/input.CyNn_tG7.js", "_app/immutable/chunks/each.Dtgx6mEA.js"];
    stylesheets14 = ["_app/immutable/assets/index.Bi8DJf9Z.css"];
    fonts14 = [];
  }
});
init_prod_ssr();
init_lifecycle();
init_ssr();
init_ssr2();
var base = "";
var assets = base;
var initial = { base, assets };
function override(paths) {
  base = paths.base;
  assets = paths.assets;
}
function reset() {
  base = initial.base;
  assets = initial.assets;
}
var public_env = {};
var safe_public_env = {};
function set_private_env(environment) {
}
function set_public_env(environment) {
  public_env = environment;
}
function set_safe_public_env(environment) {
  safe_public_env = environment;
}
var prerendering = false;
var Root = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { stores } = $$props;
  let { page: page2 } = $$props;
  let { constructors } = $$props;
  let { components = [] } = $$props;
  let { form } = $$props;
  let { data_0 = null } = $$props;
  let { data_1 = null } = $$props;
  let { data_2 = null } = $$props;
  {
    setContext("__svelte__", stores);
  }
  afterUpdate(stores.page.notify);
  if ($$props.stores === void 0 && $$bindings.stores && stores !== void 0)
    $$bindings.stores(stores);
  if ($$props.page === void 0 && $$bindings.page && page2 !== void 0)
    $$bindings.page(page2);
  if ($$props.constructors === void 0 && $$bindings.constructors && constructors !== void 0)
    $$bindings.constructors(constructors);
  if ($$props.components === void 0 && $$bindings.components && components !== void 0)
    $$bindings.components(components);
  if ($$props.form === void 0 && $$bindings.form && form !== void 0)
    $$bindings.form(form);
  if ($$props.data_0 === void 0 && $$bindings.data_0 && data_0 !== void 0)
    $$bindings.data_0(data_0);
  if ($$props.data_1 === void 0 && $$bindings.data_1 && data_1 !== void 0)
    $$bindings.data_1(data_1);
  if ($$props.data_2 === void 0 && $$bindings.data_2 && data_2 !== void 0)
    $$bindings.data_2(data_2);
  let $$settled;
  let $$rendered;
  let previous_head = $$result.head;
  do {
    $$settled = true;
    $$result.head = previous_head;
    {
      stores.page.set(page2);
    }
    $$rendered = `  ${constructors[1] ? `${validate_component(constructors[0] || missing_component, "svelte:component").$$render(
      $$result,
      { data: data_0, this: components[0] },
      {
        this: ($$value) => {
          components[0] = $$value;
          $$settled = false;
        }
      },
      {
        default: () => {
          return `${constructors[2] ? `${validate_component(constructors[1] || missing_component, "svelte:component").$$render(
            $$result,
            { data: data_1, this: components[1] },
            {
              this: ($$value) => {
                components[1] = $$value;
                $$settled = false;
              }
            },
            {
              default: () => {
                return `${validate_component(constructors[2] || missing_component, "svelte:component").$$render(
                  $$result,
                  { data: data_2, form, this: components[2] },
                  {
                    this: ($$value) => {
                      components[2] = $$value;
                      $$settled = false;
                    }
                  },
                  {}
                )}`;
              }
            }
          )}` : `${validate_component(constructors[1] || missing_component, "svelte:component").$$render(
            $$result,
            { data: data_1, form, this: components[1] },
            {
              this: ($$value) => {
                components[1] = $$value;
                $$settled = false;
              }
            },
            {}
          )}`}`;
        }
      }
    )}` : `${validate_component(constructors[0] || missing_component, "svelte:component").$$render(
      $$result,
      { data: data_0, form, this: components[0] },
      {
        this: ($$value) => {
          components[0] = $$value;
          $$settled = false;
        }
      },
      {}
    )}`} ${``}`;
  } while (!$$settled);
  return $$rendered;
});
var options = {
  app_dir: "_app",
  app_template_contains_nonce: false,
  csp: { "mode": "auto", "directives": { "upgrade-insecure-requests": false, "block-all-mixed-content": false }, "reportOnly": { "upgrade-insecure-requests": false, "block-all-mixed-content": false } },
  csrf_check_origin: true,
  embedded: false,
  env_public_prefix: "PUBLIC_",
  env_private_prefix: "",
  hooks: null,
  // added lazily, via `get_hooks`
  preload_strategy: "modulepreload",
  root: Root,
  service_worker: false,
  templates: {
    app: ({ head, body: body2, assets: assets2, nonce, env }) => '<!doctype html>\n<html lang="en">\n	<head>\n		<meta charset="utf-8" />\n		<link rel="icon" href="' + assets2 + '/favicon.png" />\n		<meta name="viewport" content="width=device-width, initial-scale=1" />\n		' + head + '\n	</head>\n	<body data-sveltekit-preload-data="hover">\n		<div style="display: contents">' + body2 + "</div>\n	</body>\n</html>\n",
    error: ({ status, message }) => '<!doctype html>\n<html lang="en">\n	<head>\n		<meta charset="utf-8" />\n		<title>' + message + `</title>

		<style>
			body {
				--bg: white;
				--fg: #222;
				--divider: #ccc;
				background: var(--bg);
				color: var(--fg);
				font-family:
					system-ui,
					-apple-system,
					BlinkMacSystemFont,
					'Segoe UI',
					Roboto,
					Oxygen,
					Ubuntu,
					Cantarell,
					'Open Sans',
					'Helvetica Neue',
					sans-serif;
				display: flex;
				align-items: center;
				justify-content: center;
				height: 100vh;
				margin: 0;
			}

			.error {
				display: flex;
				align-items: center;
				max-width: 32rem;
				margin: 0 1rem;
			}

			.status {
				font-weight: 200;
				font-size: 3rem;
				line-height: 1;
				position: relative;
				top: -0.05rem;
			}

			.message {
				border-left: 1px solid var(--divider);
				padding: 0 0 0 1rem;
				margin: 0 0 0 1rem;
				min-height: 2.5rem;
				display: flex;
				align-items: center;
			}

			.message h1 {
				font-weight: 400;
				font-size: 1em;
				margin: 0;
			}

			@media (prefers-color-scheme: dark) {
				body {
					--bg: #222;
					--fg: #ddd;
					--divider: #666;
				}
			}
		</style>
	</head>
	<body>
		<div class="error">
			<span class="status">` + status + '</span>\n			<div class="message">\n				<h1>' + message + "</h1>\n			</div>\n		</div>\n	</body>\n</html>\n"
  },
  version_hash: "x2a2al"
};
async function get_hooks() {
  return {
    ...await Promise.resolve().then(() => (init_hooks_server(), hooks_server_exports))
  };
}
init_chunks();
init_exports();
init_devalue();
init_index2();
var import_cookie = __toESM(require_cookie(), 1);
var set_cookie_parser = __toESM(require_set_cookie(), 1);
var SVELTE_KIT_ASSETS = "/_svelte_kit_assets";
var ENDPOINT_METHODS = ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS", "HEAD"];
var PAGE_METHODS = ["GET", "POST", "HEAD"];
function negotiate(accept, types) {
  const parts = [];
  accept.split(",").forEach((str, i3) => {
    const match = /([^/]+)\/([^;]+)(?:;q=([0-9.]+))?/.exec(str);
    if (match) {
      const [, type, subtype, q3 = "1"] = match;
      parts.push({ type, subtype, q: +q3, i: i3 });
    }
  });
  parts.sort((a2, b2) => {
    if (a2.q !== b2.q) {
      return b2.q - a2.q;
    }
    if (a2.subtype === "*" !== (b2.subtype === "*")) {
      return a2.subtype === "*" ? 1 : -1;
    }
    if (a2.type === "*" !== (b2.type === "*")) {
      return a2.type === "*" ? 1 : -1;
    }
    return a2.i - b2.i;
  });
  let accepted;
  let min_priority = Infinity;
  for (const mimetype of types) {
    const [type, subtype] = mimetype.split("/");
    const priority = parts.findIndex(
      (part) => (part.type === type || part.type === "*") && (part.subtype === subtype || part.subtype === "*")
    );
    if (priority !== -1 && priority < min_priority) {
      accepted = mimetype;
      min_priority = priority;
    }
  }
  return accepted;
}
function is_content_type(request, ...types) {
  const type = request.headers.get("content-type")?.split(";", 1)[0].trim() ?? "";
  return types.includes(type.toLowerCase());
}
function is_form_content_type(request) {
  return is_content_type(
    request,
    "application/x-www-form-urlencoded",
    "multipart/form-data",
    "text/plain"
  );
}
function coalesce_to_error(err) {
  return err instanceof Error || err && /** @type {any} */
  err.name && /** @type {any} */
  err.message ? (
    /** @type {Error} */
    err
  ) : new Error(JSON.stringify(err));
}
function normalize_error(error) {
  return (
    /** @type {import('../runtime/control.js').Redirect | HttpError | SvelteKitError | Error} */
    error
  );
}
function get_status(error) {
  return error instanceof HttpError || error instanceof SvelteKitError ? error.status : 500;
}
function get_message(error) {
  return error instanceof SvelteKitError ? error.text : "Internal Error";
}
function method_not_allowed(mod, method) {
  return text(`${method} method not allowed`, {
    status: 405,
    headers: {
      // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405
      // "The server must generate an Allow header field in a 405 status code response"
      allow: allowed_methods(mod).join(", ")
    }
  });
}
function allowed_methods(mod) {
  const allowed = ENDPOINT_METHODS.filter((method) => method in mod);
  if ("GET" in mod || "HEAD" in mod)
    allowed.push("HEAD");
  return allowed;
}
function static_error_page(options2, status, message) {
  let page2 = options2.templates.error({ status, message });
  return text(page2, {
    headers: { "content-type": "text/html; charset=utf-8" },
    status
  });
}
async function handle_fatal_error(event, options2, error) {
  error = error instanceof HttpError ? error : coalesce_to_error(error);
  const status = get_status(error);
  const body2 = await handle_error_and_jsonify(event, options2, error);
  const type = negotiate(event.request.headers.get("accept") || "text/html", [
    "application/json",
    "text/html"
  ]);
  if (event.isDataRequest || type === "application/json") {
    return json(body2, {
      status
    });
  }
  return static_error_page(options2, status, body2.message);
}
async function handle_error_and_jsonify(event, options2, error) {
  if (error instanceof HttpError) {
    return error.body;
  }
  const status = get_status(error);
  const message = get_message(error);
  return await options2.hooks.handleError({ error, event, status, message }) ?? { message };
}
function redirect_response(status, location2) {
  const response = new Response(void 0, {
    status,
    headers: { location: location2 }
  });
  return response;
}
function clarify_devalue_error(event, error) {
  if (error.path) {
    return `Data returned from \`load\` while rendering ${event.route.id} is not serializable: ${error.message} (data${error.path})`;
  }
  if (error.path === "") {
    return `Data returned from \`load\` while rendering ${event.route.id} is not a plain object`;
  }
  return error.message;
}
function stringify_uses(node) {
  const uses = [];
  if (node.uses && node.uses.dependencies.size > 0) {
    uses.push(`"dependencies":${JSON.stringify(Array.from(node.uses.dependencies))}`);
  }
  if (node.uses && node.uses.search_params.size > 0) {
    uses.push(`"search_params":${JSON.stringify(Array.from(node.uses.search_params))}`);
  }
  if (node.uses && node.uses.params.size > 0) {
    uses.push(`"params":${JSON.stringify(Array.from(node.uses.params))}`);
  }
  if (node.uses?.parent)
    uses.push('"parent":1');
  if (node.uses?.route)
    uses.push('"route":1');
  if (node.uses?.url)
    uses.push('"url":1');
  return `"uses":{${uses.join(",")}}`;
}
async function render_endpoint(event, mod, state) {
  const method = (
    /** @type {import('types').HttpMethod} */
    event.request.method
  );
  let handler = mod[method] || mod.fallback;
  if (method === "HEAD" && mod.GET && !mod.HEAD) {
    handler = mod.GET;
  }
  if (!handler) {
    return method_not_allowed(mod, method);
  }
  const prerender = mod.prerender ?? state.prerender_default;
  if (prerender && (mod.POST || mod.PATCH || mod.PUT || mod.DELETE)) {
    throw new Error("Cannot prerender endpoints that have mutative methods");
  }
  if (state.prerendering && !prerender) {
    if (state.depth > 0) {
      throw new Error(`${event.route.id} is not prerenderable`);
    } else {
      return new Response(void 0, { status: 204 });
    }
  }
  try {
    let response = await handler(
      /** @type {import('@sveltejs/kit').RequestEvent<Record<string, any>>} */
      event
    );
    if (!(response instanceof Response)) {
      throw new Error(
        `Invalid response from route ${event.url.pathname}: handler should return a Response object`
      );
    }
    if (state.prerendering) {
      response = new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers: new Headers(response.headers)
      });
      response.headers.set("x-sveltekit-prerender", String(prerender));
    }
    return response;
  } catch (e3) {
    if (e3 instanceof Redirect) {
      return new Response(void 0, {
        status: e3.status,
        headers: { location: e3.location }
      });
    }
    throw e3;
  }
}
function is_endpoint_request(event) {
  const { method, headers: headers2 } = event.request;
  if (ENDPOINT_METHODS.includes(method) && !PAGE_METHODS.includes(method)) {
    return true;
  }
  if (method === "POST" && headers2.get("x-sveltekit-action") === "true")
    return false;
  const accept = event.request.headers.get("accept") ?? "*/*";
  return negotiate(accept, ["*", "text/html"]) !== "text/html";
}
function compact(arr) {
  return arr.filter(
    /** @returns {val is NonNullable<T>} */
    (val) => val != null
  );
}
function is_action_json_request(event) {
  const accept = negotiate(event.request.headers.get("accept") ?? "*/*", [
    "application/json",
    "text/html"
  ]);
  return accept === "application/json" && event.request.method === "POST";
}
async function handle_action_json_request(event, options2, server2) {
  const actions3 = server2?.actions;
  if (!actions3) {
    const no_actions_error = new SvelteKitError(
      405,
      "Method Not Allowed",
      "POST method not allowed. No actions exist for this page"
    );
    return action_json(
      {
        type: "error",
        error: await handle_error_and_jsonify(event, options2, no_actions_error)
      },
      {
        status: no_actions_error.status,
        headers: {
          // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405
          // "The server must generate an Allow header field in a 405 status code response"
          allow: "GET"
        }
      }
    );
  }
  check_named_default_separate(actions3);
  try {
    const data2 = await call_action(event, actions3);
    if (false)
      ;
    if (data2 instanceof ActionFailure) {
      return action_json({
        type: "failure",
        status: data2.status,
        // @ts-expect-error we assign a string to what is supposed to be an object. That's ok
        // because we don't use the object outside, and this way we have better code navigation
        // through knowing where the related interface is used.
        data: stringify_action_response(
          data2.data,
          /** @type {string} */
          event.route.id
        )
      });
    } else {
      return action_json({
        type: "success",
        status: data2 ? 200 : 204,
        // @ts-expect-error see comment above
        data: stringify_action_response(
          data2,
          /** @type {string} */
          event.route.id
        )
      });
    }
  } catch (e3) {
    const err = normalize_error(e3);
    if (err instanceof Redirect) {
      return action_json_redirect(err);
    }
    return action_json(
      {
        type: "error",
        error: await handle_error_and_jsonify(event, options2, check_incorrect_fail_use(err))
      },
      {
        status: get_status(err)
      }
    );
  }
}
function check_incorrect_fail_use(error) {
  return error instanceof ActionFailure ? new Error('Cannot "throw fail()". Use "return fail()"') : error;
}
function action_json_redirect(redirect2) {
  return action_json({
    type: "redirect",
    status: redirect2.status,
    location: redirect2.location
  });
}
function action_json(data2, init2) {
  return json(data2, init2);
}
function is_action_request(event) {
  return event.request.method === "POST";
}
async function handle_action_request(event, server2) {
  const actions3 = server2?.actions;
  if (!actions3) {
    event.setHeaders({
      // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405
      // "The server must generate an Allow header field in a 405 status code response"
      allow: "GET"
    });
    return {
      type: "error",
      error: new SvelteKitError(
        405,
        "Method Not Allowed",
        "POST method not allowed. No actions exist for this page"
      )
    };
  }
  check_named_default_separate(actions3);
  try {
    const data2 = await call_action(event, actions3);
    if (false)
      ;
    if (data2 instanceof ActionFailure) {
      return {
        type: "failure",
        status: data2.status,
        data: data2.data
      };
    } else {
      return {
        type: "success",
        status: 200,
        // @ts-expect-error this will be removed upon serialization, so `undefined` is the same as omission
        data: data2
      };
    }
  } catch (e3) {
    const err = normalize_error(e3);
    if (err instanceof Redirect) {
      return {
        type: "redirect",
        status: err.status,
        location: err.location
      };
    }
    return {
      type: "error",
      error: check_incorrect_fail_use(err)
    };
  }
}
function check_named_default_separate(actions3) {
  if (actions3.default && Object.keys(actions3).length > 1) {
    throw new Error(
      "When using named actions, the default action cannot be used. See the docs for more info: https://kit.svelte.dev/docs/form-actions#named-actions"
    );
  }
}
async function call_action(event, actions3) {
  const url = new URL(event.request.url);
  let name5 = "default";
  for (const param of url.searchParams) {
    if (param[0].startsWith("/")) {
      name5 = param[0].slice(1);
      if (name5 === "default") {
        throw new Error('Cannot use reserved action name "default"');
      }
      break;
    }
  }
  const action = actions3[name5];
  if (!action) {
    throw new SvelteKitError(404, "Not Found", `No action with name '${name5}' found`);
  }
  if (!is_form_content_type(event.request)) {
    throw new SvelteKitError(
      415,
      "Unsupported Media Type",
      `Form actions expect form-encoded data \u2014 received ${event.request.headers.get(
        "content-type"
      )}`
    );
  }
  return action(event);
}
function uneval_action_response(data2, route_id) {
  return try_deserialize(data2, uneval, route_id);
}
function stringify_action_response(data2, route_id) {
  return try_deserialize(data2, stringify, route_id);
}
function try_deserialize(data2, fn, route_id) {
  try {
    return fn(data2);
  } catch (e3) {
    const error = (
      /** @type {any} */
      e3
    );
    if ("path" in error) {
      let message = `Data returned from action inside ${route_id} is not serializable: ${error.message}`;
      if (error.path !== "")
        message += ` (data.${error.path})`;
      throw new Error(message);
    }
    throw error;
  }
}
var INVALIDATED_PARAM = "x-sveltekit-invalidated";
var TRAILING_SLASH_PARAM = "x-sveltekit-trailing-slash";
function b64_encode(buffer) {
  if (globalThis.Buffer) {
    return Buffer.from(buffer).toString("base64");
  }
  const little_endian = new Uint8Array(new Uint16Array([1]).buffer)[0] > 0;
  return btoa(
    new TextDecoder(little_endian ? "utf-16le" : "utf-16be").decode(
      new Uint16Array(new Uint8Array(buffer))
    )
  );
}
async function load_server_data({ event, state, node, parent }) {
  if (!node?.server)
    return null;
  let is_tracking = true;
  const uses = {
    dependencies: /* @__PURE__ */ new Set(),
    params: /* @__PURE__ */ new Set(),
    parent: false,
    route: false,
    url: false,
    search_params: /* @__PURE__ */ new Set()
  };
  const url = make_trackable(
    event.url,
    () => {
      if (is_tracking) {
        uses.url = true;
      }
    },
    (param) => {
      if (is_tracking) {
        uses.search_params.add(param);
      }
    }
  );
  if (state.prerendering) {
    disable_search(url);
  }
  const result = await node.server.load?.call(null, {
    ...event,
    fetch: (info, init2) => {
      new URL(info instanceof Request ? info.url : info, event.url);
      return event.fetch(info, init2);
    },
    /** @param {string[]} deps */
    depends: (...deps) => {
      for (const dep of deps) {
        const { href } = new URL(dep, event.url);
        uses.dependencies.add(href);
      }
    },
    params: new Proxy(event.params, {
      get: (target, key2) => {
        if (is_tracking) {
          uses.params.add(key2);
        }
        return target[
          /** @type {string} */
          key2
        ];
      }
    }),
    parent: async () => {
      if (is_tracking) {
        uses.parent = true;
      }
      return parent();
    },
    route: new Proxy(event.route, {
      get: (target, key2) => {
        if (is_tracking) {
          uses.route = true;
        }
        return target[
          /** @type {'id'} */
          key2
        ];
      }
    }),
    url,
    untrack(fn) {
      is_tracking = false;
      try {
        return fn();
      } finally {
        is_tracking = true;
      }
    }
  });
  return {
    type: "data",
    data: result ?? null,
    uses,
    slash: node.server.trailingSlash
  };
}
async function load_data({
  event,
  fetched,
  node,
  parent,
  server_data_promise,
  state,
  resolve_opts,
  csr
}) {
  const server_data_node = await server_data_promise;
  if (!node?.universal?.load) {
    return server_data_node?.data ?? null;
  }
  const result = await node.universal.load.call(null, {
    url: event.url,
    params: event.params,
    data: server_data_node?.data ?? null,
    route: event.route,
    fetch: create_universal_fetch(event, state, fetched, csr, resolve_opts),
    setHeaders: event.setHeaders,
    depends: () => {
    },
    parent,
    untrack: (fn) => fn()
  });
  return result ?? null;
}
function create_universal_fetch(event, state, fetched, csr, resolve_opts) {
  const universal_fetch = async (input, init2) => {
    const cloned_body = input instanceof Request && input.body ? input.clone().body : null;
    const cloned_headers = input instanceof Request && [...input.headers].length ? new Headers(input.headers) : init2?.headers;
    let response = await event.fetch(input, init2);
    const url = new URL(input instanceof Request ? input.url : input, event.url);
    const same_origin = url.origin === event.url.origin;
    let dependency;
    if (same_origin) {
      if (state.prerendering) {
        dependency = { response, body: null };
        state.prerendering.dependencies.set(url.pathname, dependency);
      }
    } else {
      const mode = input instanceof Request ? input.mode : init2?.mode ?? "cors";
      if (mode === "no-cors") {
        response = new Response("", {
          status: response.status,
          statusText: response.statusText,
          headers: response.headers
        });
      } else {
        const acao = response.headers.get("access-control-allow-origin");
        if (!acao || acao !== event.url.origin && acao !== "*") {
          throw new Error(
            `CORS error: ${acao ? "Incorrect" : "No"} 'Access-Control-Allow-Origin' header is present on the requested resource`
          );
        }
      }
    }
    const proxy = new Proxy(response, {
      get(response2, key2, _receiver) {
        async function push_fetched(body2, is_b64) {
          const status_number = Number(response2.status);
          if (isNaN(status_number)) {
            throw new Error(
              `response.status is not a number. value: "${response2.status}" type: ${typeof response2.status}`
            );
          }
          fetched.push({
            url: same_origin ? url.href.slice(event.url.origin.length) : url.href,
            method: event.request.method,
            request_body: (
              /** @type {string | ArrayBufferView | undefined} */
              input instanceof Request && cloned_body ? await stream_to_string(cloned_body) : init2?.body
            ),
            request_headers: cloned_headers,
            response_body: body2,
            response: response2,
            is_b64
          });
        }
        if (key2 === "arrayBuffer") {
          return async () => {
            const buffer = await response2.arrayBuffer();
            if (dependency) {
              dependency.body = new Uint8Array(buffer);
            }
            if (buffer instanceof ArrayBuffer) {
              await push_fetched(b64_encode(buffer), true);
            }
            return buffer;
          };
        }
        async function text2() {
          const body2 = await response2.text();
          if (!body2 || typeof body2 === "string") {
            await push_fetched(body2, false);
          }
          if (dependency) {
            dependency.body = body2;
          }
          return body2;
        }
        if (key2 === "text") {
          return text2;
        }
        if (key2 === "json") {
          return async () => {
            return JSON.parse(await text2());
          };
        }
        return Reflect.get(response2, key2, response2);
      }
    });
    if (csr) {
      const get2 = response.headers.get;
      response.headers.get = (key2) => {
        const lower = key2.toLowerCase();
        const value = get2.call(response.headers, lower);
        if (value && !lower.startsWith("x-sveltekit-")) {
          const included = resolve_opts.filterSerializedResponseHeaders(lower, value);
          if (!included) {
            throw new Error(
              `Failed to get response header "${lower}" \u2014 it must be included by the \`filterSerializedResponseHeaders\` option: https://kit.svelte.dev/docs/hooks#server-hooks-handle (at ${event.route.id})`
            );
          }
        }
        return value;
      };
    }
    return proxy;
  };
  return (input, init2) => {
    const response = universal_fetch(input, init2);
    response.catch(() => {
    });
    return response;
  };
}
async function stream_to_string(stream) {
  let result = "";
  const reader = stream.getReader();
  const decoder = new TextDecoder();
  while (true) {
    const { done, value } = await reader.read();
    if (done) {
      break;
    }
    result += decoder.decode(value);
  }
  return result;
}
function hash(...values) {
  let hash2 = 5381;
  for (const value of values) {
    if (typeof value === "string") {
      let i3 = value.length;
      while (i3)
        hash2 = hash2 * 33 ^ value.charCodeAt(--i3);
    } else if (ArrayBuffer.isView(value)) {
      const buffer = new Uint8Array(value.buffer, value.byteOffset, value.byteLength);
      let i3 = buffer.length;
      while (i3)
        hash2 = hash2 * 33 ^ buffer[--i3];
    } else {
      throw new TypeError("value must be a string or TypedArray");
    }
  }
  return (hash2 >>> 0).toString(36);
}
var escape_html_attr_dict = {
  "&": "&amp;",
  '"': "&quot;"
};
var escape_html_attr_regex = new RegExp(
  // special characters
  `[${Object.keys(escape_html_attr_dict).join("")}]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\udc00-\\udfff]`,
  "g"
);
function escape_html_attr(str) {
  const escaped_str = str.replace(escape_html_attr_regex, (match) => {
    if (match.length === 2) {
      return match;
    }
    return escape_html_attr_dict[match] ?? `&#${match.charCodeAt(0)};`;
  });
  return `"${escaped_str}"`;
}
var replacements = {
  "<": "\\u003C",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var pattern = new RegExp(`[${Object.keys(replacements).join("")}]`, "g");
function serialize_data(fetched, filter, prerendering2 = false) {
  const headers2 = {};
  let cache_control = null;
  let age = null;
  let varyAny = false;
  for (const [key2, value] of fetched.response.headers) {
    if (filter(key2, value)) {
      headers2[key2] = value;
    }
    if (key2 === "cache-control")
      cache_control = value;
    else if (key2 === "age")
      age = value;
    else if (key2 === "vary" && value.trim() === "*")
      varyAny = true;
  }
  const payload = {
    status: fetched.response.status,
    statusText: fetched.response.statusText,
    headers: headers2,
    body: fetched.response_body
  };
  const safe_payload = JSON.stringify(payload).replace(pattern, (match) => replacements[match]);
  const attrs = [
    'type="application/json"',
    "data-sveltekit-fetched",
    `data-url=${escape_html_attr(fetched.url)}`
  ];
  if (fetched.is_b64) {
    attrs.push("data-b64");
  }
  if (fetched.request_headers || fetched.request_body) {
    const values = [];
    if (fetched.request_headers) {
      values.push([...new Headers(fetched.request_headers)].join(","));
    }
    if (fetched.request_body) {
      values.push(fetched.request_body);
    }
    attrs.push(`data-hash="${hash(...values)}"`);
  }
  if (!prerendering2 && fetched.method === "GET" && cache_control && !varyAny) {
    const match = /s-maxage=(\d+)/g.exec(cache_control) ?? /max-age=(\d+)/g.exec(cache_control);
    if (match) {
      const ttl = +match[1] - +(age ?? "0");
      attrs.push(`data-ttl="${ttl}"`);
    }
  }
  return `<script ${attrs.join(" ")}>${safe_payload}<\/script>`;
}
var s = JSON.stringify;
var encoder$2 = new TextEncoder();
function sha256(data2) {
  if (!key[0])
    precompute();
  const out = init.slice(0);
  const array2 = encode(data2);
  for (let i3 = 0; i3 < array2.length; i3 += 16) {
    const w3 = array2.subarray(i3, i3 + 16);
    let tmp;
    let a2;
    let b2;
    let out0 = out[0];
    let out1 = out[1];
    let out2 = out[2];
    let out3 = out[3];
    let out4 = out[4];
    let out5 = out[5];
    let out6 = out[6];
    let out7 = out[7];
    for (let i22 = 0; i22 < 64; i22++) {
      if (i22 < 16) {
        tmp = w3[i22];
      } else {
        a2 = w3[i22 + 1 & 15];
        b2 = w3[i22 + 14 & 15];
        tmp = w3[i22 & 15] = (a2 >>> 7 ^ a2 >>> 18 ^ a2 >>> 3 ^ a2 << 25 ^ a2 << 14) + (b2 >>> 17 ^ b2 >>> 19 ^ b2 >>> 10 ^ b2 << 15 ^ b2 << 13) + w3[i22 & 15] + w3[i22 + 9 & 15] | 0;
      }
      tmp = tmp + out7 + (out4 >>> 6 ^ out4 >>> 11 ^ out4 >>> 25 ^ out4 << 26 ^ out4 << 21 ^ out4 << 7) + (out6 ^ out4 & (out5 ^ out6)) + key[i22];
      out7 = out6;
      out6 = out5;
      out5 = out4;
      out4 = out3 + tmp | 0;
      out3 = out2;
      out2 = out1;
      out1 = out0;
      out0 = tmp + (out1 & out2 ^ out3 & (out1 ^ out2)) + (out1 >>> 2 ^ out1 >>> 13 ^ out1 >>> 22 ^ out1 << 30 ^ out1 << 19 ^ out1 << 10) | 0;
    }
    out[0] = out[0] + out0 | 0;
    out[1] = out[1] + out1 | 0;
    out[2] = out[2] + out2 | 0;
    out[3] = out[3] + out3 | 0;
    out[4] = out[4] + out4 | 0;
    out[5] = out[5] + out5 | 0;
    out[6] = out[6] + out6 | 0;
    out[7] = out[7] + out7 | 0;
  }
  const bytes = new Uint8Array(out.buffer);
  reverse_endianness(bytes);
  return base642(bytes);
}
var init = new Uint32Array(8);
var key = new Uint32Array(64);
function precompute() {
  function frac(x4) {
    return (x4 - Math.floor(x4)) * 4294967296;
  }
  let prime = 2;
  for (let i3 = 0; i3 < 64; prime++) {
    let is_prime = true;
    for (let factor = 2; factor * factor <= prime; factor++) {
      if (prime % factor === 0) {
        is_prime = false;
        break;
      }
    }
    if (is_prime) {
      if (i3 < 8) {
        init[i3] = frac(prime ** (1 / 2));
      }
      key[i3] = frac(prime ** (1 / 3));
      i3++;
    }
  }
}
function reverse_endianness(bytes) {
  for (let i3 = 0; i3 < bytes.length; i3 += 4) {
    const a2 = bytes[i3 + 0];
    const b2 = bytes[i3 + 1];
    const c2 = bytes[i3 + 2];
    const d = bytes[i3 + 3];
    bytes[i3 + 0] = d;
    bytes[i3 + 1] = c2;
    bytes[i3 + 2] = b2;
    bytes[i3 + 3] = a2;
  }
}
function encode(str) {
  const encoded = encoder$2.encode(str);
  const length = encoded.length * 8;
  const size3 = 512 * Math.ceil((length + 65) / 512);
  const bytes = new Uint8Array(size3 / 8);
  bytes.set(encoded);
  bytes[encoded.length] = 128;
  reverse_endianness(bytes);
  const words = new Uint32Array(bytes.buffer);
  words[words.length - 2] = Math.floor(length / 4294967296);
  words[words.length - 1] = length;
  return words;
}
var chars2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
function base642(bytes) {
  const l3 = bytes.length;
  let result = "";
  let i3;
  for (i3 = 2; i3 < l3; i3 += 3) {
    result += chars2[bytes[i3 - 2] >> 2];
    result += chars2[(bytes[i3 - 2] & 3) << 4 | bytes[i3 - 1] >> 4];
    result += chars2[(bytes[i3 - 1] & 15) << 2 | bytes[i3] >> 6];
    result += chars2[bytes[i3] & 63];
  }
  if (i3 === l3 + 1) {
    result += chars2[bytes[i3 - 2] >> 2];
    result += chars2[(bytes[i3 - 2] & 3) << 4];
    result += "==";
  }
  if (i3 === l3) {
    result += chars2[bytes[i3 - 2] >> 2];
    result += chars2[(bytes[i3 - 2] & 3) << 4 | bytes[i3 - 1] >> 4];
    result += chars2[(bytes[i3 - 1] & 15) << 2];
    result += "=";
  }
  return result;
}
var array = new Uint8Array(16);
function generate_nonce() {
  crypto.getRandomValues(array);
  return base642(array);
}
var quoted = /* @__PURE__ */ new Set([
  "self",
  "unsafe-eval",
  "unsafe-hashes",
  "unsafe-inline",
  "none",
  "strict-dynamic",
  "report-sample",
  "wasm-unsafe-eval",
  "script"
]);
var crypto_pattern = /^(nonce|sha\d\d\d)-/;
var BaseProvider = class {
  /** @type {boolean} */
  #use_hashes;
  /** @type {boolean} */
  #script_needs_csp;
  /** @type {boolean} */
  #style_needs_csp;
  /** @type {import('types').CspDirectives} */
  #directives;
  /** @type {import('types').Csp.Source[]} */
  #script_src;
  /** @type {import('types').Csp.Source[]} */
  #script_src_elem;
  /** @type {import('types').Csp.Source[]} */
  #style_src;
  /** @type {import('types').Csp.Source[]} */
  #style_src_attr;
  /** @type {import('types').Csp.Source[]} */
  #style_src_elem;
  /** @type {string} */
  #nonce;
  /**
   * @param {boolean} use_hashes
   * @param {import('types').CspDirectives} directives
   * @param {string} nonce
   */
  constructor(use_hashes, directives, nonce) {
    this.#use_hashes = use_hashes;
    this.#directives = directives;
    const d = this.#directives;
    this.#script_src = [];
    this.#script_src_elem = [];
    this.#style_src = [];
    this.#style_src_attr = [];
    this.#style_src_elem = [];
    const effective_script_src = d["script-src"] || d["default-src"];
    const script_src_elem = d["script-src-elem"];
    const effective_style_src = d["style-src"] || d["default-src"];
    const style_src_attr = d["style-src-attr"];
    const style_src_elem = d["style-src-elem"];
    this.#script_needs_csp = !!effective_script_src && effective_script_src.filter((value) => value !== "unsafe-inline").length > 0 || !!script_src_elem && script_src_elem.filter((value) => value !== "unsafe-inline").length > 0;
    this.#style_needs_csp = !!effective_style_src && effective_style_src.filter((value) => value !== "unsafe-inline").length > 0 || !!style_src_attr && style_src_attr.filter((value) => value !== "unsafe-inline").length > 0 || !!style_src_elem && style_src_elem.filter((value) => value !== "unsafe-inline").length > 0;
    this.script_needs_nonce = this.#script_needs_csp && !this.#use_hashes;
    this.style_needs_nonce = this.#style_needs_csp && !this.#use_hashes;
    this.#nonce = nonce;
  }
  /** @param {string} content */
  add_script(content) {
    if (this.#script_needs_csp) {
      const d = this.#directives;
      if (this.#use_hashes) {
        const hash2 = sha256(content);
        this.#script_src.push(`sha256-${hash2}`);
        if (d["script-src-elem"]?.length) {
          this.#script_src_elem.push(`sha256-${hash2}`);
        }
      } else {
        if (this.#script_src.length === 0) {
          this.#script_src.push(`nonce-${this.#nonce}`);
        }
        if (d["script-src-elem"]?.length) {
          this.#script_src_elem.push(`nonce-${this.#nonce}`);
        }
      }
    }
  }
  /** @param {string} content */
  add_style(content) {
    if (this.#style_needs_csp) {
      const empty_comment_hash = "9OlNO0DNEeaVzHL4RZwCLsBHA8WBQ8toBp/4F5XV2nc=";
      const d = this.#directives;
      if (this.#use_hashes) {
        const hash2 = sha256(content);
        this.#style_src.push(`sha256-${hash2}`);
        if (d["style-src-attr"]?.length) {
          this.#style_src_attr.push(`sha256-${hash2}`);
        }
        if (d["style-src-elem"]?.length) {
          if (hash2 !== empty_comment_hash && !d["style-src-elem"].includes(`sha256-${empty_comment_hash}`)) {
            this.#style_src_elem.push(`sha256-${empty_comment_hash}`);
          }
          this.#style_src_elem.push(`sha256-${hash2}`);
        }
      } else {
        if (this.#style_src.length === 0 && !d["style-src"]?.includes("unsafe-inline")) {
          this.#style_src.push(`nonce-${this.#nonce}`);
        }
        if (d["style-src-attr"]?.length) {
          this.#style_src_attr.push(`nonce-${this.#nonce}`);
        }
        if (d["style-src-elem"]?.length) {
          if (!d["style-src-elem"].includes(`sha256-${empty_comment_hash}`)) {
            this.#style_src_elem.push(`sha256-${empty_comment_hash}`);
          }
          this.#style_src_elem.push(`nonce-${this.#nonce}`);
        }
      }
    }
  }
  /**
   * @param {boolean} [is_meta]
   */
  get_header(is_meta = false) {
    const header = [];
    const directives = { ...this.#directives };
    if (this.#style_src.length > 0) {
      directives["style-src"] = [
        ...directives["style-src"] || directives["default-src"] || [],
        ...this.#style_src
      ];
    }
    if (this.#style_src_attr.length > 0) {
      directives["style-src-attr"] = [
        ...directives["style-src-attr"] || [],
        ...this.#style_src_attr
      ];
    }
    if (this.#style_src_elem.length > 0) {
      directives["style-src-elem"] = [
        ...directives["style-src-elem"] || [],
        ...this.#style_src_elem
      ];
    }
    if (this.#script_src.length > 0) {
      directives["script-src"] = [
        ...directives["script-src"] || directives["default-src"] || [],
        ...this.#script_src
      ];
    }
    if (this.#script_src_elem.length > 0) {
      directives["script-src-elem"] = [
        ...directives["script-src-elem"] || [],
        ...this.#script_src_elem
      ];
    }
    for (const key2 in directives) {
      if (is_meta && (key2 === "frame-ancestors" || key2 === "report-uri" || key2 === "sandbox")) {
        continue;
      }
      const value = (
        /** @type {string[] | true} */
        directives[key2]
      );
      if (!value)
        continue;
      const directive = [key2];
      if (Array.isArray(value)) {
        value.forEach((value2) => {
          if (quoted.has(value2) || crypto_pattern.test(value2)) {
            directive.push(`'${value2}'`);
          } else {
            directive.push(value2);
          }
        });
      }
      header.push(directive.join(" "));
    }
    return header.join("; ");
  }
};
var CspProvider = class extends BaseProvider {
  get_meta() {
    const content = this.get_header(true);
    if (!content) {
      return;
    }
    return `<meta http-equiv="content-security-policy" content=${escape_html_attr(content)}>`;
  }
};
var CspReportOnlyProvider = class extends BaseProvider {
  /**
   * @param {boolean} use_hashes
   * @param {import('types').CspDirectives} directives
   * @param {string} nonce
   */
  constructor(use_hashes, directives, nonce) {
    super(use_hashes, directives, nonce);
    if (Object.values(directives).filter((v3) => !!v3).length > 0) {
      const has_report_to = directives["report-to"]?.length ?? 0 > 0;
      const has_report_uri = directives["report-uri"]?.length ?? 0 > 0;
      if (!has_report_to && !has_report_uri) {
        throw Error(
          "`content-security-policy-report-only` must be specified with either the `report-to` or `report-uri` directives, or both"
        );
      }
    }
  }
};
var Csp = class {
  /** @readonly */
  nonce = generate_nonce();
  /** @type {CspProvider} */
  csp_provider;
  /** @type {CspReportOnlyProvider} */
  report_only_provider;
  /**
   * @param {import('./types.js').CspConfig} config
   * @param {import('./types.js').CspOpts} opts
   */
  constructor({ mode, directives, reportOnly }, { prerender }) {
    const use_hashes = mode === "hash" || mode === "auto" && prerender;
    this.csp_provider = new CspProvider(use_hashes, directives, this.nonce);
    this.report_only_provider = new CspReportOnlyProvider(use_hashes, reportOnly, this.nonce);
  }
  get script_needs_nonce() {
    return this.csp_provider.script_needs_nonce || this.report_only_provider.script_needs_nonce;
  }
  get style_needs_nonce() {
    return this.csp_provider.style_needs_nonce || this.report_only_provider.style_needs_nonce;
  }
  /** @param {string} content */
  add_script(content) {
    this.csp_provider.add_script(content);
    this.report_only_provider.add_script(content);
  }
  /** @param {string} content */
  add_style(content) {
    this.csp_provider.add_style(content);
    this.report_only_provider.add_style(content);
  }
};
function defer() {
  let fulfil;
  let reject;
  const promise = new Promise((f, r4) => {
    fulfil = f;
    reject = r4;
  });
  return { promise, fulfil, reject };
}
function create_async_iterator() {
  const deferred = [defer()];
  return {
    iterator: {
      [Symbol.asyncIterator]() {
        return {
          next: async () => {
            const next2 = await deferred[0].promise;
            if (!next2.done)
              deferred.shift();
            return next2;
          }
        };
      }
    },
    push: (value) => {
      deferred[deferred.length - 1].fulfil({
        value,
        done: false
      });
      deferred.push(defer());
    },
    done: () => {
      deferred[deferred.length - 1].fulfil({ done: true });
    }
  };
}
var updated = {
  ...readable(false),
  check: () => false
};
var encoder$1 = new TextEncoder();
async function render_response({
  branch,
  fetched,
  options: options2,
  manifest: manifest2,
  state,
  page_config,
  status,
  error = null,
  event,
  resolve_opts,
  action_result
}) {
  if (state.prerendering) {
    if (options2.csp.mode === "nonce") {
      throw new Error('Cannot use prerendering if config.kit.csp.mode === "nonce"');
    }
    if (options2.app_template_contains_nonce) {
      throw new Error("Cannot use prerendering if page template contains %sveltekit.nonce%");
    }
  }
  const { client } = manifest2._;
  const modulepreloads = new Set(client.imports);
  const stylesheets15 = new Set(client.stylesheets);
  const fonts15 = new Set(client.fonts);
  const link_header_preloads = /* @__PURE__ */ new Set();
  const inline_styles = /* @__PURE__ */ new Map();
  let rendered;
  const form_value = action_result?.type === "success" || action_result?.type === "failure" ? action_result.data ?? null : null;
  let base$1 = base;
  let assets$1 = assets;
  let base_expression = s(base);
  if (!state.prerendering?.fallback) {
    const segments = event.url.pathname.slice(base.length).split("/").slice(2);
    base$1 = segments.map(() => "..").join("/") || ".";
    base_expression = `new URL(${s(base$1)}, location).pathname.slice(0, -1)`;
    if (!assets || assets[0] === "/" && assets !== SVELTE_KIT_ASSETS) {
      assets$1 = base$1;
    }
  }
  if (page_config.ssr) {
    const props = {
      stores: {
        page: writable(null),
        navigating: writable(null),
        updated
      },
      constructors: await Promise.all(branch.map(({ node }) => node.component())),
      form: form_value
    };
    let data22 = {};
    for (let i3 = 0; i3 < branch.length; i3 += 1) {
      data22 = { ...data22, ...branch[i3].data };
      props[`data_${i3}`] = data22;
    }
    props.page = {
      error,
      params: (
        /** @type {Record<string, any>} */
        event.params
      ),
      route: event.route,
      status,
      url: event.url,
      data: data22,
      form: form_value,
      state: {}
    };
    override({ base: base$1, assets: assets$1 });
    {
      try {
        rendered = options2.root.render(props);
      } finally {
        reset();
      }
    }
    for (const { node } of branch) {
      for (const url of node.imports)
        modulepreloads.add(url);
      for (const url of node.stylesheets)
        stylesheets15.add(url);
      for (const url of node.fonts)
        fonts15.add(url);
      if (node.inline_styles) {
        Object.entries(await node.inline_styles()).forEach(([k2, v3]) => inline_styles.set(k2, v3));
      }
    }
  } else {
    rendered = { head: "", html: "", css: { code: "", map: null } };
  }
  let head = "";
  let body2 = rendered.html;
  const csp = new Csp(options2.csp, {
    prerender: !!state.prerendering
  });
  const prefixed = (path) => {
    if (path.startsWith("/")) {
      return base + path;
    }
    return `${assets$1}/${path}`;
  };
  if (inline_styles.size > 0) {
    const content = Array.from(inline_styles.values()).join("\n");
    const attributes = [];
    if (csp.style_needs_nonce)
      attributes.push(` nonce="${csp.nonce}"`);
    csp.add_style(content);
    head += `
	<style${attributes.join("")}>${content}</style>`;
  }
  for (const dep of stylesheets15) {
    const path = prefixed(dep);
    const attributes = ['rel="stylesheet"'];
    if (inline_styles.has(dep)) {
      attributes.push("disabled", 'media="(max-width: 0)"');
    } else {
      if (resolve_opts.preload({ type: "css", path })) {
        const preload_atts = ['rel="preload"', 'as="style"'];
        link_header_preloads.add(`<${encodeURI(path)}>; ${preload_atts.join(";")}; nopush`);
      }
    }
    head += `
		<link href="${path}" ${attributes.join(" ")}>`;
  }
  for (const dep of fonts15) {
    const path = prefixed(dep);
    if (resolve_opts.preload({ type: "font", path })) {
      const ext = dep.slice(dep.lastIndexOf(".") + 1);
      const attributes = [
        'rel="preload"',
        'as="font"',
        `type="font/${ext}"`,
        `href="${path}"`,
        "crossorigin"
      ];
      head += `
		<link ${attributes.join(" ")}>`;
    }
  }
  const global2 = `__sveltekit_${options2.version_hash}`;
  const { data: data2, chunks } = get_data(
    event,
    options2,
    branch.map((b2) => b2.server_data),
    global2
  );
  if (page_config.ssr && page_config.csr) {
    body2 += `
			${fetched.map(
      (item) => serialize_data(item, resolve_opts.filterSerializedResponseHeaders, !!state.prerendering)
    ).join("\n			")}`;
  }
  if (page_config.csr) {
    if (client.uses_env_dynamic_public && state.prerendering) {
      modulepreloads.add(`${options2.app_dir}/env.js`);
    }
    const included_modulepreloads = Array.from(modulepreloads, (dep) => prefixed(dep)).filter(
      (path) => resolve_opts.preload({ type: "js", path })
    );
    for (const path of included_modulepreloads) {
      link_header_preloads.add(`<${encodeURI(path)}>; rel="modulepreload"; nopush`);
      if (options2.preload_strategy !== "modulepreload") {
        head += `
		<link rel="preload" as="script" crossorigin="anonymous" href="${path}">`;
      } else if (state.prerendering) {
        head += `
		<link rel="modulepreload" href="${path}">`;
      }
    }
    const blocks = [];
    const load_env_eagerly = client.uses_env_dynamic_public && state.prerendering;
    const properties = [`base: ${base_expression}`];
    if (assets) {
      properties.push(`assets: ${s(assets)}`);
    }
    if (client.uses_env_dynamic_public) {
      properties.push(`env: ${load_env_eagerly ? "null" : s(public_env)}`);
    }
    if (chunks) {
      blocks.push("const deferred = new Map();");
      properties.push(`defer: (id) => new Promise((fulfil, reject) => {
							deferred.set(id, { fulfil, reject });
						})`);
      properties.push(`resolve: ({ id, data, error }) => {
							const { fulfil, reject } = deferred.get(id);
							deferred.delete(id);

							if (error) reject(error);
							else fulfil(data);
						}`);
    }
    blocks.push(`${global2} = {
						${properties.join(",\n						")}
					};`);
    const args = ["app", "element"];
    blocks.push("const element = document.currentScript.parentElement;");
    if (page_config.ssr) {
      const serialized = { form: "null", error: "null" };
      blocks.push(`const data = ${data2};`);
      if (form_value) {
        serialized.form = uneval_action_response(
          form_value,
          /** @type {string} */
          event.route.id
        );
      }
      if (error) {
        serialized.error = uneval(error);
      }
      const hydrate = [
        `node_ids: [${branch.map(({ node }) => node.index).join(", ")}]`,
        "data",
        `form: ${serialized.form}`,
        `error: ${serialized.error}`
      ];
      if (status !== 200) {
        hydrate.push(`status: ${status}`);
      }
      if (options2.embedded) {
        hydrate.push(`params: ${uneval(event.params)}`, `route: ${s(event.route)}`);
      }
      const indent = "	".repeat(load_env_eagerly ? 7 : 6);
      args.push(`{
${indent}	${hydrate.join(`,
${indent}	`)}
${indent}}`);
    }
    if (load_env_eagerly) {
      blocks.push(`import(${s(`${base$1}/${options2.app_dir}/env.js`)}).then(({ env }) => {
						${global2}.env = env;

						Promise.all([
							import(${s(prefixed(client.start))}),
							import(${s(prefixed(client.app))})
						]).then(([kit, app]) => {
							kit.start(${args.join(", ")});
						});
					});`);
    } else {
      blocks.push(`Promise.all([
						import(${s(prefixed(client.start))}),
						import(${s(prefixed(client.app))})
					]).then(([kit, app]) => {
						kit.start(${args.join(", ")});
					});`);
    }
    if (options2.service_worker) {
      const opts = "";
      blocks.push(`if ('serviceWorker' in navigator) {
						addEventListener('load', function () {
							navigator.serviceWorker.register('${prefixed("service-worker.js")}'${opts});
						});
					}`);
    }
    const init_app = `
				{
					${blocks.join("\n\n					")}
				}
			`;
    csp.add_script(init_app);
    body2 += `
			<script${csp.script_needs_nonce ? ` nonce="${csp.nonce}"` : ""}>${init_app}<\/script>
		`;
  }
  const headers2 = new Headers({
    "x-sveltekit-page": "true",
    "content-type": "text/html"
  });
  if (state.prerendering) {
    const http_equiv = [];
    const csp_headers = csp.csp_provider.get_meta();
    if (csp_headers) {
      http_equiv.push(csp_headers);
    }
    if (state.prerendering.cache) {
      http_equiv.push(`<meta http-equiv="cache-control" content="${state.prerendering.cache}">`);
    }
    if (http_equiv.length > 0) {
      head = http_equiv.join("\n") + head;
    }
  } else {
    const csp_header = csp.csp_provider.get_header();
    if (csp_header) {
      headers2.set("content-security-policy", csp_header);
    }
    const report_only_header = csp.report_only_provider.get_header();
    if (report_only_header) {
      headers2.set("content-security-policy-report-only", report_only_header);
    }
    if (link_header_preloads.size) {
      headers2.set("link", Array.from(link_header_preloads).join(", "));
    }
  }
  head += rendered.head;
  const html = options2.templates.app({
    head,
    body: body2,
    assets: assets$1,
    nonce: (
      /** @type {string} */
      csp.nonce
    ),
    env: safe_public_env
  });
  const transformed = await resolve_opts.transformPageChunk({
    html,
    done: true
  }) || "";
  if (!chunks) {
    headers2.set("etag", `"${hash(transformed)}"`);
  }
  return !chunks ? text(transformed, {
    status,
    headers: headers2
  }) : new Response(
    new ReadableStream({
      async start(controller) {
        controller.enqueue(encoder$1.encode(transformed + "\n"));
        for await (const chunk of chunks) {
          controller.enqueue(encoder$1.encode(chunk));
        }
        controller.close();
      },
      type: "bytes"
    }),
    {
      headers: {
        "content-type": "text/html"
      }
    }
  );
}
function get_data(event, options2, nodes, global2) {
  let promise_id = 1;
  let count = 0;
  const { iterator, push, done } = create_async_iterator();
  function replacer(thing) {
    if (typeof thing?.then === "function") {
      const id2 = promise_id++;
      count += 1;
      thing.then(
        /** @param {any} data */
        (data2) => ({ data: data2 })
      ).catch(
        /** @param {any} error */
        async (error) => ({
          error: await handle_error_and_jsonify(event, options2, error)
        })
      ).then(
        /**
         * @param {{data: any; error: any}} result
         */
        async ({ data: data2, error }) => {
          count -= 1;
          let str;
          try {
            str = uneval({ id: id2, data: data2, error }, replacer);
          } catch (e3) {
            error = await handle_error_and_jsonify(
              event,
              options2,
              new Error(`Failed to serialize promise while rendering ${event.route.id}`)
            );
            data2 = void 0;
            str = uneval({ id: id2, data: data2, error }, replacer);
          }
          push(`<script>${global2}.resolve(${str})<\/script>
`);
          if (count === 0)
            done();
        }
      );
      return `${global2}.defer(${id2})`;
    }
  }
  try {
    const strings = nodes.map((node) => {
      if (!node)
        return "null";
      return `{"type":"data","data":${uneval(node.data, replacer)},${stringify_uses(node)}${node.slash ? `,"slash":${JSON.stringify(node.slash)}` : ""}}`;
    });
    return {
      data: `[${strings.join(",")}]`,
      chunks: count > 0 ? iterator : null
    };
  } catch (e3) {
    throw new Error(clarify_devalue_error(
      event,
      /** @type {any} */
      e3
    ));
  }
}
function get_option(nodes, option) {
  return nodes.reduce(
    (value, node) => {
      return (
        /** @type {Value} TypeScript's too dumb to understand this */
        node?.universal?.[option] ?? node?.server?.[option] ?? value
      );
    },
    /** @type {Value | undefined} */
    void 0
  );
}
async function respond_with_error({
  event,
  options: options2,
  manifest: manifest2,
  state,
  status,
  error,
  resolve_opts
}) {
  if (event.request.headers.get("x-sveltekit-error")) {
    return static_error_page(
      options2,
      status,
      /** @type {Error} */
      error.message
    );
  }
  const fetched = [];
  try {
    const branch = [];
    const default_layout = await manifest2._.nodes[0]();
    const ssr = get_option([default_layout], "ssr") ?? true;
    const csr = get_option([default_layout], "csr") ?? true;
    if (ssr) {
      state.error = true;
      const server_data_promise = load_server_data({
        event,
        state,
        node: default_layout,
        parent: async () => ({})
      });
      const server_data = await server_data_promise;
      const data2 = await load_data({
        event,
        fetched,
        node: default_layout,
        parent: async () => ({}),
        resolve_opts,
        server_data_promise,
        state,
        csr
      });
      branch.push(
        {
          node: default_layout,
          server_data,
          data: data2
        },
        {
          node: await manifest2._.nodes[1](),
          // 1 is always the root error
          data: null,
          server_data: null
        }
      );
    }
    return await render_response({
      options: options2,
      manifest: manifest2,
      state,
      page_config: {
        ssr,
        csr
      },
      status,
      error: await handle_error_and_jsonify(event, options2, error),
      branch,
      fetched,
      event,
      resolve_opts
    });
  } catch (e3) {
    if (e3 instanceof Redirect) {
      return redirect_response(e3.status, e3.location);
    }
    return static_error_page(
      options2,
      get_status(e3),
      (await handle_error_and_jsonify(event, options2, e3)).message
    );
  }
}
function once(fn) {
  let done = false;
  let result;
  return () => {
    if (done)
      return result;
    done = true;
    return result = fn();
  };
}
var encoder2 = new TextEncoder();
async function render_data(event, route, options2, manifest2, state, invalidated_data_nodes, trailing_slash) {
  if (!route.page) {
    return new Response(void 0, {
      status: 404
    });
  }
  try {
    const node_ids = [...route.page.layouts, route.page.leaf];
    const invalidated = invalidated_data_nodes ?? node_ids.map(() => true);
    let aborted = false;
    const url = new URL(event.url);
    url.pathname = normalize_path(url.pathname, trailing_slash);
    const new_event = { ...event, url };
    const functions = node_ids.map((n2, i3) => {
      return once(async () => {
        try {
          if (aborted) {
            return (
              /** @type {import('types').ServerDataSkippedNode} */
              {
                type: "skip"
              }
            );
          }
          const node = n2 == void 0 ? n2 : await manifest2._.nodes[n2]();
          return load_server_data({
            event: new_event,
            state,
            node,
            parent: async () => {
              const data22 = {};
              for (let j2 = 0; j2 < i3; j2 += 1) {
                const parent = (
                  /** @type {import('types').ServerDataNode | null} */
                  await functions[j2]()
                );
                if (parent) {
                  Object.assign(data22, parent.data);
                }
              }
              return data22;
            }
          });
        } catch (e3) {
          aborted = true;
          throw e3;
        }
      });
    });
    const promises = functions.map(async (fn, i3) => {
      if (!invalidated[i3]) {
        return (
          /** @type {import('types').ServerDataSkippedNode} */
          {
            type: "skip"
          }
        );
      }
      return fn();
    });
    let length = promises.length;
    const nodes = await Promise.all(
      promises.map(
        (p3, i3) => p3.catch(async (error) => {
          if (error instanceof Redirect) {
            throw error;
          }
          length = Math.min(length, i3 + 1);
          return (
            /** @type {import('types').ServerErrorNode} */
            {
              type: "error",
              error: await handle_error_and_jsonify(event, options2, error),
              status: error instanceof HttpError || error instanceof SvelteKitError ? error.status : void 0
            }
          );
        })
      )
    );
    const { data: data2, chunks } = get_data_json(event, options2, nodes);
    if (!chunks) {
      return json_response(data2);
    }
    return new Response(
      new ReadableStream({
        async start(controller) {
          controller.enqueue(encoder2.encode(data2));
          for await (const chunk of chunks) {
            controller.enqueue(encoder2.encode(chunk));
          }
          controller.close();
        },
        type: "bytes"
      }),
      {
        headers: {
          // we use a proprietary content type to prevent buffering.
          // the `text` prefix makes it inspectable
          "content-type": "text/sveltekit-data",
          "cache-control": "private, no-store"
        }
      }
    );
  } catch (e3) {
    const error = normalize_error(e3);
    if (error instanceof Redirect) {
      return redirect_json_response(error);
    } else {
      return json_response(await handle_error_and_jsonify(event, options2, error), 500);
    }
  }
}
function json_response(json2, status = 200) {
  return text(typeof json2 === "string" ? json2 : JSON.stringify(json2), {
    status,
    headers: {
      "content-type": "application/json",
      "cache-control": "private, no-store"
    }
  });
}
function redirect_json_response(redirect2) {
  return json_response({
    type: "redirect",
    location: redirect2.location
  });
}
function get_data_json(event, options2, nodes) {
  let promise_id = 1;
  let count = 0;
  const { iterator, push, done } = create_async_iterator();
  const reducers = {
    /** @param {any} thing */
    Promise: (thing) => {
      if (typeof thing?.then === "function") {
        const id2 = promise_id++;
        count += 1;
        let key2 = "data";
        thing.catch(
          /** @param {any} e */
          async (e3) => {
            key2 = "error";
            return handle_error_and_jsonify(
              event,
              options2,
              /** @type {any} */
              e3
            );
          }
        ).then(
          /** @param {any} value */
          async (value) => {
            let str;
            try {
              str = stringify(value, reducers);
            } catch (e3) {
              const error = await handle_error_and_jsonify(
                event,
                options2,
                new Error(`Failed to serialize promise while rendering ${event.route.id}`)
              );
              key2 = "error";
              str = stringify(error, reducers);
            }
            count -= 1;
            push(`{"type":"chunk","id":${id2},"${key2}":${str}}
`);
            if (count === 0)
              done();
          }
        );
        return id2;
      }
    }
  };
  try {
    const strings = nodes.map((node) => {
      if (!node)
        return "null";
      if (node.type === "error" || node.type === "skip") {
        return JSON.stringify(node);
      }
      return `{"type":"data","data":${stringify(node.data, reducers)},${stringify_uses(
        node
      )}${node.slash ? `,"slash":${JSON.stringify(node.slash)}` : ""}}`;
    });
    return {
      data: `{"type":"data","nodes":[${strings.join(",")}]}
`,
      chunks: count > 0 ? iterator : null
    };
  } catch (e3) {
    throw new Error(clarify_devalue_error(
      event,
      /** @type {any} */
      e3
    ));
  }
}
function load_page_nodes(page2, manifest2) {
  return Promise.all([
    // we use == here rather than === because [undefined] serializes as "[null]"
    ...page2.layouts.map((n2) => n2 == void 0 ? n2 : manifest2._.nodes[n2]()),
    manifest2._.nodes[page2.leaf]()
  ]);
}
var MAX_DEPTH = 10;
async function render_page(event, page2, options2, manifest2, state, resolve_opts) {
  if (state.depth > MAX_DEPTH) {
    return text(`Not found: ${event.url.pathname}`, {
      status: 404
      // TODO in some cases this should be 500. not sure how to differentiate
    });
  }
  if (is_action_json_request(event)) {
    const node = await manifest2._.nodes[page2.leaf]();
    return handle_action_json_request(event, options2, node?.server);
  }
  try {
    const nodes = await load_page_nodes(page2, manifest2);
    const leaf_node = (
      /** @type {import('types').SSRNode} */
      nodes.at(-1)
    );
    let status = 200;
    let action_result = void 0;
    if (is_action_request(event)) {
      action_result = await handle_action_request(event, leaf_node.server);
      if (action_result?.type === "redirect") {
        return redirect_response(action_result.status, action_result.location);
      }
      if (action_result?.type === "error") {
        status = get_status(action_result.error);
      }
      if (action_result?.type === "failure") {
        status = action_result.status;
      }
    }
    const should_prerender_data = nodes.some((node) => node?.server?.load);
    const data_pathname = add_data_suffix(event.url.pathname);
    const should_prerender = get_option(nodes, "prerender") ?? false;
    if (should_prerender) {
      const mod = leaf_node.server;
      if (mod?.actions) {
        throw new Error("Cannot prerender pages with actions");
      }
    } else if (state.prerendering) {
      return new Response(void 0, {
        status: 204
      });
    }
    state.prerender_default = should_prerender;
    const fetched = [];
    if (get_option(nodes, "ssr") === false && !(state.prerendering && should_prerender_data)) {
      return await render_response({
        branch: [],
        fetched,
        page_config: {
          ssr: false,
          csr: get_option(nodes, "csr") ?? true
        },
        status,
        error: null,
        event,
        options: options2,
        manifest: manifest2,
        state,
        resolve_opts
      });
    }
    const branch = [];
    let load_error = null;
    const server_promises = nodes.map((node, i3) => {
      if (load_error) {
        throw load_error;
      }
      return Promise.resolve().then(async () => {
        try {
          if (node === leaf_node && action_result?.type === "error") {
            throw action_result.error;
          }
          return await load_server_data({
            event,
            state,
            node,
            parent: async () => {
              const data2 = {};
              for (let j2 = 0; j2 < i3; j2 += 1) {
                const parent = await server_promises[j2];
                if (parent)
                  Object.assign(data2, await parent.data);
              }
              return data2;
            }
          });
        } catch (e3) {
          load_error = /** @type {Error} */
          e3;
          throw load_error;
        }
      });
    });
    const csr = get_option(nodes, "csr") ?? true;
    const load_promises = nodes.map((node, i3) => {
      if (load_error)
        throw load_error;
      return Promise.resolve().then(async () => {
        try {
          return await load_data({
            event,
            fetched,
            node,
            parent: async () => {
              const data2 = {};
              for (let j2 = 0; j2 < i3; j2 += 1) {
                Object.assign(data2, await load_promises[j2]);
              }
              return data2;
            },
            resolve_opts,
            server_data_promise: server_promises[i3],
            state,
            csr
          });
        } catch (e3) {
          load_error = /** @type {Error} */
          e3;
          throw load_error;
        }
      });
    });
    for (const p3 of server_promises)
      p3.catch(() => {
      });
    for (const p3 of load_promises)
      p3.catch(() => {
      });
    for (let i3 = 0; i3 < nodes.length; i3 += 1) {
      const node = nodes[i3];
      if (node) {
        try {
          const server_data = await server_promises[i3];
          const data2 = await load_promises[i3];
          branch.push({ node, server_data, data: data2 });
        } catch (e3) {
          const err = normalize_error(e3);
          if (err instanceof Redirect) {
            if (state.prerendering && should_prerender_data) {
              const body2 = JSON.stringify({
                type: "redirect",
                location: err.location
              });
              state.prerendering.dependencies.set(data_pathname, {
                response: text(body2),
                body: body2
              });
            }
            return redirect_response(err.status, err.location);
          }
          const status2 = get_status(err);
          const error = await handle_error_and_jsonify(event, options2, err);
          while (i3--) {
            if (page2.errors[i3]) {
              const index15 = (
                /** @type {number} */
                page2.errors[i3]
              );
              const node2 = await manifest2._.nodes[index15]();
              let j2 = i3;
              while (!branch[j2])
                j2 -= 1;
              return await render_response({
                event,
                options: options2,
                manifest: manifest2,
                state,
                resolve_opts,
                page_config: { ssr: true, csr: true },
                status: status2,
                error,
                branch: compact(branch.slice(0, j2 + 1)).concat({
                  node: node2,
                  data: null,
                  server_data: null
                }),
                fetched
              });
            }
          }
          return static_error_page(options2, status2, error.message);
        }
      } else {
        branch.push(null);
      }
    }
    if (state.prerendering && should_prerender_data) {
      let { data: data2, chunks } = get_data_json(
        event,
        options2,
        branch.map((node) => node?.server_data)
      );
      if (chunks) {
        for await (const chunk of chunks) {
          data2 += chunk;
        }
      }
      state.prerendering.dependencies.set(data_pathname, {
        response: text(data2),
        body: data2
      });
    }
    const ssr = get_option(nodes, "ssr") ?? true;
    return await render_response({
      event,
      options: options2,
      manifest: manifest2,
      state,
      resolve_opts,
      page_config: {
        csr: get_option(nodes, "csr") ?? true,
        ssr
      },
      status,
      error: null,
      branch: ssr === false ? [] : compact(branch),
      action_result,
      fetched
    });
  } catch (e3) {
    return await respond_with_error({
      event,
      options: options2,
      manifest: manifest2,
      state,
      status: 500,
      error: e3,
      resolve_opts
    });
  }
}
function exec(match, params, matchers) {
  const result = {};
  const values = match.slice(1);
  const values_needing_match = values.filter((value) => value !== void 0);
  let buffered = 0;
  for (let i3 = 0; i3 < params.length; i3 += 1) {
    const param = params[i3];
    let value = values[i3 - buffered];
    if (param.chained && param.rest && buffered) {
      value = values.slice(i3 - buffered, i3 + 1).filter((s22) => s22).join("/");
      buffered = 0;
    }
    if (value === void 0) {
      if (param.rest)
        result[param.name] = "";
      continue;
    }
    if (!param.matcher || matchers[param.matcher](value)) {
      result[param.name] = value;
      const next_param = params[i3 + 1];
      const next_value = values[i3 + 1];
      if (next_param && !next_param.rest && next_param.optional && next_value && param.chained) {
        buffered = 0;
      }
      if (!next_param && !next_value && Object.keys(result).length === values_needing_match.length) {
        buffered = 0;
      }
      continue;
    }
    if (param.optional && param.chained) {
      buffered++;
      continue;
    }
    return;
  }
  if (buffered)
    return;
  return result;
}
function validate_options(options2) {
  if (options2?.path === void 0) {
    throw new Error("You must specify a `path` when setting, deleting or serializing cookies");
  }
}
function get_cookies(request, url, trailing_slash) {
  const header = request.headers.get("cookie") ?? "";
  const initial_cookies = (0, import_cookie.parse)(header, { decode: (value) => value });
  const normalized_url = normalize_path(url.pathname, trailing_slash);
  const new_cookies = {};
  const defaults6 = {
    httpOnly: true,
    sameSite: "lax",
    secure: url.hostname === "localhost" && url.protocol === "http:" ? false : true
  };
  const cookies = {
    // The JSDoc param annotations appearing below for get, set and delete
    // are necessary to expose the `cookie` library types to
    // typescript users. `@type {import('@sveltejs/kit').Cookies}` above is not
    // sufficient to do so.
    /**
     * @param {string} name
     * @param {import('cookie').CookieParseOptions} opts
     */
    get(name5, opts) {
      const c2 = new_cookies[name5];
      if (c2 && domain_matches(url.hostname, c2.options.domain) && path_matches(url.pathname, c2.options.path)) {
        return c2.value;
      }
      const decoder = opts?.decode || decodeURIComponent;
      const req_cookies = (0, import_cookie.parse)(header, { decode: decoder });
      const cookie = req_cookies[name5];
      return cookie;
    },
    /**
     * @param {import('cookie').CookieParseOptions} opts
     */
    getAll(opts) {
      const decoder = opts?.decode || decodeURIComponent;
      const cookies2 = (0, import_cookie.parse)(header, { decode: decoder });
      for (const c2 of Object.values(new_cookies)) {
        if (domain_matches(url.hostname, c2.options.domain) && path_matches(url.pathname, c2.options.path)) {
          cookies2[c2.name] = c2.value;
        }
      }
      return Object.entries(cookies2).map(([name5, value]) => ({ name: name5, value }));
    },
    /**
     * @param {string} name
     * @param {string} value
     * @param {import('./page/types.js').Cookie['options']} options
     */
    set(name5, value, options2) {
      validate_options(options2);
      set_internal(name5, value, { ...defaults6, ...options2 });
    },
    /**
     * @param {string} name
     *  @param {import('./page/types.js').Cookie['options']} options
     */
    delete(name5, options2) {
      validate_options(options2);
      cookies.set(name5, "", { ...options2, maxAge: 0 });
    },
    /**
     * @param {string} name
     * @param {string} value
     *  @param {import('./page/types.js').Cookie['options']} options
     */
    serialize(name5, value, options2) {
      validate_options(options2);
      let path = options2.path;
      if (!options2.domain || options2.domain === url.hostname) {
        path = resolve(normalized_url, path);
      }
      return (0, import_cookie.serialize)(name5, value, { ...defaults6, ...options2, path });
    }
  };
  function get_cookie_header(destination, header2) {
    const combined_cookies = {
      // cookies sent by the user agent have lowest precedence
      ...initial_cookies
    };
    for (const key2 in new_cookies) {
      const cookie = new_cookies[key2];
      if (!domain_matches(destination.hostname, cookie.options.domain))
        continue;
      if (!path_matches(destination.pathname, cookie.options.path))
        continue;
      const encoder22 = cookie.options.encode || encodeURIComponent;
      combined_cookies[cookie.name] = encoder22(cookie.value);
    }
    if (header2) {
      const parsed = (0, import_cookie.parse)(header2, { decode: (value) => value });
      for (const name5 in parsed) {
        combined_cookies[name5] = parsed[name5];
      }
    }
    return Object.entries(combined_cookies).map(([name5, value]) => `${name5}=${value}`).join("; ");
  }
  function set_internal(name5, value, options2) {
    let path = options2.path;
    if (!options2.domain || options2.domain === url.hostname) {
      path = resolve(normalized_url, path);
    }
    new_cookies[name5] = { name: name5, value, options: { ...options2, path } };
  }
  return { cookies, new_cookies, get_cookie_header, set_internal };
}
function domain_matches(hostname, constraint2) {
  if (!constraint2)
    return true;
  const normalized = constraint2[0] === "." ? constraint2.slice(1) : constraint2;
  if (hostname === normalized)
    return true;
  return hostname.endsWith("." + normalized);
}
function path_matches(path, constraint2) {
  if (!constraint2)
    return true;
  const normalized = constraint2.endsWith("/") ? constraint2.slice(0, -1) : constraint2;
  if (path === normalized)
    return true;
  return path.startsWith(normalized + "/");
}
function add_cookies_to_headers(headers2, cookies) {
  for (const new_cookie of cookies) {
    const { name: name5, value, options: options2 } = new_cookie;
    headers2.append("set-cookie", (0, import_cookie.serialize)(name5, value, options2));
    if (options2.path.endsWith(".html")) {
      const path = add_data_suffix(options2.path);
      headers2.append("set-cookie", (0, import_cookie.serialize)(name5, value, { ...options2, path }));
    }
  }
}
function create_fetch({ event, options: options2, manifest: manifest2, state, get_cookie_header, set_internal }) {
  const server_fetch = async (info, init2) => {
    const original_request = normalize_fetch_input(info, init2, event.url);
    let mode = (info instanceof Request ? info.mode : init2?.mode) ?? "cors";
    let credentials = (info instanceof Request ? info.credentials : init2?.credentials) ?? "same-origin";
    return options2.hooks.handleFetch({
      event,
      request: original_request,
      fetch: async (info2, init3) => {
        const request = normalize_fetch_input(info2, init3, event.url);
        const url = new URL(request.url);
        if (!request.headers.has("origin")) {
          request.headers.set("origin", event.url.origin);
        }
        if (info2 !== original_request) {
          mode = (info2 instanceof Request ? info2.mode : init3?.mode) ?? "cors";
          credentials = (info2 instanceof Request ? info2.credentials : init3?.credentials) ?? "same-origin";
        }
        if ((request.method === "GET" || request.method === "HEAD") && (mode === "no-cors" && url.origin !== event.url.origin || url.origin === event.url.origin)) {
          request.headers.delete("origin");
        }
        if (url.origin !== event.url.origin) {
          if (`.${url.hostname}`.endsWith(`.${event.url.hostname}`) && credentials !== "omit") {
            const cookie = get_cookie_header(url, request.headers.get("cookie"));
            if (cookie)
              request.headers.set("cookie", cookie);
          }
          return fetch(request);
        }
        const prefix = assets || base;
        const decoded = decodeURIComponent(url.pathname);
        const filename = (decoded.startsWith(prefix) ? decoded.slice(prefix.length) : decoded).slice(1);
        const filename_html = `${filename}/index.html`;
        const is_asset = manifest2.assets.has(filename);
        const is_asset_html = manifest2.assets.has(filename_html);
        if (is_asset || is_asset_html) {
          const file = is_asset ? filename : filename_html;
          if (state.read) {
            const type = is_asset ? manifest2.mimeTypes[filename.slice(filename.lastIndexOf("."))] : "text/html";
            return new Response(state.read(file), {
              headers: type ? { "content-type": type } : {}
            });
          }
          return await fetch(request);
        }
        if (credentials !== "omit") {
          const cookie = get_cookie_header(url, request.headers.get("cookie"));
          if (cookie) {
            request.headers.set("cookie", cookie);
          }
          const authorization = event.request.headers.get("authorization");
          if (authorization && !request.headers.has("authorization")) {
            request.headers.set("authorization", authorization);
          }
        }
        if (!request.headers.has("accept")) {
          request.headers.set("accept", "*/*");
        }
        if (!request.headers.has("accept-language")) {
          request.headers.set(
            "accept-language",
            /** @type {string} */
            event.request.headers.get("accept-language")
          );
        }
        const response = await respond(request, options2, manifest2, {
          ...state,
          depth: state.depth + 1
        });
        const set_cookie = response.headers.get("set-cookie");
        if (set_cookie) {
          for (const str of set_cookie_parser.splitCookiesString(set_cookie)) {
            const { name: name5, value, ...options3 } = set_cookie_parser.parseString(str);
            const path = options3.path ?? (url.pathname.split("/").slice(0, -1).join("/") || "/");
            set_internal(name5, value, {
              path,
              .../** @type {import('cookie').CookieSerializeOptions} */
              options3
            });
          }
        }
        return response;
      }
    });
  };
  return (input, init2) => {
    const response = server_fetch(input, init2);
    response.catch(() => {
    });
    return response;
  };
}
function normalize_fetch_input(info, init2, url) {
  if (info instanceof Request) {
    return info;
  }
  return new Request(typeof info === "string" ? new URL(info, url) : info, init2);
}
var body;
var etag;
var headers;
function get_public_env(request) {
  body ??= `export const env=${JSON.stringify(public_env)}`;
  etag ??= `W/${Date.now()}`;
  headers ??= new Headers({
    "content-type": "application/javascript; charset=utf-8",
    etag
  });
  if (request.headers.get("if-none-match") === etag) {
    return new Response(void 0, { status: 304, headers });
  }
  return new Response(body, { headers });
}
function get_page_config(nodes) {
  let current = {};
  for (const node of nodes) {
    if (!node?.universal?.config && !node?.server?.config)
      continue;
    current = {
      ...current,
      ...node?.universal?.config,
      ...node?.server?.config
    };
  }
  return Object.keys(current).length ? current : void 0;
}
var default_transform = ({ html }) => html;
var default_filter = () => false;
var default_preload = ({ type }) => type === "js" || type === "css";
var page_methods = /* @__PURE__ */ new Set(["GET", "HEAD", "POST"]);
var allowed_page_methods = /* @__PURE__ */ new Set(["GET", "HEAD", "OPTIONS"]);
async function respond(request, options2, manifest2, state) {
  const url = new URL(request.url);
  if (options2.csrf_check_origin) {
    const forbidden = is_form_content_type(request) && (request.method === "POST" || request.method === "PUT" || request.method === "PATCH" || request.method === "DELETE") && request.headers.get("origin") !== url.origin;
    if (forbidden) {
      const csrf_error = new HttpError(
        403,
        `Cross-site ${request.method} form submissions are forbidden`
      );
      if (request.headers.get("accept") === "application/json") {
        return json(csrf_error.body, { status: csrf_error.status });
      }
      return text(csrf_error.body.message, { status: csrf_error.status });
    }
  }
  let rerouted_path;
  try {
    rerouted_path = options2.hooks.reroute({ url: new URL(url) }) ?? url.pathname;
  } catch (e3) {
    return text("Internal Server Error", {
      status: 500
    });
  }
  let decoded;
  try {
    decoded = decode_pathname(rerouted_path);
  } catch {
    return text("Malformed URI", { status: 400 });
  }
  let route = null;
  let params = {};
  if (base && !state.prerendering?.fallback) {
    if (!decoded.startsWith(base)) {
      return text("Not found", { status: 404 });
    }
    decoded = decoded.slice(base.length) || "/";
  }
  if (decoded === `/${options2.app_dir}/env.js`) {
    return get_public_env(request);
  }
  if (decoded.startsWith(`/${options2.app_dir}`)) {
    return text("Not found", { status: 404 });
  }
  const is_data_request = has_data_suffix(decoded);
  let invalidated_data_nodes;
  if (is_data_request) {
    decoded = strip_data_suffix(decoded) || "/";
    url.pathname = strip_data_suffix(url.pathname) + (url.searchParams.get(TRAILING_SLASH_PARAM) === "1" ? "/" : "") || "/";
    url.searchParams.delete(TRAILING_SLASH_PARAM);
    invalidated_data_nodes = url.searchParams.get(INVALIDATED_PARAM)?.split("").map((node) => node === "1");
    url.searchParams.delete(INVALIDATED_PARAM);
  }
  if (!state.prerendering?.fallback) {
    const matchers = await manifest2._.matchers();
    for (const candidate of manifest2._.routes) {
      const match = candidate.pattern.exec(decoded);
      if (!match)
        continue;
      const matched = exec(match, candidate.params, matchers);
      if (matched) {
        route = candidate;
        params = decode_params(matched);
        break;
      }
    }
  }
  let trailing_slash = void 0;
  const headers2 = {};
  let cookies_to_add = {};
  const event = {
    // @ts-expect-error `cookies` and `fetch` need to be created after the `event` itself
    cookies: null,
    // @ts-expect-error
    fetch: null,
    getClientAddress: state.getClientAddress || (() => {
      throw new Error(
        `${"@sveltejs/adapter-cloudflare"} does not specify getClientAddress. Please raise an issue`
      );
    }),
    locals: {},
    params,
    platform: state.platform,
    request,
    route: { id: route?.id ?? null },
    setHeaders: (new_headers) => {
      for (const key2 in new_headers) {
        const lower = key2.toLowerCase();
        const value = new_headers[key2];
        if (lower === "set-cookie") {
          throw new Error(
            "Use `event.cookies.set(name, value, options)` instead of `event.setHeaders` to set cookies"
          );
        } else if (lower in headers2) {
          throw new Error(`"${key2}" header is already set`);
        } else {
          headers2[lower] = value;
          if (state.prerendering && lower === "cache-control") {
            state.prerendering.cache = /** @type {string} */
            value;
          }
        }
      }
    },
    url,
    isDataRequest: is_data_request,
    isSubRequest: state.depth > 0
  };
  let resolve_opts = {
    transformPageChunk: default_transform,
    filterSerializedResponseHeaders: default_filter,
    preload: default_preload
  };
  try {
    if (route) {
      if (url.pathname === base || url.pathname === base + "/") {
        trailing_slash = "always";
      } else if (route.page) {
        const nodes = await load_page_nodes(route.page, manifest2);
        if (DEV)
          ;
        trailing_slash = get_option(nodes, "trailingSlash");
      } else if (route.endpoint) {
        const node = await route.endpoint();
        trailing_slash = node.trailingSlash;
        if (DEV)
          ;
      }
      if (!is_data_request) {
        const normalized = normalize_path(url.pathname, trailing_slash ?? "never");
        if (normalized !== url.pathname && !state.prerendering?.fallback) {
          return new Response(void 0, {
            status: 308,
            headers: {
              "x-sveltekit-normalize": "1",
              location: (
                // ensure paths starting with '//' are not treated as protocol-relative
                (normalized.startsWith("//") ? url.origin + normalized : normalized) + (url.search === "?" ? "" : url.search)
              )
            }
          });
        }
      }
      if (state.before_handle || state.emulator?.platform) {
        let config = {};
        let prerender = false;
        if (route.endpoint) {
          const node = await route.endpoint();
          config = node.config ?? config;
          prerender = node.prerender ?? prerender;
        } else if (route.page) {
          const nodes = await load_page_nodes(route.page, manifest2);
          config = get_page_config(nodes) ?? config;
          prerender = get_option(nodes, "prerender") ?? false;
        }
        if (state.before_handle) {
          state.before_handle(event, config, prerender);
        }
        if (state.emulator?.platform) {
          event.platform = await state.emulator.platform({ config, prerender });
        }
      }
    }
    const { cookies, new_cookies, get_cookie_header, set_internal } = get_cookies(
      request,
      url,
      trailing_slash ?? "never"
    );
    cookies_to_add = new_cookies;
    event.cookies = cookies;
    event.fetch = create_fetch({
      event,
      options: options2,
      manifest: manifest2,
      state,
      get_cookie_header,
      set_internal
    });
    if (state.prerendering && !state.prerendering.fallback)
      disable_search(url);
    const response = await options2.hooks.handle({
      event,
      resolve: (event2, opts) => resolve2(event2, opts).then((response2) => {
        for (const key2 in headers2) {
          const value = headers2[key2];
          response2.headers.set(
            key2,
            /** @type {string} */
            value
          );
        }
        add_cookies_to_headers(response2.headers, Object.values(cookies_to_add));
        if (state.prerendering && event2.route.id !== null) {
          response2.headers.set("x-sveltekit-routeid", encodeURI(event2.route.id));
        }
        return response2;
      })
    });
    if (response.status === 200 && response.headers.has("etag")) {
      let if_none_match_value = request.headers.get("if-none-match");
      if (if_none_match_value?.startsWith('W/"')) {
        if_none_match_value = if_none_match_value.substring(2);
      }
      const etag2 = (
        /** @type {string} */
        response.headers.get("etag")
      );
      if (if_none_match_value === etag2) {
        const headers22 = new Headers({ etag: etag2 });
        for (const key2 of [
          "cache-control",
          "content-location",
          "date",
          "expires",
          "vary",
          "set-cookie"
        ]) {
          const value = response.headers.get(key2);
          if (value)
            headers22.set(key2, value);
        }
        return new Response(void 0, {
          status: 304,
          headers: headers22
        });
      }
    }
    if (is_data_request && response.status >= 300 && response.status <= 308) {
      const location2 = response.headers.get("location");
      if (location2) {
        return redirect_json_response(new Redirect(
          /** @type {any} */
          response.status,
          location2
        ));
      }
    }
    return response;
  } catch (e3) {
    if (e3 instanceof Redirect) {
      const response = is_data_request ? redirect_json_response(e3) : route?.page && is_action_json_request(event) ? action_json_redirect(e3) : redirect_response(e3.status, e3.location);
      add_cookies_to_headers(response.headers, Object.values(cookies_to_add));
      return response;
    }
    return await handle_fatal_error(event, options2, e3);
  }
  async function resolve2(event2, opts) {
    try {
      if (opts) {
        resolve_opts = {
          transformPageChunk: opts.transformPageChunk || default_transform,
          filterSerializedResponseHeaders: opts.filterSerializedResponseHeaders || default_filter,
          preload: opts.preload || default_preload
        };
      }
      if (state.prerendering?.fallback) {
        return await render_response({
          event: event2,
          options: options2,
          manifest: manifest2,
          state,
          page_config: { ssr: false, csr: true },
          status: 200,
          error: null,
          branch: [],
          fetched: [],
          resolve_opts
        });
      }
      if (route) {
        const method = (
          /** @type {import('types').HttpMethod} */
          event2.request.method
        );
        let response;
        if (is_data_request) {
          response = await render_data(
            event2,
            route,
            options2,
            manifest2,
            state,
            invalidated_data_nodes,
            trailing_slash ?? "never"
          );
        } else if (route.endpoint && (!route.page || is_endpoint_request(event2))) {
          response = await render_endpoint(event2, await route.endpoint(), state);
        } else if (route.page) {
          if (page_methods.has(method)) {
            response = await render_page(event2, route.page, options2, manifest2, state, resolve_opts);
          } else {
            const allowed_methods2 = new Set(allowed_page_methods);
            const node = await manifest2._.nodes[route.page.leaf]();
            if (node?.server?.actions) {
              allowed_methods2.add("POST");
            }
            if (method === "OPTIONS") {
              response = new Response(null, {
                status: 204,
                headers: {
                  allow: Array.from(allowed_methods2.values()).join(", ")
                }
              });
            } else {
              const mod = [...allowed_methods2].reduce(
                (acc, curr) => {
                  acc[curr] = true;
                  return acc;
                },
                /** @type {Record<string, any>} */
                {}
              );
              response = method_not_allowed(mod, method);
            }
          }
        } else {
          throw new Error("This should never happen");
        }
        if (request.method === "GET" && route.page && route.endpoint) {
          const vary = response.headers.get("vary")?.split(",")?.map((v3) => v3.trim().toLowerCase());
          if (!(vary?.includes("accept") || vary?.includes("*"))) {
            response = new Response(response.body, {
              status: response.status,
              statusText: response.statusText,
              headers: new Headers(response.headers)
            });
            response.headers.append("Vary", "Accept");
          }
        }
        return response;
      }
      if (state.error && event2.isSubRequest) {
        return await fetch(request, {
          headers: {
            "x-sveltekit-error": "true"
          }
        });
      }
      if (state.error) {
        return text("Internal Server Error", {
          status: 500
        });
      }
      if (state.depth === 0) {
        return await respond_with_error({
          event: event2,
          options: options2,
          manifest: manifest2,
          state,
          status: 404,
          error: new SvelteKitError(404, "Not Found", `Not found: ${event2.url.pathname}`),
          resolve_opts
        });
      }
      if (state.prerendering) {
        return text("not found", { status: 404 });
      }
      return await fetch(request);
    } catch (e3) {
      return await handle_fatal_error(event2, options2, e3);
    } finally {
      event2.cookies.set = () => {
        throw new Error("Cannot use `cookies.set(...)` after the response has been generated");
      };
      event2.setHeaders = () => {
        throw new Error("Cannot use `setHeaders(...)` after the response has been generated");
      };
    }
  }
}
function filter_private_env(env, { public_prefix, private_prefix }) {
  return Object.fromEntries(
    Object.entries(env).filter(
      ([k2]) => k2.startsWith(private_prefix) && (public_prefix === "" || !k2.startsWith(public_prefix))
    )
  );
}
function filter_public_env(env, { public_prefix, private_prefix }) {
  return Object.fromEntries(
    Object.entries(env).filter(
      ([k2]) => k2.startsWith(public_prefix) && (private_prefix === "" || !k2.startsWith(private_prefix))
    )
  );
}
var prerender_env_handler = {
  get({ type }, prop) {
    throw new Error(
      `Cannot read values from $env/dynamic/${type} while prerendering (attempted to read env.${prop.toString()}). Use $env/static/${type} instead`
    );
  }
};
var Server = class {
  /** @type {import('types').SSROptions} */
  #options;
  /** @type {import('@sveltejs/kit').SSRManifest} */
  #manifest;
  /** @param {import('@sveltejs/kit').SSRManifest} manifest */
  constructor(manifest2) {
    this.#options = options;
    this.#manifest = manifest2;
  }
  /**
   * @param {{
   *   env: Record<string, string>;
   *   read?: (file: string) => ReadableStream;
   * }} opts
   */
  async init({ env, read }) {
    const prefixes = {
      public_prefix: this.#options.env_public_prefix,
      private_prefix: this.#options.env_private_prefix
    };
    const private_env = filter_private_env(env, prefixes);
    const public_env2 = filter_public_env(env, prefixes);
    set_private_env(
      prerendering ? new Proxy({ type: "private" }, prerender_env_handler) : private_env
    );
    set_public_env(
      prerendering ? new Proxy({ type: "public" }, prerender_env_handler) : public_env2
    );
    set_safe_public_env(public_env2);
    if (!this.#options.hooks) {
      try {
        const module = await get_hooks();
        this.#options.hooks = {
          handle: module.handle || (({ event, resolve: resolve2 }) => resolve2(event)),
          handleError: module.handleError || (({ error }) => console.error(error)),
          handleFetch: module.handleFetch || (({ request, fetch: fetch2 }) => fetch2(request)),
          reroute: module.reroute || (() => {
          })
        };
      } catch (error) {
        {
          throw error;
        }
      }
    }
  }
  /**
   * @param {Request} request
   * @param {import('types').RequestOptions} options
   */
  async respond(request, options2) {
    return respond(request, this.#options, this.#manifest, {
      ...options2,
      error: false,
      depth: 0
    });
  }
};
var manifest = (() => {
  function __memo(fn) {
    let value;
    return () => value ??= value = fn();
  }
  return {
    appDir: "_app",
    appPath: "_app",
    assets: /* @__PURE__ */ new Set(["favicon.png", "logo-01.png", "logo-02.png", "logo-03.png", "weather-icons/01d@2x.png", "weather-icons/01n@2x.png", "weather-icons/02d@2x.png", "weather-icons/02n@2x.png", "weather-icons/03d@2x.png", "weather-icons/03n@2x.png", "weather-icons/04d@2x.png", "weather-icons/04n@2x.png", "weather-icons/09d@2x.png", "weather-icons/09n@2x.png", "weather-icons/10d@2x.png", "weather-icons/10n@2x.png", "weather-icons/11d@2x.png", "weather-icons/11n@2x.png", "weather-icons/13d@2x.png", "weather-icons/13n@2x.png", "weather-icons/50d@2x.png", "weather-icons/50n@2x.png"]),
    mimeTypes: { ".png": "image/png" },
    _: {
      client: { "start": "_app/immutable/entry/start.DycAiqCJ.js", "app": "_app/immutable/entry/app.ceAX2wHr.js", "imports": ["_app/immutable/entry/start.DycAiqCJ.js", "_app/immutable/chunks/entry.BIRdqJCX.js", "_app/immutable/chunks/scheduler.Cglc-E-6.js", "_app/immutable/chunks/index.C4PciY-_.js", "_app/immutable/entry/app.ceAX2wHr.js", "_app/immutable/chunks/scheduler.Cglc-E-6.js", "_app/immutable/chunks/index.9iPnfnGV.js"], "stylesheets": [], "fonts": [], "uses_env_dynamic_public": false },
      nodes: [
        __memo(() => Promise.resolve().then(() => (init__(), __exports))),
        __memo(() => Promise.resolve().then(() => (init__2(), __exports2))),
        __memo(() => Promise.resolve().then(() => (init__3(), __exports3))),
        __memo(() => Promise.resolve().then(() => (init__4(), __exports4))),
        __memo(() => Promise.resolve().then(() => (init__5(), __exports5))),
        __memo(() => Promise.resolve().then(() => (init__6(), __exports6))),
        __memo(() => Promise.resolve().then(() => (init__7(), __exports7))),
        __memo(() => Promise.resolve().then(() => (init__8(), __exports8))),
        __memo(() => Promise.resolve().then(() => (init__9(), __exports9))),
        __memo(() => Promise.resolve().then(() => (init__10(), __exports10))),
        __memo(() => Promise.resolve().then(() => (init__11(), __exports11))),
        __memo(() => Promise.resolve().then(() => (init__12(), __exports12))),
        __memo(() => Promise.resolve().then(() => (init__13(), __exports13))),
        __memo(() => Promise.resolve().then(() => (init__14(), __exports14)))
      ],
      routes: [
        {
          id: "/(login)",
          pattern: /^\/?$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 13 },
          endpoint: null
        },
        {
          id: "/(dashboard)/[project]",
          pattern: /^\/([^/]+?)\/?$/,
          params: [{ "name": "project", "optional": false, "rest": false, "chained": false }],
          page: { layouts: [0, 2], errors: [1, 3], leaf: 4 },
          endpoint: null
        },
        {
          id: "/(dashboard)/[project]/experiments",
          pattern: /^\/([^/]+?)\/experiments\/?$/,
          params: [{ "name": "project", "optional": false, "rest": false, "chained": false }],
          page: { layouts: [0, 2], errors: [1, 3], leaf: 5 },
          endpoint: null
        },
        {
          id: "/(dashboard)/[project]/gambar-desain",
          pattern: /^\/([^/]+?)\/gambar-desain\/?$/,
          params: [{ "name": "project", "optional": false, "rest": false, "chained": false }],
          page: { layouts: [0, 2], errors: [1, 3], leaf: 6 },
          endpoint: null
        },
        {
          id: "/(dashboard)/[project]/identitas-proyek",
          pattern: /^\/([^/]+?)\/identitas-proyek\/?$/,
          params: [{ "name": "project", "optional": false, "rest": false, "chained": false }],
          page: { layouts: [0, 2], errors: [1, 3], leaf: 7 },
          endpoint: null
        },
        {
          id: "/(dashboard)/[project]/jadwal-project",
          pattern: /^\/([^/]+?)\/jadwal-project\/?$/,
          params: [{ "name": "project", "optional": false, "rest": false, "chained": false }],
          page: { layouts: [0, 2], errors: [1, 3], leaf: 8 },
          endpoint: null
        },
        {
          id: "/(dashboard)/[project]/lokasi",
          pattern: /^\/([^/]+?)\/lokasi\/?$/,
          params: [{ "name": "project", "optional": false, "rest": false, "chained": false }],
          page: { layouts: [0, 2], errors: [1, 3], leaf: 9 },
          endpoint: null
        },
        {
          id: "/(dashboard)/[project]/progress",
          pattern: /^\/([^/]+?)\/progress\/?$/,
          params: [{ "name": "project", "optional": false, "rest": false, "chained": false }],
          page: { layouts: [0, 2], errors: [1, 3], leaf: 10 },
          endpoint: null
        },
        {
          id: "/(dashboard)/[project]/realisasi-biaya",
          pattern: /^\/([^/]+?)\/realisasi-biaya\/?$/,
          params: [{ "name": "project", "optional": false, "rest": false, "chained": false }],
          page: { layouts: [0, 2], errors: [1, 3], leaf: 11 },
          endpoint: null
        },
        {
          id: "/(dashboard)/[project]/tim-pelaksana",
          pattern: /^\/([^/]+?)\/tim-pelaksana\/?$/,
          params: [{ "name": "project", "optional": false, "rest": false, "chained": false }],
          page: { layouts: [0, 2], errors: [1, 3], leaf: 12 },
          endpoint: null
        }
      ],
      matchers: async () => {
        return {};
      },
      server_assets: {}
    }
  };
})();
var prerendered = /* @__PURE__ */ new Set([]);
var app_path = "_app";
async function e(e3, t2) {
  let n2 = "string" != typeof t2 && "HEAD" === t2.method;
  n2 && (t2 = new Request(t2, { method: "GET" }));
  let r32 = await e3.match(t2);
  return n2 && r32 && (r32 = new Response(null, r32)), r32;
}
function t(e3, t2, n2, o2) {
  return ("string" == typeof t2 || "GET" === t2.method) && r3(n2) && (n2.headers.has("Set-Cookie") && (n2 = new Response(n2.body, n2)).headers.append("Cache-Control", "private=Set-Cookie"), o2.waitUntil(e3.put(t2, n2.clone()))), n2;
}
var n = /* @__PURE__ */ new Set([200, 203, 204, 300, 301, 404, 405, 410, 414, 501]);
function r3(e3) {
  if (!n.has(e3.status))
    return false;
  if (~(e3.headers.get("Vary") || "").indexOf("*"))
    return false;
  let t2 = e3.headers.get("Cache-Control") || "";
  return !/(private|no-cache|no-store)/i.test(t2);
}
function o(n2) {
  return async function(r32, o2) {
    let a2 = await e(n2, r32);
    if (a2)
      return a2;
    o2.defer((e3) => {
      t(n2, r32, e3, o2);
    });
  };
}
var s2 = caches.default;
var c = t.bind(0, s2);
var r22 = e.bind(0, s2);
var e2 = o.bind(0, s2);
var server = new Server(manifest);
var immutable = `/${app_path}/immutable/`;
var version_file = `/${app_path}/version.json`;
var worker = {
  async fetch(req, env, context) {
    await server.init({ env });
    let pragma = req.headers.get("cache-control") || "";
    let res = !pragma.includes("no-cache") && await r22(req);
    if (res)
      return res;
    let { pathname, search } = new URL(req.url);
    try {
      pathname = decodeURIComponent(pathname);
    } catch {
    }
    const stripped_pathname = pathname.replace(/\/$/, "");
    let is_static_asset = false;
    const filename = stripped_pathname.substring(1);
    if (filename) {
      is_static_asset = manifest.assets.has(filename) || manifest.assets.has(filename + "/index.html");
    }
    let location2 = pathname.at(-1) === "/" ? stripped_pathname : pathname + "/";
    if (is_static_asset || prerendered.has(pathname) || pathname === version_file || pathname.startsWith(immutable)) {
      res = await env.ASSETS.fetch(req);
    } else if (location2 && prerendered.has(location2)) {
      if (search)
        location2 += search;
      res = new Response("", {
        status: 308,
        headers: {
          location: location2
        }
      });
    } else {
      res = await server.respond(req, {
        // @ts-ignore
        platform: { env, context, caches, cf: req.cf },
        getClientAddress() {
          return req.headers.get("cf-connecting-ip");
        }
      });
    }
    pragma = res.headers.get("cache-control") || "";
    return pragma && res.status < 400 ? c(req, res, context) : res;
  }
};
var worker_default = worker;
var drainBody = async (request, env, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request, env);
  } finally {
    try {
      if (request.body !== null && !request.bodyUsed) {
        const reader = request.body.getReader();
        while (!(await reader.read()).done) {
        }
      }
    } catch (e3) {
      console.error("Failed to drain the unused request body.", e3);
    }
  }
};
var middleware_ensure_req_body_drained_default = drainBody;
var wrap2 = void 0;
function reduceError(e3) {
  return {
    name: e3?.name,
    message: e3?.message ?? String(e3),
    stack: e3?.stack,
    cause: e3?.cause === void 0 ? void 0 : reduceError(e3.cause)
  };
}
var jsonError = async (request, env, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request, env);
  } catch (e3) {
    const error = reduceError(e3);
    return Response.json(error, {
      status: 500,
      headers: { "MF-Experimental-Error-Stack": "true" }
    });
  }
};
var middleware_miniflare3_json_error_default = jsonError;
var wrap3 = void 0;
var envWrappers = [wrap2, wrap3].filter(Boolean);
var facade = {
  ...worker_default,
  envWrappers,
  middleware: [
    middleware_ensure_req_body_drained_default,
    middleware_miniflare3_json_error_default,
    ...worker_default.middleware ? worker_default.middleware : []
  ].filter(Boolean)
};
var middleware_insertion_facade_default = facade;
var __facade_middleware__ = [];
function __facade_register__(...args) {
  __facade_middleware__.push(...args.flat());
}
function __facade_invokeChain__(request, env, ctx, dispatch, middlewareChain) {
  const [head, ...tail] = middlewareChain;
  const middlewareCtx = {
    dispatch,
    next(newRequest, newEnv) {
      return __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);
    }
  };
  return head(request, env, ctx, middlewareCtx);
}
function __facade_invoke__(request, env, ctx, dispatch, finalMiddleware) {
  return __facade_invokeChain__(request, env, ctx, dispatch, [
    ...__facade_middleware__,
    finalMiddleware
  ]);
}
var __Facade_ScheduledController__ = class {
  constructor(scheduledTime, cron, noRetry) {
    this.scheduledTime = scheduledTime;
    this.cron = cron;
    this.#noRetry = noRetry;
  }
  #noRetry;
  noRetry() {
    if (!(this instanceof __Facade_ScheduledController__)) {
      throw new TypeError("Illegal invocation");
    }
    this.#noRetry();
  }
};
var __facade_modules_fetch__ = function(request, env, ctx) {
  if (middleware_insertion_facade_default.fetch === void 0)
    throw new Error("Handler does not export a fetch() function.");
  return middleware_insertion_facade_default.fetch(request, env, ctx);
};
function getMaskedEnv(rawEnv) {
  let env = rawEnv;
  if (middleware_insertion_facade_default.envWrappers && middleware_insertion_facade_default.envWrappers.length > 0) {
    for (const wrapFn of middleware_insertion_facade_default.envWrappers) {
      env = wrapFn(env);
    }
  }
  return env;
}
var registeredMiddleware = false;
var facade2 = {
  ...middleware_insertion_facade_default.tail && {
    tail: maskHandlerEnv(middleware_insertion_facade_default.tail)
  },
  ...middleware_insertion_facade_default.trace && {
    trace: maskHandlerEnv(middleware_insertion_facade_default.trace)
  },
  ...middleware_insertion_facade_default.scheduled && {
    scheduled: maskHandlerEnv(middleware_insertion_facade_default.scheduled)
  },
  ...middleware_insertion_facade_default.queue && {
    queue: maskHandlerEnv(middleware_insertion_facade_default.queue)
  },
  ...middleware_insertion_facade_default.test && {
    test: maskHandlerEnv(middleware_insertion_facade_default.test)
  },
  ...middleware_insertion_facade_default.email && {
    email: maskHandlerEnv(middleware_insertion_facade_default.email)
  },
  fetch(request, rawEnv, ctx) {
    const env = getMaskedEnv(rawEnv);
    if (middleware_insertion_facade_default.middleware && middleware_insertion_facade_default.middleware.length > 0) {
      if (!registeredMiddleware) {
        registeredMiddleware = true;
        for (const middleware of middleware_insertion_facade_default.middleware) {
          __facade_register__(middleware);
        }
      }
      const __facade_modules_dispatch__ = function(type, init2) {
        if (type === "scheduled" && middleware_insertion_facade_default.scheduled !== void 0) {
          const controller = new __Facade_ScheduledController__(
            Date.now(),
            init2.cron ?? "",
            () => {
            }
          );
          return middleware_insertion_facade_default.scheduled(controller, env, ctx);
        }
      };
      return __facade_invoke__(
        request,
        env,
        ctx,
        __facade_modules_dispatch__,
        __facade_modules_fetch__
      );
    } else {
      return __facade_modules_fetch__(request, env, ctx);
    }
  }
};
function maskHandlerEnv(handler) {
  return (data2, env, ctx) => handler(data2, getMaskedEnv(env), ctx);
}
var middleware_loader_entry_default = facade2;

// node_modules/wrangler/templates/pages-dev-util.ts
function isRoutingRuleMatch(pathname, routingRule) {
  if (!pathname) {
    throw new Error("Pathname is undefined.");
  }
  if (!routingRule) {
    throw new Error("Routing rule is undefined.");
  }
  const ruleRegExp = transformRoutingRuleToRegExp(routingRule);
  return pathname.match(ruleRegExp) !== null;
}
function transformRoutingRuleToRegExp(rule) {
  let transformedRule;
  if (rule === "/" || rule === "/*") {
    transformedRule = rule;
  } else if (rule.endsWith("/*")) {
    transformedRule = `${rule.substring(0, rule.length - 2)}(/*)?`;
  } else if (rule.endsWith("/")) {
    transformedRule = `${rule.substring(0, rule.length - 1)}(/)?`;
  } else if (rule.endsWith("*")) {
    transformedRule = rule;
  } else {
    transformedRule = `${rule}(/)?`;
  }
  transformedRule = `^${transformedRule.replaceAll(/\./g, "\\.").replaceAll(/\*/g, ".*")}$`;
  return new RegExp(transformedRule);
}

// .wrangler/tmp/pages-Sik1DJ/w2b83gqvz8.js
var define_ROUTES_default = {
  version: 1,
  description: "Generated by @sveltejs/adapter-cloudflare",
  include: [
    "/*"
  ],
  exclude: [
    "/_app/*",
    "/favicon.png",
    "/logo-01.png",
    "/logo-02.png",
    "/logo-03.png",
    "/weather-icons/01d@2x.png",
    "/weather-icons/01n@2x.png",
    "/weather-icons/02d@2x.png",
    "/weather-icons/02n@2x.png",
    "/weather-icons/03d@2x.png",
    "/weather-icons/03n@2x.png",
    "/weather-icons/04d@2x.png",
    "/weather-icons/04n@2x.png",
    "/weather-icons/09d@2x.png",
    "/weather-icons/09n@2x.png",
    "/weather-icons/10d@2x.png",
    "/weather-icons/10n@2x.png",
    "/weather-icons/11d@2x.png",
    "/weather-icons/11n@2x.png",
    "/weather-icons/13d@2x.png",
    "/weather-icons/13n@2x.png",
    "/weather-icons/50d@2x.png",
    "/weather-icons/50n@2x.png"
  ]
};
var routes = define_ROUTES_default;
var pages_dev_pipeline_default = {
  fetch(request, env, context) {
    const { pathname } = new URL(request.url);
    for (const exclude of routes.exclude) {
      if (isRoutingRuleMatch(pathname, exclude)) {
        return env.ASSETS.fetch(request);
      }
    }
    for (const include of routes.include) {
      if (isRoutingRuleMatch(pathname, include)) {
        if (middleware_loader_entry_default.fetch === void 0) {
          throw new TypeError("Entry point missing `fetch` handler");
        }
        return middleware_loader_entry_default.fetch(request, env, context);
      }
    }
    return env.ASSETS.fetch(request);
  }
};

// node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts
var drainBody2 = async (request, env, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request, env);
  } finally {
    try {
      if (request.body !== null && !request.bodyUsed) {
        const reader = request.body.getReader();
        while (!(await reader.read()).done) {
        }
      }
    } catch (e3) {
      console.error("Failed to drain the unused request body.", e3);
    }
  }
};
var middleware_ensure_req_body_drained_default2 = drainBody2;
var wrap4 = void 0;

// node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts
function reduceError2(e3) {
  return {
    name: e3?.name,
    message: e3?.message ?? String(e3),
    stack: e3?.stack,
    cause: e3?.cause === void 0 ? void 0 : reduceError2(e3.cause)
  };
}
var jsonError2 = async (request, env, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request, env);
  } catch (e3) {
    const error = reduceError2(e3);
    return Response.json(error, {
      status: 500,
      headers: { "MF-Experimental-Error-Stack": "true" }
    });
  }
};
var middleware_miniflare3_json_error_default2 = jsonError2;
var wrap5 = void 0;

// .wrangler/tmp/bundle-Nq6h8V/middleware-insertion-facade.js
var envWrappers2 = [wrap4, wrap5].filter(Boolean);
var facade3 = {
  ...pages_dev_pipeline_default,
  envWrappers: envWrappers2,
  middleware: [
    middleware_ensure_req_body_drained_default2,
    middleware_miniflare3_json_error_default2,
    ...pages_dev_pipeline_default.middleware ? pages_dev_pipeline_default.middleware : []
  ].filter(Boolean)
};
var middleware_insertion_facade_default2 = facade3;

// node_modules/wrangler/templates/middleware/common.ts
var __facade_middleware__2 = [];
function __facade_register__2(...args) {
  __facade_middleware__2.push(...args.flat());
}
function __facade_invokeChain__2(request, env, ctx, dispatch, middlewareChain) {
  const [head, ...tail] = middlewareChain;
  const middlewareCtx = {
    dispatch,
    next(newRequest, newEnv) {
      return __facade_invokeChain__2(newRequest, newEnv, ctx, dispatch, tail);
    }
  };
  return head(request, env, ctx, middlewareCtx);
}
function __facade_invoke__2(request, env, ctx, dispatch, finalMiddleware) {
  return __facade_invokeChain__2(request, env, ctx, dispatch, [
    ...__facade_middleware__2,
    finalMiddleware
  ]);
}

// .wrangler/tmp/bundle-Nq6h8V/middleware-loader.entry.ts
var __Facade_ScheduledController__2 = class {
  constructor(scheduledTime, cron, noRetry) {
    this.scheduledTime = scheduledTime;
    this.cron = cron;
    this.#noRetry = noRetry;
  }
  #noRetry;
  noRetry() {
    if (!(this instanceof __Facade_ScheduledController__2)) {
      throw new TypeError("Illegal invocation");
    }
    this.#noRetry();
  }
};
var __facade_modules_fetch__2 = function(request, env, ctx) {
  if (middleware_insertion_facade_default2.fetch === void 0)
    throw new Error("Handler does not export a fetch() function.");
  return middleware_insertion_facade_default2.fetch(request, env, ctx);
};
function getMaskedEnv2(rawEnv) {
  let env = rawEnv;
  if (middleware_insertion_facade_default2.envWrappers && middleware_insertion_facade_default2.envWrappers.length > 0) {
    for (const wrapFn of middleware_insertion_facade_default2.envWrappers) {
      env = wrapFn(env);
    }
  }
  return env;
}
var registeredMiddleware2 = false;
var facade4 = {
  ...middleware_insertion_facade_default2.tail && {
    tail: maskHandlerEnv2(middleware_insertion_facade_default2.tail)
  },
  ...middleware_insertion_facade_default2.trace && {
    trace: maskHandlerEnv2(middleware_insertion_facade_default2.trace)
  },
  ...middleware_insertion_facade_default2.scheduled && {
    scheduled: maskHandlerEnv2(middleware_insertion_facade_default2.scheduled)
  },
  ...middleware_insertion_facade_default2.queue && {
    queue: maskHandlerEnv2(middleware_insertion_facade_default2.queue)
  },
  ...middleware_insertion_facade_default2.test && {
    test: maskHandlerEnv2(middleware_insertion_facade_default2.test)
  },
  ...middleware_insertion_facade_default2.email && {
    email: maskHandlerEnv2(middleware_insertion_facade_default2.email)
  },
  fetch(request, rawEnv, ctx) {
    const env = getMaskedEnv2(rawEnv);
    if (middleware_insertion_facade_default2.middleware && middleware_insertion_facade_default2.middleware.length > 0) {
      if (!registeredMiddleware2) {
        registeredMiddleware2 = true;
        for (const middleware of middleware_insertion_facade_default2.middleware) {
          __facade_register__2(middleware);
        }
      }
      const __facade_modules_dispatch__ = function(type, init2) {
        if (type === "scheduled" && middleware_insertion_facade_default2.scheduled !== void 0) {
          const controller = new __Facade_ScheduledController__2(
            Date.now(),
            init2.cron ?? "",
            () => {
            }
          );
          return middleware_insertion_facade_default2.scheduled(controller, env, ctx);
        }
      };
      return __facade_invoke__2(
        request,
        env,
        ctx,
        __facade_modules_dispatch__,
        __facade_modules_fetch__2
      );
    } else {
      return __facade_modules_fetch__2(request, env, ctx);
    }
  }
};
function maskHandlerEnv2(handler) {
  return (data2, env, ctx) => handler(data2, getMaskedEnv2(env), ctx);
}
var middleware_loader_entry_default2 = facade4;
export {
  middleware_loader_entry_default2 as default
};
/*! Bundled license information:

@firebase/util/dist/index.esm2017.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2022 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2021 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/component/dist/esm/index.esm2017.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/logger/dist/esm/index.esm2017.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/app/dist/esm/index.esm2017.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2021 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

firebase/app/dist/esm/index.esm.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/firestore/dist/index.esm2017.js:
  (**
  * @license
  * Copyright 2020 Google LLC
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2021 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2022 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2023 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

cookie/index.js:
  (*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

tabbable/dist/index.esm.js:
  (*!
  * tabbable 6.2.0
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)

focus-trap/dist/focus-trap.esm.js:
  (*!
  * focus-trap 7.5.4
  * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
  *)

maplibre-gl/dist/maplibre-gl.js:
  (**
   * MapLibre GL JS
   * @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v4.1.0/LICENSE.txt
   *)
*/
//# sourceMappingURL=w2b83gqvz8.js.map
